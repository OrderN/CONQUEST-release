#ifdef VMS
#include "decw$include:xlib.h"
#include "decw$include:xutil.h"
#include "decw$include:xos.h"
#include "decw$include:keysym.h"
#include "decw$include:cursorfont.h"
#include "decw$include:xatom.h"
#include <descrip.h>
#include <processes.h>
#define fork vfork
#else
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xos.h>
#include <X11/keysym.h>
#include <X11/cursorfont.h>
#include <X11/Xatom.h>
#ifdef DOGL
#include <GL/glx.h>
#include <GL/gl.h>
#include <GL/glu.h>
#endif
#if defined(DARWIN) || defined(FREEBSD)
#else
#include <malloc.h>
#endif
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <stddef.h>
#include <errno.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/stat.h>
sigset_t block_alarm;
sigset_t waiting_mask;
sigset_t base_mask;

#ifdef HASTIMER
#include <sys/time.h>
static struct itimerval it[3],ot;
#endif

#ifdef CRAY
#include <fortran.h>
#endif

#if defined(CRAY) || defined(DARWIN)
typedef char BMap;
#else
typedef unsigned char BMap;
#endif

#define ABS(a) (((a) > 0) ? (a) : (-(a)))
#define SIGN(a) (((a) > 0) ? 1 : -1)
#define MAXI(a,b)      ((a)>=(b)?(a):(b))
#define MINI(a,b)      ((a)<=(b)?(a):(b))

#define FONT "-*-fixed-medium-r-semicondensed-*-13-*-*-*-*-*-*-*"
#define LFONT "-*-helvetica-bold-r-*-*-24-*-*-*-*-*-*-*"
/*#define LFONT "-*-*-*-*-*-*-20-*-*-*-*-*-*-*"*/
#define SFONT "-*-helvetica-bold-r-*-*-12-*-*-*-*-*-*-*"
#define DenWindow 0
#define OpenWindow 1
#define MovePen 2
#define DrawLine 3
#define DrawString 4
#define ClearScreen 6
#define SolidLine 8
#define DashedLine 9
#define LineWidth 10
#define MolWindow 15
#define ParseNorbs 16
#define ChangeColor 99
#define FillPoly 100

static char *selstr = 
	"To Select: Hold mouse button down while dragging the cursor";
static char *dselstr = 
	"To DeSelect: Hold mouse button down while dragging the cursor";
static int SelRes = -3;
static int SelDel = 0;
static int xison = 0;
static int DoFreq = 0;
static int DoEig = 0;
static int *movie;
static int *iuhf;
static int ibeta;
static int lhoh = -1;
static double *esp;
static double *pol;
static double *pol2;
static double *dmao;
static int *nor;
typedef struct { 
	double *cl; 
	double *rij; 
	double *qpix;
	double *qpjx;
	double *dmao;
	int *nor;
	int *iord;
	int *iir; } BOYSPNT;
static BOYSPNT boy = { NULL,NULL,NULL,NULL,NULL,NULL };
typedef struct { 
	double *xden; 
	double *yden; 
	double *zden;
	} FSTGRD;
static FSTGRD fsgrd = { NULL,NULL,NULL};
static int *ipsa;
static int *icpsa;
static int *idtpsa;
static double cntval = 0.01;
typedef struct { double r; double g; double b; } RGB;
static RGB *mapcol;
static unsigned long mappedcols[5];
static double *valcol;
static double *espvdw;
static int *cubetyp;     
static float *frmul;
static int *normc;     
static int has_box = 0;     


typedef struct { 
		 int natc;
		 int norg;
		 int icent;
		 int inorm;
		 int ncon;
		 int nspg;
		 int kz;
		 int ichx;
		 int icrtp;
		 int nopr;
		 short int ir[3][3][192];
		 short int it[3][192];
		 double xyzc[6];
		 double cellc[6];
               } CELLSTRU;
static CELLSTRU *cell;

typedef struct { int iclon;
		 int iclpnt[4];
               } CELLSTRUC;
static CELLSTRUC *cellpnt;
static char *CellStr[] = {" O"," A"," B"," C"};

typedef struct { 
		 int ipoints;
		 int ipnt;
               } PNTSTRU;
static PNTSTRU *pnt;

typedef struct { 
		 int *nzm;
		 int *nso;
		 int *nio;
		 int *nzo;
		 int *ioropt;
		 int *ifor;
		 int *ixyz98;
		 int *iopr;
		 int *isymm;
		 int *irc;
		 int *imp2;
		 int *icntp;
		 int *msucc;
		 int *ioni;
		 int *mopopt;
		 int *isbin;
		 int *irtype;
		 int *ipdbgro;
		 int *ifav;
		 int *ioxyz;
		 int *iconv;
		 int *ircus;
		 int *nscnd;
		 int *iscst;
		 int *ialtyp;
               } PPOISTRU;
static PPOISTRU ptrpoi;

typedef struct { 
		 int nzm;
		 int nso;
		 int nio;
		 int nzo;
		 int ioropt;
		 int ifor;
		 int ixyz98;
		 int iopr;
		 int isymm;
		 int irc;
		 int imp2;
		 int icntp;
		 int msucc;
		 int ioni;
		 int mopopt;
		 int isbin;
		 int irtype;
		 int ipdbgro;
		 int ifav;
		 int ioxyz;
		 int iconv;
		 int ircus;
		 int nscnd;
		 int iscst;
		 int ialtyp;
               } POISTRU;
static POISTRU poi;

typedef struct { 
		 double abc[3];
		 int ibox;
		 int icell;
		 int igfmap;
               } PBCSTRUC;
static PBCSTRUC *pbc;

typedef struct { 
		 int type;
		 float rad;
		 float vec1[3];
		 float vec2[3];
		 float cor[3];
		 int size;
		 int incl;
               } PHARMSTRUC;

typedef struct { 
		 int nfeat;
		 int *ixp;
		 int *iyp;
		 double *rzp;
		 PHARMSTRUC *array;
		 int NSelFeat;
		 char **str;
		 int *index;
	       } PHARMFSTRUC;

static PHARMFSTRUC pharm = {0,NULL,NULL,NULL,NULL,0,NULL,NULL};
 
static char *FeatStr[] = {"Aromatic","HydrogenDonor","HydrogenAcceptor","PositiveIon","NegativeIon","Hydrophobic"};
/*
aro orange
don purple
acc blue
pos dark blue
neg red
hyd green
*/
static int FeatCol[] = {1,2,3,4,5,6};

typedef struct { 
		 int type;
		 float x1;
		 float y1;
		 float x2;
		 float y2;
		 float poly[6];
		 int col;
		 char *str;
               } SVGSTRUC;

typedef struct { int ncmd;
		 float w;
		 float h;
		 SVGSTRUC *array;
               } SVGFSTRUC;

typedef struct { int UpSVG;
		 int NUpSVG;
		 int CurSVG;
		 int ReadSVG;
		 int istruct;
		 int pid;
		} BckSVG;

static BckSVG bcksvg = {0,0,0,0,0,0};

#define DCKDEBUG 0
static int debugdck = DCKDEBUG;

static int DCKSVG = 0;
static SVGFSTRUC *DCKsvg;

static Bool DCKLIGPROC = 0;
static Bool DCKPROTPROC = -1;
static Bool DCKBYPASS = 0;
static Bool DCKINVOKE = 0;
static int DoDockCenter = 0;
static int IntSurfDone = 0;
static int DoIntSurf = 0;
static float CNTDCK[3];
static float DCKRadius = 3.5;
static float OPTRadius = 10.0;

static char ogDockStr[] = "Click on an ligand atom to define docking center\n\
Use the mouse wheel to increase the docking radius\n\
When done hit the esc key";
static char ogXYZStr[] = 
	"Supply the name of the XYZ file containing the structure\n\
to align to the current molecule.\n \n\
 - Use the standard rotation, translation and zoom in/out.\n\
 - Use the Esc to switch between rotation of part or the whole structure\n\
 - Use the Tab to enter the select mode; select 3 couples of atoms to align\n\
   A couple= atom structure1 (red), atom structure2 (white)";
static char ogOVRLStr[] = 
	"Supply the name of the PDB file containing the ligand\n\
to align to the current molecule.\n \n\
 - Use the standard rotation, translation and zoom in/out.\n\
     Cntrl+mouse       = Zoom / Z-translation,\n\
     Shift+mouse       = X/Y-translation\n\
     Cntrl+Shift+mouse = Z-rotation\n\
 - Use the Esc to switch between rotation of part or the whole structure\n\
 - Use the arrow keys  in addition to the mouse for rotation\n\
 - Use the Keypad keys in addition to the mouse for translation\n\n\
   Translation X-axis:      KP_4, KP_6  \n\
   Translation Y-axis:      KP_8, KP_2  \n\
   Translation Z-axis:      KP_1, KP_3  \n\
   Rotation    Z-axis:      KP_7, KP_9  \n\n\
 - DONT FORGET to switch on the NUMLOCK key when using the Keypad keys\n\
 - Use the Coarse icon (between the arrow buttons) to change the step/angle\n\
   increment ";
static char ogLigStr[] = 
	"Select a ligand Molecule on screen by clicking one of its atoms\n\n\
 - Use the standard rotation, translation and zoom in/out.\n\
     Cntrl+mouse       = Zoom / Z-translation,\n\
     Shift+mouse       = X/Y-translation\n\
     Cntrl+Shift+mouse = Z-rotation\n\
 - Use the Esc to switch between rotation of part or the whole structure\n\
 - Use the arrow keys  in addition to the mouse for rotation\n\
 - Use the Keypad keys in addition to the mouse for translation\n\n\
   Translation X-axis:      KP_4, KP_6  \n\
   Translation Y-axis:      KP_8, KP_2  \n\
   Translation Z-axis:      KP_1, KP_3  \n\
   Rotation    Z-axis:      KP_7, KP_9  \n\n\
 - DONT FORGET to switch on the NUMLOCK key when using the Keypad keys\n\
 - Use the Coarse icon (between the arrow buttons) to change the step/angle\n\
   increment ";

void ogIntSurf();
void ogLigSurf();
#ifdef DOGL
void ogDockSphere();
#endif
int GetStruct(char *fil2op);
int GetLig();
void ProcLig(int imode);
void drwdock();
void createDock();
void change_iso(int iop);
void remove_temp_files(char *dirname);
void rdqsar();
void rdqsarc();

void click_nmr_spec(int indx);
void prep_nmr();
void rubber(int iopt);
void RedrawStatus();
void RedrawONIStatus();
void Copy2Zmat();
void Zmat2Copy();
void UpdateZME();
void SetQZME();
void GetQZME();
void UnMapZME();
void map_prop();
void FindZRangeFromBox(int isel);
void SwitchOffAnim();
void AnimLinks(double vartmp);
void DeActZME();
void ButtonsCOL(int i);
void CreateCellPar();
void InitCellDelTrans(int dtopt);
void InitMovie(int x,int y);
void aaexp(char *aastr,int sl);
void calc_spectrum(int iupd);
void reswat();
void initflx();
void UpdateSTRC();
void initMLT();
void motion_screen(int *inct,int *incp);
void ogwrmol(double *r, double *adjus, int *natoms, int *nat, 
        double *xsym, double *ysym, double *zsym, double *vdwr);
void DeleteSurface(int isrf);
void save_rgb(char *rgbfile);
void save_bmp(char *rgbfile);
void molsrf(int SurfCol,int SrfArr,int MapSrf);
void opt3rot();
void SetExplButton(Window win,int x,int y);
void ToGIF(Drawable win,char *filename);
void LigandStruct(int het);
void wrtall();
void plcnrm();
void getrad(double *t,double *coo,int *iatoms,double *dret);
void javch3(int *ih);
void avch3();
void DeleteOMAP();
void movexy(float xval,float yval);
void drawxy(float xval,float yval);
void DrawBox(double x,double y,int xt,int yt,int r,int icol,int ifill,int iconv);
void ResetColors();
void def_colors();
void FakeCMap();
void drawstring(float xval,float yval,char *strval,int nval);
void dashline();
void changepen(float pen);
void gl2DInit();
void gl2DEnd();
void CreatewinC(char *geom);
void CreatewinMC(char *geom);
void createauthor();
void createRama();
void createconv();
void createfr(int dowin);
void creategeom();
void createscore();
void createpmf();
void CreateONI();
void CreateFLR();
void actde(int inactid,int inactf,int iwin);
void DirBox(Window hwin,int vis);
void RedrawwinC(int x,int y,int w,int h);
void ULineString(Window hwin,char *str,int x,int y);
void LineString(Window hwin,char *str,int x,int y);
void DrawTriangle(double x,double y,int xt,int yt,int r,int icol,int ifill,int iconv);
void DrawRama();
void StatusStr(int iwin,int dobell);
void domamb(char *jobstr);
void bckpoi(int istruct);
void ActOnErr(int zline,int boxnum,char *errstr);
void InsertEmptyLines(int ires,int row,int nlines,int seq_len,int nprot,int *iprot);
void FindZRange(int ires);
void ApplSel(int iop);
void ScrollBut(int i);
void maparr(float *flarr,double *dblarr,int *intarr,short int *shintarr,int iopt);
void ActVar(int isel,int itype,int butnr);
void activeZME(int *type,int *row,int *column);
void MkDistWin(int *asel,int opt,float val);
void PlotColIndex();
void OnTop();
void InitCOL();
void RButtonsCOL(int i);
void SetRadius();
void UpdateCP();
void InitISO(int x,int y);
void RedrawISO();
void InitATM(int x,int y);
void UpdateATM();
void UpdateSeqStat();
void InitSEQ(int x,int y);
void InitTNK(int x,int y);
void rearr(int *itarr,int *arr);
void rearrs(int *itarr,short int *arr);
void rearrd(double *itarr,double *arr);
void rearrz(int *itarr);
void make_aa();
void FreeAll(int delpix);
void DeleteAll();
void EditCOL();
void SetPalCol(int updateshades);
void UpdateDPT();
void InitDPT();
void WriteCML();
void InitMAP();
void InitVIR();
void write_spectrum(char *fname, int orient, int opt);
void InitDelay();
void InitPar();
void inistrc();
void inistr();
void iniselh();
void InitSRCH(int x,int y);
void InitANIM(int x,int y);
void inichg(int iopt);
void initPHRM();
void initQSAR();
void initPSRCH(char *query);
void WinName(Window win,char *wname);
void BuildList(double *r,double *cnst,int *nnpts1,int *nnpts2,int *iorb,double *dens);
void DeleteActiveSurfaces();
void allocvert(int siz,int first);
void EnableFog();
void chncol(int ich,int col,int iupd);
void showresrot(int sol);
void mvhlpat(int nlines,int *nato1);
void CombineStructs(int str2,int notaligned,int new_struct);
int DoCan(int x,int y,char *strval,int docan);
int dos2u(char *path);

#if defined(VMS) || defined(UNDERSC)
void curs(int *on);
void almgrd();
void wrtres();
void stowat(int *ino);
void initsrf();
void dlystr();
void bldlst();
void tpsa();
void getpdb(int *ires,int *ipdb,int *ihpdb);
void mkcon(int *ipdb,int *aminotyp,int *irs,int *ihpdb,int *i,int *j);
void dfires();
void plinzz(int *isel,int *istat);
void dumlin(int *isel,double *blv,double *alphv,double *betv);
void sollin();
void dpomap(int *iopt);
void qupd();
void cwidth(float *linpass);
void ststip();
void unstip();
void doexp();
void dlogo();
void crsco();
void cpmf();
void upsco();
void molstr(struct dsc$descriptor_s *str, int *nstr, int *iwin);
void drwstr(int *xvl,int *yvl,struct dsc$descriptor_s *strvl,int *sl,int *ind);
void drwqstr(int *xvl,int *yvl,int *ian,double *q,int *ind);
void cpstr(char *ostr,struct dsc$descriptor_s *str,int nlen);
void strcp(struct dsc$descriptor_s *str,char *ostr,int nlen);
void upzme();
void addchg();
void allorb(int *ZSizep,int *first);
void allgrd(int *ZSizep);
void allgrd2(int *ZSizep);
void allgeo(int *ZSizep,int *first);
void allcoo(int *ZSizep,int *first);
void srfclr();
#else
#ifdef CRAY
void CURS(int *on);
void ALMGRD();
void WRTRES();
void STOWAT(int *ino);
void INITSRF();
void DLYSTR();
void BLDLST();
void TPSA();
void GETPDB(int *ires,int *ipdb,int *ihpdb);
void MKCON(int *ipdb,int *aminotyp,int *irs,int *ihpdb,int *i,int *j);
void DFIRES();
void PLINZZ(int *isel,int *istat);
void DUMLIN(int *isel,double *blv,double *alphv,double *betv);
void SOLLIN();
void DPOMAP(int *iopt);
void QUPD();
void CWIDTH(float *linpass);
void STSTIP();
void UNSTIP();
void DOEXP();
void DLOGO();
void CRSCO();
void CPMF();
void UPSCO();
void MOLSTR(_fcd str, int *nstr, int *iwin);
void DRWSTR(int *xvl,int *yvl,_fcd strvl,int *sl,int *ind);
void DRWQSTR(int *xvl,int *yvl,int *ian,double *q,int *ind);
void cpstr(char *ostr,_fcd str,int nlen);
void strcp(_fcd str,char *ostr,int nlen);
void UPZME();
void ADDCHG();
void ALLORB(int *ZSizep,int *first);
void ALLGRD(int *ZSizep);
void ALLGRD2(int *ZSizep);
void ALLGEO(int *ZSizep,int *first);
void ALLCOO(int *ZSizep,int *first);
void SRFCLR();
#else
void curs_(int *on);
void almgrd_();
void wrtres_();
void stowat_(int *ino);
void initsrf_();
void dlystr_();
void bldlst_();
void tpsa_();
void getpdb_(int *ires,int *ipdb,int *ihpdb);
void mkcon_(int *ipdb,int *aminotyp,int *irs,int *ihpdb,int *i,int *j);
void dfires_();
void plinzz_(int *isel,int *istat);
void dumlin_(int *isel,double *blv,double *alphv,double *betv);
void sollin_();
void dpomap_(int *iopt);
void qupd_();
void cwidth_(float *linpass);
void ststip_();
void unstip_();
void doexp_();
void dlogo_();
void crsco_();
void cpmf_();
void upsco_();
void molstr_(char *str, int *nstr, int *iwin);
void drwstr_(int *xvl,int *yvl,char *strvl,int *sl,int *ind);
void drwqstr_(int *xvl,int *yvl,int *ian,double *q,int *ind);
void cpstr(char *ostr,char *str,int nlen);
void strcp(char *str,char *ostr,int nlen);
void upzme_();
void addchg_();
void allorb_(int *ZSizep,int *first);
void allgrd_(int *ZSizep);
void allgrd2_(int *ZSizep);
void allgeo_(int *ZSizep,int *first);
void allcoo_(int *ZSizep,int *first);
void srfclr_();
#endif
#endif

#define MEXCL 10

typedef struct { double qexcl[MEXCL];
		 int ianexc[MEXCL];
		} METSTRU;

static METSTRU *mets;

static char *alphbet[] = {"alpha","beta"};
static char *strsnd[] = {"HELIXOUT","STRANDTOP","RNA","COIL"};
static char *rwopt[] = {"Read","Write"};
static char *mltopt[] = {"sdf","mol2","Fields"};
static char *cubeopt[] = {"Gaussian","Vasp","Jaguar"};
static char *labels[] = {"atom","atom+number","ForceF.Type","atom+charge","PDBsymbol","Residue","Nuc. Shld."};
static char *labhet[] = {"atom","atom+number","ForceF.Type","atom+charge","Residue"};
#ifdef MPFIT
static char *pots[] = {"True Electrost. Pot.","Multipole Derived","Charges Derived","Topol. PSA","Write Surface","Read Surface","Surface OFF","ESP charges","DMA El.Pot.Charges","Mull.Charges","Read ESP Charges","EEM charges","Gasteiger","Dipole On/Off","Solv. Acc. Surf","Elec. Dens. Map","Pharmacophore Editor","GRID kont","Ramachandran","Open3DQSAR","Fit MultiPoles"};
#else
static char *pots[] = {"True Electrost. Pot.","Multipole Derived","Charges Derived","Topol. PSA","Write Surface","Read Surface","Surface OFF","ESP charges","DMA El.Pot.Charges","Mull.Charges","Read ESP Charges","EEM charges","Gasteiger","Dipole On/Off","Solv. Acc. Surf","Elec. Dens. Map","Pharmacophore Editor","GRID kont","Ramachandran","Open3DQSAR",};
#endif
static char *eems[] = {"EEM NPA","EEM Mull","EEM PESP","EEM ESFF","Gasteiger"};
static char *pots2[] = {"True Electrost. Pot.","Multipole Derived","Charges Derived"};
static char *readgrd[] = {"Replace Grid","Subtract"};
static char *surftyp[] = {"Van der Waals","IsoDensity (Slow)","DMAPSA"};
static char *hyds[] = {"Excl. All Hydrogens","Excl. H except H-bond","(Re)calculate H-bond","H-bond parameters","Opt. H positions"};
static char *postopt[] = {"Mono","Color"};
static char *srfopt[] = {"Mono-colored surface","Elec. Pot. Mapped"};
static char *srf2opt[] = {"Elec. Density Surf.","Solv. Acc. Surf."};
static char *dumopt[] = {"Include Dummies","Exclude Dummies"};
static char *vrmlopt[] = {"VRML1.0","VRML2.0","Povray","OpenGL"};
static char *vrml2dopt[] = {"VRML2.0","OpenGL"};
static char *denopt[] = {"Normal","Color Mapped"};
static char *xyzopt[] = {"XYZ","Mol2","MSF","Tinker","Tinker QM/MM"};
static char *mapopt[] = {"XYZ file","Mol2 file","MSF","Tinker .xyz","Optimise with Sybyl","Optimise with Quanta","Optimise with Tinker"};
static char *wropt[] = {"Z-Mat Gamess","Z-Mat Gaussian","Z-Mat MOPAC","XYZ","Mol2","MSF","Tinker","Tinker QM/MM","PDB","CSSR","MSI","Molden Format","mol","CML","AMBFOR","WFN"};
static char *pdbwh[]={ "Write with Hydrogens", "Write without H","Write Displayed Res. Only"};
static char *palopt[] = {"Background Mode","BackGround Color","Def. BackGround","Atom Colors","Color Editor","Reset Colors","Shade Depth","Surfaces","Chains","Blur","Occlusion","Shadows"};
static char *occlopt[] = {"Best","Good"};
static char *bgopt[] = {"Solid Color","Gradient Color"};
static char *spdopt[] = {"Normal Density","Spin Density"};
static int *ivdwpl;
static char *vdwstr[]={ "Sticks", "Space Filling", "Ball & Sticks"};
static char *alnopt[]={ "Align 2 molecules", "Interactive Docking","Incremental Docking"};
static char *dckopt[]={ "Read from PDB file", "Pick Molecule on Screen"};
static char *rsopt[]={ "640x480", "1280x720"};
static char *sdfopt[]={ "Add Polar H", "add H","conformers","3D"};
static char *sdfcopt[]={ "--AddPolarH", "-h","--writeconformers","--gen3D"};
#define MAXRES 1000
static int npdbres = 0;
static char *pdbres[MAXRES];
static int ieemopt = 1;
static int *icolps;
static int *idelx;
static int *ivtwo;
static int *ixyz;
static int *iixyz;
static int *ipnt;     
static int *iwropt;
static int denmode = 0;
static int inactMC;
static int inafMC;
static int *ispd;
static int *ibgcol;
static int *ibgclo;
static int *ibgmod;
static int *igffrm;
static int iupres[500];
static int nupres = 0;

static int  CheckForConfig();
static Bool IsConfig();

static int idum1;
static int startx;
static int starty;
static int moving = 0;
static int gmoving = 0;
static int *ball;
static int btype = 0;

double dveclen(double *a);
void vecnrm(float *v);
void crossprd(double *v1,double *v2,double *d);
void CROSS(double *v1,double *v2,double *v3);
void improduct(double *a, double *b, double *c);
void onerot(int ires,int print);
void poldrw(XPoint *points,int *npoints,int *icol,int *icon,int *isgrey);
void presetp();
void createspec(int dowin);
void RedrawwinMC(int x,int y,int w,int h);
void RedrawRESwin();
void RedrawCOMMwin();
void RedrawDIST();
void RedrawSUB();
void RedrawCOL();
void RedrawMOV();
void RedrawECOL();
void RedrawMAP();
void RedrawVIR();
void RedrawONI();
void RedrawFLR();
void RedrawDEL();
void RedrawFLX();
void RedrawPAR();
void RedrawSTRC();
void RedrawSELH();
void RedrawSRCH();
void RedrawANIM();
void RedrawSTR();
void RedrawCHG();
void RedrawSRF();
void RedrawMLT();
void RedrawDPT();
void RedrawATM();
void RedrawTNK();
void RedrawCT();
void RedrawCP();
void RedrawSEQ();
void RedrawPHRM();
void RedrawPSRCH();
void RedrawQSAR();
void InitZME();
void RedrawZME();
void EndOMAP();
int PressZME(int butnr,int x,int y);
void butje(Window bwin,int x,int y,int w,int h,int r,int bgcol,int sh_ind,int iopt,Pixmap pix,int pw,int ph,int style,int rec);
void doclr();
void drwspec();
void drwcnv();
void drwpmf();
void glpnt(int wide,int high,double x,double y,int *xr,int *yr,int iframe);
void drwsco();
void Timer(int msec,int timopt);
void UpdHet();
void UpdHet2(int nlin);
void OpenPHRME();
void exit_casel();
#if defined(VMS) || defined(UNDERSC)
void drwgeo();
#else
#ifdef CRAY
void DRWGEO();
#else
void drwgeo_();
#endif
#endif
void clrsave();
void drwgl(Window gwin,int wide,int high,double x1,double y1,double x2,double y2,int icol,int icross,int iframe,int isdash);
void RedrawWin();
void Key(unsigned char key);
static Bool gijsup = 0;
static Bool ramaup = 0;
static Bool dockup = 0;
static Bool cnvup = 0;
static Bool geoup = 0;
static Bool distup = 0;
static Bool FRup = 0;
static Bool specup = 0;
static Bool scoup = 0;
static Bool pmfup = 0;
static double scomax, scomin;
static int qboxup = 0;
static int qbopt = 0;
static int qbinct = 0;
static int qbcomm = 0;
static int qbres = 0;
static int pdb = 0;
static int *icalc;
static int *ipdbon;
static int frfor = 0;
static int coarse = 1;
static Bool do3dx = 0;
static int *dospa;
static int *do3d;
static int *ambchg;
static int *backb;
static Bool isdash = 0;
static Bool hbon = 0;
static Bool denm = 1;
static int setcmap = 0;
static int ZERO = 0;
static int ONE = 1;
static int MONE = -1;
static int TWO = 2;
static int THREE = 3;
static int FOUR = 4;
static int FIVE = 5;
static int EIGHTEEN = 18;
static int SEVENTYSEVEN = 77;
static double THRESH = 3.5;
static Colormap cmap;
static int StarNetOld = 0;
static int StarNet = 0;
#define ball_width 7
#define ball_height 7
static BMap ball_bits[] = {
   0x1c, 0x3e, 0x7f, 0x7f, 0x7f, 0x3e, 0x1c};
#define bigsmall_width 17
#define bigsmall_height 17
static BMap bigsmall_bits[] = {
   0x80, 0xff, 0x01, 0x80, 0x00, 0x01, 0xfe, 0x0f, 0x01, 0x82, 0x08, 0x01,
   0x82, 0x08, 0x01, 0x82, 0x08, 0x01, 0x82, 0x08, 0x01, 0x82, 0xff, 0x01,
   0x02, 0x08, 0x00, 0x02, 0x08, 0x00, 0x02, 0x08, 0x00, 0x02, 0x08, 0x00,
   0x02, 0x08, 0x00, 0x02, 0x08, 0x00, 0x02, 0x08, 0x00, 0xfe, 0x0f, 0x00,
   0x00, 0x00, 0x00};
#define skull_width 17
#define skull_height 17
static BMap skull_bits[] = {
   0xe0, 0x0f, 0x00, 0xf0, 0x1f, 0x00, 0xf8, 0x3f, 0x00, 0xfc, 0x7f, 0x00,
   0x9e, 0xf3, 0x00, 0x8e, 0xe3, 0x00, 0x8e, 0xe3, 0x00, 0xfe, 0xfe, 0x00,
   0x7c, 0x7c, 0x00, 0x78, 0x3c, 0x00, 0xf1, 0x1f, 0x01, 0xf1, 0x1f, 0x01,
   0x52, 0x95, 0x00, 0x44, 0x45, 0x00, 0xf8, 0x3f, 0x00, 0xfc, 0x7f, 0x00,
   0x07, 0xc0, 0x01};
#define ff_width 17
#define ff_height 17
static BMap ff_bits[] = {
   0x00, 0x00, 0x00, 0xf8, 0x03, 0x00, 0xf8, 0x03, 0x00, 0x18, 0xfc, 0x00,
   0x0c, 0xfc, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x06, 0x00, 0x7c, 0x06, 0x00,
   0x7e, 0x06, 0x00, 0x06, 0x3e, 0x00, 0x06, 0x3f, 0x00, 0x06, 0x03, 0x00,
   0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x83, 0x01, 0x00, 0x80, 0x01, 0x00,
   0x80, 0x01, 0x00};
#define mlf_width 17
#define mlf_height 17
static BMap mlf_bits[] = {
   0x00, 0x00, 0x00, 0x0e, 0xe0, 0x00, 0x1c, 0x70, 0x00, 0x3c, 0x78, 0x00,
   0x7c, 0x7c, 0x00, 0xec, 0x6e, 0x00, 0xcc, 0x67, 0x00, 0x8c, 0x63, 0x00,
   0x0c, 0x61, 0x00, 0x0c, 0x60, 0x00, 0x0c, 0x60, 0x00, 0x0c, 0x60, 0x00,
   0x0c, 0x60, 0x00, 0x0c, 0x60, 0x00, 0x0c, 0x60, 0x00, 0x1e, 0xf0, 0x00,
   0x00, 0x00, 0x00};
#define hbit_width 17
#define hbit_height 17
static BMap hbit_bits[] = {
   0x00, 0x00, 0x00, 0x70, 0xe0, 0x00, 0x70, 0xe0, 0x00, 0x70, 0xe0, 0x00,
   0x38, 0x70, 0x00, 0x38, 0x70, 0x00, 0x38, 0x70, 0x00, 0x38, 0x70, 0x00,
   0xfc, 0x3f, 0x00, 0xfc, 0x3f, 0x00, 0x1c, 0x38, 0x00, 0x1c, 0x38, 0x00,
   0x0e, 0x1c, 0x00, 0x0e, 0x1c, 0x00, 0x0e, 0x1c, 0x00, 0x0e, 0x1c, 0x00,
   0x07, 0x0e, 0x00};
#define orig_width 17
#define orig_height 17
static BMap orig_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00,
   0x10, 0x01, 0x00, 0x20, 0x01, 0x00, 0x40, 0x01, 0x00, 0x80, 0x01, 0x00,
   0xfe, 0xff, 0x00, 0x00, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x09, 0x00,
   0x00, 0x11, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00,
   0x00, 0x00, 0x00};
#define cell_width 17
#define cell_height 17
static BMap cell_bits[] = {
   0x00, 0x00, 0x00, 0xe0, 0xff, 0x00, 0x30, 0xc0, 0x00, 0x08, 0xa0, 0x00,
   0x24, 0x90, 0x00, 0xfe, 0x8f, 0x00, 0x02, 0x88, 0x00, 0x22, 0x88, 0x00,
   0x02, 0x88, 0x00, 0x22, 0x88, 0x00, 0x02, 0x88, 0x00, 0xe2, 0xeb, 0x00,
   0x12, 0x48, 0x00, 0x0a, 0x28, 0x00, 0x06, 0x18, 0x00, 0xfe, 0x0f, 0x00,
   0x00, 0x00, 0x00};
#define surf_width 17
#define surf_height 17
static BMap surf_bits[] = {
   0x92, 0x92, 0x00, 0x12, 0x91, 0x00, 0x24, 0x48, 0x00, 0x44, 0x44, 0x00,
   0x98, 0x23, 0x00, 0x74, 0x30, 0x00, 0xf2, 0x0c, 0x00, 0x2a, 0x1f, 0x00,
   0x45, 0x63, 0x00, 0xaa, 0x88, 0x00, 0x92, 0xb6, 0x00, 0x6c, 0x22, 0x01,
   0x50, 0x49, 0x01, 0x40, 0x22, 0x01, 0x80, 0xb6, 0x00, 0x80, 0x88, 0x00,
   0x00, 0x63, 0x00};
#define ogl_width 17
#define ogl_height 17
static BMap ogl_bits[] = {
   0x00, 0xa0, 0x01, 0x40, 0xe0, 0x01, 0xe0, 0xc0, 0x01, 0xd0, 0x81, 0x01,
   0xc8, 0x03, 0x00, 0xc4, 0x07, 0x00, 0xc2, 0xff, 0x00, 0x41, 0xc0, 0x00,
   0xe2, 0xbf, 0x00, 0x24, 0xa0, 0x00, 0xa8, 0xa0, 0x00, 0x30, 0xa0, 0x00,
   0xa0, 0xa0, 0x00, 0x20, 0xa0, 0x00, 0xa0, 0xaa, 0x00, 0x20, 0x60, 0x00,
   0xe0, 0x3f, 0x00};
#define foto_width 17
#define foto_height 17
static BMap foto_bits[] = {
   0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xfe, 0xff, 0x00,
   0xfe, 0xff, 0x00, 0x7e, 0xfc, 0x00, 0xbe, 0xfb, 0x00, 0x5e, 0xf4, 0x00,
   0x5e, 0xf4, 0x00, 0x5e, 0xf4, 0x00, 0xbe, 0xfb, 0x00, 0x7e, 0xfc, 0x00,
   0xfe, 0xff, 0x00, 0xfe, 0xff, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00};
#define palette_width 17
#define palette_height 17
static BMap palette_bits[] = {
   0x00, 0x80, 0x01, 0x00, 0xb0, 0x01, 0xf8, 0x78, 0x00, 0xfc, 0xfd, 0x00,
   0xfc, 0xfd, 0x00, 0xc6, 0xff, 0x00, 0x82, 0xff, 0x00, 0x86, 0xff, 0x00,
   0xc6, 0xff, 0x00, 0xfe, 0xff, 0x00, 0xfe, 0xff, 0x00, 0xfe, 0x7f, 0x00,
   0xfc, 0x7f, 0x00, 0xfc, 0x7f, 0x00, 0xfc, 0x3f, 0x00, 0xf2, 0x1f, 0x00,
   0xe1, 0x07, 0x00};
#define g_width 17
#define g_height 17
static BMap g_bits[] = {
   0xc0, 0x07, 0x00, 0x30, 0x18, 0x00, 0x0c, 0x60, 0x00, 0x04, 0x40, 0x00,
   0x02, 0x80, 0x00, 0x22, 0x88, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01,
   0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x11, 0x10, 0x01, 0x22, 0x88, 0x00,
   0xc2, 0x87, 0x00, 0x04, 0x40, 0x00, 0x0c, 0x60, 0x00, 0x30, 0x18, 0x00,
   0xc0, 0x07, 0x00};
#define vrml_width 17
#define vrml_height 17
static BMap vrml_bits[] = {
   0x00, 0x00, 0x00, 0xe6, 0xc3, 0x00, 0x66, 0xc6, 0x00, 0x66, 0xc4, 0x00,
   0x66, 0xc6, 0x00, 0xec, 0x63, 0x00, 0x6c, 0x63, 0x00, 0x78, 0x36, 0x00,
   0x78, 0x36, 0x00, 0x30, 0x18, 0x00, 0x30, 0x18, 0x00, 0x60, 0x0c, 0x00,
   0x60, 0x0c, 0x00, 0xc0, 0x06, 0x00, 0xc0, 0x06, 0x00, 0x80, 0x03, 0x00,
   0x80, 0x03, 0x00};
#define align_width 17
#define align_height 17
static BMap align_bits[] = {
   0x20, 0x00, 0x00, 0x70, 0x04, 0x00, 0x98, 0x04, 0x00, 0x0d, 0x0f, 0x00,
   0x06, 0x13, 0x00, 0x86, 0xa3, 0x00, 0xc6, 0x42, 0x00, 0xc6, 0x42, 0x00,
   0xc6, 0x42, 0x00, 0xc6, 0x42, 0x00, 0xc6, 0x42, 0x00, 0xcd, 0x41, 0x00,
   0xd8, 0x40, 0x00, 0xf0, 0xa1, 0x00, 0x20, 0x13, 0x00, 0x20, 0x0e, 0x00,
   0x00, 0x04, 0x00};
#define map_width 24
#define map_height 16
static BMap map_bits[] = {
   0xff, 0x01, 0x00, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x3f, 0x00, 0xc0, 0x1f, 0x00, 0x40, 0x1f, 0x00, 0x60,
   0x0f, 0x00, 0x20, 0x0f, 0x00, 0x30, 0x07, 0x00, 0x10, 0x07, 0x00, 0x18,
   0x03, 0x00, 0x08, 0x03, 0x00, 0x0c, 0xff, 0xff, 0x07, 0xff, 0xff, 0x07};
#define tri_width 8
#define tri_height 8
static BMap tri_bits[] = {
   0xff, 0xff, 0x7e, 0x7e, 0x3c, 0x3c, 0x18, 0x18};
#define mol_width 169
#define mol_height 52
static BMap mol_bits[] = {
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0xfc,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0xfe,0x00,0x03,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x06,0xfe,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xfe,0x40,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x10,0xfe,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0xfe,0x20,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x20,0xfe,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xfe,0x20,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x20,0xfe,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xfe,0x20,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
 0xfe,0x20,0x00,0xc0,0x3f,0xc0,0x1f,0x00,0xff,0x00,0xf8,0x00,0x80,0xff,0x1f,
 0x80,0xff,0xff,0xf1,0x03,0xf8,0x20,0xfe,0x20,0x00,0xc0,0x3f,0xe0,0x1f,0xe0,
 0xff,0x07,0xf8,0x00,0x80,0xff,0x7f,0x80,0xff,0xff,0xf1,0x03,0xf8,0x20,0xfe,
 0x20,0x00,0xc0,0x3f,0xe0,0x1f,0xf0,0xff,0x0f,0xf8,0x00,0x80,0xff,0xff,0x80,
 0xff,0xff,0xf0,0x03,0xf8,0x20,0xfe,0x20,0x00,0xe0,0x3f,0xe0,0x1f,0xf8,0xff,
 0x0f,0xfc,0x00,0xc0,0xff,0xff,0xc0,0xff,0xff,0xf8,0x07,0xfc,0x20,0xfe,0x20,
 0x00,0xe0,0x3f,0xf0,0x0f,0xfc,0xe1,0x1f,0x7c,0x00,0xc0,0x07,0xfe,0xc1,0x07,
 0x00,0xf8,0x07,0x7c,0x20,0xfe,0x20,0x00,0xe0,0x3f,0xf0,0x0f,0x7e,0x80,0x1f,
 0x7c,0x00,0xc0,0x07,0xf8,0xc1,0x07,0x00,0xf8,0x07,0x7c,0x20,0xfe,0x20,0x00,
 0xe0,0x3f,0xf8,0x0f,0x3f,0x00,0x3f,0x7c,0x00,0xc0,0x07,0xf0,0xc1,0x07,0x00,
 0xf8,0x0f,0x7c,0x20,0xfe,0x20,0x00,0xe0,0x3f,0xb8,0x0f,0x1f,0x00,0x3f,0x7c,
 0x00,0xc0,0x07,0xf0,0xc1,0x07,0x00,0xf8,0x0f,0x7c,0x20,0xfe,0x20,0x00,0xf0,
 0x3d,0xbc,0x8f,0x0f,0x00,0x3e,0x7e,0x00,0xe0,0x07,0xf0,0xe1,0x03,0x00,0xfc,
 0x1f,0x7e,0x20,0xfe,0x20,0x00,0xf0,0x3d,0xdc,0x87,0x0f,0x00,0x3e,0x3e,0x00,
 0xe0,0x03,0xf0,0xe1,0x03,0x00,0x7c,0x1f,0x3e,0x20,0xfe,0x20,0x00,0xf0,0x3d,
 0xde,0xc7,0x07,0x00,0x3e,0x3e,0x00,0xe0,0x03,0xf0,0xe1,0xff,0x3f,0x7c,0x1e,
 0x3e,0x20,0xfe,0x20,0x00,0xf0,0x3d,0xde,0xc7,0x07,0x00,0x3e,0x3e,0x00,0xe0,
 0x03,0xf0,0xe1,0xff,0x3f,0x7c,0x3e,0x3e,0x20,0xfe,0x20,0x00,0xf0,0x3d,0xce,
 0xc7,0x03,0x00,0x3e,0x3e,0x00,0xe0,0x03,0xf0,0xe1,0xff,0x1f,0x7c,0x3e,0x3e,
 0x20,0xfe,0x20,0x00,0xf8,0x3c,0xef,0xe7,0x03,0x00,0x1f,0x3f,0x00,0xf0,0x03,
 0xf8,0xf1,0xff,0x1f,0x7e,0x3c,0x3f,0x20,0xfe,0x20,0x00,0xf8,0x3c,0xe7,0xe3,
 0x03,0x00,0x1f,0x1f,0x00,0xf0,0x01,0xf8,0xf0,0x01,0x00,0x3e,0x7c,0x1f,0x20,
 0xfe,0x20,0x00,0xf8,0xbc,0xe7,0xe3,0x03,0x80,0x1f,0x1f,0x00,0xf0,0x01,0xf8,
 0xf0,0x01,0x00,0x3e,0x7c,0x1f,0x20,0xfe,0x20,0x00,0xf8,0xbc,0xe7,0xe3,0x03,
 0x80,0x0f,0x1f,0x00,0xf0,0x01,0x7c,0xf0,0x01,0x00,0x3e,0x78,0x1f,0x20,0xfe,
 0x20,0x00,0xf8,0xfc,0xe3,0xe3,0x07,0xc0,0x0f,0x1f,0x00,0xf0,0x01,0x7c,0xf0,
 0x01,0x00,0x3e,0xf8,0x1f,0x20,0xfe,0x20,0x00,0x7c,0xfc,0xf3,0xe1,0x07,0xe0,
 0x87,0x0f,0x00,0xf8,0x00,0x3e,0xf8,0x00,0x00,0x3f,0xf0,0x0f,0x20,0xfe,0x20,
 0x00,0x7c,0xfc,0xf1,0xc1,0x0f,0xf0,0x83,0x0f,0x00,0xf8,0x00,0x3f,0xf8,0x00,
 0x00,0x1f,0xf0,0x0f,0x20,0xfe,0x20,0x00,0x7c,0xfc,0xf1,0xc1,0x3f,0xfc,0x83,
 0x0f,0x00,0xf8,0xc0,0x1f,0xf8,0x00,0x00,0x1f,0xf0,0x0f,0x20,0xfe,0x20,0x00,
 0x7c,0xfc,0xf0,0x81,0xff,0xff,0x81,0xff,0x7f,0xf8,0xff,0x0f,0xf8,0xff,0x1f,
 0x1f,0xe0,0x0f,0x20,0xfe,0x20,0x00,0x7e,0xfc,0xf0,0x01,0xff,0xff,0xc0,0xff,
 0x7f,0xfc,0xff,0x07,0xfc,0xff,0x9f,0x1f,0xe0,0x0f,0x20,0xfe,0x20,0x00,0x3e,
 0xfc,0xf8,0x00,0xfe,0x3f,0xc0,0xff,0x3f,0xfc,0xff,0x03,0xfc,0xff,0x8f,0x0f,
 0xe0,0x07,0x20,0xfe,0x20,0x00,0x3e,0x7c,0xf8,0x00,0xf8,0x0f,0xc0,0xff,0x3f,
 0xfc,0xff,0x00,0xfc,0xff,0x8f,0x0f,0xc0,0x07,0x20,0xfe,0x20,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x20,0xfe,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xfe,0x20,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x20,0xfe,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xfe,0x20,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
 0xfe,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xfe,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0xfe,
 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x10,0xfe,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xfe,0x00,
 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x06,0xfe,0x00,0xfc,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0xfe,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0xfe};
#define icon_bitmap_width 100
#define icon_bitmap_height 70
static BMap icon_bitmap_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x70, 0xa2, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x0e, 0x14, 0xe1, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xa7, 0xd2, 0x0b, 0x19, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0x12, 0x04, 0x50, 0x76, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xa9, 0x2a, 0x25, 0xd0, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x05, 0x40, 0x88, 0x92, 0x06,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xa8, 0x8a, 0x22, 0x24,
   0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x02, 0x10, 0x88,
   0xa8, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x54, 0x4b,
   0x25, 0x25, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x81,
   0x48, 0x10, 0xb0, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e,
   0x35, 0x12, 0x45, 0x25, 0xd2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x02, 0x88, 0x54, 0x88, 0x88, 0xc8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xb2, 0x22, 0x80, 0x12, 0x52, 0x12, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x42, 0x8a, 0x2a, 0xa4, 0x08, 0xc5, 0x04, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x5e, 0x10, 0x41, 0x01, 0x51, 0x91, 0x06, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x9b, 0x4a, 0x16, 0xd4, 0x84, 0x54, 0x0c, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x22, 0xa1, 0x32, 0x52, 0x09, 0x0d,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x44, 0x14, 0x88, 0x08, 0x52,
   0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xa8, 0xa2, 0x22, 0xaa,
   0x80, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x83, 0x06, 0x89,
   0x02, 0x15, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x15, 0x58,
   0x70, 0x54, 0x51, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x61,
   0x21, 0x05, 0x21, 0x94, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26,
   0x9e, 0x45, 0x48, 0x94, 0x02, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x4a, 0x26, 0x18, 0x91, 0x21, 0xa8, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0xa3, 0x94, 0x42, 0x22, 0x4a, 0x8d, 0x70, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0x3f, 0x11, 0x29, 0x84, 0x90, 0x64, 0x6a, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x7e, 0xac, 0x8c, 0x52, 0x25, 0x81, 0x55, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xbf, 0x7f, 0x1d, 0xa1, 0x0f, 0x48, 0x2a, 0x60, 0x00,
   0x00, 0x00, 0x00, 0x80, 0xf7, 0xed, 0x39, 0x04, 0xa0, 0x52, 0x84, 0x4a,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0xfd, 0xff, 0x53, 0xa9, 0x04, 0x93, 0x29,
   0x59, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xdf, 0x6e, 0x25, 0x12, 0xa9, 0x04,
   0x4a, 0x4a, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf7, 0xf3, 0xc3, 0x46, 0x40,
   0x58, 0x10, 0x51, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xbe, 0x7f, 0xb4, 0x68,
   0xf5, 0x82, 0xc5, 0x64, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf6, 0xdd, 0x21,
   0x02, 0x08, 0x68, 0x54, 0x38, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x7e,
   0xb5, 0xb4, 0x42, 0x13, 0x05, 0x29, 0x00, 0x00, 0x00, 0x00, 0x80, 0xee,
   0xdf, 0x90, 0x01, 0x17, 0x42, 0x69, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x0e, 0x3c, 0x26, 0xaa, 0xa0, 0x56, 0x89, 0x32, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xfb, 0x77, 0x89, 0xc1, 0x3d, 0x48, 0x4a, 0x1c, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x23, 0x21, 0x2c, 0x80, 0x8a, 0x92, 0x0a, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0x8c, 0xe1, 0xea, 0x51, 0x68, 0x0e, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xf1, 0x0c, 0x00, 0x8c, 0x96, 0x04,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x26, 0xd1, 0xcb, 0xa1, 0x20,
   0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x59, 0x0a, 0x10, 0x2e,
   0xad, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x91, 0xd0, 0x75,
   0xe1, 0xc5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0x25,
   0x81, 0xaa, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
   0x12, 0x3e, 0x20, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x5a, 0xa5, 0xa0, 0x95, 0xfa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x46, 0x48, 0x0a, 0xc9, 0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xdc, 0x16, 0x7f, 0x12, 0x0e, 0x3f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x18, 0x51, 0x80, 0xb3, 0x07, 0xfc, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x70, 0x1a, 0x29, 0xa5, 0x01, 0xe0, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x49, 0x07, 0xe2, 0x00, 0x00, 0x1f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x2a, 0x50, 0x3f, 0x00, 0x00,
   0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x0f, 0x00,
   0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x00,
   0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#define gijsface_width 160
#define gijsface_height 144
static BMap gijsface_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x1c, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
   0x07, 0x24, 0xf0, 0x07, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x3e, 0xfe, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x60, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xfe, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x60, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0xff, 0xff, 0x0f, 0xf8, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00,
   0x90, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x03, 0x00, 0x00, 0xfe, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xff, 0x03, 0x00, 0x00, 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x00, 0x00,
   0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x10, 0x00, 0xf0, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
   0xff, 0x3f, 0x00, 0x80, 0x00, 0x04, 0xfb, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x3f, 0x00, 0x00,
   0x00, 0x80, 0xfd, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x08, 0xfe, 0xff,
   0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
   0xff, 0x1f, 0x00, 0x00, 0x00, 0x8e, 0xfd, 0xff, 0xff, 0xff, 0xff, 0x3f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00,
   0x00, 0x00, 0xfd, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xfe, 0xff, 0x07, 0x00, 0x00, 0x00, 0x20, 0xfc, 0xff,
   0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
   0xff, 0x03, 0x00, 0x00, 0x00, 0x4c, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x7f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x00, 0x00,
   0x00, 0x38, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x0c, 0xfc, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
   0xff, 0x01, 0x00, 0x00, 0x00, 0x78, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00,
   0x00, 0x0a, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x80, 0x0c, 0x6c, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x02, 0xb2, 0xbb, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xc0, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x9b,
   0xfe, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xfd, 0xff, 0xff, 0xff,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x3f, 0x00, 0x00, 0x00,
   0x00, 0x04, 0x00, 0x10, 0x6e, 0xfe, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28,
   0xee, 0xf9, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xdb, 0x7f, 0xf9, 0xff, 0xff,
   0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x10, 0x60, 0xf7, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x09,
   0x14, 0xfe, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xc1, 0x1d, 0xf8, 0xff, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xff, 0xa7, 0xf7, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0xff, 0xf7, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0x00,
   0x01, 0xe8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff,
   0x0f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x0f, 0xf8, 0x3f, 0x1e,
   0xe2, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
   0x00, 0x00, 0xf0, 0xff, 0x0f, 0xfe, 0xff, 0xff, 0xa3, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,
   0x87, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7, 0xff, 0xff, 0xff,
   0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00,
   0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x2f, 0xff, 0xff,
   0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x00, 0xfc, 0xff, 0xff, 0xff, 0x2f, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00,
   0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xfe, 0xff, 0xff,
   0xff, 0xbf, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff,
   0xc7, 0xff, 0xff, 0x7f, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x83, 0x7f, 0xfe, 0x1f,
   0x00, 0xf7, 0xff, 0xff, 0xff, 0x13, 0xfd, 0xff, 0xff, 0x0f, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0xff, 0x83, 0x7f, 0xfc, 0x1f, 0x00, 0xff, 0xff, 0xff,
   0xcd, 0x1f, 0xfd, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0x03, 0x12, 0xfc, 0x07, 0x00, 0xf3, 0xbf, 0xff, 0x01, 0x80, 0xfd, 0xff,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x00, 0xe0, 0x07,
   0x00, 0xe7, 0xff, 0xff, 0x11, 0x00, 0xfd, 0xff, 0xff, 0x0f, 0x00, 0x00,
   0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x20, 0x03, 0x80, 0xff, 0xbf, 0x9f,
   0x60, 0x00, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
   0x03, 0x00, 0x00, 0x00, 0x00, 0xca, 0xbf, 0x1d, 0x20, 0x00, 0xfc, 0xff,
   0xff, 0x03, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
   0x80, 0x0b, 0xa4, 0x02, 0x10, 0x80, 0xf8, 0xff, 0xff, 0x03, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff, 0x84, 0x02,
   0x80, 0x42, 0xf8, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff,
   0x03, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x8f, 0x05, 0x00, 0x82, 0xf8, 0xff,
   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00, 0x00,
   0x40, 0xff, 0x0b, 0x00, 0x10, 0x80, 0xf8, 0xff, 0xff, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00, 0x00, 0x80, 0x49, 0x18, 0x00,
   0x1e, 0xe0, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff,
   0x03, 0x00, 0x00, 0x00, 0x80, 0x23, 0xfc, 0x03, 0x80, 0xc2, 0xe0, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00, 0x00,
   0x80, 0x4b, 0x1e, 0xc0, 0x08, 0x21, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xf8, 0xff, 0x07, 0x00, 0x00, 0x00, 0x40, 0xeb, 0x1f, 0x80,
   0x00, 0xc1, 0xf9, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,
   0x07, 0x00, 0x00, 0x00, 0x80, 0xff, 0x07, 0x00, 0x40, 0x0c, 0xec, 0xff,
   0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x07, 0x00, 0x00, 0x00,
   0x80, 0xff, 0x3f, 0x80, 0x00, 0xff, 0xfa, 0xf8, 0xff, 0x07, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xff, 0x07, 0x00, 0x00, 0x00, 0x80, 0xff, 0x3f, 0x80,
   0x00, 0xef, 0xfc, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0x03, 0x60, 0xe5, 0xf8, 0xf9,
   0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbe, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x48, 0xff, 0xeb, 0xe8, 0x03, 0xea, 0xe9, 0xff, 0x3f, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x2f,
   0x40, 0x02, 0xf8, 0xed, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
   0x0e, 0x00, 0x00, 0x00, 0xf0, 0x6f, 0xff, 0x05, 0x90, 0x3d, 0xee, 0xe5,
   0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
   0xfc, 0xff, 0xff, 0xdd, 0x88, 0xfd, 0xfc, 0xf5, 0xff, 0x7f, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe1, 0xff, 0xff, 0xff, 0x7f,
   0x00, 0x26, 0xea, 0xf8, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xe0, 0xff, 0xff, 0x7f, 0xf8, 0xfd, 0x87, 0xf8, 0xf8,
   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0xff, 0xff, 0x7f, 0x19, 0x0d, 0x81, 0xf8, 0xfd, 0xff, 0xff, 0x03, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0xac,
   0x0f, 0x1c, 0xf4, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xe4, 0xc2, 0x7f, 0xfc, 0xff,
   0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
   0xf8, 0xff, 0xff, 0xf7, 0x80, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xb1,
   0x4f, 0xc0, 0xfc, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x01, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xff, 0xbf, 0x4f, 0x1f, 0xff, 0xff,
   0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0x3f, 0xcb, 0xf7, 0xfc, 0xff, 0xff, 0xff, 0x03, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x7c,
   0x68, 0xcf, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0x3f, 0x44, 0x9b, 0xfc, 0xff,
   0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x20, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0xfc, 0xcf, 0xbf, 0x4c, 0x9f, 0xfc, 0xff, 0xff, 0xff, 0x03, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff,
   0xcc, 0xed, 0xfe, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xff, 0x00, 0x00, 0x80, 0xfa, 0xff, 0xff, 0xff, 0x9c, 0x9f, 0xff, 0xff,
   0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xf3,
   0xff, 0xff, 0xff, 0xff, 0xc0, 0xd9, 0xfe, 0xff, 0xff, 0xff, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x80, 0xff, 0xff, 0xff, 0xdf, 0xff,
   0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0x00, 0x80, 0x0f, 0x00, 0xc0, 0x8d, 0xff, 0xa0, 0xfe, 0xff, 0xff,
   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x00, 0x01,
   0x00, 0xc0, 0x00, 0xf8, 0x40, 0xfd, 0xff, 0xff, 0xff, 0xbf, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0xf8, 0xe0, 0xf8,
   0xfc, 0xf7, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xc0, 0x01, 0x00, 0x00, 0xf0, 0xff, 0x5f, 0xfa, 0xff, 0xfd, 0xff, 0xff,
   0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00,
   0xf0, 0xff, 0xff, 0xdb, 0xbf, 0xff, 0xfd, 0xff, 0xff, 0x7f, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xff, 0xff, 0x9f, 0x73,
   0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x07, 0x00, 0x00, 0xff, 0xff, 0xbf, 0xf1, 0xf5, 0xff, 0xfc, 0xff,
   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00,
   0xfc, 0xff, 0x2f, 0x38, 0xf7, 0xff, 0xf9, 0xff, 0xff, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xc0, 0xbf, 0x60, 0xfe,
   0xfd, 0xff, 0xfb, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x1f, 0x00, 0x00, 0xc0, 0x12, 0xe0, 0xbf, 0xf7, 0xff, 0xfd, 0xff,
   0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0xf6, 0xff, 0xfc, 0xff, 0xf9, 0xff, 0xff, 0xff, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xf8,
   0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x7f, 0x00, 0x00, 0x00, 0xc0, 0xf9, 0xff, 0xff, 0xff, 0xf9, 0xff,
   0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xfb, 0x00, 0x00,
   0x00, 0xc0, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0xf3, 0x03, 0x00, 0x00, 0xdc, 0xff, 0xff,
   0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf3, 0x07, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x1f, 0x00,
   0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x3f, 0x00, 0xc0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf7, 0xff, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xe1,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

#define hourglass_width 13
#define hourglass_height 19
static BMap hourglass_bits[] = {
   0xfe, 0x0f, 0xfe, 0x0f, 0x5c, 0x05, 0xac, 0x04, 0x5c, 0x04, 0x2c, 0x02,
   0x58, 0x01, 0xb0, 0x00, 0x60, 0x00, 0xe0, 0x00, 0x60, 0x00, 0xb0, 0x00,
   0x58, 0x01, 0x2c, 0x02, 0x5c, 0x04, 0xac, 0x04, 0x5c, 0x05, 0xfe, 0x0f,
   0xfe, 0x0f};
/*
   0xfe, 0x0f, 0xfe, 0x0f, 0x54, 0x05, 0xac, 0x04, 0x54, 0x04, 0x2c, 0x02,
   0x58, 0x01, 0xb0, 0x00, 0x60, 0x00, 0xa0, 0x00, 0x60, 0x00, 0xb0, 0x00,
   0x58, 0x01, 0x2c, 0x02, 0x54, 0x04, 0xac, 0x04, 0x54, 0x05, 0xfe, 0x0f,
   0xfe, 0x0f};
*/

#define stipple_width 16 
#define stipple_height 16 

static BMap stipple_bits[] = {
   0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55,
   0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55,
   0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55};

static Pixmap hlfgrey = (Pixmap) NULL;

#define hlfgrey_width 8
#define hlfgrey_height 8
static BMap hlfgrey_bits[] = {
   0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

static Pixmap qwgrey = (Pixmap) NULL;
#define qwgrey_width 8
#define qwgrey_height 8
static BMap qwgrey_bits[] = {
   0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44};

static Pixmap tqwgrey = (Pixmap) NULL;
#define tqwgrey_width 8
#define tqwgrey_height 8
static BMap tqwgrey_bits[] = {
   0xee, 0xbb, 0xee, 0xbb, 0xee, 0xbb, 0xee, 0xbb};

static Pixmap upPix,  downPix,  lPix, rPix, molPix, gPix,fastPix,slowPix,blastPix,SkullPix,OrigPix,FotoPix,ColPix,CellPix,SurfPix,VRMLPix,HPix,AlignPix,FFPix,BigPix, ballPix, HourPix, MLFPix, OGLPix, movPix,stopPix,mapPix,triPix;

#define down_width 16
#define down_height 16
static BMap down_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x10, 0x04, 0x10, 0x04,
   0x10, 0x04, 0x1e, 0x3c, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0x20, 0x02,
   0x40, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};

#define up_width 16
#define up_height 16
static BMap up_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x01, 0x20, 0x02, 0x10, 0x04,
   0x08, 0x08, 0x04, 0x10, 0x1e, 0x3c, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04,
   0xf0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#define l_width 16
#define l_height 16
static BMap l_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x01, 0x40, 0x01, 0x20, 0x1f,
   0x10, 0x10, 0x08, 0x10, 0x04, 0x10, 0x08, 0x10, 0x10, 0x10, 0x20, 0x1f,
   0x40, 0x01, 0x80, 0x01, 0x00, 0x01, 0x00, 0x00};
#define r_width 16
#define r_height 16
static BMap r_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x01, 0x80, 0x02, 0xf8, 0x04,
   0x08, 0x08, 0x08, 0x10, 0x08, 0x20, 0x08, 0x10, 0x08, 0x08, 0xf8, 0x04,
   0x80, 0x02, 0x80, 0x01, 0x80, 0x00, 0x00, 0x00};
#define pace_width 16
#define pace_height 16
static BMap slow_bits[] = {
   0xe0, 0x03, 0x18, 0x0c, 0x04, 0x10, 0x02, 0x20, 0x02, 0x20, 0x01, 0x40,
   0x01, 0x40, 0x81, 0x40, 0x81, 0x40, 0x81, 0x41, 0x82, 0x21, 0x82, 0x21,
   0x84, 0x13, 0x98, 0x0f, 0xe0, 0x03, 0x00, 0x00};
static BMap fast_bits[] = {
   0xe0, 0x03, 0x18, 0x0c, 0x04, 0x10, 0x02, 0x20, 0x02, 0x20, 0x01, 0x40,
   0x01, 0x40, 0x81, 0x40, 0x81, 0x41, 0x81, 0x43, 0x82, 0x27, 0x82, 0x2f,
   0x84, 0x1f, 0x98, 0x0f, 0xe0, 0x03, 0x00, 0x00};
static BMap blast_bits[] = {
   0xe0, 0x03, 0x18, 0x0c, 0x04, 0x10, 0x02, 0x20, 0x02, 0x20, 0x01, 0x40,
   0x01, 0x40, 0x81, 0x7f, 0x81, 0x7f, 0x81, 0x7f, 0x82, 0x3f, 0x82, 0x3f,
   0x84, 0x1f, 0x98, 0x0f, 0xe0, 0x03, 0x00, 0x00};

#define film_width 17
#define film_height 17
static char film_bits[] = {
   0x00, 0x00, 0x0, 0x00, 0x07, 0x0, 0xb8, 0x0f, 0x0, 0xfc, 0x0f, 0x0, 0xfc, 
   0x07, 0x0, 0xf8, 0x03, 0x0, 0xfc, 0xcf, 0x0, 0x04, 0xf8, 0x0, 0xf4, 0xfb, 
   0x0, 0xf4, 0xfb, 0x0, 0xf6, 0xfb, 0x0, 0x06, 0xc8, 0x0, 0xfc, 0x0f, 0x0, 
   0xe0, 0x01, 0x0, 0xa0, 0x01, 0x0, 0xe0, 0x01, 0x0, 0x00, 0x00, 0x0 };

#define stop_width 16
#define stop_height 16
static BMap stop_bits[] = {
  0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e,
  0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e,
  0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x00, 0x00, };

#define MAX_COLORS  256
#ifndef COLOR_OFFSET
#define COLOR_OFFSET 0.25
#endif
static float coloff = COLOR_OFFSET;

static Display *display;
static int screen;
static unsigned long colors[MAX_COLORS];
static unsigned short colorr[MAX_COLORS];
static unsigned short colorg[MAX_COLORS];
static unsigned short colorb[MAX_COLORS];
static int colcells = 16;
static int IBGcolor = 0;
static int OBGcolor = 0;
static int BGmode = 0;
#define SHCOLNUM 7
static int shcolors[SHCOLNUM] = {190,193,196,199,202,205,208};
static int rimcols[7] = {0,0,3,1,6,10,5};
#define LIGHT  1
#define MEDIUM 0
#define DARK   2

#define MAXSAVE 100000
#define MXSAVESTR 1000
static struct{float xxval;
              float yyval;
	      XPoint *points;
	      int npoints;
	      int icol;
	      int icon;
	      int isgrey;
              int evtype;} savecom[MAXSAVE] = {0.0,0.0,NULL,0,0};
              
static int count = 0;
static int scount = 0;
static int cnt = 0;
static int ihlp ;
static int hold = 0;
static int holdt = 0;
static int holdp = 0;
static char savestr[MXSAVESTR][255];
static int nsavestr[MXSAVESTR];
	 
static Bool monoscr = 0;
static int linwid = 1;
static int linmax = 10;

static float xoff = 0.0;
static float yoff = 0.0;
static float scale = 1.0;
static int MotionCount = 0;
static int ZoomX1, ZoomY1;
static int ZoomX2, ZoomY2;
static int ZoomW, ZoomH;
static int inited = 0;
static Bool ZoomEnable = True, ZoomSelection = False;
static Bool Select = True;
static Cursor ZoomCursor;
static Cursor AtomCursor;
static Cursor WaitCursor;
static int *jring;
static int *isimpl;
static int *fancy;
static int *istaro;
static int *atcol;
static int *shade;
static int *persp;
static int TRANS;
static int TRANSb;
static int DoShadow = 0;
static int DoLines = 0;
static int DoBlur = 0;
static int DoSSAO = 0;
static int DoShad = 0;
static int DoMIPMAP = 1;
static int DoIntel = 0;
static int SSAO_type = 1;
static int aflag = 0,anum,acnt;
static int bflag = 0;
static int cflag = 0;
static int dflag = 0;
static int eflag = 0;
static int doalign = 0;
static int bretval = 320;
static int omapr = 0;
static int omapfol = 0;
static int omaplck = 0;
static int omaphlp = 0;
static int omapCa = -1;
static int omapPandN = 0;
#define MINDIFF 15
static int asel[6];
static int aselkeep[2];
static int monmode = 2;
static float aret;
static float toangs = 0.52917706e0;

static Window win,winC,subC,winMC,subMC,winau,wincnv,wingeo,winspec,subSPEC,winsco,winpmf,winrama,subMOV,windock; 			
static Window Fwin,RESwin,COMMwin,DISTwin,subDIST,SUBwin,CPwin,CTwin;
static Window rootW;
static GC gc;				
static GC gc1;				
static Pixmap stipple;
static Pixmap gijs;
static Pixmap molback;
static Pixmap distpix;
static Pixmap bckwin;
static Pixmap colmap;
static int dstpxini = 0;
static unsigned int BckW = 100;	
static unsigned int BckH = 20;	
static Drawable molcur;
XSizeHints size_hints;		
XTextProperty windowProp;
XIconSize *size_list;	
XEvent report;
XEvent event;
XGCValues values;
XWindowAttributes xwa;
static XFontStruct *mfinfo;
static XFontStruct *labinfo;
static XFontStruct *slabinfo;
Pixmap icon_pixmap;
void filecall(char *str);
void fwincall(char *str);
void substrcall(char *str);
void getpdbcall(char *str);
void obsrch(char *str);
void killob();
void savsdf(char *str);
static int addfile = 0;
static int poszset = 0;
static float poszbck = 0;
static KeySym ks;

static int xlx, yly ;			/* more statics for     */
static int start_xlx, start_yly;	/* line drawing		*/
static int isgl2D = 0;
static unsigned int width, height;		/* window size		*/
static float Aspect = 1.0;
static int Mwidth, Mheight;		/* window size		*/

static int wx = 10, wy = 30;	/* window location	*/
static unsigned int border_width = 0;	/* no border 		*/

unsigned int icon_width, icon_height;       
unsigned long foreground_pixel;
static XSetWindowAttributes xswa;
static XVisualInfo *vi;
#define FFOGD 2.0
#define FFOGDS 4.0
static int has_opengl = 0;

static char *window_name  = "MOLDEN";
static char *icon_name    = "Molden";
static char *display_name = NULL;
static char *unknown  = "Unknown";

#define MAXSTRLEN 80 
#define MAXPATHLEN 1024 
#define MAXSTRLMW 40 
#define MAXNAMES 10000
#define MAXDIRS 500
#define MAXDIRLEN 1024
#define DEFSTRNAME ""
#define DEFAUTHGEOM  "-100+100"
#define DEFCNVGEOM  "-10+10"
#define DEFPMFGEOM  "-10+440"
#define DEFCNV2GEOM  "-410+10"
#define DEFQBOXGEOM  "-400-400"
#define DEFPOPGEOM  "-200+200"
#define DEFQX	3
#define DEFQY	3
#define QBOXWIDE  450
#define QBOXHIGH   40
#define QBOXTX    340
#define QBOXZM    290
#define QBOXRF    290
#define QBOXRFD   331
#define QBOXFR      4
#define QBOXBORD    4
#define CNVOFFX    30
#define CNVOFFY    30
#define CNVBORD    10
#define DBHIGH     46
#define DBWIDE    236


static int CNVWIDE = 300;
static int CNVHIGH = 300;
static int gwi = 300;
static int ghi = 300;
static int rwi = 300;
static int rhi = 300;
static int rwiold = 300;
static int rhiold = 300;
static int nwframes = 0;
static int nhframes = 0;


#define SBOXWIDE  600
#define SBOXHIGH  400
#define SBOXOFFX  52
#define SBOXBLEN  200
#define SBOXOFFL  SBOXOFFX+SBOXBLEN+10
static int SUBup = 0;
static int *ipdbwh;

#ifdef DOQUEUE
static int nques = 4;
static int qopt = 0;
static char *ques[] = {"short","medium","long","power"};
static int quetims[] = {9,105,325,650};
#endif

static char *subwname[]  = {"Submit Gamess-UK Job","Submit Gaussian Job","Submit Mopac Job"};

static char *topt1[] = {"Single Point","Geometry Optimisation",
"Cart. Geom. Optimisation","Transition State","Frequency (Numerical)",
"Frequency (Analytical)","SDCI","Polarisability","HyperPolarisability",
"Magnetisability","Raman Intensities","IR Intensities","Localised Orbitals"};
static char *topt2[] = {"Single Point","Geometry Optimisation","Transition State","Frequency"};
static char *topt3[] = {"Single Point","Geometry Optimisation","Transition State","Frequency","Geometry Opt. & Frequency"};
static char *topt4[] = {"Single Point","Geometry Optimisation","Transition State","Frequency","Geometry Opt. & Frequency"};
static char **toph[4] = {topt1,topt2,topt3,topt4};
static int topn[4] = {13,4,5,5};
static char **topt;
static int toptn;
static char *tkey1[] = {" "," "," "," "," "," "," "," "," "," "," "," "," "};
static char *tkey2[] = {" ","Opt","Opt=TS","Freq"};
static char *tkey2b[] = {" ","Opt=Z-matrix","Opt=(TS,Z-matrix)","Freq"};
static char *tkey3[] = {"1SCF","EF","TS","FORCE LET","FORCE"};
static char *tkey4[] = {"1SCF","EF","TS","FORCE LET","FORCE"};
static char **tkeyh[4] = {tkey1,tkey2,tkey3,tkey4};
static char **tkey;
static int itopt[4] = {1,1,1,1};

static char *mopt1[] = {"RHF","Direct RHF","UHF","GVB n","MP2","Direct MP2","MP3","CASSCF"};
static char *mopt2[] = {"HF","RHF","UHF","ROHF","MP2","MP4","QCISD","CASSCF","LSDA","BHandH","BHandHLYP","Becke 3 LYP","AM1","dreiding","Amber"};
static char *mopt3[] = {"PM3","AM1","MNDO","MINDO3","PM6","PM7","RM1"};
static char *mopt4[] = {"RHF","UHF","DFT LDA","DFT PBE","DFT B3LYP"};
static char **moph[4] = {mopt1,mopt2,mopt3,mopt4};
static int mopn[4] = {8,15,7,5};
static char **mopt;
static int moptn;
static char *mkey1[] = {" "," "," "," "," "," "," "," "};
static char *mkey2[] = {"HF","RHF","UHF","ROHF","MP2","MP4","QCISD","CASSCF(4,6)","SVWN","BHandH","BHandHLYP","Becke3LYP","AM1","dreiding","Amber"};
static char *mkey3[] = {"PM3","AM1","MNDO","MINDO3","PM6","PM7","RM1"};
static char *mkey4[] = {"RHF","UHF","DFT LDA","DFT PBE","DFT B3LYP"};
static char **mkeyh[4] = {mkey1,mkey2,mkey3,mkey4};
static char **mkey;
static int imopt[4] = {0,0,1,0};

static char *bopt1[] = {"STO-3G","3-21G","4-31G","6-31G","6-31G*","6-31G**","MINI1","MINI4","MIDI1","MIDI4","DZ","TZV","TZVP","ECPMIN","ECPDZ","ECPTZV","ECPTZVP"};
static char *bopt2[] = {"STO-3G","3-21G","4-31G","6-31g","6-31G*","6-31G**","6-31+G*","LANL2DZ"};
static char *bopt3[] = {" "};
static char *bopt4[] = {"STO-3G","3-21G","4-31G","6-31g","6-31G*","6-31G**","6-31+G*","6-311G**"};
static char **boph[4] = {bopt1,bopt2,bopt3,bopt4};
static int bopn[4] = {17,8,1,8};
static char **bopt;
static int boptn;
static char *bkey1[] = {"STO-3G","3-21G","4-31G","6-31G","6-31G*","6-31G**","6-31+G*","LANL2DZ"};
static char *bkey2[] = {"STO-3G","3-21G","4-31G","6-31G","6-31G*","6-31G**","6-31+G*","LANL2DZ"};
static char *bkey3[] = {" "};
static char *bkey4[] = {"STO-3G","3-21G","4-31G","6-31G","6-31G*","6-31G**","6-31+G*","6-311G**"};
static char **bkeyh[4] = {bkey1,bkey2,bkey3,bkey4};
static char **bkey;
static int ibopt[4] = {0,0,0,0};


static char *spopt[] = {"Singlet","Doublet","Triplet","Quartet","Quintet","Sextet","Septet","Octet"};
static int ispopt = 0;

static char *molopt1[] = {"No extra keys","Molden G94/98","Molden G92"};
static char *molopt2[] = {"No extra keys","extra keys"};
static char *molopt3[] = {"ecce key","no keys"};
static char **molopt;
static int imolopt[4] = {1,1,1,1};

static char *copt[] = {"-3","-2","-1","0","1","2","3","other"};
static int icopt = 3;

static char *resopt[] = {"Dont Save EDs","ed3","ed2","ed2 + ed3","Restart HF","Restart CASSCF","Restart MCSCF","Restart CI","Restart MRDCI","Restart FULLCI"};
static char *reskey[] = {" ","-t ed3","-t ed2","-t ed2 -t ed3","-r hf","-r casscf","-r mcscf","-r ci","-r mrdci","-r fullci"};
static int iresopt = 0;

static int iscfd = 1;
static int ihess = 1;
static char scfdir[] = "SCF=Direct";
static char nullstr[] = " ";
static int jmode;
static int izmat = 1;
static int ioniom = 0;
static int ionon = 0;

#define SUBLEN1 80
#define SUBLEN2 15
static char rungam[SUBLEN1];
#ifdef VMS
static struct dsc$descriptor_s *glin1;
static struct dsc$descriptor_s *glin2;
static struct dsc$descriptor_s *gtitl;
static struct dsc$descriptor_s *jname;
static struct dsc$descriptor_s *qname;
static struct dsc$descriptor_s *ename;
static struct dsc$descriptor_s *vfile;
static struct dsc$descriptor_s *mfile;
static struct dsc$descriptor_s *gfile;
static struct dsc$descriptor_s *oglfile;
static struct dsc$descriptor_s *povfile;
static struct dsc$descriptor_s *tnkjn;
static struct dsc$descriptor_s *tmpfil;
#else
#ifdef CRAY
static _fcd glin1;
static _fcd glin2;
static _fcd gtitl;
static _fcd jname;
static _fcd qname;
static _fcd ename;
static _fcd vfile;
static _fcd mfile;
static _fcd gfile;
static _fcd oglfile;
static _fcd povfile;
static _fcd tnkjn;
static _fcd tmpfil;
#else
static char *glin1;
static char *glin2;
static char *gtitl;
static char *jname;
static char *qname;
static char *ename;
static char *vfile;
static char *mfile;
static char *gfile;
static char *oglfile;
static char *povfile;
static char *tnkjn;
static char *tmpfil;
#endif
#endif

#define MAXCMD 256
static char cmdstr[MAXCMD];
static int cycle = 0;
static int delcyclefile = 0;
/*static int fndfile = 0;*/
volatile sig_atomic_t fndfile;
/*static int uping = 0;*/
#define CHUNK 5
volatile sig_atomic_t uping;
static volatile sig_atomic_t nomemf = 0;
volatile sig_atomic_t DoSVGExpose;
static int tnkfrk = 0;
static int tnkpid = 0;
static int tnkupd = 0;
volatile sig_atomic_t tnkupf = 0;
static int tnkesc = 0;
static int tnkloop = 0;
static int handle = 0;
static int tnk_single = 0;
static int opttim = 0;
static int icyco = 0;
static int TIMi = 100;
#define NCYCO 5
static long timo[NCYCO];
static double newen;
static int hasmpi = 0;
static char mpicmd[MAXCMD];
static char mpilib[MAXCMD];
static char npth[MAXCMD];
static int maxproc = 0;
static int useproc = 1;
static int usempi = 0;

static unsigned long infofg, infobg;
static unsigned long Black, White;
static Window QBox, PopUp, FrBox,EBox, PopOk;
static char   strname[MAXSTRLEN];
static char   molwstr[MAXSTRLMW] = " ";
static char   densstr[MAXSTRLMW] = " ";
static char   *qboxprmt;
static char   stemp[MAXSTRLEN];
static char   atemp[MAXSTRLEN];
static char   chgtmp[MAXSTRLEN];
static char   pchgtmp[MAXSTRLEN];
static char   resfil[MAXSTRLEN];
static char   qrb_title[MAXCMD] = " ";
static char   organism[MAXCMD] = " ";
static int norbs;

#define gray50_width 8
#define gray50_height 8
static BMap gray50_bits[] = {
   0x33, 0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33, 0xcc};

typedef void (*ptr_void_proc)();

typedef struct { Window win;            /* parent window */
                 int x,y,w,h;           /* size of button rectangle */
                 int lit;               /* if true, invert colors */
                 int active;            /* if false, stipple gray */
                 int toggle;            /* if true, clicking toggles state */
                 int boggle;            /* if true, clicking toggles state */
                 int lastused;          /* lastused */
		 int fg;		/* foreground color index */
                 int bg;		/* colors */
                 char *str;             /* string in button */
                 char *explstr;         /* string with explanation */
                 Pixmap pix;            /* use pixmap instead of string */
                 int pw,ph;             /* size of pixmap */
                 int style;             /* ... */
                 int fwidth;            /* width of frame */
               } BSTRU;

void DrwBut(BSTRU *bp);
void ActBut(BSTRU *bp,int act);
void TogDown(BSTRU *bp);
void TogUp(BSTRU *bp);
void SelBut(BSTRU *bp);
void DefBut(BSTRU *bp,Window win,int x,int y,int w,int h,
	char *str,unsigned long bg,int fg);

typedef struct { Window win;            /* parent window */
		 int x,y;		/* pos. of scroll rectangle */
                 unsigned int w,h;      /* size of scroll rectangle */
		 int *wn;		/* number of elements in list */
		 int *wpos;		/* position of window in list */
		 int fpos;		/* position cursor */
		 int wh;		/* hight of the rectangle in elements */
		 ptr_void_proc callback;/* callback routine */
               } SCRSTRU;

static SCRSTRU zscroll;

#define SCRMIN 10

void DefScroll(SCRSTRU *sc,Window win,int x,int y,unsigned int w,
	unsigned int h,int *wn,int *wpos,int wh,ptr_void_proc callback);
void RedrawScroll(SCRSTRU *sc);

typedef struct {char   **list;		/* pointer to list of strings */
		float  *rlst;		/* pointer to float array */
		double  *flst;		/* pointer to double array */
		int *ilst;		/* pointer into list */
		int *slst;		/* pointer into selected list */
		SVGFSTRUC *svgs;	/* list of svg's for each file */
		int *nents;		/* number of entries in list */
		} LSTRU;

typedef struct {char   **list;		/* pointer to list of strings */
		int nents;		/* number of entries in list */
		} LSSTRU;

typedef struct { Window win;            /* parent window */
                 int x,y;		/* size of list rectangle */
                 unsigned int w,h;      /* size of list rectangle */
		 unsigned int wwin;	/* size of parent window */
		 int mxents;		/* max entries in visible window on list*/
		 LSTRU list;
		 char *label;		/* tabel header */
		 int lpnt;		/* position of window in list */
		 int dosel;
		 int select;		/* selected entry */
		 int fgc;
		 int bgc;
		 int hlc;
		 char *sub;
		 BSTRU arrbut[2];	/* pointer to arrbuttons */
		 SCRSTRU scrbar;	/* scrollbar */
               } LISTSTRU;

typedef struct { Window win;            /* parent window */
		 Window Callwin;
		 LISTSTRU flist;
		 LISTSTRU dirlist;
		 BSTRU rbut[7];
		 char  *files[MAXNAMES];
		 char  *dirs[MAXDIRS];
		 char  lastdir[MAXDIRLEN];
		 char  label[MAXSTRLEN];
		 char  substr[MAXSTRLEN];
		 char *pntr;
		 int nfiles;
		 int ndirs;
		 int qbrfile;
		 int inct;
		 int parse;
		 int subopt;
		 char **commstr;
		 int ncomm;
		 int icomm;
               } FSELSTRU;

void RedrawFwin(FSELSTRU *fs);
void RedrawList(LISTSTRU *lp);
void getfiles(FSELSTRU *fs, char* dirname);
void RedrawLBox(LISTSTRU *lp);
void DefList(LISTSTRU *lp,Window win,int x,int y,unsigned int w,unsigned int h,
	char *label,int mx,char **lstr,float *rlist,double *flst,int *slist,
	int *nentries,SVGFSTRUC *svgs);
void RedrawPopUp(LSSTRU *List);
int DoPopUp(Window ParentWin,int x,int y,LSSTRU *List,int *iopt,int icent);

static int nbytes_select;
static char *select_pointer;
typedef struct { Window win;            /* parent window */
		 int pop;		/* is it a popup */
		 int active;		/* is it active  */
		 int changed;		/* is it changed  */
		 int fake;		/* is it a fake empty box  */
                 int x,y;		/* size of list rectangle */
                 unsigned int w,h;      /* size of list rectangle */
		 int col;		/* color of rectangle */
		 int bgcol;		/* background color of fake rectangle */
                 char *prompt;          /* prompt string */
		 int qbopt;		/* what is the answer, any of 3 below */
                 char *str; /* query string */
		 int strmax;		/* maximum length of string */
		 int wnd_start;		/* the start of the visible protion of he string */
		 int wlen;		/* length in char of the windows */
		 int shfilint;
		 int curpos;		/* insertion position */
		 int	*iflt;		/* int answer */
		 short int	*i2flt;	/* short int answer */
		 float	*qflt;		/* float answer */
		 double	*dflt;		/* double answer */
		 int qbinct;		/* option to be given to fortran */
                 char *explstr;         /* string with explanation */
                 int expldone;          /* flag explanation done */
		 ptr_void_proc callback;/* callback routine */
               } QBOXSTRU;

void PromptBox(QBOXSTRU *qp);

void qboxstr(QBOXSTRU *qp,Window *win,int active,int fake,int bgcol,int x,int y,int w,int h,int col,char *prompt,char *defstr,int strmax,int iopt,int qinct,int mxstr,ptr_void_proc callback);

#define mxvalc 10
typedef struct { double edge;
		 double ctval[mxvalc];
		 double pxyz[3];
                 int nvalc,nspts,istyp; 
               } SRFSTRU;

static SRFSTRU *surface;

typedef struct { Window win;            /* parent window */
		 int x,y;		/* pos. of scroll rectangle */
                 unsigned int w,h;      /* size of scroll rectangle */
		 int sh;		/* slider height */
		 int *wn;		/* max slider position */
		 int *wpos;		/* slider position */
		 float *ratio;		/* ratio */
		 ptr_void_proc callback;/* callback routine */
               } SLIDESTRU;

void DefSlide(SLIDESTRU *sc,Window win,int x,int y,unsigned int w,unsigned int h,int sh,int *wn,int *wpos,float *rat,ptr_void_proc callback);
void RedrawSlide(SLIDESTRU *sc);

typedef struct { 
	char *str; 
	int *line_index; 
	int *fpos;
	char **lines;
	int size;
	int nlines;
	int nfiles;
	int list;
	int opt;
	int currl; } FILEOP;

#define FILEBUT 2
#define FILEWINW 1000
#define FILEWINH 700

typedef struct { 
		 int *commds;
		 char **commstr;
		 int ncomm;
		 int icomm;
		 char **Open3Dcomms;
		 int nOpen3Dcomm;
		 FILEOP fileop;
		 int FILEup;
		 Window FILEwin;
		 Window subFILE;
		 LISTSTRU FILElist;
		 LISTSTRU COMMlist;
		 BSTRU FILEbut[FILEBUT];
		 QBOXSTRU *qbox;
               } SHFILSTRU;

#define MXSHFILS 10

static SHFILSTRU shfiles[MXSHFILS];
static int nshfile = 0;

void ShowFile(char *fname,char *sub,SHFILSTRU *sh);

#define NOBJS 59
typedef struct { 
		Window *win;
		Window *subwin;
		int *winup;
		BSTRU *butarr;
		int numbut;
		ptr_void_proc init;
		ptr_void_proc redraw;
		SHFILSTRU *sh;
               } WSTRU;

#if defined(DARWIN) || defined(FREEBSD)
static WSTRU WinObj[NOBJS];
#else
static WSTRU WinObj[NOBJS] = {{.win = NULL, .winup = NULL, .butarr = NULL, .win = NULL, .redraw = NULL, .sh =  NULL}};
#endif

static char **mlftit = NULL;
static int mxtits = 0;
static int ntits = 0;
static double *scle;
static double *adjuss;
static double *rng1;
static double *rng2;
static double *vlcnt;
static double *vlcnt2;
static double *valcnt;

typedef struct { double hdmin;
		 double hdmax;
		 float hamin;
		 float hamax;
               } HBSTRU;

static HBSTRU *hbpars;

typedef struct { int button;
		 Window win;
		 BSTRU *barr;
		 QBOXSTRU *qarr;
		 int borq;
		 int active;
		 int *winup;
               } EXPLSTRU;

static EXPLSTRU expldat = {-1,-1,NULL,NULL,0,0,NULL};

static char *cellopts[] = {"Molecule","Mol+Cell","Packed-Cell 1",
"Packed-Cell 2","Packed-1+Surf","Packed-2+Surf","Multiple-Cells",
"Multiple-CellsA","Multiple-CellsB","Multiple-CellsC","Multiple-CellsAB",
"Multiple-CellsAC","Multiple-CellsBC","Cell Rot On/Off",
"Edit Cell Parameters","Delete Sel. Atoms","Move Sel. Atoms","SuperCell", "Optimise xtinker","Write"};
static int ncell = 20;
static char *cellwopts[] = {"Write DMAREL","Write CRYSTAL95","Write SHELX","Write VASP","write PLUTON","write MOPAC Tv","write CPMD","write CIF"};
static int nwcell = 8;
static double CellTran[] = {0.0,0.0,0.0};
static char *xtinkopts[] = {"Charges","Multipoles"};
static char *ambwopts[] = {"Without Cell","With Cell"};

static char *cellpars[] = {"A    ","B    ","C    ","ALPHA","BETA ","GAMMA","SpaceGroupNumber","SpaceGroupName"};
static char *cellvec[] = {"A","B","C"};
static int CPact[5][6] = {
  {1,1,1,1,1,1},
  {1,1,1,0,1,0},
  {1,1,1,0,0,0},
  {1,0,1,0,0,0},
  {1,0,0,0,0,0}
};
static int CPup = 0;
static int CPopt = 0;
#define CPBOXWIDE  250
#define CPBOXHIGH  310
#define CPBOXOFFX  20
#define CPBOXOFFY  20

static int CTdel = 0;
static int CTup = 0;
static int CTsdone = 0;
static int CTdsdone = 0;
static int CTconn = 1;
#define CTBOXWIDE  260
#define CTBOXHIGH  140
#define CTBOXOFFX  15
#define CTBOXOFFY  20

#define GLTOL 5

#define MAXPNT 2000
typedef struct { double fmaxt,frmst,dmaxt,drmst,fgmin,fgmax,dgmin,dgmax,enmax,enmin;
                 int ngeoms;
                 int nepnts;
                 int gcvav;
		 int ifmxav,ifrmav,idmxav,idrmav,ieav,ifrav,mxpnt;
               } GEO1STRU;

static GEO1STRU *geo1ptr;

typedef struct { double formax[MAXPNT];
                 double forrms[MAXPNT];
                 double dismax[MAXPNT];
                 double disrms[MAXPNT];
                 double epoints[MAXPNT];
                 int isav[MAXPNT];
               } GEO2STRU;

static GEO2STRU *geo2ptr;

typedef struct { double *formax;
                 double *forrms;
                 double *dismax;
                 double *disrms;
                 double *epoints;
                 int *isav;
		 int mxorg;
               } GEOPSTRU;

static GEOPSTRU geopntr;
static GEOPSTRU TMPgeopntr;

static GEOPSTRU *geop = &geopntr;

#define MAXITER 1000
typedef struct { double convg1[MAXITER];
                 double convg2[MAXITER];
                 double cnvmax,cnvmin;
                 int jstrt1,jend1;
                 int jstrt2,jend2;
                 int icvav1,icvav2;
               } CNVSTRU;

static CNVSTRU *cnvptr;

#define MXAMB 1590
#define MXGFF  72
#define MXAMBC 49
typedef struct { double ambchg[MXAMB];
                 double ambvw1[MXAMBC];
                 double ambvw2[MXAMBC];
                 double gfvdw[MXGFF][2];
		 int ambvdt[MXAMB];
                 double cysneg[9];
               } CHGVDWSTRU;

static CHGVDWSTRU *chgvdwptr;

#define MAXAT 1000

typedef struct {
	int swap;
	int prec;
	int box;
	int vir;
	int pres;
	int x;
	int v;
	int f;
	int natoms;
	int nframes;
	long *fpos;
	FILE *fptr;
       } sttrr;

static sttrr strx = {0,0,0,0,0,0,0,0,0,0,NULL,NULL};

typedef struct {
	int etot;
	FILE *fptr;
       } stedr;

static stedr stre;

void DoBackbone();
void cltrr();

static Bool Selecting = 0;


typedef struct { double *variable;
		 double varinit;
		 double varincr[3];
		 int isel;
		 int vartype;
		 int vdirection;
		 int frame;
		 int nframe;
		 int on;
		 int part;
		 int ssdone;
               } ANIMSTRU;

static ANIMSTRU animptr = {NULL,0.0,{0.01,5.0,5.0},0,0,1,0,60,0,0,0};

static int ANIMNXT = 0;

typedef struct { int ihasd;
		 int isgau;
		 int ido5d;
		 int ido7f;
		 int ido9g;
		 int ihasg;
               } GAUSTRU;
static GAUSTRU *slagau;

#define MAXFAT 1000
#define MAXFRQ MAXFAT*3
typedef struct { float freq[MAXFRQ];
		 float a[MAXFAT][3];
		 double fcoo[MAXFAT][3];
		 double frint[MAXFRQ];
		 double ramint[MAXFRQ];
		 int nfreq;
		 int ihasi;
               } FRQSTRU;
static FRQSTRU *FRQ;

typedef struct { double bl[MAXAT];
		 double alph[MAXAT];
		 double bet[MAXAT];
		 int ibl[MAXAT];
		 int ialph[MAXAT];
		 int ibet[MAXAT];
		 int ianz[MAXAT];
		 int iz[MAXAT][4];
		 int imap[MAXAT];
               } ZMATSTRU;

static ZMATSTRU *zmatptr;
static ZMATSTRU *zmatcptr;

typedef struct { double *bl;
		 double *alph;
		 double *bet;
		 int *ibl;
		 int *ialph;
		 int *ibet;
		 int *nz;
		 int *ianz;
		 int *iz;
		 int *imap;
		 int *ihaszm;
		 int *mxzat;
		 int mxzorg;
		} ZMSTRU;

static ZMSTRU zmptr;
static ZMSTRU zmcptr;
static ZMSTRU TMPzmptr;
static ZMSTRU TMPzmcptr;
static ZMSTRU *zmptrp = &zmptr;
static ZMSTRU *zmcptrp = &zmcptr;
static int zmcnz = -1;


typedef struct { int ipart;
		 int imn;
		 int imx;
		 int idcur;
		} ZMPARTSTRU;

static ZMPARTSTRU *zmpart;

typedef struct { int ianz;
		 int iz[4];
		 double bl;
		 double alph;
		 double bet;
		} ZLINESTRU;

void CopyFrag(ZLINESTRU *frag,int frglen,int linkoffset);
void MoveFrag(ZLINESTRU *frag,ZLINESTRU *destiny,int frglen,int destoff);
void AddFrag(ZLINESTRU *frag,int fraglen,double covang,double dih,
	int addrow,int update,int pdbt,int doadd);

typedef struct { double cstoc[MAXAT][3];
		 double czstoc[MAXAT][3];
		 double astoc[MAXAT];
		 double bstoc[MAXAT];
		 int ianstc[MAXAT];
               } TSTOCSTRU;

static TSTOCSTRU *tstoc;

typedef struct { double *cstoc;
		 double *czstoc;
		 double *astoc;
		 double *bstoc;
		 int *ianstc;
               } STOCSTRU;

static STOCSTRU stoc;
static STOCSTRU TMPstoc;
static STOCSTRU *stocp = &stoc;

void FreeZmt(ZMSTRU tzmt,STOCSTRU tstoc,
QBOXSTRU *tbox1,QBOXSTRU *tbox2,QBOXSTRU *tbox3,QBOXSTRU *tbox4,QBOXSTRU *tbox5);
#define MAXORB 256

typedef struct { double qd[MAXORB][MAXORB];
                 double pd[MAXORB];
                 double gd[MAXORB][3];
                 double hd[MAXORB][6];
               } TORBSTRU;

static TORBSTRU *torb;

typedef struct { double *qd;
		 double *pd;
		 double *gd;
		 double *hd;
               } ORBSTRU;

static ORBSTRU orb;
static ORBSTRU TMPorb;
static ORBSTRU *orbp = &orb;

typedef struct { double *focc;
		 double *focb;
		 double *vectrs;
		 double *vectrb;
		 double *p;
		 double *paa;
		 double *averag;
		 double *phi;
		 double *dphi;
		 double *dxpsi;
		 double *dypsi;
		 double *dzpsi;
		 float *eiga;
		 float *eigb;
		 float *stoalfa;
		 float *stobnorm;
		 int *ncols;
		 int *ncolb;
		 int *nocc;
		 int *nocb;
		 int *naorbs;
		 int *mxorb;
		 int *istos;
		 int mxorg;
               } DORBSTRU;

static DORBSTRU dorb;
static DORBSTRU TMPdorb;
static DORBSTRU *dorbp = &dorb;

#define NUMPRM 1600
#define NUMCEX NUMPRM*3

typedef struct { double exx[NUMCEX];
		 double c1[NUMCEX];
		 double c2[NUMCEX];
		 double c3[NUMCEX];
		 double c4[NUMCEX];
		 double c5[NUMCEX];
		 int shladf[NUMPRM];
		 double gx[NUMPRM];
		 double gy[NUMPRM];
		 double gz[NUMPRM];
		 int jan[NUMPRM];
		 int shella[NUMPRM];
		 int shelln[NUMPRM];
		 int shellt[NUMPRM];
		 int shellc[NUMPRM];
		 int aos[NUMPRM];
		 int nshell;
		 int maxtyp;
               } BASSTRU;
static BASSTRU *BAS;

#define NUMATM 2000

typedef struct { int ipseud;
		 int ivale[NUMATM];
               } PSEUDSTRU;
static PSEUDSTRU *PSEUD;

typedef struct { int nfirst[NUMATM];
		 int nlast[NUMATM];
		 int npq[NUMATM];
		 int pqn[NUMATM];
		 double emus[NUMATM];
		 double emup[NUMATM];
		 double emud[NUMATM];
		 double consts[NUMATM];
		 double constp[NUMATM];
		 double constd[NUMATM];
		 int npqref[54];
               } MOPSTRU;
static MOPSTRU *MOP;

typedef struct { double px;
		 double py;
		 double pz;
		 double cx;
		 double cy;
		 double cz;
		 double r[3];
		 double v1[3];
		 double v2[3];
		 int iplat;
               } PLANESTRU;
static PLANESTRU *plane;

typedef struct { double ca;
		 double cb;
		 double sa;
		 double sb;
		 double cc;
		 double sc;
               } EULSTRU;
static EULSTRU *eul;

typedef struct { double xsym[NUMATM];
		 double ysym[NUMATM];
		 double zsym[NUMATM];
		 int isym[NUMATM];
               } PROJSTRU;
static PROJSTRU *proj;

typedef struct { 
		 double nucshld[NUMATM];
		 int ihsnmr;
               } NMRSTRU;
static NMRSTRU *nmrptr;
static double *jcoupl = NULL;

typedef struct { double *denn;
		 double *denn2;
		 double *pmnn;
		 double *dens;
		 double *denst;
		 double *edx;
		 double *edy;
		 double *rz;
		 double *bucket;
		 int *iedlog;
		 int *ix;
		 int *iy;
		 int *mx3d;
		 int *mx3d2;
		 int mxorg;
               } GRDSTRU;

static GRDSTRU sgrd;
static GRDSTRU TMPsgrd;

typedef struct { double *fmap;
		 int *mx3d;
		 int mxorg;
               } MGRDSTRU;

static MGRDSTRU mgrd;
static MGRDSTRU TMPmgrd;
static int *mapit;
static int *ipsi;

#define MAXMOL 100
#define MXMFMOL 100

typedef struct { int nmols;
		 int imol;
		 int iendmf;
		 int ielin;
		 int maxmol;
		 int *mollin;
		} MFSTRU;

static MFSTRU *mfdata;

#define MXPLEV 5
typedef struct { double grdw;
		 double plevel[MXPLEV];
		 int ipcol[MXPLEV+1];
		 int nplev;
		} POTSTRU;

static POTSTRU *potcom;

typedef struct { int nps1;
		 int nps2;
		 int nps3;
		 int srfmap;
		 int srfloc;
		 int ifogl;
		 int itsrf;
		} HSRFSTRU;

static HSRFSTRU *hlpsrf;

typedef struct { int ito;
		 int imo;
		 int ibo;
		 int itotc;
		 int imult;
		 int ibatch;
		 int ihs;
		 int itm;
		 int iwxyz;
		 int icopth;
		 int icoptm;
		 int icoptl;
		 int ispopth;
		 int ispoptm;
		 int ispoptl;
		 int iextopt;
		} JOBSTRU;

static JOBSTRU *jobcom;

typedef struct { double rx[3];
		 double ry[3];
		 double rz[3];
		 double t[3];
		 double td[3];
		} ROTSTRU;

static ROTSTRU *rotptr;

typedef struct { double xv;
		 double yv;
		 double zv;
		 double c0;
		 double pincr;
		} POSSTRU;

static POSSTRU *posptr;

typedef struct { 
		 double scal;
		 double fscal;
		 double scali;
		 double smag;
		 int iscupd;
               } SCALSTRU;

static SCALSTRU *scalptr;

#define NUMCAL 50000
#define MXCHAI 50
#define MXRES 42
#define MXHETA 150
#define MXALN 20

typedef struct { 
		 double rphi[NUMCAL];
		 double rpsi[NUMCAL];
		 int icalf[NUMCAL][6];
		 int ncalf;
		 int ianf[MXCHAI];
		 int islu[MXCHAI];
		 int nchain;
		 int iamino[NUMCAL];
		 int ihet[MXHETA];
		 int iclhet[MXHETA];
		 int reson[NUMCAL];
		 int issdon;
		 int icxp[NUMCAL];
		 int icyp[NUMCAL];
		 int iams[NUMCAL];
		 int ihets[MXHETA];
		 int ibck[4];
		 int isal[NUMCAL];
		 int irsnr[NUMCAL];
		 int lab[NUMCAL];
		 int ihashb;
		 int ishoh;
		 int ision;
		 int achain[NUMCAL];
		} CALFSTRU;

static CALFSTRU *calfptr;

typedef struct { int ihashz;
		 int ihetq[MXHETA];
		 int ihqset[MXHETA];
		 int ihhadd[MXHETA];
		 int labhet[MXHETA];
		 int ilcset;
		 int ligcat[MXHETA];
		} CLFSTRU;

static CLFSTRU *clfstrptr;

#define MXINRS 100
typedef struct { int incomp[MXINRS];
		 int nincmp;
		} INCOMPLSTRU;

static INCOMPLSTRU *incompl;

typedef struct { int nalign;
		 int istst[MXALN];
		 int istch[MXALN];
		 int istres[MXALN];
		 int istcol[MXALN];
		 char *istptr[MXALN];
		} ALNSTRU;

static ALNSTRU *alnptr;

typedef struct { int iener;
		 float energy;
		} ENERSTRU;

static ENERSTRU *eneptr;

typedef struct { int Allocated[MXHETA];
		 char  *HetAtm[MXHETA];
		 int NHetAtm;
		} HETATMSTRU;
static HETATMSTRU hetptr = {.Allocated = {0},.HetAtm = {NULL},.NHetAtm = 0};

#define MXHETLAB 5000
typedef struct { int iat[MXHETLAB];
		 char  *HetLab[MXHETLAB];
		 int NHetLab;
		} HETLABSTRU;
static HETLABSTRU hetlab = {.NHetLab = 0};

typedef struct { 
		 int isndcl[4];
		 int iamicl[MXRES];
		 int ichcol[MXCHAI];
		} CLFHSTR;

static CLFHSTR *clfhptr;

static int *iftyp;

typedef struct { double *coo;
		 double *rzp;
		 double *qat;
		 int *isurf;
		 int *icont;
		 int *lwrit;
		 int *lring;
		 int *ianz;
		 int *iaton;
		 int *iatclr;
		 int *iresid;
		 int *ixp;
		 int *iyp;
		 int *iconn;
		 int *inat;
		 short int *ityp;
		 short int *ipdbt;
		 int *mxnat;
		 int *iatoms;
		 int *ncont;
		 int mxorg;
               } COOSTRU;

static COOSTRU xyz;
static COOSTRU TMPxyz;
static COOSTRU DCKxyz;
static COOSTRU MOLxyz;
static int ndocka;
static int nmolat;
static int MapConformers;
static COOSTRU *xyzp = &xyz;
static double *COOt = NULL;

void FreeCoo(COOSTRU txyz);
void Compress_Tri_L();
/* static dimension density coordinates*/


typedef struct { double xyz[NUMATM][3]; 
	} XYZSTRU;
static XYZSTRU *XYZ;

typedef struct { 
		int natoms;
		int norbs;
		int nelecs;
		int nat[NUMATM]; 
	} NATSTRU;
static NATSTRU *NAT;

typedef struct { double dipo[3];
		 int ihasq;
		 int ihsdp;
		 int iqon;
		 int idipon;
               } CHGDIP;

static CHGDIP *qdpptr;

#define MXEL 100

#define MAXFIELD 100

typedef struct { int done;
		 int editted;
		 int nfields;
		 int fldtyp[MAXFIELD];
		 char *FldNames[MAXFIELD];
		 char **Fields[MAXFIELD];
               } FLDSTRU;

static FLDSTRU FLDS = {.done = 0,.editted = 0,.nfields = 0,.fldtyp = MAXFIELD*0,.FldNames = NULL,.Fields = NULL};

#define MAXSTRUCT 100
typedef struct { COOSTRU coo;
		 CALFSTRU calf;
		 CLFSTRU clfstr;
		 ALNSTRU alnstr;
		 ROTSTRU rot;
		 POSSTRU pos;
		 SCALSTRU scal;
		 CELLSTRU cell;
		 CELLSTRUC cellpnt;
		 CNVSTRU cnv;
		 GEO1STRU geo;
		 GEOPSTRU geop;
		 POISTRU poi;
		 XYZSTRU XYZ;
		 NATSTRU NAT;
		 ZMSTRU zmt;
		 QBOXSTRU *IANZbox;
		 QBOXSTRU *BLbox;
		 QBOXSTRU *ALPHbox;
		 QBOXSTRU *BETbox;
		 QBOXSTRU *IZbox;
		 STOCSTRU stoc;
		 DORBSTRU dorb;
		 ORBSTRU orb;
		 BASSTRU bas;
		 GAUSTRU gau;
		 MOPSTRU mop;
		 FRQSTRU frq;
		 PSEUDSTRU pseud;
		 PLANESTRU plane;
		 EULSTRU eul;
		 PROJSTRU proj;
		 MFSTRU mfdata;
		 FLDSTRU FLDS;
		 POTSTRU potcom;
		 ZMPARTSTRU zmpart;
		 JOBSTRU jobcom;
		 CHGDIP qdpptr;
		 HSRFSTRU hlpsrf;
		 HETLABSTRU hetlab;
		 NMRSTRU nmr;
		 PBCSTRUC pbc;
		 double *jcoupl;
		 sttrr strx;
		 int ipoints;
		 HETATMSTRU  hetatm;
		 char *frsym[MAXFRQ];
		 char **mlftit;
		 int ntits;
		 int mxtits;
		 SVGFSTRUC *svgs;
		 BckSVG bcksvg;
		 int svgdone;
		 char *fname;
		 char *pdbcode;
		 int iatoms;
		 int mxnat;
		 int pdb;
		 int backb;
		 int iftyp;
		 int natorg;
		 int nz;
		 int ihaszm;
		 int mxzat;
		 int ncols;
		 int ncolb;
		 int nocc;
		 int nocb;
		 int naorbs;
		 int mxorb;
		 int uhf;
		 int spd;
		 int ipsi;
		 int inact;
		 int inaf;
		 int atcol;
		 int ZMEAA;
		 int doesp;
		 int fftyp;
		 int irtcel;
		 int normc;
		 int icst;
		 int ibox;
		 int igfmap;
		 int iresrd;
		 int fancy;
		 int ihasex;
		 double uscl;
		 double adjus;
		 int ihasmf;
		 FILEOP memfil;
               } STRUSTRU;

static STRUSTRU *COO[MAXSTRUCT] = {NULL};
static char  *strfiles[MAXSTRUCT];

static int nstruct = 0;
static int istruct = 0;
static int sstruct = 0;

static int *multstruct;

static FILEOP fileop = {NULL, NULL, NULL, 0, 0, 0, 0};
typedef struct { float vert[3]; int type;} VRTSTRU;

double dst_coo(COOSTRU *xyzp1,COOSTRU *xyzp2,int nato1,int nato2);

#ifdef DOGL
#define MAXSURF 500
#else
#define MAXSURF 15
#endif

static int SSon[MAXSTRUCT][MAXSURF];
static int SStyp[MAXSTRUCT][MAXSURF];
static int Schain[MAXSTRUCT][MAXSURF];
static int clp[MAXSTRUCT][MAXSURF];
static int trns[MAXSTRUCT][MAXSURF];
static int SSdone[MAXSTRUCT];
static int NSurf[MAXSTRUCT];
static int NMols[MAXSTRUCT];
static int CMols[MAXSTRUCT];
static double scl[MAXSTRUCT];
static char *sndstr[MAXSTRUCT][MAXSURF];
static int nwater[MAXSTRUCT];
static double *watcoo[MAXSTRUCT];
static int *watanz[MAXSTRUCT];
static int *watres[MAXSTRUCT];
static int *watcon[MAXSTRUCT];
static int *watmap[MAXSTRUCT];
static double *watqat[MAXSTRUCT];
static short int *wattyp[MAXSTRUCT];

#define MXVERT 5000
#define MXVERT2 10000
#define MXVERT3 100000
#define MXVERT4 200000
#define MXVERT5 300000
#define MXVERT6 400000
#define MXVERT7 500000
#define MXVERT8 1000000
#define MXVERT9 2000000
#define MXVERT10 3000000
#define MXVERT11 4000000
#define MXVERT12 5000000
static int dovrt = 1;
static VRTSTRU *srfvert[MAXSTRUCT][MAXSURF];
static int nvert[MAXSTRUCT][MAXSURF];
static int nvrtmx[MAXSTRUCT][MAXSURF];

static float diffuseColor[MAXSTRUCT][MAXSURF][4];
static float diffColor[MAXSURF][4] =
{ 
  {0.15,0.15,1.0,0.8}, 
  {1.0 ,0.1 ,0.1,0.8}, 
  {1.0,1.0,0.0,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,1.0,1.0,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8},
  {1.0,0.5,0.5,0.8}
};

static float ambientColor[4] = {0.1,0.1,0.1,0.1};
static float ambientDColor[4] = {0.2,0.2,0.2,0.2};
static float specColor[4] = {0.8,0.8,0.8,1.0};
static float specularColor[MAXSURF][4] =
         { {0.8,0.8,0.8,1.0} , {0.8,0.8,0.8,1.0}, {0.9,0.8,0.8,1.0},
           {0.8,0.8,0.8,1.0} , {0.8,0.8,0.8,1.0}, {0.9,0.8,0.8,1.0},
           {0.8,0.8,0.8,1.0} , {0.8,0.8,0.8,1.0}, {0.9,0.8,0.8,1.0},
           {0.8,0.8,0.8,1.0} , {0.8,0.8,0.8,1.0}, {0.9,0.8,0.8,1.0},
};

typedef struct {int nhelx;
		int nbeta;
		int nrna;
		int ncoil; 
		int start[4];
		int end[4];
	} RIBIND;

static RIBIND RIBindex[MAXSTRUCT];

#define NHETRES -4
static char *fragments[] = {"Read","-CH3","-CH=CH2","-HC=O","-COOH","-NH2","-OH","-CHCH","-CycloHexane","-Phenyl","-CycloPentane","-Pyrrole","-Cl","-Br","-I","-OCH3","-SH","-NO2","CH4","Period. Chain","Amino Acid","Sequence"};
static int nfrag = 22;
static char *fragmnts[] = {"-CH3","-CH=CH2","-HC=O","-COOH","-NH2","-OH","-CHCH","-CycloHexane","-Phenyl","-CycloPentane","-Pyrrole","-Cl","-Br","-I","-OCH3","-SH","-NO2","CH4","ACE","FOR","NME","NH2"};
static int nfrags = 18;
static char *Periodic[] = {"Translation","Screw Axis"};
static char *ChainLength[] = {"1","2","3","4","5","6","7","8","9","10"};
static char *AminoAcids[] = {"GLY","ALA","SER","CYS","THR","ILE","VAL","MET",
"ASP","ASN","LEU","LYS","GLU","GLN","PRO","ARG","HIS","PHE","TYR","TRP",
"ASX","GLX","HYP","A","C","G","T","U","1MA","5MC","OMC","1MG","2MG","M2G",
"7MG","OMG","YG","I","+U","H2U","5MU","PSU"};
static char *AAlet[] = {"G","A","S","C","T","I","V","M","D","N","L","K","E",
"Q","P","R","H","F","Y","W","?","?","?","A","C","G","T","U","?","?","?","?","?","?","?","?","?","I","?","?","?","?"};
static int NAminos = 20;
static char *AminoCaps[] = {"GLY","ALA","SER","CYS","THR","ILE","VAL","MET",
"ASP","ASN","LEU","LYS","GLU","GLN","PRO","ARG","HIS","PHE","TYR","TRP",
"ACE","FOR","NME","NH2"};
static char *AmiOpt[] = {"Add","Delete","Insert","Replace"};
static char *HetOpt[] = {"Center","Label On/OFF","Contacts","Contacts+Surf","Calculate Charges","Delete Molecule","Mol.->Structure","Add Hydrogens","Color","Add to Surface"};
static char *HisOpt[] = {"HIP","HID","HIE"};
static char *AmiBOpt[] = {"Switch On/Off","Select Range","Label On/Off","Center","Contacts","Contacts+Surf","Add to Surface","Rotamer","Fit Rotamer","Best Rotamer","Change Rot. Libr.","Add to Flex. Resid.","Delete","Insert","Replace","Cap Residue","Add"};
static char *AmiNQOpt[] = {"Switch On/Off","Select Range","Label On/Off","Center","Contacts","Flip","Contacts+Surf","Add to Surface","Rotamer","Fit Rotamer","Best Rotamer","Change Rot. Libr.","Add to Flex. Resid.","Delete","Insert","Replace","Cap Residue","Add"};
static char *AmiHOpt[] = {"Switch On/Off","Select Range","Label On/Off","Center","Contacts","Prot. State","Contacts+Surf","Add to Surface","Rotamer","Fit Rotamer","Best Rotamer","Change Rot. Libr.","Add to Flex. Resid.","Delete","Insert","Replace","Cap Residue","Add"};
static char *AmiBOptS[] = {"Switch On/Off","Select Range","Label On/Off","Center","Contacts","Rotamer","Fit Rotamer","Best Rotamer","Change Rot. Libr.","Add to Flex. Resid.","Delete","Insert","Replace","Cap Residue","Add"};
static char *AmiNQOptS[] = {"Switch On/Off","Select Range","Label On/Off","Center","Contacts","Flip","Rotamer","Fit Rotamer","Best Rotamer","Change Rot. Libr.","Add to Flex. Resid.","Delete","Insert","Replace","Cap Residue","Add"};
static char *AmiHOptS[] = {"Switch On/Off","Select Range","Label On/Off","Center","Contacts","Prot. State","Rotamer","Fit Rotamer","Best Rotamer","Change Rot. Libr.","Add to Flex. Resid.","Delete","Insert","Replace","Cap Residue","Add"};
static char *Rotamers[] = {
"Rotamer1","Rotamer2","Rotamer3","Rotamer4","Rotamer5","Rotamer6","Rotamer7",
"Rotamer8","Rotamer9","Rotamer10", "Rotamer11","Rotamer12","Rotamer13","Rotamer14",
"Rotamer15","Rotamer16","Rotamer17","Rotamer18","Rotamer19","Rotamer20","Rotamer21",
"Rotamer22","Rotamer23","Rotamer24","Rotamer25","Rotamer26","Rotamer27","Rotamer28",
"Rotamer29","Rotamer30","Rotamer31","Rotamer32","Rotamer33","Rotamer34","Rotamer35",
"Rotamer36","Rotamer37","Rotamer38","Rotamer39","Rotamer40","Rotamer41","Rotamer42",
"Rotamer43","Rotamer44","Rotamer45","Rotamer46","Rotamer47","Rotamer48","Rotamer49",
"Rotamer50","Rotamer51","Rotamer52","Rotamer53","Rotamer54","Rotamer55","Rotamer56",
"Rotamer57","Rotamer58","Rotamer59","Rotamer60","Rotamer61","Rotamer62","Rotamer63",
"Rotamer64","Rotamer65","Rotamer66","Rotamer67","Rotamer68","Rotamer69","Rotamer70",
"Rotamer71","Rotamer72","Rotamer73","Rotamer74","Rotamer75","Rotamer76","Rotamer77",
"Rotamer78","Rotamer79","Rotamer80","Rotamer81"
};
static char *RotLib[] = {"Richardson","Dunbrack"};
#define MAXSEQ 1000
static int Sequence[MAXSEQ];
static int NSeq = 0;
static char SeqStat[64] = " ";
static int LastAmino = -1;
static int InsertAmino = -1;
static int ReplaceAmino = 0;
static int CurAmino = -1;
static int DisAmino = -1;
static int DisDir = 0;
static int DisHlp = 1;
#define MXEXP 20
static int oque[MXEXP] = {MXEXP*0};
static int oqlen = 0;
static int oqpos = 0;

static char *Chains[] = {
"Chain1","Chain2","Chain3","Chain4","Chain5","Chain6","Chain7",
"Chain8","Chain9","Chain10", "Chain11","Chain12","Chain13","Chain14",
"Chain15","Chain16","Chain17","Chain18","Chain19","Chain20"};

static char *Processors[] = {
	" 1"," 2"," 3"," 4"," 5"," 6"," 7"," 8"," 9","10",
	"11","12","13","14","15","16","17","18","19","20",
	"21","22","23","24","25","26","27","28","29","30",
	"31","32","33","34","35","36","37","38","39","40",
	"41","42","43","44","45","46","47","48","49","50"};
#define BENZLEN 11
#define CCBENZ 1.40
#define CHBENZ 1.089

static ZLINESTRU benzyl[BENZLEN] = { {6,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},CCBENZ,0.0,0.0},
				{6,{2,1,0,0},CCBENZ,120.0,0.0},
				{6,{3,2,1,0},CCBENZ,120.0,0.0},
				{6,{4,3,2,0},CCBENZ,120.0,0.0},
				{6,{5,4,3,0},CCBENZ,120.0,0.0},
				{1,{2,1,3,0},CHBENZ,120.0,180.0},
				{1,{3,2,4,0},CHBENZ,120.0,180.0},
				{1,{4,3,5,0},CHBENZ,120.0,180.0},
				{1,{5,4,3,0},CHBENZ,120.0,180.0},
				{1,{6,5,4,0},CHBENZ,120.0,180.0}
				};

#define PENT 14
#define CCPENT 1.546
#define CHPENT 1.103
static ZLINESTRU cyclopentane[PENT] = { {6,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},CCPENT,0.0,0.0},
				{6,{2,1,0,0},CCPENT,102.5,0.0},
				{6,{3,2,1,0},CCPENT,102.5,45.42},
				{6,{4,3,2,0},CCPENT,102.5,-36.20},
				{1,{2,3,4,0},CHPENT,109.47,-71.2},
				{1,{2,3,4,0},CHPENT,109.47,167.0},
				{1,{3,2,1,0},CHPENT,109.47,-71.2},
				{1,{3,2,1,0},CHPENT,109.47,167.0},
				{1,{4,3,2,0},CHPENT,109.47,-160.0},
				{1,{4,3,2,0},CHPENT,109.47,80.9},
				{1,{5,4,3,0},CHPENT,109.47,-106.8},
				{1,{5,4,3,0},CHPENT,109.47,133.2},
				{1,{1,2,3,0},CHPENT,109.47,80.9}
				};

#define PYRROLE 9
#define CHPYRR 1.090
static ZLINESTRU pyrrole[PYRROLE] = { {7,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},1.301,0.0,0.0},
				{6,{2,1,0,0},1.335,107.6,0.0},
				{6,{3,2,1,0},1.469,105.5,0.0},
				{6,{1,2,3,0},1.301,113.9,0.0},
				{1,{5,1,2,0},CHPYRR,126.6,180.0},
				{1,{4,3,2,0},CHPYRR,127.3,180.0},
				{1,{3,2,1,0},CHPYRR,127.3,180.0},
				{1,{2,1,5,0},CHPYRR,126.6,180.0},
				};

static ZLINESTRU CHCH2[5] =   { {6,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},1.335,0.0,0.0},
				{1,{1,2,0,0},1.089,120.0,0.0},
				{1,{2,1,3,0},1.089,120.0,0.0},
				{1,{2,1,3,0},1.089,120.0,180.0}
				};

static ZLINESTRU COOH[4] =   {  {6,{0,0,0,0},0.0,0.0,0.0},
				{8,{1,0,0,0},1.400,0.0,0.0},
				{8,{1,2,0,0},1.220,120.0,0.0},
				{1,{2,1,3,0},0.950,109.471,0.0}
				};

static ZLINESTRU CHO[3] =   {   {6,{0,0,0,0},0.0,0.0,0.0},
				{8,{1,0,0,0},1.220,0.0,0.0},
				{1,{1,2,0,0},1.089,120.0,0.0}
				};

static ZLINESTRU OH[2] =    {   {8,{0,0,0,0},0.0,0.0,0.0},
				{1,{1,0,0,0},0.947,0.0,0.0}
				};

static ZLINESTRU CHCH[5] =   {  {6,{0,0,0,0},0.0,0.0,0.0},
				{99,{1,0,0,0},1.0,0.0,0.0},
				{6,{1,2,0,0},1.189,90.0,0.0},
				{99,{3,1,2,0},1.0,90.0,0.0},
				{1,{3,4,1,0},1.051,90.0,180.0}
				};

static ZLINESTRU CL[1] =    {   {17,{0,0,0,0},0.0,0.0,0.0}
				};

static ZLINESTRU BR[1] =    {   {35,{0,0,0,0},0.0,0.0,0.0}
				};

static ZLINESTRU I[1] =    {   {53,{0,0,0,0},0.0,0.0,0.0}
				};

static ZLINESTRU OCH3[5] =   {  {8,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},1.400,0.0,0.0},
				{1,{2,1,0,0},1.089,109.471,0.0},
				{1,{2,1,3,0},1.089,109.471,120.0},
				{1,{2,1,3,0},1.089,109.471,-120.0}
				};

static ZLINESTRU SH[2] =    {   {16,{0,0,0,0},0.0,0.0,0.0},
				{1,{1,0,0,0},0.947,0.0,0.0}
				};

static ZLINESTRU NO2[3] =   {   {7,{0,0,0,0},0.0,0.0,0.0},
				{8,{1,0,0,0},1.210,0.0,0.0},
				{8,{1,2,0,0},1.210,125.25,0.0}
				};

static ZLINESTRU NH2[3] =   {   {7,{0,0,0,0},0.0,0.0,0.0},
				{1,{1,0,0,0},1.010,0.0,0.0},
				{1,{1,2,0,0},1.010,120.0,0.0}
				};

static ZLINESTRU CH4[5] =   {   {6,{0,0,0,0},0.0,0.0,0.0},
				{1,{1,0,0,0},1.089,0.0,0.0},
				{1,{1,2,0,0},1.089,109.471,0.0},
				{1,{1,2,3,0},1.089,109.471,120.0},
				{1,{1,2,3,0},1.089,109.471,-120.0}
				};

static ZLINESTRU SCREW[2] = {	{99,{0,0,0,0},0.0,0.0,0.0},
				{99,{1,0,0,0},10.0,0.0,0.0}
				};

static ZLINESTRU BACK[6] = {	{7,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},1.460,0.0,0.0},
				{6,{2,1,0,0},1.510,111.6,0.0},
				{8,{3,2,1,0},1.220,121.0,113.0},
				{8,{3,2,4,0},1.220,122.5,180.0},
				{1,{1,2,3,0},1.020,121.0,61.0}
			    };

static short int BACK_TYP[5] = { 2,3,38,4,1};

static ZLINESTRU BACKHS[2] = {  {1,{1,2,6,0},1.020,107.9,120.0},
				{1,{1,2,6,0},1.020,107.9,-120.0}
			     };

static short int BACKHS_TYP[2] = {2,3};

typedef struct { double rots[4]; double ener[1];} ROTSSTRU;

static ZLINESTRU GLY[2] = {     {1,{2,3,1,0},1.100,109.3,121.6},
				{1,{2,3,1,0},1.100,109.3,-121.6}
			   };
static short int GLY_TYP[2] = { 4,5};
static int GLY_CHI[4] = {-1,-1,-1,-1};
static ROTSSTRU GLY_ROT[1] = {
				{ 0.0, 0.0, 0.0, 0.0, 0.0}
				};


static ZLINESTRU ALA[5] = {     {6,{2,3,1,0},1.536,110.1,122.910},
				{1,{2,3,1,0},1.100,108.234,-118.193},
				{1,{7,2,3,0},1.100,110.3,179.999},
				{1,{7,2,3,0},1.100,110.3,60.0},
				{1,{7,2,3,0},1.100,110.3,-60.326}
			   };
static short int ALA_TYP[5] = { 5,4,7,8,9};
static int ALA_CHI[4] = {-1,-1,-1,-1};
static ROTSSTRU ALA_ROT[1] = {
				{ 0.0, 0.0, 0.0, 0.0, 0.0}
				};


static ZLINESTRU SER[6] = {     {6,{2,3,1,0},1.530,110.1,122.8},
				{8,{7,2,1,0},1.417,111.1,62.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.8,-121.8},
				{1,{7,2,8,0},1.100,108.8,121.8},
				{1,{8,7,2,0},1.000,109.5,180.0}
			   };
static short int SER_TYP[6] = { 5,31,4,7,8,10 };
static int SER_CHI[4] = {2,6,-1,-1};
static ROTSSTRU SER_ROT[3] = {
				{  62.0, 180.0, 0.0, 0.0, 0.00},
				{-177.0, 180.0, 0.0, 0.0, 0.47},
				{ -65.0, 180.0, 0.0, 0.0, 0.77}
				};

static ROTSSTRU SER_ROTD[3] = {
				{  65.3, 180.0, 0.0, 0.0, 0.00},
				{ 179.0, 180.0, 0.0, 0.0, 0.41},
				{ -63.9, 180.0, 0.0, 0.0, 0.28}
				};


static ZLINESTRU CYS[6] = {     {6,{2,3,1,0},1.530,110.1,122.8},
				{16,{7,2,1,0},1.822,114.4,-65.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.8,-121.8},
				{1,{7,2,8,0},1.100,108.8,121.8},
				{1,{8,7,2,0},1.300,109.5,0.0}
			   };
static short int CYS_TYP[6] = { 5,37,4,7,8,10 };
static int CYS_CHI[4] = {2,6,-1,-1};
static ROTSSTRU CYS_ROT[3] = {
				{  62.0,  0.0, 0.0, 0.0, 0.47},
				{-177.0,  0.0, 0.0, 0.0, 0.39},
				{ -65.0,  0.0, 0.0, 0.0, 0.00}
				};

static ROTSSTRU CYS_ROTD[3] = {
				{  63.7,  0.0, 0.0, 0.0, 0.75},
				{-177.3,  0.0, 0.0, 0.0, 0.43},
				{ -64.3,  0.0, 0.0, 0.0, 0.00}
				};


static ZLINESTRU THR[9] = {     {6,{2,3,1,0},1.540,109.1,123.4},
				{8,{7,2,1,0},1.433,109.6,62.0},
				{6,{7,2,8,0},1.521,110.5,-120.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.5,120.2},
				{1,{8,7,2,0},1.000,109.5,60.0},
				{1,{9,7,2,0},1.100,109.5,180.0},
				{1,{9,7,13,0},1.100,109.5,120.0},
				{1,{9,7,13,0},1.100,109.5,-120.0}
			   };
static short int THR_TYP[9] = { 5,32,8,4,7,13,16,17,18};
static int THR_CHI[4] = {2,6,-1,-1};
static ROTSSTRU THR_ROT[3] = {
				{  62.0,  60.0, 0.0, 0.0, 0.00},
				{-175.0,  60.0, 0.0, 0.0, 1.16},
				{ -65.0,  60.0, 0.0, 0.0, 0.07}
				};

static ROTSSTRU THR_ROTD[3] = {
				{  61.1,  60.0, 0.0, 0.0, 0.00},
				{-173.3,  60.0, 0.0, 0.0, 1.11},
				{ -60.4,  60.0, 0.0, 0.0, 0.07}
				};


static ZLINESTRU ILE[14] = {    {6,{2,3,1,0},1.540,109.1,123.4},
				{6,{7,2,1,0},1.530,110.4,-65.0},
				{6,{7,2,8,0},1.521,110.5,-120.0},
				{6,{8,7,2,0},1.512,113.8,170.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,107.8,120.0},
				{1,{8,7,10,0},1.100,109.0,121.8},
				{1,{8,7,10,0},1.100,109.0,-121.8},
				{1,{9,7,2,0}, 1.100,109.5,180.0},
				{1,{9,7,15,0},1.100,109.5,120.0},
				{1,{9,7,15,0},1.100,109.5,-120.0},
				{1,{10,8,7,0},1.100,109.5,180.0},
				{1,{10,8,18,0},1.100,109.5,120.0},
				{1,{10,8,18,0},1.100,109.5,-120.0}
			   };
static short int ILE_TYP[14] = { 5,7,8,10,4,7,13,14,16,17,18,22,23,24 };
static int ILE_CHI[4] = {2,4,-1,-1};
static ROTSSTRU ILE_ROT[7] = {
				{  62.0, 100.0, 0.0, 0.0, 2.72},
				{  62.0, 170.0, 0.0, 0.0, 0.90},
				{-177.0,  66.0, 0.0, 0.0, 1.97},
				{-177.0, 165.0, 0.0, 0.0, 1.22},
				{ -65.0, 100.0, 0.0, 0.0, 2.34},
				{ -65.0, 170.0, 0.0, 0.0, 0.00},
				{ -57.0, -60.0, 0.0, 0.0, 0.84}
				};

static ROTSSTRU ILE_ROTD[9] = {
				{  60.6,  85.4, 0.0, 0.0, 2.78},
				{  61.1, 171.0, 0.0, 0.0, 0.97},
				{  61.7, -80.0, 0.0, 0.0, 4.11},
				{-167.9,  66.8, 0.0, 0.0, 1.86},
				{-171.4, 167.4, 0.0, 0.0, 1.36},
				{-165.5, -78.0, 0.0, 0.0, 3.76},
				{ -67.1,  83.0, 0.0, 0.0, 2.30},
				{ -63.8, 170.1, 0.0, 0.0, 0.00},
				{ -59.2, -61.0, 0.0, 0.0, 0.81}
				};


static ZLINESTRU VAL[11] = {    {6,{2,3,1,0},1.540,109.1,123.4},
				{6,{7,2,1,0},1.521,110.5,-65.0},
				{6,{7,2,8,0},1.521,110.5,-120.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,107.7,120.0},
				{1,{8,7,2,0},1.100,109.5,180.0},
				{1,{8,7,12,0},1.100,109.5,120.0},
				{1,{8,7,12,0},1.100,109.5,-120.0},
				{1,{9,7,8,0}, 1.100,109.5,180.0},
				{1,{9,7,15,0},1.100,109.5,120.0},
				{1,{9,7,15,0},1.100,109.5,-120.0}
			   };
static short int VAL_TYP[11] = { 5,7,8,4,7,13,14,15,16,17,18};
static int VAL_CHI[4] = {2,-1,-1,-1};
static ROTSSTRU VAL_ROT[3] = {
				{  63.0, 0.0, 0.0, 0.0, 1.44},
				{ 175.0, 0.0, 0.0, 0.0, 0.00},
				{ -60.0, 0.0, 0.0, 0.0, 0.77}
				};

static ROTSSTRU VAL_ROTD[3] = {
				{  65.5, 0.0, 0.0, 0.0, 1.36},
				{ 175.9, 0.0, 0.0, 0.0, 0.00},
				{ -61.7, 0.0, 0.0, 0.0, 0.81}
				};


static ZLINESTRU MET[12] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.520,114.1,-65.0},
				{16,{8,7,2,0},1.801,112.8,-65.0},
				{6,{9,8,7,0},1.791,100.9,-70.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,109.4,108.9},
				{1,{7,2,8,0},1.100,109.4,-108.9},
				{1,{8,7,9,0},1.100,109.2,121.6},
				{1,{8,7,9,0},1.100,109.2,-121.6},
				{1,{10,9,8,0}, 1.100,109.5,180.0},
				{1,{10,9,16,0},1.100,109.5,120.0},
				{1,{10,9,16,0},1.100,109.5,-120.0}
			   };
static short int MET_TYP[12] = { 5,6,36,12,4,7,8,10,11,28,29,30};
static int MET_CHI[4] = {2,3,4,-1};
static ROTSSTRU MET_ROT[13] = {
				{  62.0, 180.0,  75.0, 0.0, 1.28},
				{  62.0, 180.0, -75.0, 0.0, 1.08},
				{-177.0,  65.0,  75.0, 0.0, 0.74},
				{-177.0,  65.0, 180.0, 0.0, 1.46},
				{-177.0, 180.0,  75.0, 0.0, 0.78},
				{-177.0, 180.0, 180.0, 0.0, 1.08},
				{-177.0, 180.0, -75.0, 0.0, 0.63},
				{ -67.0, 180.0,  75.0, 0.0, 0.07},
				{ -67.0, 180.0, 180.0, 0.0, 0.53},
				{ -67.0, 180.0, -75.0, 0.0, 0.35},
				{ -65.0, -65.0, 103.0, 0.0, 1.15},
				{ -65.0, -65.0, 180.0, 0.0, 1.39},
				{ -65.0, -65.0, -70.0, 0.0, 0.00}
				};

static ROTSSTRU MET_ROTD[27] = {
				{  60.8,   78.3,   73.3, 0.0, 2.33},
				{  57.6,   78.1,  177.7, 0.0, 2.60},
				{  59.4,   77.8,  -97.4, 0.0, 9.99},
				{  64.4, -178.3,   76.1, 0.0, 1.20},
				{  64.9, -176.0, -175.0, 0.0, 1.53},
				{  63.4,  179.1,  -71.8, 0.0, 1.17},
				{  72.5,  -70.1,   99.6, 0.0, 9.99},
				{  72.2,  -70.4,  174.3, 0.0, 3.75},
				{  72.6,  -72.0,  -71.4, 0.0, 2.69},
				{-176.0,   64.0,   72.5, 0.0, 0.58},
				{-174.5,   69.3, -166.1, 0.0, 1.42},
				{-172.4,   76.6,  -96.9, 0.0, 1.76},
				{-177.8,  179.2,   72.1, 0.0, 0.59},
				{-177.4,  174.6,  177.3, 0.0, 0.99},
				{-174.6,  179.7,  -71.6, 0.0, 0.52},
				{-178.7,  -73.7,   99.6, 0.0, 9.99},
				{-178.2,  -78.4,  173.0, 0.0, 2.39},
				{-178.8,  -82.3,  -73.4, 0.0, 1.41},
				{ -78.6,   67.3,   73.0, 0.0, 2.08},
				{ -78.9,   69.3, -175.6, 0.0, 2.69},
				{ -77.7,   70.6,  -98.9, 0.0, 3.34},
				{ -67.4,  178.0,   70.4, 0.0, 0.06},
				{ -67.3,  179.2, -177.6, 0.0, 0.39},
				{ -67.7, -176.3,  -73.7, 0.0, 0.30},
				{ -65.8,  -64.9,   99.6, 0.0, 1.04},
				{ -62.7,  -64.0,  171.9, 0.0, 1.02},
				{ -65.8,  -61.8,  -69.4, 0.0, 0.00}
				};


static ZLINESTRU ASP[7] = {     {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.516,112.6,-70.0},
				{8,{8,7,2,0},1.250,118.4,-15.0},
				{8,{8,7,9,0},1.250,118.4,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,109.3,121.6},
				{1,{7,2,8,0},1.100,109.3,-121.6}
			   };
static short int ASP_TYP[7] = { 5,6,29,30,4,7,8};
static int ASP_CHI[4] = {2,3,-1,-1};

static ROTSSTRU ASP_ROT[5] = {
				{  62.0, -10.0, 0.0, 0.0, 0.95},
				{  62.0,  30.0, 0.0, 0.0, 0.98},
				{-177.0,   0.0, 0.0, 0.0, 0.49},
				{-177.0,  65.0, 0.0, 0.0, 1.27},
				{ -70.0, -15.0, 0.0, 0.0, 0.00}
				};

static ROTSSTRU ASP_ROTD[9] = {
				{  57.1,   54.3, 0.0, 0.0, 1.60},
				{  62.5,    1.3, 0.0, 0.0, 0.61},
				{  62.4,  -55.8, 0.0, 0.0, 1.30},
				{-173.6,   58.5, 0.0, 0.0, 0.75},
				{-172.3,   -0.8, 0.0, 0.0, 0.33},
				{-167.9,  -55.7, 0.0, 0.0, 1.09},
				{ -69.1,   65.0, 0.0, 0.0, 1.65},
				{ -72.1,  -12.7, 0.0, 0.0, 0.00},
				{ -65.4,  -49.8, 0.0, 0.0, 0.27}
				};


static ZLINESTRU ASN[9] = {     {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.516,112.6,-65.0},
				{8,{8,7,2,0},1.230,120.8,-21.0},
				{7,{8,7,9,0},1.327,116.4,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,109.3,121.6},
				{1,{7,2,8,0},1.100,109.3,-121.6},
				{1,{10,8,7,0}, 1.000,120.0,0.0},
				{1,{10,8,14,0},1.000,120.0,180.0}
			   };
static short int ASN_TYP[9] = { 5,6,29,21,4,7,8,25,26};
static int ASN_CHI[4] = {2,3,-1,-1};

static ROTSSTRU ASN_ROT[7] = {
				{  62.0, -10.0, 0.0, 0.0, 1.02},
				{  62.0,  30.0, 0.0, 0.0, 0.88},
				{-174.0, -20.0, 0.0, 0.0, 0.70},
				{-177.0,  30.0, 0.0, 0.0, 0.55},
				{ -65.0, -20.0, 0.0, 0.0, 0.00},
				{ -65.0, -75.0, 0.0, 0.0, 0.94},
				{ -65.0, 120.0, 0.0, 0.0, 1.36}
				};

static ROTSSTRU ASN_ROTD[18] = {
				{  50.3, -115.0, 0.0, 0.0, 2.98},
				{  64.5,  -53.9, 0.0, 0.0, 1.41},
				{  64.6,    1.5, 0.0, 0.0, 0.82},
				{  60.0,   57.0, 0.0, 0.0, 1.22},
				{  68.9,  101.9, 0.0, 0.0, 2.57},
				{  69.3,  175.1, 0.0, 0.0, 3.76},
				{-176.0, -114.6, 0.0, 0.0, 1.31},
				{-173.5,  -66.3, 0.0, 0.0, 1.11},
				{-170.8,  -20.2, 0.0, 0.0, 0.81},
				{-169.3,   24.3, 0.0, 0.0, 0.62},
				{-171.9,   60.6, 0.0, 0.0, 0.97},
				{-160.3,  121.5, 0.0, 0.0, 2.49},
				{ -77.3, -137.6, 0.0, 0.0, 2.27},
				{ -65.7,  -63.9, 0.0, 0.0, 0.25},
				{ -70.4,  -23.2, 0.0, 0.0, 0.00},
				{ -79.5,   34.3, 0.0, 0.0, 1.85},
				{ -77.3,   96.5, 0.0, 0.0, 1.13},
				{ -64.7,  139.8, 0.0, 0.0, 1.32}
				};


static ZLINESTRU LEU[14] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.530,116.3,-65.0},
				{6,{8,7,2,0},1.521,110.7,174.0},
				{6,{8,7,9,0},1.521,110.7,119.9},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.3,122.2},
				{1,{7,2,8,0},1.100,108.3,-122.2},
				{1,{8,7,9,0},1.100,107.5,-120.1},
				{1,{9,8,7,0}, 1.100,109.5,180.0},
				{1,{9,8,15,0},1.100,109.5,120.0},
				{1,{9,8,15,0},1.100,109.5,-120.0},
				{1,{10,8,7,0}, 1.100,109.5,180.0},
				{1,{10,8,18,0},1.100,109.5,120.0},
				{1,{10,8,18,0},1.100,109.5,-120.0}
			   };
static short int LEU_TYP[14] = { 5,6,10,11,4,7,8,10,22,23,24,25,26,27};
static int LEU_CHI[4] = {2,3,-1,-1};
static ROTSSTRU LEU_ROT[5] = {
				{  62.0,  80.0, 0.0, 0.0, 2.55},
				{-177.0,  65.0, 0.0, 0.0, 0.43},
				{-172.0, 145.0, 0.0, 0.0, 2.05},
				{ -85.0,  65.0, 0.0, 0.0, 1.90},
				{ -65.0, 175.0, 0.0, 0.0, 0.00}
				};

static ROTSSTRU LEU_ROTD[9] = {
				{  58.7,  80.7, 0.0, 0.0, 2.63},
				{  71.8, 164.6, 0.0, 0.0, 3.05},
				{  58.2, -73.6, 0.0, 0.0, 4.69},
				{-179.2,  63.0, 0.0, 0.0, 0.46},
				{-164.9, 170.7, 0.0, 0.0, 1.89},
				{-169.8, -73.1, 0.0, 0.0, 2.99},
				{ -86.1,  54.6, 0.0, 0.0, 1.68},
				{ -64.7, 174.5, 0.0, 0.0, 0.00},
				{ -81.5, -55.0, 0.0, 0.0, 2.55}
				};


static ZLINESTRU LYS[17] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.520,114.1,-67.0},
				{6,{8,7,2,0},1.520,111.3,180.0},
				{6,{9,8,7,0},1.520,111.3,180.0},
				{7,{10,9,8,0},1.490,111.9,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.9},
				{1,{7,2,8,0},1.100,108.9,-121.9},
				{1,{8,7,9,0},1.100,109.6,121.4},
				{1,{8,7,9,0},1.100,109.6,-121.4},
				{1,{9,8,10,0},1.100,109.6,121.4},
				{1,{9,8,10,0},1.100,109.6,-121.4},
				{1,{10,9,11,0},1.100,109.5,121.5},
				{1,{10,9,11,0},1.100,109.5,-121.5},
				{1,{11,10,9,0}, 1.000,109.5,180.0},
				{1,{11,10,21,0},1.000,109.5,120.0},
				{1,{11,10,21,0},1.000,109.5,-120.0}
			   };
static short int LYS_TYP[17] = { 5,6,9,12,27,4,7,8,10,11,19,20,28,29,40,41,42};
static int LYS_CHI[4] = {2,3,4,5};
static ROTSSTRU LYS_ROT[27] = {
				{  62.0, 180.0,  68.0, 180.0, 2.10},
				{  62.0, 180.0, 180.0,  65.0, 1.74},
				{  62.0, 180.0, 180.0, 180.0, 1.21},
				{  62.0, 180.0, 180.0, -65.0, 1.97},
				{  62.0, 180.0, -68.0, 180.0, 2.25},
				{-177.0,  68.0, 180.0,  65.0, 1.79},
				{-177.0,  68.0, 180.0, 180.0, 1.15},
				{-177.0,  68.0, 180.0, -65.0, 2.10},
				{-177.0, 180.0,  68.0,  65.0, 1.73},
				{-177.0, 180.0,  68.0, 180.0, 1.30},
				{-177.0, 180.0, 180.0,  65.0, 0.90},
				{-177.0, 180.0, 180.0, 180.0, 0.19},
				{-177.0, 180.0, 180.0, -65.0, 1.07},
				{-177.0, 180.0, -68.0, 180.0, 1.43},
				{-177.0, 180.0, -68.0, -65.0, 2.25},
				{ -90.0,  68.0, 180.0, 180.0, 2.38},
				{ -67.0, 180.0,  68.0,  65.0, 1.73},
				{ -67.0, 180.0,  68.0, 180.0, 1.05},
				{ -67.0, 180.0, 180.0,  65.0, 0.99},
				{ -67.0, 180.0, 180.0, 180.0, 0.00},
				{ -67.0, 180.0, 180.0, -65.0, 0.82},
				{ -67.0, 180.0, -68.0, 180.0, 1.02},
				{ -67.0, 180.0, -68.0, -65.0, 1.73},
				{ -62.0, -68.0, 180.0,  65.0, 1.90},
				{ -62.0, -68.0, 180.0, 180.0, 0.63},
				{ -62.0, -68.0, 180.0, -65.0, 1.49},
				{ -62.0, -68.0, -68.0, 180.0, 1.84} 
				};

static ROTSSTRU LYS_ROTD[81] = {
				{  66.8,  76.3,  66.4,  71.1, 9.99},
				{  66.9,  76.7,  66.8, 175.9, 3.85},
				{  57.5,  74.0,  85.8, -83.1, 4.09},
				{  65.7,  78.2, 174.6,  62.6, 3.85},
				{  68.9,  76.7, 177.2, 175.3, 4.09},
				{  68.9,  77.8,-177.5, -68.4, 3.55},
				{  66.8,  82.3, -86.0,  74.7, 9.99},
				{  69.5,  85.2, -93.8,-177.2, 4.50},
				{  66.8,  82.3, -83.6, -67.0, 9.99},
				{  65.8, 175.6,  68.3,  68.9, 2.67},
				{  64.7, 175.2,  70.9, 174.9, 2.23},
				{  68.4,-179.3,  87.4, -84.8, 3.44},
				{  65.9,-178.1, 173.2,  66.9, 2.00},
				{  66.0,-179.4,-179.5, 179.9, 1.19},
				{  65.6,-178.1,-175.9, -68.7, 2.03},
				{  67.2,-175.2, -71.5,  74.3, 3.55},
				{  64.3,-172.4, -68.2,-176.8, 2.10},
				{  67.2,-173.7, -70.3, -68.0, 2.57},
				{  67.2, -83.2,  80.8,  69.9, 4.50},
				{  64.1, -83.7,  88.2, 177.6, 4.50},
				{  66.9, -81.3,  88.3, -80.2, 9.99},
				{  71.8, -79.7,-178.6,  65.4, 4.09},
				{  69.4, -80.1,-178.3, 177.0, 3.27},
				{  64.2, -81.9, 174.4, -65.5, 3.68},
				{  66.9, -76.7, -78.3,  74.7, 9.99},
				{  63.7, -77.8, -67.7, 179.7, 3.68},
				{  67.5, -77.5, -75.5, -67.1, 4.50},
				{-178.7,  68.1,  65.3,  66.2, 3.08},
				{-172.9,  65.9,  71.0, 179.7, 2.33},
				{-179.1,  68.7,  81.0, -81.3, 3.35},
				{-178.4,  67.8, 170.7,  67.0, 1.98},
				{-177.7,  70.3, 175.8, 179.3, 1.21},
				{-174.2,  66.7,-178.3, -65.6, 2.05},
				{-170.3,  87.2, -90.8,  76.8, 3.68},
				{-172.6,  88.2, -91.5,-177.5, 2.94},
				{-173.8,  86.5, -86.4, -69.3, 3.68},
				{-174.3, 174.4,  72.8,  70.5, 1.98},
				{-177.5, 173.7,  71.5, 177.8, 1.35},
				{-172.2, 168.9,  87.1, -78.4, 2.51},
				{-176.7, 176.0, 175.4,  65.1, 1.10},
				{-177.2, 177.1, 179.5, 179.9, 0.32},
				{-177.1, 177.0,-176.6, -67.4, 1.13},
				{ 179.6,-178.0, -75.8,  70.6, 2.67},
				{-175.0,-177.3, -70.2,-176.8, 1.35},
				{-175.4,-178.7, -71.0, -65.1, 2.04},
				{-162.4, -81.9,  82.2,  74.2, 4.50},
				{-163.0, -83.1,  95.7,-178.9, 3.68},
				{-164.5, -82.8,  88.3, -80.2, 9.99},
				{-161.2, -77.8,-177.5,  66.4, 3.08},
				{-165.2, -87.2,-177.2,-178.9, 2.32},
				{-166.1, -83.0,-177.8, -67.3, 3.08},
				{-160.1, -90.5, -80.9,  68.3, 4.09},
				{-166.8, -96.6, -69.4, 178.4, 3.14},
				{-168.0, -93.8, -76.0, -65.7, 3.44},
				{ -88.0,  81.2,  68.0,  69.3, 3.55},
				{ -80.9,  81.3,  66.9,-179.6, 2.94},
				{ -86.8,  86.0,  84.3, -83.2, 3.85},
				{ -80.7,  75.7, 176.2,  62.3, 2.43},
				{ -81.0,  74.0,-178.3, 177.9, 2.12},
				{ -87.6,  74.5, 178.0, -61.8, 2.51},
				{ -86.6,  83.2, -85.6,  68.2, 4.09},
				{ -82.6,  71.2, -96.3,-172.0, 3.55},
				{ -85.8,  78.0, -86.1, -66.3, 4.50},
				{ -70.1, 178.9,  73.0,  72.3, 1.70},
				{ -68.5, 176.2,  69.4, 177.3, 1.13},
				{ -70.3, 174.9,  84.2, -76.5, 2.49},
				{ -67.1,-178.4, 177.7,  66.5, 0.89},
				{ -67.1,-179.4,-179.4, 179.5, 0.00},
				{ -66.8,-178.0,-177.5, -65.9, 0.87},
				{ -66.8,-174.8, -76.5,  78.2, 2.29},
				{ -67.6,-175.0, -72.6,-176.5, 1.07},
				{ -65.1,-174.8, -72.3, -65.7, 1.66},
				{ -64.8, -75.8,  85.4,  76.5, 3.55},
				{ -62.3, -76.6,  91.0,-179.6, 2.53},
				{ -62.3, -83.2,  88.3, -84.3, 3.68},
				{ -63.5, -67.5,-177.9,  64.3, 1.52},
				{ -62.2, -66.1,-177.3,-177.9, 0.72},
				{ -60.1, -67.0,-174.3, -69.4, 1.38},
				{ -65.2, -68.9, -76.9,  78.3, 2.98},
				{ -63.4, -66.5, -70.5,-179.8, 1.73},
				{ -60.5, -68.5, -73.1, -72.7, 2.39}
				};



static ZLINESTRU GLU[10] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.521,114.1,-67.0},
				{6,{8,7,2,0},1.516,112.5,180.0},
				{8,{9,8,7,0}, 1.250,118.4,-10.0},
				{8,{9,8,10,0},1.250,118.4,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.8},
				{1,{7,2,8,0},1.100,108.9,-121.8},
				{1,{8,7,9,0},1.100,109.3,121.6},
				{1,{8,7,9,0},1.100,109.3,-121.6}
			   };
static short int GLU_TYP[10] = { 5,6,9,34,35,4,7,8,10,11};
static int GLU_CHI[4] = {2,3,4,-1};

static ROTSSTRU GLU_ROT[8] = {
				{  62.0, 180.0, -20.0, 0.0, 1.07},
				{  70.0, -80.0,   0.0, 0.0, 1.61},
				{-177.0,  65.0,  10.0, 0.0, 0.99},
				{-177.0, 180.0,   0.0, 0.0, 0.19},
				{-177.0, -80.0, -25.0, 0.0, 1.98},
				{ -65.0,  85.0,   0.0, 0.0, 1.01},
				{ -67.0, 180.0, -10.0, 0.0, 0.00},
				{ -65.0, -65.0, -40.0, 0.0, 0.53}
				};

static ROTSSTRU GLU_ROTD[27] = {
				{  54.3,  83.1,  49.0, 0.0, 2.95},
				{  54.5,  88.3,   6.4, 0.0, 2.66},
				{  50.8,  78.6, -61.4, 0.0, 3.82},
				{  64.2,-178.4,  58.7, 0.0, 1.47},
				{  64.6,-177.4,   1.7, 0.0, 1.23},
				{  65.3,-176.6, -58.5, 0.0, 1.47},
				{  58.6, -93.4,  51.0, 0.0, 2.06},
				{  68.3, -81.5,   2.6, 0.0, 1.52},
				{  65.1, -74.4, -51.1, 0.0, 2.69},
				{-172.8,  62.1,  52.1, 0.0, 1.07},
				{-178.4,  67.8,   9.7, 0.0, 0.93},
				{-174.2,  72.2, -65.1, 0.0, 2.02},
				{-177.6, 175.8,  57.3, 0.0, 0.66},
				{-177.3, 177.9,  -0.2, 0.0, 0.28},
				{-175.2, 179.2, -57.4, 0.0, 0.73},
				{-155.8, -76.6,  63.4, 0.0, 3.05},
				{-169.0, -86.3, -14.5, 0.0, 1.99},
				{-166.0, -80.1, -49.5, 0.0, 1.83},
				{ -66.3,  71.1,  52.3, 0.0, 1.35},
				{ -66.2,  82.2,   1.9, 0.0, 0.92},
				{ -66.8,  91.0, -54.1, 0.0, 1.90},
				{ -68.3, 179.3,  56.0, 0.0, 0.58},
				{ -67.7, 177.8,  -2.2, 0.0, 0.00},
				{ -65.3,-178.2, -54.7, 0.0, 0.44},
				{ -64.1, -79.0,  64.0, 0.0, 1.60},
				{ -64.2, -71.2,  -9.8, 0.0, 0.62},
				{ -67.7, -60.7, -52.4, 0.0, 0.48}
				};

static ZLINESTRU GLN[12] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.521,114.1,-67.0},
				{6,{8,7,2,0},1.516,112.5,180.0},
				{8,{9,8,7,0},1.231,120.9,-25.0},
				{7,{9,8,10,0},1.329,116.3,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.8},
				{1,{7,2,8,0},1.100,108.9,-121.8},
				{1,{8,7,9,0},1.100,109.3,121.6},
				{1,{8,7,9,0},1.100,109.3,-121.6},
				{1,{11,9,8,0}, 1.000,120.0,0.0},
				{1,{11,9,17,0},1.000,120.0,180.0}
			   };
static short int GLN_TYP[12] = { 5,6,9,34,24,4,7,8,10,11,34,35};
static int GLN_CHI[4] = {2,3,4,-1};

static ROTSSTRU GLN_ROT[9] = {
				{  62.0, 180.0,  20.0, 0.0, 1.25},
				{  70.0, -75.0,   0.0, 0.0, 1.78},
				{-177.0,  65.0,-100.0, 0.0, 1.82},
				{-177.0,  65.0,  60.0, 0.0, 0.81},
				{-177.0, 180.0,   0.0, 0.0, 0.46},
				{ -65.0,  85.0,   0.0, 0.0, 1.50},
				{ -67.0, 180.0, -25.0, 0.0, 0.00},
				{ -65.0, -65.0, -40.0, 0.0, 0.52},
				{ -65.0, -65.0, 100.0, 0.0, 1.56}
				};

static ROTSSTRU GLN_ROTD[36] = {
				{  64.1,  74.9,-124.0, 0.0, 9.99},
				{  64.9,  86.9, -33.0, 0.0, 3.22},
				{  62.5,  84.6,  38.5, 0.0, 2.24},
				{  67.7,  84.8, 117.2, 0.0, 3.76},
				{  61.5,-174.9,-179.8, 0.0, 2.37},
				{  64.0,-177.6, -79.1, 0.0, 1.53},
				{  65.1,-177.5,  -4.1, 0.0, 1.23},
				{  65.4,-177.1,  79.5, 0.0, 1.39},
				{  64.1, -82.4,-111.9, 0.0, 9.99},
				{  66.3, -76.0, -34.4, 0.0, 2.16},
				{  64.8, -89.6,  38.2, 0.0, 1.72},
				{  57.6, -79.7, 123.9, 0.0, 2.75},
				{-174.0,  60.6,-124.1, 0.0, 1.60},
				{-175.4,  74.1, -37.5, 0.0, 1.61},
				{-176.1,  65.7,  44.6, 0.0, 0.51},
				{-178.1,  70.4, 109.0, 0.0, 2.70},
				{-175.5, 178.6,-179.1, 0.0, 1.89},
				{-178.0, 176.1, -77.6, 0.0, 0.95},
				{-177.0, 177.3,   1.0, 0.0, 0.39},
				{-176.6,-179.4,  74.8, 0.0, 0.83},
				{-165.2, -77.7,-112.0, 0.0, 3.52},
				{-169.4, -81.4, -34.9, 0.0, 1.61},
				{-165.7, -83.7,  46.1, 0.0, 2.94},
				{-170.6, -75.8, 125.3, 0.0, 2.65},
				{ -70.8,  73.4,-123.8, 0.0, 2.40},
				{ -64.6,  86.7, -35.4, 0.0, 1.69},
				{ -68.4,  74.8,  37.4, 0.0, 1.30},
				{ -72.0,  83.7, 110.1, 0.0, 3.02},
				{ -66.9, 179.0,-177.9, 0.0, 1.28},
				{ -66.8,-179.7, -76.8, 0.0, 0.41},
				{ -67.5, 177.6,  -1.1, 0.0, 0.00},
				{ -65.8,-178.9,  75.3, 0.0, 0.53},
				{ -66.1, -82.1,-111.8, 0.0, 2.43},
				{ -63.4, -63.2, -46.3, 0.0, 0.13},
				{ -67.0, -76.5,  44.4, 0.0, 1.26},
				{ -68.5, -61.2, 119.9, 0.0, 1.19}
				};

static ZLINESTRU PRO[10] = {    {6,{2,3,1,0},1.530,112.2,115.146},
				{6,{6,2,1,0},1.512,104.1,-27.9},
				{6,{7,6,2,0},1.518,103.0,39.0},
				{1,{2,3,1,0},1.100,104.1,-122.6},
				{1,{6,2,7,0},1.100,111.4,120.3},
				{1,{6,2,7,0},1.100,111.4,-120.3},
				{1,{7,6,8,0},1.100,111.7,120.1},
				{1,{7,6,8,0},1.100,111.7,-120.1},
				{1,{8,7,1,0},1.100,111.8,120.0},
				{1,{8,7,1,0},1.100,111.8,-120.0}
			   };
static short int PRO_TYP[10] = { 5,6,9,4,7,8,10,11,19,20};
static int PRO_CHI[4] = {2,3,-1,-1};

/* definitie */
static ROTSSTRU PRO_ROT[2] = {
				{ -27.943,  39.047, 0.0, 0.0, 0.00},
				{  27.570, -35.774, 0.0, 0.0, 0.01}
				};

static ROTSSTRU PRO_ROTD[2] = {
				{ 27.0, -34.6, 0.0, 0.0, 0.00},
				{-25.1,  36.3, 0.0, 0.0, 0.02}
				};

static ZLINESTRU ARG[19] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.520,114.1,-67.0},
				{6,{8,7,2,0},1.520,111.3,180.0},
				{7,{9,8,7,0},1.459,112.0,180.0},
				{6,{10,9,8,0},1.330,124.2,180.0},
				{7,{11,10,9,0},1.326,120.0,0.0},
				{7,{11,10,12,0},1.326,120.0,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.9},
				{1,{7,2,8,0},1.100,108.9,-121.9},
				{1,{8,7,9,0},1.100,109.6,121.4},
				{1,{8,7,9,0},1.100,109.6,-121.4},
				{1,{9,8,10,0},1.100,109.4,121.5},
				{1,{9,8,10,0},1.100,109.4,-121.5},
				{1,{10,9,11,0}, 1.000,118.0,180.0},
				{1,{12,11,10,0},1.000,120.0,0.0},
				{1,{12,11,22,0},1.000,120.0,180.0},
				{1,{13,11,10,0},1.000,120.0,0.0},
				{1,{13,11,24,0},1.000,120.0,180.0}
			   };
static short int ARG_TYP[19] = { 5,6,9,22,17,25,26,4,7,8,10,11,19,20,28,55,56,58,59};
static int ARG_CHI[4] = {2,3,4,5};
static ROTSSTRU ARG_ROT[34] = {
				{  62.0, 180.0,  65.0,  85.0, 2.01},
				{  62.0, 180.0,  65.0,-175.0, 1.24},
				{  62.0, 180.0, 180.0,  85.0, 1.02},
				{  62.0, 180.0, 180.0, 180.0, 1.02},
				{  62.0, 180.0, 180.0, -85.0, 1.06},
				{  62.0, 180.0, -65.0, 175.0, 1.60},
				{  62.0, 180.0, -65.0, -85.0, 1.71},
				{-177.0,  65.0,  65.0,  85.0, 1.24},
				{-177.0,  65.0,  65.0,-175.0, 1.43},
				{-177.0,  65.0, 180.0,  85.0, 0.89},
				{-177.0,  65.0, 180.0, 180.0, 1.06},
				{-177.0, 180.0,  65.0,  85.0, 0.59},
				{-177.0, 180.0,  65.0,-175.0, 0.76},
				{-177.0, 180.0,  65.0,-105.0, 1.36},
				{-177.0, 180.0, 180.0,  85.0, 0.92},
				{-177.0, 180.0, 180.0, 180.0, 0.59},
				{-177.0, 180.0, 180.0, -85.0, 0.73},
				{-177.0, 180.0, -65.0, 105.0, 1.30},
				{-177.0, 180.0, -65.0, 175.0, 1.14},
				{-177.0, 180.0, -65.0, -85.0, 0.69},
				{ -67.0, 180.0,  65.0,  85.0, 0.83},
				{ -67.0, 180.0,  65.0,-175.0, 0.41},
				{ -67.0, 180.0,  65.0,-105.0, 1.51},
				{ -67.0, 180.0, 180.0,  85.0, 0.57},
				{ -67.0, 180.0, 180.0, 180.0, 0.00},
				{ -67.0, 180.0, 180.0, -85.0, 0.31},
				{ -67.0, 180.0, -65.0, 105.0, 1.06},
				{ -67.0, 180.0, -65.0, 175.0, 0.37},
				{ -67.0,-167.0, -65.0, -85.0, 0.30},
				{ -62.0, -68.0, 180.0,  85.0, 1.51},
				{ -62.0, -68.0, 180.0, 180.0, 0.95},
				{ -62.0, -68.0, 180.0, -85.0, 0.83},
				{ -62.0, -68.0, -65.0, 175.0, 1.24},
				{ -62.0, -68.0, -65.0, -85.0, 0.95}
				};

static ROTSSTRU ARG_ROTD[81] = {
				{  55.4,  79.7,  62.4,  82.3, 3.50},
				{  59.2,  85.4,  68.2,-166.2, 2.95},
				{  54.5,  79.4,  64.6,-103.2, 9.99},
				{  54.5,  86.6, 178.2,  85.5, 3.26},
				{  53.9,  87.8,-178.5, 178.1, 2.60},
				{  53.5,  87.8,-176.0, -81.1, 3.09},
				{  54.5,  83.5, -78.4, 102.9, 9.99},
				{  50.0,  82.4, -92.5, 169.0, 3.50},
				{  54.5,  83.5, -77.1, -84.1, 9.99},
				{  62.0, 177.8,  64.9,  84.4, 1.80},
				{  64.1,-175.8,  68.0,-172.6, 1.39},
				{  65.1,-178.6,  61.1,-104.5, 2.43},
				{  65.3, 180.0, 178.0,  85.7, 1.16},
				{  66.5,-177.6,-178.9,-177.2, 1.12},
				{  66.4,-175.2,-177.5, -82.5, 1.22},
				{  63.8,-171.9, -64.5, 102.9, 2.67},
				{  63.4,-176.5, -66.7, 173.2, 1.44},
				{  62.9, 179.9, -69.2, -82.5, 1.95},
				{  65.2, -85.1,  84.2,  84.5, 3.91},
				{  63.2, -85.5,  80.7,-172.0, 3.91},
				{  63.6, -82.1,  71.6,-103.2, 9.99},
				{  63.6, -78.2,-179.8,  85.7, 9.99},
				{  57.6, -83.1,-176.1,-178.4, 2.95},
				{  68.7, -75.7,-177.8, -85.7, 3.09},
				{  63.6, -77.9, -77.1, 102.9, 9.99},
				{  63.7, -78.1, -64.2, 169.9, 2.84},
				{  63.8, -78.2, -59.5, -83.3, 3.50},
				{-176.5,  65.8,  60.2,  80.8, 1.69},
				{ 179.4,  65.8,  65.3,-170.9, 1.47},
				{-173.6,  68.1,  67.3,-103.0, 2.95},
				{ 179.3,  66.2,-178.6,  85.1, 1.45},
				{-177.0,  67.4, 177.0, 171.0, 1.21},
				{ 178.1,  66.9,-178.7, -85.3, 1.71},
				{-176.1,  81.2, -80.9, 103.3, 3.91},
				{-175.6,  79.6, -90.4, 172.4, 2.10},
				{-178.7,  78.6, -78.3, -84.6, 2.84},
				{-177.3, 178.6,  64.9,  80.8, 0.72},
				{-174.1, 176.8,  67.8,-167.7, 0.66},
				{-176.7, 178.8,  63.4,-103.7, 1.36},
				{-176.8, 177.6, 178.8,  85.2, 0.92},
				{-176.9, 176.3, 178.8,-179.4, 0.46},
				{-177.5, 176.5,-177.8, -85.2, 0.78},
				{-174.4, 178.1, -63.4, 105.1, 1.23},
				{-175.4, 179.7, -64.8, 165.2, 0.78},
				{-175.6, 179.6, -65.0, -82.6, 0.80},
				{-169.7, -83.6,  80.9,  82.5, 9.99},
				{-166.0, -82.2,  78.0,-172.4, 3.91},
				{-169.7, -83.6,  71.6,-103.2, 9.99},
				{-171.4, -85.4,-174.0,  84.2, 3.26},
				{-171.3, -87.2,-179.0,-176.1, 2.26},
				{-171.0, -84.3,-176.8, -81.1, 2.67},
				{-170.0, -92.9, -72.5, 104.0, 3.26},
				{-170.2, -91.1, -67.4, 170.0, 2.10},
				{-165.9, -84.4, -59.4, -82.3, 2.75},
				{ -79.0,  87.7,  66.3,  84.2, 2.60},
				{ -83.1,  81.9,  69.8,-178.0, 2.23},
				{ -80.8,  86.2,  67.4,-101.7, 3.91},
				{ -78.6,  73.8,-179.4,  85.1, 2.75},
				{ -85.8,  70.4, 174.6, 179.0, 1.69},
				{ -80.8,  79.3, 177.3, -81.8, 2.23},
				{ -82.6,  77.9, -78.4, 102.9, 9.99},
				{ -85.1,  77.1, -91.5, 168.7, 3.50},
				{ -81.6,  78.0, -79.6, -84.1, 3.91},
				{ -66.2, 179.5,  66.1,  84.3, 0.66},
				{ -66.7, 178.5,  65.6,-170.1, 0.37},
				{ -67.2,-178.5,  63.1,-101.8, 1.59},
				{ -66.9, 179.7, 178.7,  86.7, 0.51},
				{ -67.7, 179.1,-179.0, 176.3, 0.00},
				{ -68.1,-179.7,-176.3, -82.7, 0.38},
				{ -68.9,-175.6, -68.5, 102.2, 1.36},
				{ -67.0, 179.5, -67.9, 173.2, 0.30},
				{ -68.4,-170.6, -64.5, -85.4, 0.44},
				{ -63.9, -76.1,  80.0,  79.6, 1.95},
				{ -64.3, -80.3,  78.7,-165.9, 1.95},
				{ -62.5, -80.5,  71.6,-105.6, 3.26},
				{ -62.6, -68.9, 179.4,  83.8, 1.30},
				{ -62.7, -72.4,-177.9,-177.8, 0.85},
				{ -63.2, -69.8,-175.2, -87.0, 0.87},
				{ -64.9, -74.5, -79.7,  95.0, 2.39},
				{ -63.6, -67.9, -65.0, 169.4, 1.13},
				{ -62.8, -68.8, -60.8, -83.5, 1.00}
				};

static ZLINESTRU HIS[13] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.497,113.8,-65.0},
				{7,{8,7,2,0},1.378,122.7,-69.0},
				{6,{9,8,7,0},1.321,109.3,180.0},
				{7,{10,9,8,0},1.318,108.5,0.0},
				{6,{11,10,9,0},1.373,108.9,0.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.8},
				{1,{7,2,8,0},1.100,108.9,-121.8},
				{1,{9,8,10,0},  1.000,125.3,180.0},
				{1,{10,9,8,0}, 1.100,125.7,180.0},
				{1,{12,11,10,0},1.100,126.4,180.0}
			   };
static short int HIS_TYP[13] = { 5,6,20,13,24,11,4,7,8,22,31,25};
static int HIS_CHI[4] = {2,3,-1,-1};
static ROTSSTRU HIS_ROT[8] = {
				{  62.0, -75.0, 0.0, 0.0, 0.73},
				{  62.0,  80.0, 0.0, 0.0, 1.13},
				{-177.0,-165.0, 0.0, 0.0, 1.02},
				{-177.0, -80.0, 0.0, 0.0, 0.59},
				{-177.0,  60.0, 0.0, 0.0, 0.36},
				{ -65.0, -70.0, 0.0, 0.0, 0.00},
				{ -65.0, 165.0, 0.0, 0.0, 0.81},
				{ -65.0,  80.0, 0.0, 0.0, 0.48}
				};

static ROTSSTRU HIS_ROTD[9] = {
				{  63.0,  85.6,  0.0,   0.0, 1.09},
				{  64.8, 166.2,  0.0,   0.0, 2.37},
				{  65.4, -79.5,  0.0,   0.0, 0.85},
				{-178.4,  71.5,  0.0,   0.0, 0.39},
				{-172.8,-170.3,  0.0,   0.0, 1.02},
				{-172.6, -83.8,  0.0,   0.0, 0.53},
				{ -66.0,  85.6,  0.0,   0.0, 0.42},
				{ -68.1, 168.7,  0.0,   0.0, 0.60},
				{ -63.7, -72.9,  0.0,   0.0, 0.00}
				};

static ZLINESTRU PHE[15] = {    {6,{2,3,1,0},1.530,110.4,122.8},
				{6,{7,2,1,0},1.501,113.8,-65.0},
				{6,{8,7,2,0},1.384,120.7,-85.0},
				{6,{9,8,7,0},1.382,120.7,180.0},
				{6,{10,9,8,0},1.378,120.1,0.0},
				{6,{11,10,9,0},1.378,119.7,0.0},
				{6,{12,11,10,0},1.381,120.0,0.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.8},
				{1,{7,2,8,0},1.100,108.9,-121.8},
				{1,{9,8,7,0},1.100,119.6,0.0},
				{1,{10,9,8,0},1.100,119.9,180.0},
				{1,{11,10,9,0},1.100,120.1,180.0},
				{1,{12,11,10,0},1.100,120.0,180.0},
				{1,{13,12,11,0},1.100,119.5,180.0}
			   };
static short int PHE_TYP[15] = { 5,6,10,13,17,14,11,4,7,8,22,31,40,34,25};
static int PHE_CHI[4] = {2,3,-1,-1};
static ROTSSTRU PHE_ROT[4] = {
				{  62.0,  90.0, 0.0, 0.0, 0.73},
				{-177.0,  80.0, 0.0, 0.0, 0.14},
				{ -65.0, -85.0, 0.0, 0.0, 0.00},
				{ -65.0, -30.0, 0.0, 0.0, 0.95}
				};

static ROTSSTRU PHE_ROTD[6] = {
				{  63.0,  90.4, 0.0, 0.0, 0.86},
				{  62.0,  -6.5, 0.0, 0.0, 3.71},
				{-178.8,  78.1, 0.0, 0.0, 0.23},
				{-174.2,  21.2, 0.0, 0.0, 1.90},
				{ -66.9,  97.7, 0.0, 0.0, 0.00},
				{ -68.8, -15.3, 0.0, 0.0, 1.04}
				};


static ZLINESTRU TYR[16] = {    {6,{2,3,1,0},1.530,110.4,122.8},
				{6,{7,2,1,0},1.501,113.8,-65.0},
				{6,{8,7,2,0},1.389,120.8,-85.0},
				{6,{9,8,7,0},1.381,121.2,180.0},
				{6,{10,9,8,0},1.390,119.4,0.0},
				{6,{11,10,9,0},1.382,120.4,0.0},
				{6,{12,11,10,0},1.382,119.4,0.0},
				{8,{11,10,9,0},1.376,119.7,180.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,108.9,121.8},
				{1,{7,2,8,0},1.100,108.9,-121.8},
				{1,{9,8,7,0},1.100,119.4,0.0},
				{1,{10,9,8,0},1.100,120.3,180.0},
				{1,{12,11,10,0},1.100,120.3,180.0},
				{1,{13,12,11,0},1.100,119.4,180.0},
				{1,{14,11,10,0},1.000,109.5,0.0}
			   };
static short int TYR_TYP[16] = { 5,6,10,13,17,14,11,33,4,7,8,22,31,34,25,52};
static int TYR_CHI[4] = {2,3,-1,-1};
/* 1 te veel ?  alex ?*/
static ROTSSTRU TYR_ROT[5] = {
				{  62.0,  90.0, 0.0, 0.0, 0.72},
				{-177.0,  80.0, 0.0, 0.0, 0.14},
				{ -65.0, -85.0, 0.0, 0.0, 0.00},
				{ -65.0, -30.0, 0.0, 0.0, 0.95},
				{ -65.0,  30.0, 0.0, 0.0, 0.00}
				};
static ROTSSTRU TYR_ROTD[6] = {
				{  63.6,  90.2, 0.0, 0.0, 0.83},
				{  69.7,  -9.5, 0.0, 0.0, 3.55},
				{-179.6,  77.5, 0.0, 0.0, 0.22},
				{-174.2,  21.0, 0.0, 0.0, 1.90},
				{ -65.8,  97.8, 0.0, 0.0, 0.00},
				{ -67.2, -16.7, 0.0, 0.0, 1.17}
				};


static ZLINESTRU TRP[19] = {    {6,{2,3,1,0},1.530,110.1,122.8},
				{6,{7,2,1,0},1.498,113.6,-65.0},
				{6,{8,7,2,0},1.365,126.9,95.0},
				{7,{9,8,7,0},1.374,110.2,180.0},
				{6,{10,9,8,0},1.375,108.7,0.0},
				{6,{11,10,9,0},1.409,107.6,0.0},
				{6,{12,11,10,0},1.397,118.9,180.0},
				{6,{13,12,11,0},1.382,118.6,0.0},
				{6,{14,13,12,0},1.406,121.3,0.0},
				{6,{15,14,13,0},1.370,121.2,0.0},
				{1,{2,3,1,0},1.100,108.2,-118.2},
				{1,{7,2,8,0},1.100,109.0,121.8},
				{1,{7,2,8,0},1.100,109.0,-121.8},
				{1,{9,8,7,0},1.100,124.9,0.0},
				{1,{10,9,8,0},1.000,125.7,180.0},
				{1,{13,12,10,0},1.100,120.7,180.0},
				{1,{14,13,12,0},1.100,119.4,180.0},
				{1,{15,14,13,0},1.100,119.4,180.0},
				{1,{16,15,14,0},1.100,121.2,180.0}
			   };
static short int TRP_TYP[19] = { 5,6,10,23,14,11,15,19,16,18,4,7,8,22,31,37,49,58,46};
static int TRP_CHI[4] = {2,3,-1,-1};
static ROTSSTRU TRP_ROT[7] = {
				{  62.0, -90.0, 0.0, 0.0, 0.63},
				{  62.0,  90.0, 0.0, 0.0, 1.03},
				{-177.0,-105.0, 0.0, 0.0, 0.40},
				{-177.0,  90.0, 0.0, 0.0, 0.34},
				{ -65.0, -90.0, 0.0, 0.0, 1.09},
				{ -65.0,  -5.0, 0.0, 0.0, 0.83},
				{ -65.0,  95.0, 0.0, 0.0, 0.00}
				};
static ROTSSTRU TRP_ROTD[9] = {
				{  61.2, -89.9,   0.0,   0.0, 0.67},
				{  66.0,  -6.3,   0.0,   0.0, 2.37},
				{  61.5,  89.2,   0.0,   0.0, 1.04},
				{-177.3,-104.9,   0.0,   0.0, 0.38},
				{-175.1,  17.3,   0.0,   0.0, 0.99},
				{-179.8,  84.7,   0.0,   0.0, 0.51},
				{ -70.1, -92.2,   0.0,   0.0, 1.04},
				{ -68.6,  -4.2,   0.0,   0.0, 0.51},
				{ -67.4, 100.3,   0.0,   0.0, 0.00}
				};


static ZLINESTRU ACE[6] =   {   {6,{0,0,0,0},0.0,0.0,0.0},
				{8,{1,0,0,0},1.220,0.0,0.0},
				{6,{1,2,0,0},1.335,120.0,0.0},
				{1,{3,1,2,0},1.089,109.471,180.0},
				{1,{3,1,2,0},1.089,109.471,60.0},
				{1,{3,1,2,0},1.089,109.471,-60.0}
				};

static ZLINESTRU FOR[3] =   {   {6,{0,0,0,0},0.0,0.0,0.0},
				{8,{1,0,0,0},1.220,0.0,0.0},
				{1,{1,2,0,0},1.089,120.0,0.0}
				};

static ZLINESTRU NME[6] =   {  {7,{0,0,0,0},0.0,0.0,0.0},
				{6,{1,0,0,0},1.300,0.0,0.0},
				{1,{1,2,0,0},1.020,120.0,0.0},
				{1,{2,1,3,0},1.089,109.471,180.0},
				{1,{2,1,4,0},1.089,109.471,120.0},
				{1,{2,1,4,0},1.089,109.471,-120.0}
				};

static ZLINESTRU AMINO[28];

typedef struct { ZLINESTRU *zmat;
		 short int *ipdbt;
		 int *chis;
		 ROTSSTRU *rots;
		 int zlines;
		 int nrots;
		} AMINOSTRU;

static AMINOSTRU aminozmtr[20] = { 
	{GLY,GLY_TYP,GLY_CHI,GLY_ROT,2,0}, {ALA,ALA_TYP,ALA_CHI,ALA_ROT,5,0}, 
	{SER,SER_TYP,SER_CHI,SER_ROT,6,3}, {CYS,CYS_TYP,CYS_CHI,CYS_ROT,6,3}, 
	{THR,THR_TYP,THR_CHI,THR_ROT,9,3}, {ILE,ILE_TYP,ILE_CHI,ILE_ROT,14,5}, 
	{VAL,VAL_TYP,VAL_CHI,VAL_ROT,11,3},{MET,MET_TYP,MET_CHI,MET_ROT,12,13}, 
	{ASP,ASP_TYP,ASP_CHI,ASP_ROT,7,5}, {ASN,ASN_TYP,ASN_CHI,ASN_ROT,9,7}, 
	{LEU,LEU_TYP,LEU_CHI,LEU_ROT,14,5},{LYS,LYS_TYP,LYS_CHI,LYS_ROT,17,27}, 
	{GLU,GLU_TYP,GLU_CHI,GLU_ROT,10,8},{GLN,GLN_TYP,GLN_CHI,GLN_ROT,12,9},
	{PRO,PRO_TYP,PRO_CHI,PRO_ROT,10,2},{ARG,ARG_TYP,ARG_CHI,ARG_ROT,19,34}, 
	{HIS,HIS_TYP,HIS_CHI,HIS_ROT,12,8},{PHE,PHE_TYP,PHE_CHI,PHE_ROT,15,4}, 
	{TYR,TYR_TYP,TYR_CHI,TYR_ROT,16,5},{TRP,TRP_TYP,TRP_CHI,TRP_ROT,19,7}
	};

static AMINOSTRU aminozmtd[20] = { 
	{GLY,GLY_TYP,GLY_CHI,GLY_ROT,2,0}, {ALA,ALA_TYP,ALA_CHI,ALA_ROT,5,0}, 
	{SER,SER_TYP,SER_CHI,SER_ROTD,6,3}, {CYS,CYS_TYP,CYS_CHI,CYS_ROTD,6,3}, 
	{THR,THR_TYP,THR_CHI,THR_ROTD,9,3}, {ILE,ILE_TYP,ILE_CHI,ILE_ROTD,14,9}, 
	{VAL,VAL_TYP,VAL_CHI,VAL_ROTD,11,3},{MET,MET_TYP,MET_CHI,MET_ROTD,12,27}, 
	{ASP,ASP_TYP,ASP_CHI,ASP_ROTD,7,9}, {ASN,ASN_TYP,ASN_CHI,ASN_ROTD,9,18}, 
	{LEU,LEU_TYP,LEU_CHI,LEU_ROTD,14,9},{LYS,LYS_TYP,LYS_CHI,LYS_ROTD,17,81}, 
	{GLU,GLU_TYP,GLU_CHI,GLU_ROTD,10,27},{GLN,GLN_TYP,GLN_CHI,GLN_ROTD,12,36},
	{PRO,PRO_TYP,PRO_CHI,PRO_ROTD,10,2},{ARG,ARG_TYP,ARG_CHI,ARG_ROTD,19,81}, 
	{HIS,HIS_TYP,HIS_CHI,HIS_ROTD,12,9},{PHE,PHE_TYP,PHE_CHI,PHE_ROTD,15,6}, 
	{TYR,TYR_TYP,TYR_CHI,TYR_ROTD,16,6},{TRP,TRP_TYP,TRP_CHI,TRP_ROTD,19,9}
	};

static AMINOSTRU *aminozmt = aminozmtr;


/* start dimension dynamic molecule coordinates*/

#define NUMAT 20000
#define MXCON 10
#define NUMADD 50000
static int addat = NUMADD;

typedef struct { double coo[NUMAT][3];
		 double rzp[NUMAT];
		 int ianz[NUMAT];
		 int iaton[NUMAT];
		 int iatclr[NUMAT];
		 int iresid[NUMAT];
		 int ixp[NUMAT];
		 int iyp[NUMAT];
		 int iconn[NUMAT][MXCON+1];
               } ATOMSTRU;

static ATOMSTRU *atomptr;

#define MXDRES 40
#define MXROT 81
#define MXROTRES 10

typedef struct { double estat[MXROT][MXDRES];
		 int ndrs;
		 int idrs[MXDRES];
		 int lrots[MXDRES];
		 } PMFROTSTRU;

static PMFROTSTRU *pmfrot;

#define MXSYM 103
#define MXHSYM 64

static int ipdb[MXSYM];
static int ihpdb[MXHSYM*3];

double vln( double *a);

/* This is a sin, I know :-) */

static int NW_MKBACK = 0;

void ogsarr();
void ogres(int ires, int iopt,int iupd);
void DrCircle(int cx,int cy,float r,int nseg);
static int vis = 0;

#include "rots.h"

typedef struct { double etot;
		 int ndrs;
		 int mx;
		 int mn;
		 int idrs[MXDRES];
		 int rot[MXDRES];
		 } RESROTSTRU;

static RESROTSTRU resrot[MXROTRES];
static int nresrot = 0;
static double flxen[MXROTRES];

static int *iresflx = NULL;
typedef struct { double vo[3];
		 double r[3];
		 double v1[3];
		 double v2[3];
		 double v3[3];
		 double wo[3];
		 double sl[3];
		 int isl;
               } COMSRFSTRU;

static COMSRFSTRU *comsrfptr;

typedef struct { float fc[NUMAT][3];
               } FCSTRU;

static FCSTRU *fcptr;

#define MAXDM 20
typedef struct { double rdm[MAXDM];
		 int idmon[MAXDM][2];
		 int ndm;
               } MONSTRU;

static MONSTRU *monptr;


#define MXEL 100
typedef struct { 
		 double vdwr[MXEL];
		 double vrad[MXEL];
		 int icol[MXEL];
               } ELMSTRU;

static ELMSTRU *elmptr;

typedef struct  { int *iamino;
		  int phi;
		  int psi;
		  int omega;
		  int chi1;
		  int chi2;
		  int chi3;
		  int chi4;
		} AASTRU;
		 
static AASTRU aaptr[NUMCAL];

static int *ResChanged = NULL;
static int CurrRes = 0;
static double xyzpdb[MXSYM][3];
static double xyzhpdb[MXHSYM*3][3];

#define MXCOLNAM 20
static char  *ColNam[MXCOLNAM];
static int NColNam = 0;

void dummyproc();
static void DoExpl();
static void ogunsel();
static void handle_explalarm();
static void handle_svgfile();
static void DoSvgfile();
static void SvgExpose();
void DrawSVG(int x,int y,int w0,int h0,SVGFSTRUC svgfile,Window win);
void InitOmap(int opt);
void dispsf(void);
void ogbox();
void ogelem();
void ogsetel20(int j);
void ogsetel20_bs(int j);
void ogsetel12(int j);
void ogsetel12_bs(int j);
void ogfeatures();
void GetPDBWWW(char *het, char *retstr);
int GetOMAPWWW(char *het, char *retstr);
int PDBquery(char *het);
void LigandHydroPBE(int ihet);
void LigandHydroQ(int DoHyd,int DoChg,int DoFF,int CHGtot);
void LigandQ(int ihet);
void LigandHydro(int het);
int Ligand2Amino(int ihet);
int ParseFile(char *strname, char *shortname);
static int hasWGET = 0;
int CheckWGET();
void update_struct();
void oghet(int iopt);
void oglines();
void ogsel();
#if defined(VMS) || defined(UNDERSC)
void ogmon();
#else
#ifdef CRAY
void OGMON();
#else
void ogmon_();
#endif
#endif
void ogforces();
void ogmoll(int iopt);
void ogbck(int isec);
void ResetRes();
void ressel();
void ogdipole();
void zmt2cor(int ires, int iopt);
void moused(int button, unsigned int state, int x, int y);
void mouseu(int button, int state, int x, int y);
void motion(int x, int y, int iopt);
void Reshape(int update);
void empty_model(int sel,int updis);
void empty_ribb();
void MoveOne(int i);
void initOpengl();
void initthe();
void initnthe();
void initOne(int i);
void setobg();
void DelHet(int het);
void znorm(double rpts, double cnst, double *dens, double *vn,
	   int npts1, int npts2, int i, int j);
void printString(int x, int y, int init, char *s);
void makeRasterFont(Display *dpy);

#include <math.h>

#include <fcntl.h>
#if defined(__APPLE__)
#include <copyfile.h>
#elif defined(__FreeBSD__)
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#else
#include <sys/sendfile.h>
#endif

int OSCopyFile(const char* source, const char* destination)
{    
    int input, output;    
    if ((input = open(source, O_RDONLY)) == -1)
    {
        return -1;
    }    
    if ((output = creat(destination, 0660)) == -1)
    {
        close(input);
        return -1;
    }

    //Here we use kernel-space copying for performance reasons
#if defined(__APPLE__)
    //fcopyfile works on FreeBSD and OS X 10.5+ 
    int result = fcopyfile(input, output, 0, COPYFILE_ALL);
#elif defined(__FreeBSD__)
    off_t bytesCopied = 0;
    struct stat fileinfo = {0};
    fstat(input, &fileinfo);
    int result = sendfile(output, input, 0/*ofset*/, fileinfo.st_size, 0/*hdtr*/, &bytesCopied, 0/*flags*/);

#else
    //sendfile will work with non-socket output (i.e. regular file) on Linux 2.6.33+
    off_t bytesCopied = 0;
    struct stat fileinfo = {0};
    fstat(input, &fileinfo);
    int result = sendfile(output, input, &bytesCopied, fileinfo.st_size);
#endif

    close(input);
    close(output);

    return result;
}

char* myStrcasestr(const char* haystack, const char* needle)
{
    int i,j,matches;

    if (!needle[0]) return (char*) haystack;

    for (i = 0; haystack[i]; i++) {
        matches = 1;
        for (j = 0; needle[j]; j++) {
            if (!haystack[i + j]) return NULL;

            if (tolower((unsigned char)needle[j]) != 
                tolower((unsigned char)haystack[i + j])) {
                matches = 0;
                break;
            }
        }
        if (matches) return (char *)(haystack + i);
    }
    return NULL;
}

void cross(float *a,float *b, float *c)
{
/*

       calculates cross product:   a x b = c
                                   -   -   -
*/
 
      c[0] = a[1]*b[2] - a[2]*b[1];
      c[1] = a[2]*b[0] - a[0]*b[2];
      c[2] = a[0]*b[1] - a[1]*b[0];

}

float veclen(float *a)
{
      float vl;
      double tot;

      tot = a[0]*a[0]+a[1]*a[1]+a[2]*a[2];

      vl = 0.0;
      if (tot > 0.0) vl = (float) sqrt(tot);

      return(vl);

}

void dimprod(double *a, double *b, double *c)
{
      int i;
      double rimp, al, bl;

      rimp = 0.0;

      for (i=0; i<3; i++) rimp = rimp + a[i]*b[i];

      al = dveclen(a);
      bl = dveclen(b);

      if (al > 0.0 && bl > 0.0) {
         *c = rimp / (al*bl);
      } else {
         *c = 0.0;
      }

}

void improd(float *a, float *b, double *c)
{
      int i;
      float rimp, al, bl;

      rimp = 0.0;

      for (i=0; i<3; i++) rimp = rimp + a[i]*b[i];

      al = veclen(a);
      bl = veclen(b);

      if (al > 0.0 && bl > 0.0) {
         *c = (double) rimp / (veclen(a)*veclen(b));
      } else {
         *c = 0.0;
      }

}

void IMPRD(float *a, float *b, float *c,int norm)
{
      int i;
      float rimp, al, bl;

      rimp = 0.0;

      for (i=0; i<3; i++) rimp = rimp + a[i]*b[i];

      al = veclen(a);
      bl = veclen(b);

      if (al > 0.0 && bl > 0.0) {
	 if (norm) {
            *c = rimp / (veclen(a)*veclen(b));
	 } else {
            *c = rimp;
	 }
      } else {
         *c = 0.0;
      }

}

void vsubt(float *a, float *b, float *c)
{
      int i;

      for (i=0; i<3; i++) c[i] = a[i] - b[i];
}

#ifdef DOGL
static GLXContext cx;
const char *glExtensions;
static int attributeList[] = {GLX_RGBA, GLX_DEPTH_SIZE,16, 
GLX_RED_SIZE, 1, GLX_GREEN_SIZE, 1, GLX_BLUE_SIZE, 1, GLX_DOUBLEBUFFER, None};
static GLuint theDens;
static GLfloat gxlx, gyly ;			/* more statics for     */
static GLfloat gstart_xlx, gstart_yly;	/* line drawing		*/
static float CV[6][3] = {
  {0.4,0.0,0.0},
  {0.0,0.4,0.0},
  {0.0,0.0,0.4},
  {-0.4,0.0,0.0},
  {0.0,-0.4,0.0},
  {0.0,0.0,-0.4}
};
void dimprod(double *a, double *b, double *c);
static GLfloat posx = 0.0;
static GLfloat posy = 0.0;
static GLfloat posz = -20.0;
typedef struct { 
	GLfloat fogcolor[4]; 
	GLint fstart; 
	GLint fend; 
	GLfloat fscale;} FOG;

static FOG fog;

static GLfloat fogColor[4] = {0.5, 0.5, 0.5, 1.0};
static GLfloat gradcol[2][4] = { {0.0, 0.0, 0.9, 1.0}, {1.0, 1.0, 1.0, 1.0}};
static float AxesXYZ[4][3] =
{ 
  {0.0,0.0,0.0}, 
  {1.0,0.0,0.0}, 
  {0.0,1.0,0.0}, 
  {0.0,0.0,1.0} 
};

static int AxesProj[4][2];

static GLfloat AxesCol[4][4] =
{ 
  {0.0,0.0,0.0,1.0}, 
  {1.0,0.0,0.0,1.0}, 
  {0.0,1.0,0.0,1.0}, 
  {0.0,0.0,1.0,1.0} 
};

static char *AxesStr[] = {"O","X","Y","Z"};

static int has_shader = 0;
static int has_fbo = 0;
#ifdef GL_COLOR_ATTACHMENT0_EXT
static int fbo_type = GL_RGBA32F_ARB;
#else
static int fbo_type = 4;
#endif

#define NUM_PROG 13
GLenum program[NUM_PROG];
GLenum vertex_shader[NUM_PROG], fragment_shader[NUM_PROG];

#define NUM_FBOS 4
struct FBO {
        GLuint frame[NUM_FBOS], depth[NUM_FBOS],
	texid[NUM_FBOS],texid1[NUM_FBOS],texid2[NUM_FBOS],texid3[NUM_FBOS];
};

struct FBO fbo;

char vertex_shader_source0[] = "\
uniform int doshad;\n\
uniform int dofog;\n\
varying float Blur;\n\
varying vec3 vertex_normal;\n\
varying vec3 eyeVec;\n\
varying vec4 ShadowCoord;\n\
\n\
void main() {\n\
	vertex_normal = normalize(gl_NormalMatrix * gl_Normal).xyz;\n\
	eyeVec = -vec3(gl_ModelViewMatrix * gl_Vertex);\n\
	Blur = clamp(abs(eyeVec.z - 10.0) / 60.0, 0.0, 1.0);\n\
	gl_FrontColor = gl_Color;\n\
	gl_BackColor = gl_Color;\n\
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n\
	gl_FogFragCoord = abs(eyeVec.z);\n\
	ShadowCoord = vec4(0.0);\n\
        vec4 clipVertex = gl_ModelViewMatrix*gl_Vertex;\n\
	gl_ClipDistance[0] = dot(clipVertex, gl_ClipPlane[0]);\n\
	gl_ClipDistance[1] = dot(clipVertex, gl_ClipPlane[1]);\n\
	gl_ClipDistance[2] = dot(clipVertex, gl_ClipPlane[2]);\n\
	gl_ClipDistance[3] = dot(clipVertex, gl_ClipPlane[3]);\n\
	gl_ClipDistance[4] = dot(clipVertex, gl_ClipPlane[4]);\n\
	gl_ClipDistance[5] = dot(clipVertex, gl_ClipPlane[5]);\n\
	if (doshad == 1) {\n\
	   ShadowCoord = gl_TextureMatrix[7]*gl_Vertex;\n\
	   gl_FrontColor = gl_Color;\n\
	}\n\
}\n";

char vertex_shader_source0b[] = "\
#version 130\n\
uniform int doshad;\n\
uniform int dofog;\n\
varying float Blur;\n\
varying vec3 vertex_normal;\n\
varying vec3 eyeVec;\n\
varying vec4 ShadowCoord;\n\
out float gl_ClipDistance[6];\n\
\n\
void main() {\n\
	vertex_normal = normalize(gl_NormalMatrix * gl_Normal).xyz;\n\
	eyeVec = -vec3(gl_ModelViewMatrix * gl_Vertex);\n\
	Blur = clamp(abs(eyeVec.z - 10.0) / 60.0, 0.0, 1.0);\n\
	gl_FrontColor = gl_Color;\n\
	gl_BackColor = gl_Color;\n\
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n\
	gl_FogFragCoord = abs(eyeVec.z);\n\
	ShadowCoord = vec4(0.0);\n\
        vec4 clipVertex = gl_ModelViewMatrix*gl_Vertex;\n\
        for (int i = 0; i < 6; i++) {\n\
	    gl_ClipDistance[i] = dot(clipVertex, gl_ClipPlane[i]);\n\
	}\n\
	if (doshad == 1) {\n\
	   ShadowCoord = gl_TextureMatrix[7]*gl_Vertex;\n\
	   gl_FrontColor = gl_Color;\n\
	}\n\
}\n";

char fragment_shader_source0[] = "\
uniform int colmat;\n\
uniform int dofog;\n\
uniform int doblur;\n\
uniform int dossao;\n\
uniform int dotrns;\n\
uniform int doshad;\n\
uniform sampler2D ShadowMap;\n\
varying vec3 vertex_normal;\n\
varying vec3 eyeVec;\n\
varying float Blur;\n\
varying vec4 ShadowCoord;\n\
vec4 ShadowCoordPostW;\n\
\n\
float chebyshevUpperBound( float distance)\n\
{\n\
	vec2 moments = texture2D(ShadowMap,ShadowCoordPostW.xy).rg;\n\
	float lit = 0.0;\n\
\n\
	if (distance <= moments.x) return 1.0 ;\n\
\n\
	float E_x2 = moments.y;\n\
	float Ex_2 = moments.x*moments.x;\n\
	float vsmEps = 0.00003;\n\
	float litFactor = 0.0;\n\
	if (distance <= moments.x) {\n\
	   litFactor = 1.0;\n\
	}\n\
	float variance = min(max(E_x2-Ex_2,0.0)+vsmEps,1.0);\n\
	variance = max(variance,0.00002);\n\
\n\
	float d = (distance - moments.x)/distance;\n\
	//float p = variance / (variance + d*d);\n\
	float p = variance / (variance + 0.008*abs(d));\n\
        lit = max(p, float (distance <= moments.x));\n\
\n\
	//return smoothstep(0.2,1, max(litFactor,p));\n\
	return lit;\n\
}\n\
\n\
void main() {\n\
   vec3 lightDir = normalize(vec3(gl_LightSource[2].position));\n\
   vec3 eyeVecNormal = normalize(eyeVec);\n\
   vec3 reflectVec = normalize(-reflect(lightDir, vertex_normal));\n\
   vec3 vnorm = vertex_normal;\n\
   if (!gl_FrontFacing) {\n\
       vnorm.x = -1.0*vnorm.x;\n\
       vnorm.y = -1.0*vnorm.y;\n\
       vnorm.z = -1.0*vnorm.z;\n\
   }\n\
   vec4 diff = gl_LightSource[2].diffuse * max(dot(vnorm,lightDir),0.0);\n\
   vec4 specularf = gl_FrontMaterial.specular * pow(max(dot(reflectVec, eyeVecNormal), 0.0), gl_FrontMaterial.shininess);\n\
   vec4 specularb = vec4(0.0,0.0,0.0,0.0);\n\
\n\
   vec4 fcolor;\n\
   vec4 Colb;\n\
   vec4 Colf;\n\
   if (doshad == 1) {\n\
   ShadowCoordPostW = ShadowCoord / ShadowCoord.w;\n\
   ShadowCoordPostW.z += 0.00005;\n\
   }\n\
   float fogFactor = (gl_Fog.end-gl_FogFragCoord)*gl_Fog.scale;\n\
   if (colmat == 1) {\n\
	if (dossao == 1) {\n\
	   fcolor = gl_Color*(gl_LightSource[2].ambient+diff);\n\
	} else {\n\
	   fcolor = gl_Color*(gl_LightSource[2].ambient+diff+specularf);\n\
	}\n\
	if (dotrns == 1) {\n\
	   fcolor.w = 0.6;\n\
	} else {\n\
	   fcolor.w = gl_FrontMaterial.diffuse.w;\n\
	}\n\
   } else { \n\
	vec4 ambientf = gl_LightSource[2].ambient * gl_FrontMaterial.ambient;\n\
	vec4 diffusef = diff * gl_FrontMaterial.diffuse;\n\
	reflectVec = normalize(-reflect(lightDir, -vnorm));\n\
	vec4 ambientb = gl_LightSource[2].ambient * gl_BackMaterial.ambient;\n\
	specularb = gl_BackMaterial.specular * pow(max(dot(reflectVec, eyeVecNormal), 0.0), gl_BackMaterial.shininess);\n\
	vec4 diffuseb= gl_LightSource[2].diffuse * max(dot(-vnorm,lightDir),0.0) * gl_BackMaterial.diffuse;\n\
\n\
	if (dossao == 1) {\n\
	   //vec4 Colb = ambientb + specularb + diffuseb;\n\
	   //vec4 Colf = ambientf + specularf + diffusef;\n\
	   Colb = ambientb + diffuseb;\n\
	   Colf = ambientf + diffusef;\n\
	   fcolor = (Colb + Colf);\n\
	} else {\n\
	   Colb = ambientb + specularb + diffuseb;\n\
	   Colf = ambientf + specularf + diffusef;\n\
	   fcolor = (Colb + Colf);\n\
	}\n\
   } \n\
\n\
   float shadow = 1.0;\n\
   if (doshad == 1) {\n\
       shadow = chebyshevUpperBound(ShadowCoordPostW.z);\n\
       if (shadow < 0.5) shadow = 0.5;\n\
   }\n\
   gl_FragData[1] = vec4(shadow)*fcolor;\n\
   gl_FragData[2] = (specularb+specularf);\n\
\n\
   if (dofog == 1) {\n\
      fcolor = mix(gl_Fog.color, vec4(shadow)*fcolor, fogFactor);\n\
      gl_FragData[2].w = fogFactor;\n\
   }\n\
\n\
   gl_FragData[0] = vec4(shadow)*fcolor;\n\
\n\
   if (doblur == 1) {\n\
      gl_FragData[0].a = Blur;\n\
   }\n\
   \n\
}\n";

char vertex_shader_source1[] = "\
\n\
void main(void)\n\
{\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source1[] = "\
uniform sampler2D gdepth;\n\
uniform int dofog;\n\
uniform int Width;\n\
uniform int Height;\n\
uniform int ssaotyp;\n\
\n\
#define PI 3.14159265\n\
\n\
float near = 1.0; //Z-near\n\
float far = 600.0; //Z-far\n\
int samples;\n\
int rings;\n\
\n\
vec2 texCoord = gl_TexCoord[0].st;\n\
\n\
vec2 rand(in vec2 coord) {\n\
   float noiseX = (fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453));\n\
   float noiseY = (fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453));\n\
   if (ssaotyp == 1) {\n\
      return vec2(noiseX,noiseY)*0.0004;\n\
   } else {\n\
      return vec2(noiseX,noiseY)*0.004;\n\
   }\n\
}\n\
\n\
float LinearizeDepth(vec2 uv) {\n\
  float z = texture2D(gdepth, uv).x;\n\
  return (2.0 * near) / (far + near - z * (far - near));\n\
}\n\
\n\
float compareDepths( in float depth1, in float depth2 ) {\n\
   float aoCap = 1.0;\n\
   float aoMultiplier = 150.0;\n\
   float depthTolerance = 0.0000;\n\
   float aorange = 600.0;\n\
   float diff = sqrt(clamp(1.0-(depth1-depth2) / (aorange/(far-near)),0.0,1.0));\n\
   float ao = min(aoCap,max(0.0,depth1-depth2-depthTolerance) * aoMultiplier) * diff;\n\
   if (ssaotyp != 1) {\n\
	if (diff < 0.9) ao = 0.0;\n\
   }\n\
   return ao;\n\
}\n\
\n\
void main(void)\n\
{\n\
   float depth = LinearizeDepth(texCoord);\n\
   float d;\n\
   float aspect = float(Width)/float(Height);\n\
   vec2 noise = rand(texCoord);\n\
   float nmul = 1.0;\n\
   samples = 6;\n\
   rings = 6;\n\
   if (ssaotyp == 0) nmul = 20.0;\n\
   if (ssaotyp == 0) samples = 3;\n\
\n\
   float w = (1.0 / float(Width))/clamp(depth,0.05,1.0)+nmul*(noise.x*(1.0-noise.x));\n\
   float h = (1.0 / float(Height))/clamp(depth,0.05,1.0)+nmul*(noise.y*(1.0-noise.y));\n\
\n\
   float pw;\n\
   float ph;\n\
   float ao;\n\
   float s = 0.0;\n\
\n\
   for (int i = -rings ; i < rings; i += 1) {\n\
      for (int j = -samples ; j < samples; j += 1) {\n\
	float step = PI*2.0 / float(samples*i);\n\
	pw = (cos(float(j)*step)*float(i));\n\
	ph = (sin(float(j)*step)*float(i))*aspect;\n\
	d = LinearizeDepth(vec2(texCoord.s+pw*w,texCoord.t+ph*h));\n\
	ao += compareDepths(depth,d);\n\
	s += 1.0;\n\
      }\n\
   }\n\
\n\
   ao /= s;\n\
   ao = 1.0-ao;\n\
\n\
   gl_FragColor = vec4(ao,ao,ao,1.0);\n\
}\n";

char vertex_shader_source2[] = "\
void main(void)\n\
{\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source2[] = "\
uniform sampler2D Tex0;\n\
\n\
void main (void)\n\
{\n\
	gl_FragData[0] = texture2D(Tex0, gl_TexCoord[0].st);\n\
	//gl_FragData[0] = vec4(texture2D(Tex0, gl_TexCoord[0].st).rgb, Blur);\n\
}\n";

char vertex_shader_source3[] = "\
varying vec2 Tap[4], TapNeg[3];\n\
uniform int Width;\n\
\n\
void main(void)\n\
{\n\
	vec2 horzTapOffs[7];\n\
	vec2 TexCoord = gl_MultiTexCoord0.st;\n\
\n\
	float dx = 1.0/float(Width);\n\
	horzTapOffs[0] = vec2(0.0, 0.0);\n\
	horzTapOffs[1] = vec2(1.3366 * dx, 0.0);\n\
	horzTapOffs[2] = vec2(3.4295 * dx, 0.0);\n\
	horzTapOffs[3] = vec2(5.4264 * dx, 0.0);\n\
	horzTapOffs[4] = vec2(7.4359 * dx, 0.0);\n\
	horzTapOffs[5] = vec2(9.4436 * dx, 0.0);\n\
	horzTapOffs[6] = vec2(11.4401 * dx, 0.0);\n\
\n\
	Tap[0] = TexCoord;\n\
	Tap[1] = TexCoord + horzTapOffs[1];\n\
	Tap[2] = TexCoord + horzTapOffs[2];\n\
	Tap[3] = TexCoord + horzTapOffs[3];\n\
\n\
	TapNeg[0] = TexCoord - horzTapOffs[1];\n\
	TapNeg[1] = TexCoord - horzTapOffs[2];\n\
	TapNeg[2] = TexCoord - horzTapOffs[3];\n\
\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source3[] = "\
varying vec2 Tap[4], TapNeg[3];\n\
uniform sampler2D Tex0;\n\
uniform int Width;\n\
\n\
void main (void)\n\
{\n\
	vec2 horzTapOffs[7];\n\
	vec2 Tap4[3], TapNeg4[3];\n\
\n\
	// Thresholds for computing sample weights\n\
	const vec4 Thresh0 = vec4(0.1, 0.3, 0.5, -0.01);\n\
	const vec4 Thresh1 = vec4(0.6, 0.7, 0.8, 0.9);\n\
\n\
	// Samples\n\
	vec4 s[7], Weights4;\n\
	vec3 Weights3, ColorSum;\n\
	float WeightSum;\n\
\n\
	float dx = 1.0/float(Width);\n\
	horzTapOffs[0] = vec2(0.0, 0.0);\n\
	horzTapOffs[1] = vec2(1.3366 * dx, 0.0);\n\
 	horzTapOffs[2] = vec2(3.4295 * dx, 0.0);\n\
	horzTapOffs[3] = vec2(5.4264 * dx, 0.0);\n\
	horzTapOffs[4] = vec2(7.4359 * dx, 0.0);\n\
	horzTapOffs[5] = vec2(9.4436 * dx, 0.0);\n\
	horzTapOffs[6] = vec2(11.4401 * dx, 0.0);\n\
\n\
\n\
	// Sample taps with coordinates from VS\n\
	s[0] = texture2D(Tex0, Tap[0]);\n\
	s[1] = texture2D(Tex0, Tap[1]);\n\
	s[2] = texture2D(Tex0, Tap[2]);\n\
	s[3] = texture2D(Tex0, Tap[3]);\n\
	s[4] = texture2D(Tex0, TapNeg[0]);\n\
	s[5] = texture2D(Tex0, TapNeg[1]);\n\
	s[6] = texture2D(Tex0, TapNeg[2]);\n\
\n\
	// Compute weights for 4 first samples (including center tap)\n\
	// by thresholding blurriness (in sample alpha)\n\
	Weights4.x = clamp(s[1].a - Thresh0.x, 0.0, 1.0);\n\
	Weights4.y = clamp(s[2].a - Thresh0.y, 0.0, 1.0);\n\
	Weights4.z = clamp(s[3].a - Thresh0.x, 0.0, 1.0);\n\
	Weights4.w = clamp(s[0].a - Thresh0.w, 0.0, 1.0);\n\
\n\
	// Accumulate weighted samples\n\
	ColorSum = vec3(s[0] * Weights4.x + s[1] * Weights4.y + s[2] * Weights4.z + s[3] * Weights4.w);\n\
\n\
	// Sum weights using DOT\n\
	WeightSum = dot(Weights4, vec4(1.0));\n\
\n\
	// Compute weights for 3 remaining samples\n\
	Weights3.x = clamp(s[4].a - Thresh0.x, 0.0, 1.0);\n\
	Weights3.y = clamp(s[5].a - Thresh0.y, 0.0, 1.0);\n\
	Weights3.z = clamp(s[6].a - Thresh0.z, 0.0, 1.0);\n\
\n\
	// Accumulate weighted samples\n\
	ColorSum += vec3(s[4] * Weights3.x + s[4] * Weights3.y + s[6] * Weights3.z);\n\
\n\
	// Sum weights using DOT\n\
	WeightSum += dot(Weights3, vec3(1.0));\n\
\n\
	// Compute tex coords for other taps\n\
	Tap4[0] = Tap[0] + horzTapOffs[4];\n\
	Tap4[1] = Tap[0] + horzTapOffs[5];\n\
	Tap4[2] = Tap[0] + horzTapOffs[6];\n\
	TapNeg4[0] = Tap[0] - horzTapOffs[4];\n\
	TapNeg4[1] = Tap[0] - horzTapOffs[5];\n\
	TapNeg4[2] = Tap[0] - horzTapOffs[6];\n\
\n\
	// Sample the taps\n\
	s[0] = texture2D(Tex0, Tap4[0]);\n\
	s[1] = texture2D(Tex0, Tap4[1]);\n\
	s[2] = texture2D(Tex0, Tap4[2]);\n\
	s[3] = texture2D(Tex0, TapNeg4[0]);\n\
	s[4] = texture2D(Tex0, TapNeg4[1]);\n\
	s[5] = texture2D(Tex0, TapNeg4[2]);\n\
\n\
	// Compute weights for 3 samples\n\
	Weights3.x = clamp(s[0].a - Thresh1.x, 0.0, 1.0);\n\
	Weights3.y = clamp(s[1].a - Thresh1.y, 0.0, 1.0);\n\
	Weights3.z = clamp(s[2].a - Thresh1.z, 0.0, 1.0);\n\
	\n\
	// Accumulate weighted samples\n\
	ColorSum += vec3(s[0] * Weights3.x + s[1] * Weights3.y + s[2] * Weights3.z);\n\
\n\
	// Sum weights using DOT\n\
	WeightSum += dot(Weights3, vec3(1.0));\n\
\n\
	// Compute weights for 3 samples\n\
	Weights3.x = clamp(s[3].a - Thresh1.x, 0.0, 1.0);\n\
	Weights3.y = clamp(s[4].a - Thresh1.y, 0.0, 1.0);\n\
	Weights3.z = clamp(s[5].a - Thresh1.z, 0.0, 1.0);\n\
\n\
	// Accumulate weighted samples\n\
	ColorSum += vec3(s[3] * Weights3.x + s[4] * Weights3.y + s[5] * Weights3.z);\n\
\n\
	// Sum weights using DOT\n\
	WeightSum += dot(Weights3, vec3(1.0));\n\
\n\
	// Divide weighted sum of samples by sum of all weights\n\
	ColorSum /= WeightSum;\n\
	WeightSum = clamp(WeightSum,0.0,1.0);\n\
\n\
	// Color and weights sum output\n\
	gl_FragData[0] = vec4(ColorSum, WeightSum);\n\
}\n";

char vertex_shader_source4[] = "\
varying vec2 Tap[4], TapNeg[3];\n\
uniform int Height;\n\
\n\
void main(void)\n\
{\n\
	vec2 vertTapOffs[7];\n\
	vec2 TexCoord = gl_MultiTexCoord0.st;\n\
\n\
	float dy = 1.0/float(Height);\n\
	vertTapOffs[0] = vec2(0.0, 0.0);\n\
	vertTapOffs[1] = vec2(0.0, 1.3366 * dy);\n\
	vertTapOffs[2] = vec2(0.0, 3.4295 * dy);\n\
	vertTapOffs[3] = vec2(0.0, 5.4264 * dy);\n\
	vertTapOffs[4] = vec2(0.0, 7.4359 * dy);\n\
	vertTapOffs[5] = vec2(0.0, 9.4436 * dy);\n\
	vertTapOffs[6] = vec2(0.0, 11.4401 * dy);\n\
\n\
	Tap[0] = TexCoord;\n\
	Tap[1] = TexCoord + vertTapOffs[1];\n\
	Tap[2] = TexCoord + vertTapOffs[2];\n\
	Tap[3] = TexCoord + vertTapOffs[3];\n\
\n\
	TapNeg[0] = TexCoord - vertTapOffs[1];\n\
	TapNeg[1] = TexCoord - vertTapOffs[2];\n\
	TapNeg[2] = TexCoord - vertTapOffs[3];\n\
\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source4[] = "\
varying vec2 Tap[4], TapNeg[3];\n\
uniform sampler2D Tex0;\n\
uniform int Height;\n\
\n\
void main (void)\n\
{\n\
	vec2 vertTapOffs[7];\n\
	vec2 Tap4[3], TapNeg4[3];\n\
\n\
	const vec4 Weights0 = vec4(0.080, 0.075, 0.070, 0.100);\n\
	const vec4 Weights1 = vec4(0.065, 0.060, 0.055, 0.050);\n\
\n\
	// Samples\n\
	vec4 s[7];\n\
	// Acumulated color and weights\n\
	vec4 ColorWeightSum;\n\
\n\
	float dy = 1.0/float(Height);\n\
	vertTapOffs[0] = vec2(0.0, 0.0);\n\
	vertTapOffs[1] = vec2(0.0, 1.3366 * dy);\n\
	vertTapOffs[2] = vec2(0.0, 3.4295 * dy);\n\
	vertTapOffs[3] = vec2(0.0, 5.4264 * dy);\n\
	vertTapOffs[4] = vec2(0.0, 7.4359 * dy);\n\
	vertTapOffs[5] = vec2(0.0, 9.4436 * dy);\n\
	vertTapOffs[6] = vec2(0.0, 11.4401 * dy);\n\
\n\
\n\
	// Sample taps with coordinates from VS\n\
	s[0] = texture2D(Tex0, Tap[0]);\n\
	s[1] = texture2D(Tex0, Tap[1]);\n\
	s[2] = texture2D(Tex0, Tap[2]);\n\
	s[3] = texture2D(Tex0, Tap[3]);\n\
	s[4] = texture2D(Tex0, TapNeg[0]);\n\
	s[5] = texture2D(Tex0, TapNeg[1]);\n\
	s[6] = texture2D(Tex0, TapNeg[2]);\n\
\n\
	// Modulate sampled color values by the weights stored\n\
	// in the alpha channel of each sample\n\
	s[0].rgb = s[0].rgb * s[0].a;\n\
	s[1].rgb = s[1].rgb * s[1].a;\n\
	s[2].rgb = s[2].rgb * s[2].a;\n\
	s[3].rgb = s[3].rgb * s[3].a;\n\
	s[4].rgb = s[4].rgb * s[4].a;\n\
	s[5].rgb = s[5].rgb * s[5].a;\n\
	s[6].rgb = s[6].rgb * s[6].a;\n\
\n\
	// Aggregate all samples weighting them with pre-defined\n\
	// kernel weights, weight sum in alpha\n\
	ColorWeightSum = s[0] * Weights0.w +\n\
      (s[1] + s[4]) * Weights0.x +\n\
      (s[2] + s[5]) * Weights0.y +\n\
      (s[3] + s[6]) * Weights0.z;\n\
\n\
	// Compute tex coords for other taps\n\
	Tap4[0] = Tap[0] + vertTapOffs[4];\n\
	Tap4[1] = Tap[0] + vertTapOffs[5];\n\
	Tap4[2] = Tap[0] + vertTapOffs[6];\n\
	TapNeg4[0] = Tap[0] - vertTapOffs[4];\n\
	TapNeg4[1] = Tap[0] - vertTapOffs[5];\n\
	TapNeg4[2] = Tap[0] - vertTapOffs[6];\n\
\n\
	// Sample the taps\n\
	s[0] = texture2D(Tex0, Tap4[0]);\n\
	s[1] = texture2D(Tex0, Tap4[1]);\n\
	s[2] = texture2D(Tex0, Tap4[2]);\n\
	s[3] = texture2D(Tex0, TapNeg4[0]);\n\
	s[4] = texture2D(Tex0, TapNeg4[1]);\n\
	s[5] = texture2D(Tex0, TapNeg4[2]);\n\
\n\
	// Modulate sampled color values by the weights stored\n\
	// in the alpha channel of each sample\n\
	s[0].rgb = s[0].rgb * s[0].a;\n\
	s[1].rgb = s[1].rgb * s[1].a;\n\
	s[2].rgb = s[2].rgb * s[2].a;\n\
	s[3].rgb = s[3].rgb * s[3].a;\n\
	s[4].rgb = s[4].rgb * s[4].a;\n\
	s[5].rgb = s[5].rgb * s[5].a;\n\
\n\
	 // Aggregate all samples weighting them with pre-defined\n\
	// kernel weights, weight sum in alpha\n\
	ColorWeightSum += (s[1] + s[3]) * Weights1.x +\n\
      (s[1] + s[4]) * Weights1.y +\n\
      (s[2] + s[5]) * Weights1.z;\n\
\n\
	// Average combined sample for all samples in the kernel\n\
	ColorWeightSum.rgb /= ColorWeightSum.a;\n\
\n\
	// Final sum output\n\
	gl_FragData[0] = ColorWeightSum;\n\
}\n";

char vertex_shader_source5[] = "\
void main(void)\n\
{\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
	gl_TexCoord[1] = gl_MultiTexCoord1;\n\
}\n";

char fragment_shader_source5[] = "\
uniform sampler2D Tex0, Tex1;\n\
\n\
void main (void)\n\
{\n\
	vec4 Fullres = texture2D(Tex0, gl_TexCoord[0].st);\n\
	vec4 Blurred = texture2D(Tex1, gl_TexCoord[1].st);\n\
\n\
	// HLSL linear interpolation function\n\
	gl_FragData[0] = Fullres + Fullres.a * (Blurred - Fullres);\n\
}\n";


char vertex_shader_source6[] = "\
void main(void)\n\
{\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source6[] = "\
uniform sampler2D Tex0;\n\
\n\
void main (void)\n\
{\n\
	vec4 colorMap = texture2D(Tex0, gl_TexCoord[0].st);\n\
	gl_FragColor = colorMap;\n\
}\n";

char vertex_shader_source7[] = "\
\n\
varying vec4 v_position;\n\
void main(void)\n\
{\n\
	gl_Position = ftransform();\n\
	v_position = gl_Position;\n\
	gl_TexCoord[0] = gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source7[] = "\
uniform sampler2D gnormals;\n\
uniform sampler2D gdepth;\n\
uniform sampler2D gdiffuse;\n\
uniform sampler2D grandom;\n\
\n\
float LinearizeDepth(vec2 uv) {\n\
  float n = 1.0;\n\
  float f = 100.0;\n\
  float z = texture2D(gdepth, uv).x;\n\
  return (2.0 * n) / (f + n - z * (f - n));\n\
}\n\
\n\
vec3 readNormal(vec2 coord) {\n\
   vec3 v1 = vec3(1.0);\n\
   vec3 vout = normalize(texture2D(gnormals, coord).stp*2.0  - v1);  \n\
   return vout;\n\
}\n\
\n\
vec3 posFromDepth(vec2 coord) {\n\
   float d = texture2D(gdepth, coord).r;\n\
   vec3 tray = vec3(gl_ProjectionMatrixInverse*\n\
	vec4((coord.x-0.5)*2.0,(coord.y-0.5)*2.0,1.0,0.0));\n\
   return tray*d;\n\
}\n\
\n\
//Ambient Occlusion form factor:    \n\
\n\
float aoFF(in vec3 ddiff,in vec3 cnorm, in float c1, in float c2) {\n\
   vec3 vv = normalize(ddiff);\n\
   float rd = length(ddiff);\n\
   return (1.0-\n\
	clamp(dot(readNormal(gl_TexCoord[0].st+vec2(c1,c2)),-vv),0.0,1.0)) *\n\
	clamp(dot(cnorm,vv),0.0,1.0)*(1.0 - 1.0/sqrt(1.0/(rd*rd) + 1.0));\n\
}\n\
\n\
//GI form factor:    \n\
\n\
float giFF(vec3 ddiff, vec3 cnorm, float c1, float c2) {\n\
   vec3 vv = normalize(ddiff);\n\
   float rd = length(ddiff);\n\
   return 1.0*\n\
	clamp(dot(readNormal(gl_TexCoord[0].st+vec2(c1,c2)),-vv),0.0,1.0)*\n\
	clamp(dot(cnorm,vv),0.0,1.0)/ (rd*rd+1.0);\n\
}\n\
\n\
void main() {\n\
\n\
    //read current normal,position and color.\n\
\n\
    vec3 n = readNormal(gl_TexCoord[0].st);\n\
    vec3 p = posFromDepth(gl_TexCoord[0].st);\n\
    vec3 col = vec3(texture2D(gdiffuse, gl_TexCoord[0].st));\n\
\n\
    //randomization texture\n\
\n\
    vec2 fres = vec2(800.0/64.0*5.0,800.0/64.0*5.0);\n\
    vec3 random = vec3(texture2D(grandom, gl_TexCoord[0].st*fres.xy));\n\
    random = random*2.0-vec3(1.0);\n\
\n\
    //initialize variables:\n\
\n\
    float ao = 0.0;\n\
    vec3 gi = vec3(0.0,0.0,0.0);\n\
    float incx = 1.0/800.0*0.1;\n\
    float incy = 1.0/800.0*0.1;\n\
    float pw = incx;\n\
    float ph = incy;\n\
    float cdepth = LinearizeDepth(gl_TexCoord[0].st);\n\
\n\
    for (float i=0.0; i<3.0; ++i) {\n\
\n\
       float npw = (pw+0.0007*random.x)/cdepth;\n\
       float nph = (ph+0.0007*random.y)/cdepth;\n\
\n\
       vec3 ddiff  = posFromDepth(gl_TexCoord[0].st+vec2(npw,nph))-p;\n\
       vec3 ddiff2 = posFromDepth(gl_TexCoord[0].st+vec2(npw,-nph))-p;\n\
       vec3 ddiff3 = posFromDepth(gl_TexCoord[0].st+vec2(-npw,nph))-p;\n\
       vec3 ddiff4 = posFromDepth(gl_TexCoord[0].st+vec2(-npw,-nph))-p;\n\
       vec3 ddiff5 = posFromDepth(gl_TexCoord[0].st+vec2(0.0,nph))-p;\n\
       vec3 ddiff6 = posFromDepth(gl_TexCoord[0].st+vec2(0.0,-nph))-p;\n\
       vec3 ddiff7 = posFromDepth(gl_TexCoord[0].st+vec2(npw,0.0))-p;\n\
       vec3 ddiff8 = posFromDepth(gl_TexCoord[0].st+vec2(-npw,0.0))-p;\n\
\n\
       ao+=  aoFF(ddiff ,n,npw,nph);\n\
       ao+=  aoFF(ddiff2,n,npw,-nph);\n\
       ao+=  aoFF(ddiff3,n,-npw,nph);\n\
       ao+=  aoFF(ddiff4,n,-npw,-nph);\n\
       ao+=  aoFF(ddiff5,n,0.0,nph);\n\
       ao+=  aoFF(ddiff6,n,0.0,-nph);\n\
       ao+=  aoFF(ddiff7,n,npw,0.0);\n\
       ao+=  aoFF(ddiff8,n,-npw,0.0);\n\
\n\
       gi+=  giFF(ddiff,n,npw,nph)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(npw,nph)).rgb;\n\
       gi+=  giFF(ddiff2,n,npw,-nph)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(npw,-nph)).rgb;\n\
       gi+=  giFF(ddiff3,n,-npw,nph)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(-npw,nph)).rgb;\n\
       gi+=  giFF(ddiff4,n,-npw,-nph)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(-npw,-nph)).rgb;\n\
       gi+=  giFF(ddiff5,n,0.0,nph)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(0.0,nph)).rgb;\n\
       gi+=  giFF(ddiff6,n,0.0,-nph)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(0.0,-nph)).rgb;\n\
       gi+=  giFF(ddiff7,n,npw,0.0)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(npw,0.0)).rgb;\n\
       gi+=  giFF(ddiff8,n,-npw,0.0)*\n\
		texture2D(gdiffuse, gl_TexCoord[0].st+vec2(-npw,0.0)).rgb;\n\
\n\
       //increase sampling area:\n\
\n\
       pw += incx;\n\
       ph += incy;\n\
    }\n\
    ao/=24.0;\n\
    gi/=24.0;\n\
\n\
    //gl_FragColor = vec4(col-vec3(ao)+gi*5.0,1.0);\n\
    gl_FragColor = vec4(col-vec3(ao),1.0);\n\
}\n";

char fragment_shader_source8[] = "\
uniform sampler2D sampler0;\n\
uniform int width;\n\
uniform int height;\n\
\n\
void main(void)\n\
{\n\
    vec2 tc_offset[9];\n\
    vec4 sample[9];\n\
    float xinc,yinc;\n\
\n\
    xinc = 1.0/float(width);\n\
    yinc = 1.0/float(height);\n\
    for (int i = 0; i < 2; i++) {\n\
	for (int j = 0; j < 2; j++) {\n\
	   tc_offset[(i*3)+j] = \n\
		vec2((float(i)-1.0)*xinc,(float(j)-1.0)*yinc);\n\
	}\n\
    }\n\
    for (int i = 0; i < 9; i++) {\n\
        sample[i] = texture2D(sampler0,\n\
                              gl_TexCoord[0].st + tc_offset[i]);\n\
    }\n\
\n\
    gl_FragColor = (sample[0] + (2.0*sample[1]) + sample[2] + \n\
                    (2.0*sample[3]) + sample[4] + (2.0*sample[5]) + \n\
                    sample[6] + (2.0*sample[7]) + sample[8]) / 13.0;\n\
}\n";

char fragment_shader_source9[] = "\
uniform sampler2D gcolor;\n\
uniform sampler2D glum;\n\
uniform sampler2D aotex;\n\
uniform int dofog;\n\
vec2 texCoord = gl_TexCoord[0].st;\n\
void main(void)\n\
{\n\
   float fogFactor = texture2D(glum,texCoord).w;\n\
   vec3 color = texture2D(gcolor,texCoord).rgb;\n\
   vec3 luminance = texture2D(glum,texCoord).rgb;\n\
   vec3 ao = texture2D(aotex,texCoord).rgb;\n\
   vec4 fcolor = vec4(color*ao+luminance,1.0);\n\
   if (dofog == 1) {\n\
	fcolor = mix(gl_Fog.color, fcolor, fogFactor);\n\
   }\n\
   gl_FragColor = fcolor;\n\
}\n";

char vertex_shader_source10[] = "\
varying vec4 ShadowCoord;\n\
\n\
void main()\n\
{\n\
        ShadowCoord = gl_TextureMatrix[7] * gl_Vertex;\n\
        gl_Position = ftransform();\n\
        gl_FrontColor = gl_Color;\n\
}\n";

char fragment_shader_source10[] = "\
uniform sampler2D ShadowMap;\n\
varying vec4 ShadowCoord;\n\
vec4 ShadowCoordPostW;\n\
\n\
float chebyshevUpperBound( float distance)\n\
{\n\
	vec2 moments = texture2D(ShadowMap,ShadowCoordPostW.xy).rg;\n\
	float lit = 0.0;\n\
\n\
	if (distance <= moments.x) return 1.0 ;\n\
\n\
	float variance = moments.y - (moments.x*moments.x);\n\
	//variance = max(variance,0.00002);\n\
	variance = max(variance,0.02);\n\
\n\
	float d = distance - moments.x;\n\
	float p_max = variance / (variance + d*d);\n\
        lit = max(p_max, float (distance <= moments.x));\n\
\n\
	return lit;\n\
}\n\
\n\
void main()\n\
{\n\
	ShadowCoordPostW = ShadowCoord / ShadowCoord.w;\n\
	float shadow = chebyshevUpperBound(ShadowCoordPostW.z);\n\
	gl_FragColor = vec4(shadow ) *gl_Color;\n\
}\n";

char vertex_shader_source11[] = "\
varying vec4 v_position;\n\
\n\
void main()\n\
{\n\
	gl_Position = ftransform();\n\
	v_position = gl_Position;\n\
}\n";

char fragment_shader_source11[] = "\
varying vec4 v_position;\n\
\n\
void main()\n\
{\n\
	float depth = v_position.z / v_position.w;\n\
	depth = depth * 0.5 + 0.5;\n\
	float moment1 = depth;\n\
	float moment2 = depth * depth;\n\
	float dx = dFdx(depth);\n\
	float dy = dFdy(depth);\n\
	moment2 += 0.25*(dx*dx+dy*dy);\n\
	//moment2 += (dx*dx+dy*dy);\n\
\n\
	gl_FragColor = vec4( moment1,moment2, 0.0, 0.0 );\n\
}\n";

char vertex_shader_source12[] = "\
\n\
void main()\n\
{\n\
	gl_Position = ftransform();\n\
	gl_TexCoord[0] =  gl_MultiTexCoord0;\n\
}\n";

char fragment_shader_source12[] = "\
uniform int width;\n\
uniform int height;\n\
uniform sampler2D tex;\n\
\n\
void main()\n\
{\n\
	vec4 color = vec4(0.0);\n\
	float scx = 1.0 / float(width);\n\
	float scy = 1.0 / float(height);\n\
\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(-3.0*scx,-3.0*scy)) * 0.015625;\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(-2.0*scx,-2.0*scy))*0.09375;\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(-1.0*scx,-1.0*scy))*0.234375;\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(0.0 , 0.0) )*0.3125;\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(1.0*scx,1.0*scy))*0.234375;\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(2.0*scx,2.0*scy))*0.09375;\n\
	color += texture2D(tex, gl_TexCoord[0].st + vec2(3.0*scx,-3.0*scy)) * 0.015625;\n\
\n\
	gl_FragColor = color;\n\
}\n";

char *vert_shader[NUM_PROG] = {vertex_shader_source0,vertex_shader_source1,vertex_shader_source2,vertex_shader_source3,vertex_shader_source4,vertex_shader_source5,vertex_shader_source6,vertex_shader_source7,vertex_shader_source7,vertex_shader_source7,vertex_shader_source10,vertex_shader_source11,vertex_shader_source12};
char *v_shader[NUM_PROG] = {vertex_shader_source0b,vertex_shader_source1,vertex_shader_source2,vertex_shader_source3,vertex_shader_source4,vertex_shader_source5,vertex_shader_source6,vertex_shader_source7,vertex_shader_source7,vertex_shader_source7,vertex_shader_source10,vertex_shader_source11,vertex_shader_source12};

char *frag_shader[NUM_PROG] = {fragment_shader_source0,fragment_shader_source1,fragment_shader_source2,fragment_shader_source3,fragment_shader_source4,fragment_shader_source5,fragment_shader_source6,fragment_shader_source7,fragment_shader_source8,fragment_shader_source9,fragment_shader_source10,fragment_shader_source11,fragment_shader_source12};

#ifdef GL_ARB_shader_objects
void printInfoLog(GLhandleARB obj)
	{
	    int infologLength = 0;
	    int charsWritten = 0;
	    int status;
	    char *infoLog;
	
	    glGetObjectParameterivARB(obj, GL_OBJECT_COMPILE_STATUS_ARB,&status);
	    //printf(" compile status %d\n",status);
	    glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB,
						 &infologLength);


	    if (infologLength > 0) {
	
		infoLog = (char *) malloc(sizeof(char)*infologLength);


		glGetInfoLogARB(obj, infologLength, &charsWritten, infoLog);

		//printf("%s\n",infoLog);
		free(infoLog);
	    }
	}
#endif

GLint rndid;
GLint colmat;
GLint DoShadLoc;
GLint dofog;
GLint dofog2;
GLint dofog3;
GLint doblur;
GLint dossao;
GLint dotrns;
#ifdef GL_COLOR_ATTACHMENT0_EXT
GLenum buffers[] = { GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_COLOR_ATTACHMENT2_EXT};
#endif

#ifdef GL_ARB_shader_objects
int load_shader(GLenum *program, int prg)
{

	program[prg] = glCreateProgramObjectARB();
	vertex_shader[prg] = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
	fragment_shader[prg] = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

	glShaderSourceARB(fragment_shader[prg], 1, &frag_shader[prg], NULL);
	glShaderSourceARB(vertex_shader[prg], 1, &vert_shader[prg], NULL);
	if (DoIntel && prg == 0) {
	   glShaderSourceARB(vertex_shader[prg], 1, &v_shader[prg], NULL);
	}

	glCompileShaderARB(vertex_shader[prg]);
	printInfoLog((GLhandleARB) vertex_shader[prg]);
	glCompileShaderARB(fragment_shader[prg]);
	printInfoLog((GLhandleARB) fragment_shader[prg]);

	glAttachObjectARB(program[prg], vertex_shader[prg]);
	glAttachObjectARB(program[prg], fragment_shader[prg]);

	glLinkProgramARB(program[prg]);
}

void del_shader()
{
    int i;

    for (i = 0; i < NUM_PROG; i++) {
	glDeleteObjectARB(vertex_shader[i]);
	glDeleteObjectARB(fragment_shader[i]);
	glDeleteObjectARB(program[i]);
    }
}

int check_shader(const char *ext)
{
   GLint loc;

   if (!ext || !ext[0]) return 0;

   if (strstr(ext,"GL_ARB_vertex_shader") 
	&& strstr(ext,"GL_ARB_fragment_shader")) {

	load_shader(program,0);
	load_shader(program,1);
	load_shader(program,2);
	load_shader(program,3);
	load_shader(program,4);
	load_shader(program,5);
	load_shader(program,6);
	load_shader(program,7);
	load_shader(program,8);
	load_shader(program,9);
	load_shader(program,10);
	load_shader(program,11);
	load_shader(program,12);

/* passing Uniforms */

	glUseProgramObjectARB(program[0]);

	colmat   = glGetUniformLocationARB(program[0], "colmat");
	dofog    = glGetUniformLocationARB(program[0], "dofog");
	doblur   = glGetUniformLocationARB(program[0], "doblur");
	dossao   = glGetUniformLocationARB(program[0], "dossao");
	dotrns   = glGetUniformLocationARB(program[0], "dotrns");
	DoShadLoc   = glGetUniformLocationARB(program[0], "doshad");
	loc      = glGetUniformLocationARB(program[0], "ShadowMap");
	glUniform1iARB(loc, 7);

	glUniform1iARB(colmat, 0);
	glUniform1iARB(dofog, 0);
	glUniform1iARB(doblur, 0);
	glUniform1iARB(dossao, 0);
	glUniform1iARB(dotrns, 0);
	glUniform1iARB(DoShadLoc, 0);

	glUseProgramObjectARB(program[1]);

	loc    = glGetUniformLocationARB(program[1], "gdepth");
	glUniform1iARB(loc, 0);
	dofog2 = glGetUniformLocationARB(program[1], "dofog");
	glUniform1iARB(dofog2, 0);
	loc    = glGetUniformLocationARB(program[1], "Width");
	glUniform1iARB(loc, width);
	loc    = glGetUniformLocationARB(program[1], "Height");
	glUniform1iARB(loc, height);
	loc    = glGetUniformLocationARB(program[1], "ssaotyp");
	glUniform1iARB(loc, SSAO_type);

	glUseProgramObjectARB(program[3]);
	loc   = glGetUniformLocationARB(program[3], "Width");
	glUniform1iARB(loc, width*2);

	glUseProgramObjectARB(program[4]);
	loc   = glGetUniformLocationARB(program[4], "Height");
	glUniform1iARB(loc, height*2);

	glUseProgramObjectARB(program[5]);
	loc   = glGetUniformLocationARB(program[5], "Tex0");
	glUniform1iARB(loc, 0);
	loc   = glGetUniformLocationARB(program[5], "Tex1");
	glUniform1iARB(loc, 1);

	glUseProgramObjectARB(program[6]);
	loc   = glGetUniformLocationARB(program[6], "Tex0");
	glUniform1iARB(loc, 0);

	glUseProgramObjectARB(program[8]);
	loc   = glGetUniformLocationARB(program[8], "width");
	glUniform1iARB(loc, width);
	loc   = glGetUniformLocationARB(program[8], "height");
	glUniform1iARB(loc, height);

	glUseProgramObjectARB(program[9]);
	loc    = glGetUniformLocationARB(program[9], "gcolor");
	glUniform1iARB(loc, 0);
	loc    = glGetUniformLocationARB(program[9], "glum");
	glUniform1iARB(loc, 1);
	loc    = glGetUniformLocationARB(program[9], "aotex");
	glUniform1iARB(loc, 2);
	dofog3 = glGetUniformLocationARB(program[9], "dofog");
	glUniform1iARB(dofog3, 0);

	glUseProgramObjectARB(program[10]);
	loc    = glGetUniformLocationARB(program[10], "ShadowMap");
	glUniform1iARB(loc, 7);

	glUseProgramObjectARB(program[8]);

	loc   = glGetUniformLocationARB(program[8], "width");
	glUniform1iARB(loc, width);
	loc   = glGetUniformLocationARB(program[8], "height");
	glUniform1iARB(loc, height);

	glUseProgramObjectARB(program[9]);
	loc    = glGetUniformLocationARB(program[9], "tex");
	glUniform1iARB(loc, 7);

	glUseProgramObjectARB(0);

	return(1);
   }

   return(0);
}
#endif

#ifdef GL_COLOR_ATTACHMENT0_EXT
int init_fbo(struct FBO *fbo,int fbo_type,const char *ext)
{
   int i,maxColorBuffers,maxBuffers;
   GLenum status;

   if (!ext || !ext[0]) return(0);

   if (strstr(ext,"GL_EXT_framebuffer_object") &&
	strstr(ext,"GL_ARB_texture_float")) {

	glGetIntegerv( GL_MAX_COLOR_ATTACHMENTS_EXT, &maxColorBuffers );
	if (maxColorBuffers < 4) return(0);

#if defined(GL_ARB_draw_buffers)
	glGetIntegerv( GL_MAX_DRAW_BUFFERS, &maxBuffers );
	if (maxBuffers < NUM_FBOS || maxBuffers <= 0) {
	    fprintf(stderr,"maxBuffers %d < NUM_FBOS %d\n",maxBuffers,NUM_FBOS);
	    return(0);
	}
#else
	return(0);
#endif

	glGenFramebuffersEXT(1, &(fbo->frame[0]));
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo->frame[0]);

	glGenRenderbuffersEXT(1, &(fbo->depth[0]));
	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, fbo->depth[0]);
	//glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24,
	//	width, height);
	glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT,
		width, height);
	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, 
					GL_DEPTH_ATTACHMENT_EXT,
					GL_RENDERBUFFER_EXT,fbo->depth[0]);

	glGenTextures(1, &fbo->texid[0]);
	glBindTexture(GL_TEXTURE_2D, fbo->texid[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type,  
		width, height, 0,
		GL_RGBA, GL_FLOAT, NULL);
	if (DoMIPMAP) glGenerateMipmapEXT(GL_TEXTURE_2D);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, 
			GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
			GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );
	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
		GL_TEXTURE_2D, fbo->texid[0], 0);

	glGenTextures(1, &fbo->texid1[0]);
	glBindTexture(GL_TEXTURE_2D, fbo->texid1[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type,  
		width, height, 0,
		GL_RGBA, GL_FLOAT, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT,
		GL_TEXTURE_2D, fbo->texid1[0], 0);

	glGenTextures(1, &fbo->texid2[0]);
	glBindTexture(GL_TEXTURE_2D, fbo->texid2[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type,  
		width, height, 0,
		GL_RGBA, GL_FLOAT, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT2_EXT,
		GL_TEXTURE_2D, fbo->texid2[0], 0);

	glGenTextures(1, &fbo->texid3[0]);
	glBindTexture(GL_TEXTURE_2D, fbo->texid3[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24,  
		width, height, 0,
		GL_DEPTH_COMPONENT, GL_FLOAT, NULL);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );
	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
		GL_TEXTURE_2D, fbo->texid3[0], 0);

	status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
	if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
		/*printf("FBO[0] Error: 0x%x\n", status);*/
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
		return(0);
	}

	for (i = 1; i < NUM_FBOS; i++) {
		glGenFramebuffersEXT(1, &(fbo->frame[i]));
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo->frame[i]);

		glGenTextures(1, &fbo->texid[i]);

		glBindTexture(GL_TEXTURE_2D, fbo->texid[i]);
		glTexImage2D(GL_TEXTURE_2D, 0, fbo_type, 
			width, height, 
			0, GL_RGBA, GL_FLOAT, NULL);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
		glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );

		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, 
		  GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, fbo->texid[i], 0);

		status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
		if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
			/*printf("FBO[%d] Error: 0x%x\n", i, status);*/
			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
			return(0);
		}
	}

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	return(1);
   }
   return(0);
}

void del_fbo(struct FBO *fbo)
{
  int i;

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
  glDeleteRenderbuffersEXT(1, &(fbo->depth[0]));
  glDeleteTextures(1, &fbo->texid1[0]);
  glDeleteTextures(1, &fbo->texid2[0]);
  glDeleteTextures(1, &fbo->texid3[0]);

  for (i = 0; i < NUM_FBOS; i++) {
	glDeleteTextures(1, &fbo->texid[i]);
	glDeleteFramebuffersEXT(1, &(fbo->frame[i]));
  }
   
}
#endif

void DoQuad()
{
  glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f);
	glVertex2d(-1, -1);
	glTexCoord2f(1.0f, 0.0f);
	glVertex2d(1, -1);
	glTexCoord2f( 1.0f, 1.0f);
	glVertex2d(1, 1);
	glTexCoord2f(0.0f, 1.0f);
	glVertex2d(-1, 1);
  glEnd();
}

void DoQuad2()
{
  glBegin(GL_QUADS);
	glTexCoord2d(0,0);
	glVertex2f(-width/2,-height/2);
	glTexCoord2d(1,0);
	glVertex2f( width/2,-height/2);
	glTexCoord2d(1,1);
	glVertex2f( width/2, height/2);
	glTexCoord2d(0,1);
	glVertex2f(-width/2, height/2);
  glEnd();
}

void setupMatrices(pos_x,pos_y,pos_z,lookx,looky,lookz)
float pos_x;
float pos_y;
float pos_z;
float lookx;
float looky;
float lookz;
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (*persp) {
	   glFrustum(-0.2*Aspect,0.2*Aspect,-0.2,0.2,0.3,600.0);
	} else {
	   glOrtho(1.0*Aspect,-1.0*Aspect,1.0,-1.0,-10.0,300.0);
	}
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(pos_x,pos_y,pos_z,
		  0.0,0.0,0.0,0.0,1.0,0.0);
}

void blurShadowMap()
{
	GLint loc;

#ifdef GL_COLOR_ATTACHMENT0_EXT
        glDepthMask(GL_FALSE);
        glDisable(GL_DEPTH_TEST);

        glPushMatrix();
        glLoadIdentity();
        glMatrixMode(GL_PROJECTION);
        glPushMatrix();
        glLoadIdentity();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,fbo.frame[1]);	
	glUseProgramObjectARB(program[12]);
	loc   = glGetUniformLocationARB(program[12], "width");
	glUniform1iARB(loc, width);
	loc   = glGetUniformLocationARB(program[12], "height");
	glUniform1iARB(loc, 0);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D,fbo.texid[0]);

	DoQuad();
		
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,fbo.frame[0]);	
	loc   = glGetUniformLocationARB(program[12], "width");
	glUniform1iARB(loc, 0);
	loc   = glGetUniformLocationARB(program[12], "height");
	glUniform1iARB(loc, height);

	glBindTexture(GL_TEXTURE_2D,fbo.texid[1]);

	DoQuad();
		
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
#endif
}

void DepthBlur()
{
	GLint loc;

#ifdef GL_COLOR_ATTACHMENT0_EXT

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[2]);
	glDrawBuffers(1,buffers);
	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, fbo.texid[0]);
	glUseProgramObjectARB(program[2]);

	DoQuad();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[3]);
	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glBindTexture(GL_TEXTURE_2D, fbo.texid[2]);
	glUseProgramObjectARB(program[3]);
	loc   = glGetUniformLocationARB(program[3], "Width");
	glUniform1iARB(loc, width*2);

	DoQuad();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[2]);
	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glBindTexture(GL_TEXTURE_2D, fbo.texid[3]);
	glUseProgramObjectARB(program[4]);
	loc   = glGetUniformLocationARB(program[4], "Height");
	glUniform1iARB(loc, height*2);

	DoQuad();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	glDrawBuffer(GL_BACK);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, fbo.texid[0]);
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, fbo.texid[2]);
	glUseProgramObjectARB(program[5]);

	glBegin(GL_QUADS);
		glMultiTexCoord2f(GL_TEXTURE0, 0.0f, 0.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 0.0f, 0.0f);
		glVertex2d(-1, -1);
		glMultiTexCoord2f(GL_TEXTURE0, 1.0f, 0.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 1.0f, 0.0f);
		glVertex2d(1, -1);
		glMultiTexCoord2f(GL_TEXTURE0, 1.0f, 1.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 1.0f, 1.0f);
		glVertex2d(1, 1);
		glMultiTexCoord2f(GL_TEXTURE0, 0.0f, 1.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 0.0f, 1.0f);
		glVertex2d(-1, 1);
	glEnd();

	glXSwapBuffers(display, win);
#endif
}

void SSAO()
{
	GLint loc;

#ifdef GL_COLOR_ATTACHMENT0_EXT
	glDepthMask(GL_FALSE);
	glDisable(GL_DEPTH_TEST);

	glPushMatrix();
	glLoadIdentity();
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[1]);
	glDrawBuffers(1,buffers);
	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, fbo.texid3[0]);

	glUseProgramObjectARB(program[1]);
	if (*shade) {
	   glUniform1iARB(dofog2, 1);
	} else {
	   glUniform1iARB(dofog2, 0);
	}

	DoQuad();

	if (SSAO_type) {

	   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[2]);
	   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	   glBindTexture(GL_TEXTURE_2D, fbo.texid[1]);
	   glUseProgramObjectARB(program[8]);

	   DoQuad();

	} else {

	   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[2]);
	   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	   glBindTexture(GL_TEXTURE_2D, fbo.texid[1]);
	   glUseProgramObjectARB(program[3]);
	   loc   = glGetUniformLocationARB(program[3], "Width");
	   glUniform1iARB(loc, width);

	   DoQuad();

	   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[1]);
	   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	   glBindTexture(GL_TEXTURE_2D, fbo.texid[2]);
	   glUseProgramObjectARB(program[4]);
	   loc   = glGetUniformLocationARB(program[4], "Height");
	   glUniform1iARB(loc, height);

	   DoQuad();

	}

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	glDrawBuffer(GL_BACK);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, fbo.texid1[0]);
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, fbo.texid2[0]);
	glActiveTexture(GL_TEXTURE2);

	if (SSAO_type) {
	   glBindTexture(GL_TEXTURE_2D, fbo.texid[2]);
	} else {
	   glBindTexture(GL_TEXTURE_2D, fbo.texid[1]);
	}

	glUseProgramObjectARB(program[9]);
	if (*shade) {
	   glUniform1iARB(dofog3, 1);
	} else {
	   glUniform1iARB(dofog3, 0);
	}

	glBegin(GL_QUADS);
		glMultiTexCoord2f(GL_TEXTURE0, 0.0f, 0.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 0.0f, 0.0f);
		glVertex2d(-1, -1);
		glMultiTexCoord2f(GL_TEXTURE0, 1.0f, 0.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 1.0f, 0.0f);
		glVertex2d(1, -1);
		glMultiTexCoord2f(GL_TEXTURE0, 1.0f, 1.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 1.0f, 1.0f);
		glVertex2d(1, 1);
		glMultiTexCoord2f(GL_TEXTURE0, 0.0f, 1.0f);
		glMultiTexCoord2f(GL_TEXTURE1, 0.0f, 1.0f);
		glVertex2d(-1, 1);
	glEnd();

	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	glXSwapBuffers(display, win);
#endif
}

GLint shadowMapTexture;
GLdouble lightProj[16], lightView[16];
GLdouble TexMat[16];
GLfloat amb_dif[4] = {0.2f, 0.2f, 0.2f, 1.0f};
GLfloat blk[4] = {0.0f, 0.0f, 0.0f, 0.0f};
GLfloat wht[4] = {1.0f, 1.0f, 1.0f, 1.0f};
static float lightPos[] = { 2.0f, 3.0f, -2.0f, 0.0f };

void invmat(mati,mato)
double mati[16];
double mato[16];
{
   int i,j;

   mato[0]  = mati[0];
   mato[5]  = mati[5];
   mato[10] = mati[10];
   mato[1]  = mati[4];
   mato[4]  = mati[1];
   mato[2]  = mati[8];
   mato[8]  = mati[2];
   mato[6]  = mati[9];
   mato[9]  = mati[6];

   mato[3]  = mati[3];
   mato[7]  = mati[7];
   mato[11] = mati[11];
   mato[15] = mati[15];

   mato[12] = -mati[12];
   mato[13] = -mati[13];
   mato[14] = -mati[14];
}

static double mView[16];
static double Lproj[16];

static GLdouble RR[4][4] = { 
{1.0,0.0,0.0,0.0}, {0.0,1.0,0.0,0.0}, {0.0,0.0,1.0,0.0}, {0.0,0.0,0.0,1.0} 
};

void MultInvTextMat()
{
	double mV[16];
	static double mViewi[16];
	glGetDoublev(GL_MODELVIEW_MATRIX, mV);
	invmat(mV,mViewi);
	glMatrixMode(GL_TEXTURE);
	glActiveTexture(GL_TEXTURE7);
	glLoadIdentity();	
	glMultMatrixd (Lproj);
	glMultMatrixd (mView);
	glMultMatrixd (mViewi);
	glMultMatrixd ((const GLdouble *) RR);
	glMatrixMode(GL_MODELVIEW);
}

void startTranslate(float x,float y,float z)
{
        glPushMatrix();

        glMatrixMode(GL_TEXTURE);
        glActiveTexture(GL_TEXTURE7);
	glLoadIdentity();	
	glMultMatrixd(TexMat);
        glTranslatef(x,y,z);

        glMatrixMode(GL_MODELVIEW);
        glPopMatrix();
}

void RotateShad(RR)
const GLdouble *RR;
{
	glMultMatrixd((const GLdouble *) RR);
        glPushMatrix();

        glMatrixMode(GL_TEXTURE);
        glActiveTexture(GL_TEXTURE7);
	glMultMatrixd((const GLdouble *) RR);

        glMatrixMode(GL_MODELVIEW);
        glPopMatrix();
       
}

void setTextureMatrix(void)
{
	const GLdouble bias[16] = {	
		0.5, 0.0, 0.0, 0.0, 
		0.0, 0.5, 0.0, 0.0,
		0.0, 0.0, 0.5, 0.0,
		0.5, 0.5, 0.5, 1.0};
	
	glGetDoublev(GL_MODELVIEW_MATRIX, mView);
	glGetDoublev(GL_PROJECTION_MATRIX, Lproj);
	
	glMatrixMode(GL_TEXTURE);
	glActiveTexture(GL_TEXTURE7);
	
	glLoadIdentity();	
	glLoadMatrixd(bias);
	
	glMultMatrixd (Lproj);
	glMultMatrixd (mView);
	glGetDoublev(GL_TEXTURE_MATRIX, TexMat);
	
	glMatrixMode(GL_MODELVIEW);
}

#endif

#define RESUND -20000
static int rsold = RESUND;
static int bckx,bcky;

void ogind();

static int update_model = 1;
static int update_res = -1;
static int update_sel = 1;
static int update_casel = 0;

static char *VRMLFname;

static char *GEOMstr;
static int GEOMset = 0;

static BSTRU qboxclose[2];

static int ISOup = 0;
static Window ISOwin;
#define ISOWINW 250
#define ISOWINH 290
#define ISOOffx 10
#define NBUTISO 2
static BSTRU isobut[NBUTISO];
static int ISOt = 0;

#define NBUTDCK 4
static BSTRU dockbut[NBUTDCK];

static char dcklig[MAXPATHLEN] = "dock.xyz";
static char dckout[MAXPATHLEN] = "dock.mol2";
static int dcksol = 20;

static char  *nofor[1] = {"       "};
static int Nnofor = 1;

#define MXMM3 164
static char  *mm3[MXMM3];
static int Nmm3 = 0;

static int mm3ptr[] = {
4,20,22,23,27,35,43,47,72,123,50,162,25,26,0,
1,2,3,21,28,29,37,49,55,56,57,66,67,70,105,
112,113,159,160,161,7,8,9,36,38,39,42,44,45,71,
106,107,108,109,110,142,143,145,149,150,154,163,5,6,40,
46,48,68,69,74,75,76,77,78,79,80,81,82,83,84,
85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
100,101,102,114,115,116,117,118,119,120,144,147,148,158,10,
51,58,18,24,59,152,14,15,16,17,41,73,103,104,153,
11,52,124,60,61,64,65,62,63,30,33,12,53,125,31,
34,13,54,126,127,128,129,130,131,132,133,134,135,136,137,
138,139,140,141,32,19,111,121,122,146,151,155,156,157
};

static int mm3atnr[] = {
1,1,1,1,1,1,1,1,1,1,2,3,5,5,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,
10,12,14,15,15,15,16,16,16,16,16,16,16,16,16,
17,18,20,26,26,27,27,28,28,32,34,35,36,38,50,
52,53,54,56,57,58,59,60,61,62,63,64,65,66,67,
68,69,70,71,82,0,0,0,0,0,0,0,0,0
};

/* static int mm3ptr[] = {
 4,20,22,23,27,43,47,72,123,35,50,25,26,0,1,
 2,3,21,28,29,37,49,55,56,57,66,67,70,105,112,
 113,155,156,157,7,8,9,36,38,39,42,44,45,71,106,
 107,108,109,110,142,143,145,149,150,154,5,6,40,46,48,
 68,69,74,75,76,77,78,79,80,81,82,83,84,85,86,
 87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,
 102,114,115,116,117,118,119,120,144,147,148,158,10,51,58,
 18,24,59,152,14,15,16,17,41,73,103,104,153,11,52,
 124,60,61,64,65,62,63,30,12,33,53,125,31,13,34,
 54,126,127,128,129,130,131,132,133,134,135,136,137,138,139,
 140,141,32,19,111,121,122,146,151
};

static int mm3atnr[] = {
 1,1,1,1,1,1,1,1,1,1,2,5,5,6,6,6,6,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
 7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
 8,7,9,10,12,14,15,15,15,16,16,16,16,16,16,16,16,16,17,18,
 20,26,26,27,27,28,28,32,35,34,36,38,50,53,52,54,56,57,58,
 59,60,61,62,63,64,65,66,67,68,69,70,71,82,0,0,0,0,0,0
}; */

static int gffatnr[] = {
 0,6,6,6,6,6,6,6,6,6,
 6,6,6,6,6,6,6,6,1,1,
 1,1,1,1,1,1,1,1,1,1,
 1,9,17,35,53,7,7,7,7,7,
 7,7,7,7,7,7,7,7,8,8,
 8,8,15,15,15,15,15,15,15,15,
 15,15,15,16,16,16,16,16,16,16,16,6
};

#define MXCHTP 136

static char  *chmtnk[MXCHTP];
static int Nchmtnk = 0;

static int chmptr[] = {
/* Hydrogen */
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,82,
83,84,85,86,87,88,115,116,117,118,119,
/* Carbon */
19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,
37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,
55,56,57,58,59,60,61,89,90,91,92,93,94,95,96,97,98,120,
121,122,123,124,125,126,127,128,129,
/* Nitrogen */
62,63,64,65,66,67,68,69,70,71,72,99,130,
/* Oxygen */
73,74,75,76,77,78,100,101,102,103,104,131,132,133,134,
/* Other atoms */
79,80,81,105,106,107,108,109,110,111,112,113,114,135
/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,82,
19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,
37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,
55,56,57,58,59,60,61,83,84,85,86,87,88,62,63,64,65,66,
67,68,69,70,71,72,89,73,74,75,76,77,78,90,91,92,93,79,
80,81,94,95,96,97,98,9980,81,94,95,96,97,98,99 */
};

static int chmatnr[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,
7,7,7,7,7,7,7,7,7,7,7,7,7,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
16,16,16,16,26,2,10,11,12,17,19,20,30,15
};

static char  *ambstr[MXAMB];
static int Nambstr = 0;

static int ambatnr[] = {
7,6,6,1,8,1,7,6,6,1,8,1,6,1,7,6,6,1,8,1,
6,1,6,1,6,1,7,6,6,1,8,1,6,1,6,1,6,1,6,1,
7,6,6,1,8,1,6,1,6,1,6,1,6,1,7,6,6,1,8,1,
6,1,8,1,7,6,6,1,8,1,6,1,8,1,6,1,7,6,6,1,
8,1,6,1,16,1,7,6,6,1,8,1,6,1,16,7,6,6,8,1,
6,1,6,1,6,1,7,6,6,1,8,1,6,1,6,6,1,6,1,6,
1,7,6,6,1,8,1,6,1,6,6,1,6,1,6,8,1,7,6,6,
1,8,1,6,1,6,6,1,6,7,1,6,6,1,6,1,6,1,6,1,
7,6,6,1,8,1,6,1,6,7,1,6,1,6,1,7,1,7,6,6,
1,8,1,6,1,6,7,1,6,1,6,1,7,7,6,6,1,8,1,6,
1,6,7,6,1,6,1,7,1,7,6,6,1,8,1,6,1,6,8,7,
6,6,1,8,1,6,1,6,8,7,1,7,6,6,1,8,1,6,1,6,
1,6,8,7,6,6,1,8,1,6,1,6,1,6,8,7,1,7,6,6,
1,8,1,6,1,6,1,16,6,1,7,6,6,1,8,1,6,1,6,1,
6,1,6,1,7,1,7,6,6,1,8,1,6,1,6,1,6,1,7,1,
6,7,1,7,6,6,1,8,1,6,1,6,1,6,1,7,1,7,6,6,
1,8,6,1,7,6,6,1,8,1,6,1,6,1,6,8,6,1,8,6,
1,6,8,7,1,7,1,6,1,7,6,6,1,8,1,7,6,6,1,8,
1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,
6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,
1,8,1,7,6,6,1,8,1,6,1,7,6,6,1,8,1,7,6,6,
1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,
1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,
6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,
1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,
7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,
6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,
8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,8,1,7,
6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,
1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,
1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,
6,6,1,8,1,7,6,6,1,8,1,7,6,6,1,8,1,7,6,6,
1,8,1,7,6,6,1,8,8,1,3,11,19,37,55,12,20,30,17,
7,6,6,1,8,1,6,1,6,8,8,1,
7,6,6,1,8,1,6,1,6,1,6,8,8,1,
7,6,6,1,8,1,6,1,6,1,6,1,7,1,
299*0,
8,6,1,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,6,7,
6,7,6,7,6,1,7,1,1,1,8,6,1,1,6,1,8,6,1,6,
1,6,1,8,1,8,7,6,6,7,6,7,6,7,6,1,7,1,1,8,
1,8,6,1,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,7,
6,6,6,8,7,1,1,1,1,8,6,1,1,6,1,8,6,1,6,1,
6,1,8,1,8,7,6,7,6,6,6,8,1,8,1,1,8,6,1,1,
6,1,8,6,1,6,1,6,1,1,8,7,6,6,7,6,7,6,7,6,
1,7,1,1,1,8,6,1,1,6,1,8,6,1,6,1,6,1,1,8,
7,6,6,7,6,7,6,7,6,1,7,1,1,8,1,8,6,1,1,6,
1,8,6,1,6,1,6,1,1,8,7,6,7,6,6,6,8,7,1,1,
1,1,8,6,1,1,6,1,8,6,1,6,1,6,1,1,8,7,6,7,
6,6,6,8,1,8,6,1,1,15,8,8,1,8,15,8,8,1,8,15,
8,15,8,8,1,8,15,8,8,1,8,15,8,
8,6,1,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,6,7,6,7,6,7,6,1,7,1,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,7,6,6,6,1,8,7,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,8,7,6,8,7,6,7,1,6,1,6,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,6,7,6,1,7,6,7,1,6,8,6,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,6,7,6,7,6,7,6,8,1,1,7,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,6,7,6,7,6,7,6,8,1,1,7,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,8,7,6,6,7,6,7,6,7,6,8,1,1,7,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,6,7,6,7,6,7,6,8,7,6,6,1,6,1,6,1,6,1,6,1,6,1,6,8,8,6,1,7,1,6,8,8,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,7,6,6,6,8,8,1,1,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,7,6,7,6,6,6,8,8,1,1,6,1,
8,6,1,6,1,8,6,1,6,1,6,1,8,1,8,6,6,7,6,7,6,8,8,1,1,1
};


#define MXMOL2 41
static char  *mol2[MXMOL2];
static int Nmol2 = 0;

#define MXGMX 53
static char  *gmx[MXGMX];
static int Ngmx = 0;

#define MXGMX2 57
static char  *gmx2[MXGMX2];
static int Ngmx2 = 0;

#define MXG43 49
static char  *g43[MXG43];
static int Ng43 = 0;

#define MXAMO 201
static char  *amostr[MXAMO];
static int Namostr = 0;

#define MXMSF 235
static char  *chmsf[MXMSF];
static int Nchmsf = 0;

#define MXTRR 512
static char  *grostr[MXTRR];
static int Ngrostr = 0;

#define MXGFF 72
static char  *gffext[MXGFF];
static int Ngffext = 0;

static char  *exepath[1];
static int Nexepath = 0;

static int isnul = 0;
static char **typs[12] = { nofor,mm3,chmtnk,ambstr,amostr,mol2,chmsf,ambstr,NULL,gmx,gmx2,g43};
static char **typsn[12] = { nofor,mm3,chmtnk,ambstr,amostr,mol2,chmsf,gffext,NULL,gmx,gmx2,g43};
static int *Ntyps[12] = { &Nnofor,&Nmm3,&Nchmtnk,&Nambstr,&Namostr,&Nmol2,&Nchmsf,&Nambstr,&isnul,&Ngmx,&Ngmx2,&Ng43};
static int *Ntypsn[12] = { &Nnofor,&Nmm3,&Nchmtnk,&Nambstr,&Namostr,&Nmol2,&Nchmsf,&Ngffext,&isnul,&Ngmx,&Ngmx2,&Ng43};
static int ffsgn[12] = { 1,1,1,1,1,1,1,-1,1,1,1,1};
static int *ffptr[12] = { NULL,mm3ptr,chmptr,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
static int *ffatnr[12] = { NULL,mm3atnr,chmatnr,ambatnr,NULL,NULL,NULL,gffatnr,NULL,NULL,NULL,NULL};

#define MXSG 238
static char  *spacegr[MXSG];
static int Nspgr = 0;

static char  *achain[NUMCAL];
static int ncal = 0;

static int ATMup = 0;
static Window ATMwin;
static Window subATM;
#define ATMWINW 250
#define ATMWINH 350
#define ATMOffx 10
#define NBUTATM 6
static BSTRU butATM[NBUTATM];
static int ATMt = 0;
static int itcopt = 3;
static char *ForceFields[] = {"No Force Field","Tinker MM3","Tinker Charmm","Tinker Amber","Tink AmoebaPRO","Sybyl","Quanta Charmm","Amber/GAFF","PMF","Gromacs","Gromacs2","Gromos96"};
static int *fftyp;
static int ATMsel = 0;
static int ATMselp = 0;

static int SEQup = 0;
static Window SEQwin;
#define SEQWINW 430
#define SEQWINH 220
#define SEQOffx 15
#define SEQRESY  40
#define SEQSTATY 105
#define SEQCONFY 150
#define SEQBROWY 180
#define NBUTSEQ 25
static BSTRU butSEQ[NBUTSEQ];
static char *Conformations[] = {"Alpha-Helix","Beta","Turn"};
static double phis[3] = {-58.0, -139.0, -60.0};
static double psis[3] = {-47.0, 135.0, -30.0};
static double phi_angle = -58.0;
static double psi_angle = -47.0;
static int iconform = 0;

static int TNKup = 0;
static Window TNKwin, subTNK;
#define TNKWINW 430
#define TNKWINH 205
#define TNKOffx 15
#define TNKRESY  17
#define TNKBWIDE 30
#define TNKBROWY 165
#define NBUTTNK 11
static int ntnkb = NBUTTNK-2;
static BSTRU butTNK[NBUTTNK];
static char *TnkProgs[] = {"minimize","optimize","newton","dynamic","Xtinker","newton-ts"};
static char *AmbProgs[] = {"ambfor","ambmd","crys. opt"};
static char *grdFlags[] = {"-g","-t"};
static char *iterFlags[] = {"-c","-s"};
static char **Progs = TnkProgs;
static int nprogs = 6;
static int *tnkprg;
static double mxgrads[] = {0.01,0.01,0.01,0.0,0.01};
static double *currgrd;
static double *uscl;
static int *archfrq;
static int *arch;
static int *tnkbg;
static int AddChrg = 1;
static int Box = 0;
static int Cutoff = 1;
static int *tnkit;
static int *iqopt;
static int *ibell;
static int *natorg;
static int *irtcel;
static int *irtval;
static int *ifntcl;

static SCRSTRU dptscr[2];
static int dptwn[3];
static int dptwpos[3];
static BSTRU butdpt[2];
static int DPTup = 0;
static Window DPTwin;

static SLIDESTRU omapscr[6];
static int omapwn[6];
static int omapwpos[6];
static float omaprat[6];
static int omapsrf;
static BSTRU butomap[4];
static double omapt[3];
static double omapcnt1;
static double omapcnt2;
static int OMAPup = 0;
static int OMAPtype = 0;
static Window OMAPwin;
static Window subOMAP;
static double slab[3] = {10.0,10.0,10.0};
static double EQ[3] = {0.0,0.0,0.0};
static double extnt[3] = {0.0,0.0,0.0};
static double vox[3] = {0.0,0.0,0.0};

static SCRSTRU ecolscr[3];
static int ecolwn[3];
static int ecolwpos[3];
static int activecolor = 1;
static BSTRU butecol[1];
static int ECOLup = 0;
static Window ECOLwin;
#define ECOLWINW 250
#define ECOLWINH 180
void colcall(char* str);

static int COLup = 0;
static Window COLwin;
#define NBUTSC 2
static BSTRU colbut[NBUTSC];
#define COLWINW 513
#define COLWINH 400
#define COLWINIW 464
#define COLWINIH 361
#define COLFRBord 20
#define COLBord 10
#define COLOffx 10
#define COLOffy 50
#define COLWINHT COLOffy-COLFRBord+COLWINH
static int ipropopt = 0;
static int propat = 0;
static char *propopts[] = {"Atom Color","VDW radius","Display radius","ESP VDW radius"};
#define PATMCOL 0
#define PVDWRAD 1
#define PDISRAD 2
#define PESPRAD 3

static int MAPup = 0;
static Window MAPwin;
#define NBUTSM 7
static BSTRU mapbut[NBUTSM];
#define MAPWINW 513
#define MAPWINH 400
#define MAPOFFX  130
#define MAPOFFY  130
static char *mapstr[] = {"Red        < ","Yellow       ","Green        ","Light Blue   ","Blue       > "};
static double *mapval;
static int *imapopt;
static char *mapopts[] = {"Molden Gridfile","Gaussian Cube"};
static int iviropt = 2;
static char *viropts[] = {"VRML2.0","OpenGL file","OpenGL screen"};

static int VIRup = 0;
static Window VIRwin;
static BSTRU virbut[2];
#define VIRWINW 513
#define VIRWINH 170

static int DELup = 0;
static Window DELAYwin;
static BSTRU delbut[3];
#define DELWINW 300
#define DELWINH 120
static int DelayRemember = 0;
static int *ideltm;

static int MLTup = 0;
static int MLTwide = 0;
static Window MLTwin, subMLT;
#define NMLTBUT 6
static BSTRU mltbut[NMLTBUT];
static int Nmltb = NMLTBUT;
#define MLTWINW 350
#define MLTWINH 450
#define MLTWIDE 140
static LISTSTRU mltlist;

static int PHRMup = 0;
static Window PHRMwin, subPHRM;
static int FeatSel = -1;
#define PHRMBUT 8
static BSTRU PHRMbut[PHRMBUT];
#define PHRMWINW 360
#define PHRMWINH 375
static LISTSTRU PHRMlist;
static int PHRMloc = -1;
static int OBloc = -1;

static int PSRCHup = 0;
static Window PSRCHwin, subPSRCH;
static char *PSRCHquery;
#define PSRCHBUT 4
static BSTRU PSRCHbut[PSRCHBUT];
#define PSRCHWINW 360
#define PSRCHWINH 150

static int QSARup = 0;
static Window QSARwin, subQSAR;
#define QSARBUT 10
static BSTRU QSARbut[QSARBUT];
#define QSARWINW 360
#define QSARWINH 415

typedef struct { int fldopt;
		 char sdf[MAXSTRLEN];
		 char plt[MAXSTRLEN];
		 char act[MAXSTRLEN];
		 char dat[MAXSTRLEN];
                 int varred; 
                 int pc; 
                 int cv; 
                 int cut; 
                 float cutmin; 
                 float cutmax; 
                 float cntvdw; 
                 float cntele; 
		 int vdwsrf;
               } QSARSTRU;

static QSARSTRU QSAR;

static char *fldopts[] = {"Molden Gaff","Open3DQSAR"};
static char *cvopts[] = {"Off","On"};

static int QEDITup = 0;
static Window QEDITwin, subQEDIT;
#define QEDITBUT 4
static BSTRU QEDITbut[QEDITBUT];
#define QEDITWINW 500
#define QEDITWINH 400

static int SRFup = 0;
static Window SRFwin, subSRF;
static BSTRU srfbut[6];
#define SRFWINW 310
#define SRFWINH 200
static float cursrfcol[2][4] = {{0.0,0.0,1.0,0.8},{1.0,0.0,0.0,0.8}};
static int cursrfcoli = 0;
static int idorad = 0;

static int FLXup = 0;
static Window FLXwin;
static BSTRU flxbut[9];
#define FLXWINW 320
#define FLXWINH 250
static short int *itypBackup = NULL;
static int *idoh;
static int *itot;

static int PARup = 0;
static Window PARwin;
static BSTRU parbut[3];
#define PARWINW 320
#define PARWINH 250

static int CHGup = 0;
static int CHGret = 0;
static int CHGopt = 0;
static int CHGstat = 0;
static int CHGother = 0;
static Window CHGwin;
static BSTRU chgbut[3];
#define CHGWINW 350
#define CHGWINH 150

static int STRup = 0;
static int STRCup = 0;
static Window STRwin, STRCwin, subSTR, subSTRC;
static BSTRU strbut[5];
#define STRCBN 14
static BSTRU strcbut[STRCBN];
#define STRWINW 250
#define STRWINH 265
#define STRSH 150
#define STRX 10
#define STRW 205

static int SELHup = 0;
static Window SELHwin, subSELH;
#define SELHBN 7
static BSTRU selhbut[SELHBN];
#define SELHWINW 230
#define SELHWINH 200
static int HINC;
static int HRES;
static int HLIG;
static int HFLP;
static int HHIS;
static int HWAT;

static int SRCHup = 0;
static Window SRCHwin, subSRCH;
#define SRCHBN 3
static BSTRU butSRCH[SRCHBN];
#define SRCHWINW 300
#define SRCHWINH 350

static int ANIMup = 0;
static Window ANIMwin, subANIM;
#define ANIMBN 5
static BSTRU butANIM[ANIMBN];
#define ANIMWINW 190
#define ANIMWINH 86

static int Movup = 0;
static Window MOVwin;
static BSTRU movbut[5];
static int rmsnap = 1;
static int timsnap = 0;
static int record = 0;
static int tmpfmt = 0;
static int tmpmxg = 0;
static int Tbeg = 0;
static int Tend = 0;
#define MOVWINW 250
#define MOVWINH 150

static int ONIup = 0;
static Window ONIwin, subONI;
#define NBUTSO 24
#define OMETHH  0
#define OBASSH  1
#define OALLH   2
#define OSELH   3
#define OMETHL  4
#define OBASSL  5
#define OALLL   6
#define OSELL   7
#define OMETHM  8
#define OBASSM  9
#define OALLM  10
#define OSELM  11
#define OSEL   12
#define OUSEL  13
#define OCOLO  14
#define OSELR  15
#define OCLOS  16
#define OCHARH 17
#define OMULTH 18
#define OCHARM 19
#define OMULTM 20
#define OCHARL 21
#define OMULTL 22
#define OAMBCH 23
static BSTRU onbut[NBUTSO];
#define OBOXWIDE 350
#define OBOXHIGH 350
#define OBOXOFFX 10
#define OBOXBLEN 100
#define ONIHCOL 12
#define ONIMCOL 9
#define ONILCOL 1
static char olev[3][MAXSTRLEN];
static int imopth = 0;
static int imoptl = 0;
static int imoptm = 0;
static int ibopth = 0;
static int iboptl = 0;
static int iboptm = 0;
static int lnkat = 0;

static int FLRup = 0;
static Window FLRwin, subFLR;
#define NBUTSF  10
#define FRIGD   0
#define FSELR   1
#define FFLEX   2
#define FSELF   3
#define FSEL    4
#define FUSEL   5
#define FSELA   6
#define FCLOS   7
#define FBACK   8
#define FCONT   9
static BSTRU flrbut[NBUTSF];

#define FBOXWIDE 350
#define FBOXHIGH 250
#define FBOXOFFX 10
#define FBOXBLEN 100

#define FRIGCOL 12
#define FLEXCOL 9

static int bckrig = 0;

static QBOXSTRU IANZboxes[MAXAT];
static QBOXSTRU IZboxes[MAXAT][4];
static QBOXSTRU BLboxes[MAXAT];
static QBOXSTRU ALPHboxes[MAXAT];
static QBOXSTRU BETboxes[MAXAT];
static QBOXSTRU EXPbox[1];
static QBOXSTRU TMPbox;

static QBOXSTRU *IANZbox = IANZboxes;
static QBOXSTRU *BLbox = BLboxes;
static QBOXSTRU *ALPHbox = ALPHboxes;
static QBOXSTRU *BETbox = BETboxes;
static QBOXSTRU *IZbox = (QBOXSTRU *) IZboxes;
static char *IANZstr = 
	"Element string. To change element\ntype new element and hit Enter/Return";
static char *IZstr = 
	"Previously defined atoms used to define\nbondlength, bondangle and dihedral of current atom\nTo edit: Click with 1st mouse button to activate,\ntype previously defined atom number and hit Enter/Return\n4th field can be ignored";
static char *BLstr = 
	"Bondlength between current atom and\natom specified in first connectivity field.\nTo edit: Click with 1st mouse button to activate,\n         type new bondlength and hit Enter/Return\nClick with 2nd mouse button for actions with this variable";
static char *ALPHstr = 
	"Bondangle between current atom and\natoms specified in first two connectivity fields.\nTo edit: Click with 1st mouse button to activate,\n         type new bondangle and hit Enter/Return\nClick with 2nd mouse button for actions with this variable";
static char *BETstr = 
	"Dihedral angle between current atom and\natoms specified in first three connectivity fields.\nTo edit: Click with 1st mouse button to activate,\n         type new angle and hit Enter/Return\nClick with 2nd mouse button for actions with this variable";

static Window ZMEwin, subZM;
static int ZMEbig = 1;
#define ZMEWINW 513
#define ZMEQHIGH 40
#define ZMESHIGH 40
#define ZMEFRBord 20
#define ZMEBord 10
#define ZMETab1 35
#define ZMETab2 5
#define ZMETab3 5
#define ZME_window_high 8
static int ZMEiz, ZMEizs, ZMEanW, ZMEconW, ZMEbutW, ZMEvarW, ZMEvarWs, ZMEiz4W;
static int ZMEZWIDE;
#define ZMEZHIGH ZME_window_high*ZMEQHIGH+2*ZMEFRBord+ZMEBord
#define ZMEZOffx 10
#define ZMEZOffy 50
#define ZMESCR 5
#define ZMEBOFFY 10
#define ZMEBHIGH 160
#define ZMEBWIDE 30
#define ZMEButOffy ZMEZOffy-ZMEFRBord+ZMEZHIGH+ZMEBOFFY
#define ZMEWOffy ZMEZOffy-ZMEFRBord+ZMEZHIGH+ZMEBHIGH+ZMESHIGH
#define ZMEWHIGH 120
#define ZMEWBOFF 80
#define ZMEWINH ZMEZOffy-ZMEFRBord+ZMEZHIGH+ZMEBHIGH+ZMESHIGH+ZMEWHIGH-3
#define ZMEBW2  ZMEWINW/2-2*ZMEZOffx
#define ZMEBW4  (ZMEBW2-ZMEZOffx)/2
#define ZMBCOL -15

static int ZMEup = 0;
static int ZME_window_pos;
static int ZMEmode = 0;
static int ZMEAA = 0;
static int ZMEsel = 0;
static int ZMEatom = 0;
#define MAXZMEERR 128
static char ZMEerr[MAXZMEERR+1];
static char *zmevaropt[] = {"constant","variable","mark","unmark","animate","link","-link"};
static char *zmevarclr[] = {"constant","variable"};
static char *zmeblform[] = {"%f","%#9.3f"};
static char *zmeform[] = {"%f","%#8.3f"};
static char ZMEups[5];

#define ZMEBUTTS 24

static BSTRU ZMEbut[ZMEBUTTS];

#define ZMEARR1 0
#define ZMEARR2 1
#define ZMEAPPL 2
#define ZMECAN1 3
#define ZMEFRG  4
#define ZMEDEL  5
#define ZMEADD  6
#define ZMEGAM  7
#define ZMEGAU  8
#define ZMEMOP  9
#define ZMECAR  10
#define ZMENWC  11
#define ZMEWRT  12
#define ZMESEL  13
#define ZMEUSEL 14
#define ZMESELA 15
#define ZMENEW  16
#define ZMECANC 17
#define ZMECVAR 18
#define ZMEMAP  19
#define ZMESUB  20
#define ZMEORD  21
#define ZMEUS   22
#define ZMEREVT 23

static BSTRU ZMEBbut[3];
#define ZMESIN  0
#define ZMEDBL  1
#define ZMETRI  2

static int ZMEopt = ZMEGAM;
static int ZMEmul = ZMESIN;
static int *igztyp;
static int *igtfil;

static BSTRU ZMEAAbut[ZME_window_high];
static BSTRU ZMEAASbut[ZME_window_high];
static BSTRU ZMEswitch[2];

#define TABBUTN 99
static int TabPos[TABBUTN][2] = {
	{0,0},{0,17},
	{1,0},{1,1},{1,12},{1,13},{1,14},{1,15},{1,16},{1,17},
	{2,0},{2,1},{2,12},{2,13},{2,14},{2,15},{2,16},{2,17},
	{3,0},{3,1},{3,2},{3,3},{3,4},{3,5},{3,6},{3,7},{3,8},{3,9},{3,10},{3,11},{3,12},{3,13},{3,14},{3,15},{3,16},{3,17},
	{4,0},{4,1},{4,2},{4,3},{4,4},{4,5},{4,6},{4,7},{4,8},{4,9},{4,10},{4,11},{4,12},{4,13},{4,14},{4,15},{4,16},{4,17},
	{5,0},{5,1},{5,2},
	{8,0},{8,1},{8,2},{8,3},{8,4},{8,5},{8,6},{8,7},{8,8},{8,9},{8,10},{8,11},{8,12},{8,13},
	{5,3},{5,4},{5,5},{5,6},{5,7},{5,8},{5,9},{5,10},{5,11},{5,12},{5,13},{5,14},{5,15},{5,16},{5,17},
	{6,0},{6,1},{6,2},
	{9,0},{9,1},{9,2},{9,3},{9,4},{9,5},{9,6},{9,7},{9,8},
	{11,9}
		};
static BSTRU TabBut[TABBUTN];
static BSTRU AtmBut[TABBUTN];
#define ZMETABH 24
#define ZMETABA 22

/* 
Covalent radii based on Pyykko's and Atsumi's work: 
http://www.chem.helsinki.fi/~pyykko/Radii09.pdf
*/

#define NUMDIS 98
static int DisAtoms[NUMDIS] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98};

static float SingleDis[NUMDIS][NUMDIS] = {
   {0.64,0.78,1.65,1.34,1.17,1.07,1.03,0.95,0.96,0.99,1.87,1.71,1.58,1.48,1.43,1.35,1.31,1.28,2.28,2.03,1.80,1.68,1.66,1.54,1.51,1.48,1.43,1.42,1.44,1.50,1.56,1.53,1.53,1.48,1.46,1.49,2.42,2.17,1.95,1.86,1.79,1.70,1.60,1.57,1.57,1.52,1.60,1.68,1.74,1.72,1.72,1.68,1.65,1.63,2.64,2.28,2.12,1.95,2.08,2.06,2.05,2.04,2.00,2.01,2.00,1.99,1.98,1.97,1.96,2.02,1.94,1.84,1.78,1.69,1.63,1.61,1.54,1.55,1.56,1.65,1.76,1.76,1.83,1.77,1.79,1.74,2.55,2.33,2.18,2.07,2.01,2.02,2.03,2.04,1.98,1.98,2.00,2.00},
   {0.78,0.92,1.79,1.48,1.31,1.21,1.17,1.09,1.10,1.13,2.01,1.85,1.72,1.62,1.57,1.49,1.45,1.42,2.42,2.17,1.94,1.82,1.80,1.68,1.65,1.62,1.57,1.56,1.58,1.64,1.70,1.67,1.67,1.62,1.60,1.63,2.56,2.31,2.09,2.00,1.93,1.84,1.74,1.71,1.71,1.66,1.74,1.82,1.88,1.86,1.86,1.82,1.79,1.77,2.78,2.42,2.26,2.09,2.22,2.20,2.19,2.18,2.14,2.15,2.14,2.13,2.12,2.11,2.10,2.16,2.08,1.98,1.92,1.83,1.77,1.75,1.68,1.69,1.70,1.79,1.90,1.90,1.97,1.91,1.93,1.88,2.69,2.47,2.32,2.21,2.15,2.16,2.17,2.18,2.12,2.12,2.14,2.14},
   {1.65,1.79,2.66,2.35,2.18,2.08,2.04,1.96,1.97,2.00,2.88,2.72,2.59,2.49,2.44,2.36,2.32,2.29,3.29,3.04,2.81,2.69,2.67,2.55,2.52,2.49,2.44,2.43,2.45,2.51,2.57,2.54,2.54,2.49,2.47,2.50,3.43,3.18,2.96,2.87,2.80,2.71,2.61,2.58,2.58,2.53,2.61,2.69,2.75,2.73,2.73,2.69,2.66,2.64,3.65,3.29,3.13,2.96,3.09,3.07,3.06,3.05,3.01,3.02,3.01,3.00,2.99,2.98,2.97,3.03,2.95,2.85,2.79,2.70,2.64,2.62,2.55,2.56,2.57,2.66,2.77,2.77,2.84,2.78,2.80,2.75,3.56,3.34,3.19,3.08,3.02,3.03,3.04,3.05,2.99,2.99,3.01,3.01},
   {1.34,1.48,2.35,2.04,1.87,1.77,1.73,1.65,1.66,1.69,2.57,2.41,2.28,2.18,2.13,2.05,2.01,1.98,2.98,2.73,2.50,2.38,2.36,2.24,2.21,2.18,2.13,2.12,2.14,2.20,2.26,2.23,2.23,2.18,2.16,2.19,3.12,2.87,2.65,2.56,2.49,2.40,2.30,2.27,2.27,2.22,2.30,2.38,2.44,2.42,2.42,2.38,2.35,2.33,3.34,2.98,2.82,2.65,2.78,2.76,2.75,2.74,2.70,2.71,2.70,2.69,2.68,2.67,2.66,2.72,2.64,2.54,2.48,2.39,2.33,2.31,2.24,2.25,2.26,2.35,2.46,2.46,2.53,2.47,2.49,2.44,3.25,3.03,2.88,2.77,2.71,2.72,2.73,2.74,2.68,2.68,2.70,2.70},
   {1.17,1.31,2.18,1.87,1.70,1.60,1.56,1.48,1.49,1.52,2.40,2.24,2.11,2.01,1.96,1.88,1.84,1.81,2.81,2.56,2.33,2.21,2.19,2.07,2.04,2.01,1.96,1.95,1.97,2.03,2.09,2.06,2.06,2.01,1.99,2.02,2.95,2.70,2.48,2.39,2.32,2.23,2.13,2.10,2.10,2.05,2.13,2.21,2.27,2.25,2.25,2.21,2.18,2.16,3.17,2.81,2.65,2.48,2.61,2.59,2.58,2.57,2.53,2.54,2.53,2.52,2.51,2.50,2.49,2.55,2.47,2.37,2.31,2.22,2.16,2.14,2.07,2.08,2.09,2.18,2.29,2.29,2.36,2.30,2.32,2.27,3.08,2.86,2.71,2.60,2.54,2.55,2.56,2.57,2.51,2.51,2.53,2.53},
   {1.07,1.21,2.08,1.77,1.60,1.50,1.46,1.38,1.39,1.42,2.30,2.14,2.01,1.91,1.86,1.78,1.74,1.71,2.71,2.46,2.23,2.11,2.09,1.97,1.94,1.91,1.86,1.85,1.87,1.93,1.99,1.96,1.96,1.91,1.89,1.92,2.85,2.60,2.38,2.29,2.22,2.13,2.03,2.00,2.00,1.95,2.03,2.11,2.17,2.15,2.15,2.11,2.08,2.06,3.07,2.71,2.55,2.38,2.51,2.49,2.48,2.47,2.43,2.44,2.43,2.42,2.41,2.40,2.39,2.45,2.37,2.27,2.21,2.12,2.06,2.04,1.97,1.98,1.99,2.08,2.19,2.19,2.26,2.20,2.22,2.17,2.98,2.76,2.61,2.50,2.44,2.45,2.46,2.47,2.41,2.41,2.43,2.43},
   {1.03,1.17,2.04,1.73,1.56,1.46,1.42,1.34,1.35,1.38,2.26,2.10,1.97,1.87,1.82,1.74,1.70,1.67,2.67,2.42,2.19,2.07,2.05,1.93,1.90,1.87,1.82,1.81,1.83,1.89,1.95,1.92,1.92,1.87,1.85,1.88,2.81,2.56,2.34,2.25,2.18,2.09,1.99,1.96,1.96,1.91,1.99,2.07,2.13,2.11,2.11,2.07,2.04,2.02,3.03,2.67,2.51,2.34,2.47,2.45,2.44,2.43,2.39,2.40,2.39,2.38,2.37,2.36,2.35,2.41,2.33,2.23,2.17,2.08,2.02,2.00,1.93,1.94,1.95,2.04,2.15,2.15,2.22,2.16,2.18,2.13,2.94,2.72,2.57,2.46,2.40,2.41,2.42,2.43,2.37,2.37,2.39,2.39},
   {0.95,1.09,1.96,1.65,1.48,1.38,1.34,1.26,1.27,1.30,2.18,2.02,1.89,1.79,1.74,1.66,1.62,1.59,2.59,2.34,2.11,1.99,1.97,1.85,1.82,1.79,1.74,1.73,1.75,1.81,1.87,1.84,1.84,1.79,1.77,1.80,2.73,2.48,2.26,2.17,2.10,2.01,1.91,1.88,1.88,1.83,1.91,1.99,2.05,2.03,2.03,1.99,1.96,1.94,2.95,2.59,2.43,2.26,2.39,2.37,2.36,2.35,2.31,2.32,2.31,2.30,2.29,2.28,2.27,2.33,2.25,2.15,2.09,2.00,1.94,1.92,1.85,1.86,1.87,1.96,2.07,2.07,2.14,2.08,2.10,2.05,2.86,2.64,2.49,2.38,2.32,2.33,2.34,2.35,2.29,2.29,2.31,2.31},
   {0.96,1.10,1.97,1.66,1.49,1.39,1.35,1.27,1.28,1.31,2.19,2.03,1.90,1.80,1.75,1.67,1.63,1.60,2.60,2.35,2.12,2.00,1.98,1.86,1.83,1.80,1.75,1.74,1.76,1.82,1.88,1.85,1.85,1.80,1.78,1.81,2.74,2.49,2.27,2.18,2.11,2.02,1.92,1.89,1.89,1.84,1.92,2.00,2.06,2.04,2.04,2.00,1.97,1.95,2.96,2.60,2.44,2.27,2.40,2.38,2.37,2.36,2.32,2.33,2.32,2.31,2.30,2.29,2.28,2.34,2.26,2.16,2.10,2.01,1.95,1.93,1.86,1.87,1.88,1.97,2.08,2.08,2.15,2.09,2.11,2.06,2.87,2.65,2.50,2.39,2.33,2.34,2.35,2.36,2.30,2.30,2.32,2.32},
   {0.99,1.13,2.00,1.69,1.52,1.42,1.38,1.30,1.31,1.34,2.22,2.06,1.93,1.83,1.78,1.70,1.66,1.63,2.63,2.38,2.15,2.03,2.01,1.89,1.86,1.83,1.78,1.77,1.79,1.85,1.91,1.88,1.88,1.83,1.81,1.84,2.77,2.52,2.30,2.21,2.14,2.05,1.95,1.92,1.92,1.87,1.95,2.03,2.09,2.07,2.07,2.03,2.00,1.98,2.99,2.63,2.47,2.30,2.43,2.41,2.40,2.39,2.35,2.36,2.35,2.34,2.33,2.32,2.31,2.37,2.29,2.19,2.13,2.04,1.98,1.96,1.89,1.90,1.91,2.00,2.11,2.11,2.18,2.12,2.14,2.09,2.90,2.68,2.53,2.42,2.36,2.37,2.38,2.39,2.33,2.33,2.35,2.35},
   {1.87,2.01,2.88,2.57,2.40,2.30,2.26,2.18,2.19,2.22,3.10,2.94,2.81,2.71,2.66,2.58,2.54,2.51,3.51,3.26,3.03,2.91,2.89,2.77,2.74,2.71,2.66,2.65,2.67,2.73,2.79,2.76,2.76,2.71,2.69,2.72,3.65,3.40,3.18,3.09,3.02,2.93,2.83,2.80,2.80,2.75,2.83,2.91,2.97,2.95,2.95,2.91,2.88,2.86,3.87,3.51,3.35,3.18,3.31,3.29,3.28,3.27,3.23,3.24,3.23,3.22,3.21,3.20,3.19,3.25,3.17,3.07,3.01,2.92,2.86,2.84,2.77,2.78,2.79,2.88,2.99,2.99,3.06,3.00,3.02,2.97,3.78,3.56,3.41,3.30,3.24,3.25,3.26,3.27,3.21,3.21,3.23,3.23},
   {1.71,1.85,2.72,2.41,2.24,2.14,2.10,2.02,2.03,2.06,2.94,2.78,2.65,2.55,2.50,2.42,2.38,2.35,3.35,3.10,2.87,2.75,2.73,2.61,2.58,2.55,2.50,2.49,2.51,2.57,2.63,2.60,2.60,2.55,2.53,2.56,3.49,3.24,3.02,2.93,2.86,2.77,2.67,2.64,2.64,2.59,2.67,2.75,2.81,2.79,2.79,2.75,2.72,2.70,3.71,3.35,3.19,3.02,3.15,3.13,3.12,3.11,3.07,3.08,3.07,3.06,3.05,3.04,3.03,3.09,3.01,2.91,2.85,2.76,2.70,2.68,2.61,2.62,2.63,2.72,2.83,2.83,2.90,2.84,2.86,2.81,3.62,3.40,3.25,3.14,3.08,3.09,3.10,3.11,3.05,3.05,3.07,3.07},
   {1.58,1.72,2.59,2.28,2.11,2.01,1.97,1.89,1.90,1.93,2.81,2.65,2.52,2.42,2.37,2.29,2.25,2.22,3.22,2.97,2.74,2.62,2.60,2.48,2.45,2.42,2.37,2.36,2.38,2.44,2.50,2.47,2.47,2.42,2.40,2.43,3.36,3.11,2.89,2.80,2.73,2.64,2.54,2.51,2.51,2.46,2.54,2.62,2.68,2.66,2.66,2.62,2.59,2.57,3.58,3.22,3.06,2.89,3.02,3.00,2.99,2.98,2.94,2.95,2.94,2.93,2.92,2.91,2.90,2.96,2.88,2.78,2.72,2.63,2.57,2.55,2.48,2.49,2.50,2.59,2.70,2.70,2.77,2.71,2.73,2.68,3.49,3.27,3.12,3.01,2.95,2.96,2.97,2.98,2.92,2.92,2.94,2.94},
   {1.48,1.62,2.49,2.18,2.01,1.91,1.87,1.79,1.80,1.83,2.71,2.55,2.42,2.32,2.27,2.19,2.15,2.12,3.12,2.87,2.64,2.52,2.50,2.38,2.35,2.32,2.27,2.26,2.28,2.34,2.40,2.37,2.37,2.32,2.30,2.33,3.26,3.01,2.79,2.70,2.63,2.54,2.44,2.41,2.41,2.36,2.44,2.52,2.58,2.56,2.56,2.52,2.49,2.47,3.48,3.12,2.96,2.79,2.92,2.90,2.89,2.88,2.84,2.85,2.84,2.83,2.82,2.81,2.80,2.86,2.78,2.68,2.62,2.53,2.47,2.45,2.38,2.39,2.40,2.49,2.60,2.60,2.67,2.61,2.63,2.58,3.39,3.17,3.02,2.91,2.85,2.86,2.87,2.88,2.82,2.82,2.84,2.84},
   {1.43,1.57,2.44,2.13,1.96,1.86,1.82,1.74,1.75,1.78,2.66,2.50,2.37,2.27,2.22,2.14,2.10,2.07,3.07,2.82,2.59,2.47,2.45,2.33,2.30,2.27,2.22,2.21,2.23,2.29,2.35,2.32,2.32,2.27,2.25,2.28,3.21,2.96,2.74,2.65,2.58,2.49,2.39,2.36,2.36,2.31,2.39,2.47,2.53,2.51,2.51,2.47,2.44,2.42,3.43,3.07,2.91,2.74,2.87,2.85,2.84,2.83,2.79,2.80,2.79,2.78,2.77,2.76,2.75,2.81,2.73,2.63,2.57,2.48,2.42,2.40,2.33,2.34,2.35,2.44,2.55,2.55,2.62,2.56,2.58,2.53,3.34,3.12,2.97,2.86,2.80,2.81,2.82,2.83,2.77,2.77,2.79,2.79},
   {1.35,1.49,2.36,2.05,1.88,1.78,1.74,1.66,1.67,1.70,2.58,2.42,2.29,2.19,2.14,2.06,2.02,1.99,2.99,2.74,2.51,2.39,2.37,2.25,2.22,2.19,2.14,2.13,2.15,2.21,2.27,2.24,2.24,2.19,2.17,2.20,3.13,2.88,2.66,2.57,2.50,2.41,2.31,2.28,2.28,2.23,2.31,2.39,2.45,2.43,2.43,2.39,2.36,2.34,3.35,2.99,2.83,2.66,2.79,2.77,2.76,2.75,2.71,2.72,2.71,2.70,2.69,2.68,2.67,2.73,2.65,2.55,2.49,2.40,2.34,2.32,2.25,2.26,2.27,2.36,2.47,2.47,2.54,2.48,2.50,2.45,3.26,3.04,2.89,2.78,2.72,2.73,2.74,2.75,2.69,2.69,2.71,2.71},
   {1.31,1.45,2.32,2.01,1.84,1.74,1.70,1.62,1.63,1.66,2.54,2.38,2.25,2.15,2.10,2.02,1.98,1.95,2.95,2.70,2.47,2.35,2.33,2.21,2.18,2.15,2.10,2.09,2.11,2.17,2.23,2.20,2.20,2.15,2.13,2.16,3.09,2.84,2.62,2.53,2.46,2.37,2.27,2.24,2.24,2.19,2.27,2.35,2.41,2.39,2.39,2.35,2.32,2.30,3.31,2.95,2.79,2.62,2.75,2.73,2.72,2.71,2.67,2.68,2.67,2.66,2.65,2.64,2.63,2.69,2.61,2.51,2.45,2.36,2.30,2.28,2.21,2.22,2.23,2.32,2.43,2.43,2.50,2.44,2.46,2.41,3.22,3.00,2.85,2.74,2.68,2.69,2.70,2.71,2.65,2.65,2.67,2.67},
   {1.28,1.42,2.29,1.98,1.81,1.71,1.67,1.59,1.60,1.63,2.51,2.35,2.22,2.12,2.07,1.99,1.95,1.92,2.92,2.67,2.44,2.32,2.30,2.18,2.15,2.12,2.07,2.06,2.08,2.14,2.20,2.17,2.17,2.12,2.10,2.13,3.06,2.81,2.59,2.50,2.43,2.34,2.24,2.21,2.21,2.16,2.24,2.32,2.38,2.36,2.36,2.32,2.29,2.27,3.28,2.92,2.76,2.59,2.72,2.70,2.69,2.68,2.64,2.65,2.64,2.63,2.62,2.61,2.60,2.66,2.58,2.48,2.42,2.33,2.27,2.25,2.18,2.19,2.20,2.29,2.40,2.40,2.47,2.41,2.43,2.38,3.19,2.97,2.82,2.71,2.65,2.66,2.67,2.68,2.62,2.62,2.64,2.64},
   {2.28,2.42,3.29,2.98,2.81,2.71,2.67,2.59,2.60,2.63,3.51,3.35,3.22,3.12,3.07,2.99,2.95,2.92,3.92,3.67,3.44,3.32,3.30,3.18,3.15,3.12,3.07,3.06,3.08,3.14,3.20,3.17,3.17,3.12,3.10,3.13,4.06,3.81,3.59,3.50,3.43,3.34,3.24,3.21,3.21,3.16,3.24,3.32,3.38,3.36,3.36,3.32,3.29,3.27,4.28,3.92,3.76,3.59,3.72,3.70,3.69,3.68,3.64,3.65,3.64,3.63,3.62,3.61,3.60,3.66,3.58,3.48,3.42,3.33,3.27,3.25,3.18,3.19,3.20,3.29,3.40,3.40,3.47,3.41,3.43,3.38,4.19,3.97,3.82,3.71,3.65,3.66,3.67,3.68,3.62,3.62,3.64,3.64},
   {2.03,2.17,3.04,2.73,2.56,2.46,2.42,2.34,2.35,2.38,3.26,3.10,2.97,2.87,2.82,2.74,2.70,2.67,3.67,3.42,3.19,3.07,3.05,2.93,2.90,2.87,2.82,2.81,2.83,2.89,2.95,2.92,2.92,2.87,2.85,2.88,3.81,3.56,3.34,3.25,3.18,3.09,2.99,2.96,2.96,2.91,2.99,3.07,3.13,3.11,3.11,3.07,3.04,3.02,4.03,3.67,3.51,3.34,3.47,3.45,3.44,3.43,3.39,3.40,3.39,3.38,3.37,3.36,3.35,3.41,3.33,3.23,3.17,3.08,3.02,3.00,2.93,2.94,2.95,3.04,3.15,3.15,3.22,3.16,3.18,3.13,3.94,3.72,3.57,3.46,3.40,3.41,3.42,3.43,3.37,3.37,3.39,3.39},
   {1.80,1.94,2.81,2.50,2.33,2.23,2.19,2.11,2.12,2.15,3.03,2.87,2.74,2.64,2.59,2.51,2.47,2.44,3.44,3.19,2.96,2.84,2.82,2.70,2.67,2.64,2.59,2.58,2.60,2.66,2.72,2.69,2.69,2.64,2.62,2.65,3.58,3.33,3.11,3.02,2.95,2.86,2.76,2.73,2.73,2.68,2.76,2.84,2.90,2.88,2.88,2.84,2.81,2.79,3.80,3.44,3.28,3.11,3.24,3.22,3.21,3.20,3.16,3.17,3.16,3.15,3.14,3.13,3.12,3.18,3.10,3.00,2.94,2.85,2.79,2.77,2.70,2.71,2.72,2.81,2.92,2.92,2.99,2.93,2.95,2.90,3.71,3.49,3.34,3.23,3.17,3.18,3.19,3.20,3.14,3.14,3.16,3.16},
   {1.68,1.82,2.69,2.38,2.21,2.11,2.07,1.99,2.00,2.03,2.91,2.75,2.62,2.52,2.47,2.39,2.35,2.32,3.32,3.07,2.84,2.72,2.70,2.58,2.55,2.52,2.47,2.46,2.48,2.54,2.60,2.57,2.57,2.52,2.50,2.53,3.46,3.21,2.99,2.90,2.83,2.74,2.64,2.61,2.61,2.56,2.64,2.72,2.78,2.76,2.76,2.72,2.69,2.67,3.68,3.32,3.16,2.99,3.12,3.10,3.09,3.08,3.04,3.05,3.04,3.03,3.02,3.01,3.00,3.06,2.98,2.88,2.82,2.73,2.67,2.65,2.58,2.59,2.60,2.69,2.80,2.80,2.87,2.81,2.83,2.78,3.59,3.37,3.22,3.11,3.05,3.06,3.07,3.08,3.02,3.02,3.04,3.04},
   {1.66,1.80,2.67,2.36,2.19,2.09,2.05,1.97,1.98,2.01,2.89,2.73,2.60,2.50,2.45,2.37,2.33,2.30,3.30,3.05,2.82,2.70,2.68,2.56,2.53,2.50,2.45,2.44,2.46,2.52,2.58,2.55,2.55,2.50,2.48,2.51,3.44,3.19,2.97,2.88,2.81,2.72,2.62,2.59,2.59,2.54,2.62,2.70,2.76,2.74,2.74,2.70,2.67,2.65,3.66,3.30,3.14,2.97,3.10,3.08,3.07,3.06,3.02,3.03,3.02,3.01,3.00,2.99,2.98,3.04,2.96,2.86,2.80,2.71,2.65,2.63,2.56,2.57,2.58,2.67,2.78,2.78,2.85,2.79,2.81,2.76,3.57,3.35,3.20,3.09,3.03,3.04,3.05,3.06,3.00,3.00,3.02,3.02},
   {1.54,1.68,2.55,2.24,2.07,1.97,1.93,1.85,1.86,1.89,2.77,2.61,2.48,2.38,2.33,2.25,2.21,2.18,3.18,2.93,2.70,2.58,2.56,2.44,2.41,2.38,2.33,2.32,2.34,2.40,2.46,2.43,2.43,2.38,2.36,2.39,3.32,3.07,2.85,2.76,2.69,2.60,2.50,2.47,2.47,2.42,2.50,2.58,2.64,2.62,2.62,2.58,2.55,2.53,3.54,3.18,3.02,2.85,2.98,2.96,2.95,2.94,2.90,2.91,2.90,2.89,2.88,2.87,2.86,2.92,2.84,2.74,2.68,2.59,2.53,2.51,2.44,2.45,2.46,2.55,2.66,2.66,2.73,2.67,2.69,2.64,3.45,3.23,3.08,2.97,2.91,2.92,2.93,2.94,2.88,2.88,2.90,2.90},
   {1.51,1.65,2.52,2.21,2.04,1.94,1.90,1.82,1.83,1.86,2.74,2.58,2.45,2.35,2.30,2.22,2.18,2.15,3.15,2.90,2.67,2.55,2.53,2.41,2.38,2.35,2.30,2.29,2.31,2.37,2.43,2.40,2.40,2.35,2.33,2.36,3.29,3.04,2.82,2.73,2.66,2.57,2.47,2.44,2.44,2.39,2.47,2.55,2.61,2.59,2.59,2.55,2.52,2.50,3.51,3.15,2.99,2.82,2.95,2.93,2.92,2.91,2.87,2.88,2.87,2.86,2.85,2.84,2.83,2.89,2.81,2.71,2.65,2.56,2.50,2.48,2.41,2.42,2.43,2.52,2.63,2.63,2.70,2.64,2.66,2.61,3.42,3.20,3.05,2.94,2.88,2.89,2.90,2.91,2.85,2.85,2.87,2.87},
   {1.48,1.62,2.49,2.18,2.01,1.91,1.87,1.79,1.80,1.83,2.71,2.55,2.42,2.32,2.27,2.19,2.15,2.12,3.12,2.87,2.64,2.52,2.50,2.38,2.35,2.32,2.27,2.26,2.28,2.34,2.40,2.37,2.37,2.32,2.30,2.33,3.26,3.01,2.79,2.70,2.63,2.54,2.44,2.41,2.41,2.36,2.44,2.52,2.58,2.56,2.56,2.52,2.49,2.47,3.48,3.12,2.96,2.79,2.92,2.90,2.89,2.88,2.84,2.85,2.84,2.83,2.82,2.81,2.80,2.86,2.78,2.68,2.62,2.53,2.47,2.45,2.38,2.39,2.40,2.49,2.60,2.60,2.67,2.61,2.63,2.58,3.39,3.17,3.02,2.91,2.85,2.86,2.87,2.88,2.82,2.82,2.84,2.84},
   {1.43,1.57,2.44,2.13,1.96,1.86,1.82,1.74,1.75,1.78,2.66,2.50,2.37,2.27,2.22,2.14,2.10,2.07,3.07,2.82,2.59,2.47,2.45,2.33,2.30,2.27,2.22,2.21,2.23,2.29,2.35,2.32,2.32,2.27,2.25,2.28,3.21,2.96,2.74,2.65,2.58,2.49,2.39,2.36,2.36,2.31,2.39,2.47,2.53,2.51,2.51,2.47,2.44,2.42,3.43,3.07,2.91,2.74,2.87,2.85,2.84,2.83,2.79,2.80,2.79,2.78,2.77,2.76,2.75,2.81,2.73,2.63,2.57,2.48,2.42,2.40,2.33,2.34,2.35,2.44,2.55,2.55,2.62,2.56,2.58,2.53,3.34,3.12,2.97,2.86,2.80,2.81,2.82,2.83,2.77,2.77,2.79,2.79},
   {1.42,1.56,2.43,2.12,1.95,1.85,1.81,1.73,1.74,1.77,2.65,2.49,2.36,2.26,2.21,2.13,2.09,2.06,3.06,2.81,2.58,2.46,2.44,2.32,2.29,2.26,2.21,2.20,2.22,2.28,2.34,2.31,2.31,2.26,2.24,2.27,3.20,2.95,2.73,2.64,2.57,2.48,2.38,2.35,2.35,2.30,2.38,2.46,2.52,2.50,2.50,2.46,2.43,2.41,3.42,3.06,2.90,2.73,2.86,2.84,2.83,2.82,2.78,2.79,2.78,2.77,2.76,2.75,2.74,2.80,2.72,2.62,2.56,2.47,2.41,2.39,2.32,2.33,2.34,2.43,2.54,2.54,2.61,2.55,2.57,2.52,3.33,3.11,2.96,2.85,2.79,2.80,2.81,2.82,2.76,2.76,2.78,2.78},
   {1.44,1.58,2.45,2.14,1.97,1.87,1.83,1.75,1.76,1.79,2.67,2.51,2.38,2.28,2.23,2.15,2.11,2.08,3.08,2.83,2.60,2.48,2.46,2.34,2.31,2.28,2.23,2.22,2.24,2.30,2.36,2.33,2.33,2.28,2.26,2.29,3.22,2.97,2.75,2.66,2.59,2.50,2.40,2.37,2.37,2.32,2.40,2.48,2.54,2.52,2.52,2.48,2.45,2.43,3.44,3.08,2.92,2.75,2.88,2.86,2.85,2.84,2.80,2.81,2.80,2.79,2.78,2.77,2.76,2.82,2.74,2.64,2.58,2.49,2.43,2.41,2.34,2.35,2.36,2.45,2.56,2.56,2.63,2.57,2.59,2.54,3.35,3.13,2.98,2.87,2.81,2.82,2.83,2.84,2.78,2.78,2.80,2.80},
   {1.50,1.64,2.51,2.20,2.03,1.93,1.89,1.81,1.82,1.85,2.73,2.57,2.44,2.34,2.29,2.21,2.17,2.14,3.14,2.89,2.66,2.54,2.52,2.40,2.37,2.34,2.29,2.28,2.30,2.36,2.42,2.39,2.39,2.34,2.32,2.35,3.28,3.03,2.81,2.72,2.65,2.56,2.46,2.43,2.43,2.38,2.46,2.54,2.60,2.58,2.58,2.54,2.51,2.49,3.50,3.14,2.98,2.81,2.94,2.92,2.91,2.90,2.86,2.87,2.86,2.85,2.84,2.83,2.82,2.88,2.80,2.70,2.64,2.55,2.49,2.47,2.40,2.41,2.42,2.51,2.62,2.62,2.69,2.63,2.65,2.60,3.41,3.19,3.04,2.93,2.87,2.88,2.89,2.90,2.84,2.84,2.86,2.86},
   {1.56,1.70,2.57,2.26,2.09,1.99,1.95,1.87,1.88,1.91,2.79,2.63,2.50,2.40,2.35,2.27,2.23,2.20,3.20,2.95,2.72,2.60,2.58,2.46,2.43,2.40,2.35,2.34,2.36,2.42,2.48,2.45,2.45,2.40,2.38,2.41,3.34,3.09,2.87,2.78,2.71,2.62,2.52,2.49,2.49,2.44,2.52,2.60,2.66,2.64,2.64,2.60,2.57,2.55,3.56,3.20,3.04,2.87,3.00,2.98,2.97,2.96,2.92,2.93,2.92,2.91,2.90,2.89,2.88,2.94,2.86,2.76,2.70,2.61,2.55,2.53,2.46,2.47,2.48,2.57,2.68,2.68,2.75,2.69,2.71,2.66,3.47,3.25,3.10,2.99,2.93,2.94,2.95,2.96,2.90,2.90,2.92,2.92},
   {1.53,1.67,2.54,2.23,2.06,1.96,1.92,1.84,1.85,1.88,2.76,2.60,2.47,2.37,2.32,2.24,2.20,2.17,3.17,2.92,2.69,2.57,2.55,2.43,2.40,2.37,2.32,2.31,2.33,2.39,2.45,2.42,2.42,2.37,2.35,2.38,3.31,3.06,2.84,2.75,2.68,2.59,2.49,2.46,2.46,2.41,2.49,2.57,2.63,2.61,2.61,2.57,2.54,2.52,3.53,3.17,3.01,2.84,2.97,2.95,2.94,2.93,2.89,2.90,2.89,2.88,2.87,2.86,2.85,2.91,2.83,2.73,2.67,2.58,2.52,2.50,2.43,2.44,2.45,2.54,2.65,2.65,2.72,2.66,2.68,2.63,3.44,3.22,3.07,2.96,2.90,2.91,2.92,2.93,2.87,2.87,2.89,2.89},
   {1.53,1.67,2.54,2.23,2.06,1.96,1.92,1.84,1.85,1.88,2.76,2.60,2.47,2.37,2.32,2.24,2.20,2.17,3.17,2.92,2.69,2.57,2.55,2.43,2.40,2.37,2.32,2.31,2.33,2.39,2.45,2.42,2.42,2.37,2.35,2.38,3.31,3.06,2.84,2.75,2.68,2.59,2.49,2.46,2.46,2.41,2.49,2.57,2.63,2.61,2.61,2.57,2.54,2.52,3.53,3.17,3.01,2.84,2.97,2.95,2.94,2.93,2.89,2.90,2.89,2.88,2.87,2.86,2.85,2.91,2.83,2.73,2.67,2.58,2.52,2.50,2.43,2.44,2.45,2.54,2.65,2.65,2.72,2.66,2.68,2.63,3.44,3.22,3.07,2.96,2.90,2.91,2.92,2.93,2.87,2.87,2.89,2.89},
   {1.48,1.62,2.49,2.18,2.01,1.91,1.87,1.79,1.80,1.83,2.71,2.55,2.42,2.32,2.27,2.19,2.15,2.12,3.12,2.87,2.64,2.52,2.50,2.38,2.35,2.32,2.27,2.26,2.28,2.34,2.40,2.37,2.37,2.32,2.30,2.33,3.26,3.01,2.79,2.70,2.63,2.54,2.44,2.41,2.41,2.36,2.44,2.52,2.58,2.56,2.56,2.52,2.49,2.47,3.48,3.12,2.96,2.79,2.92,2.90,2.89,2.88,2.84,2.85,2.84,2.83,2.82,2.81,2.80,2.86,2.78,2.68,2.62,2.53,2.47,2.45,2.38,2.39,2.40,2.49,2.60,2.60,2.67,2.61,2.63,2.58,3.39,3.17,3.02,2.91,2.85,2.86,2.87,2.88,2.82,2.82,2.84,2.84},
   {1.46,1.60,2.47,2.16,1.99,1.89,1.85,1.77,1.78,1.81,2.69,2.53,2.40,2.30,2.25,2.17,2.13,2.10,3.10,2.85,2.62,2.50,2.48,2.36,2.33,2.30,2.25,2.24,2.26,2.32,2.38,2.35,2.35,2.30,2.28,2.31,3.24,2.99,2.77,2.68,2.61,2.52,2.42,2.39,2.39,2.34,2.42,2.50,2.56,2.54,2.54,2.50,2.47,2.45,3.46,3.10,2.94,2.77,2.90,2.88,2.87,2.86,2.82,2.83,2.82,2.81,2.80,2.79,2.78,2.84,2.76,2.66,2.60,2.51,2.45,2.43,2.36,2.37,2.38,2.47,2.58,2.58,2.65,2.59,2.61,2.56,3.37,3.15,3.00,2.89,2.83,2.84,2.85,2.86,2.80,2.80,2.82,2.82},
   {1.49,1.63,2.50,2.19,2.02,1.92,1.88,1.80,1.81,1.84,2.72,2.56,2.43,2.33,2.28,2.20,2.16,2.13,3.13,2.88,2.65,2.53,2.51,2.39,2.36,2.33,2.28,2.27,2.29,2.35,2.41,2.38,2.38,2.33,2.31,2.34,3.27,3.02,2.80,2.71,2.64,2.55,2.45,2.42,2.42,2.37,2.45,2.53,2.59,2.57,2.57,2.53,2.50,2.48,3.49,3.13,2.97,2.80,2.93,2.91,2.90,2.89,2.85,2.86,2.85,2.84,2.83,2.82,2.81,2.87,2.79,2.69,2.63,2.54,2.48,2.46,2.39,2.40,2.41,2.50,2.61,2.61,2.68,2.62,2.64,2.59,3.40,3.18,3.03,2.92,2.86,2.87,2.88,2.89,2.83,2.83,2.85,2.85},
   {2.42,2.56,3.43,3.12,2.95,2.85,2.81,2.73,2.74,2.77,3.65,3.49,3.36,3.26,3.21,3.13,3.09,3.06,4.06,3.81,3.58,3.46,3.44,3.32,3.29,3.26,3.21,3.20,3.22,3.28,3.34,3.31,3.31,3.26,3.24,3.27,4.20,3.95,3.73,3.64,3.57,3.48,3.38,3.35,3.35,3.30,3.38,3.46,3.52,3.50,3.50,3.46,3.43,3.41,4.42,4.06,3.90,3.73,3.86,3.84,3.83,3.82,3.78,3.79,3.78,3.77,3.76,3.75,3.74,3.80,3.72,3.62,3.56,3.47,3.41,3.39,3.32,3.33,3.34,3.43,3.54,3.54,3.61,3.55,3.57,3.52,4.33,4.11,3.96,3.85,3.79,3.80,3.81,3.82,3.76,3.76,3.78,3.78},
   {2.17,2.31,3.18,2.87,2.70,2.60,2.56,2.48,2.49,2.52,3.40,3.24,3.11,3.01,2.96,2.88,2.84,2.81,3.81,3.56,3.33,3.21,3.19,3.07,3.04,3.01,2.96,2.95,2.97,3.03,3.09,3.06,3.06,3.01,2.99,3.02,3.95,3.70,3.48,3.39,3.32,3.23,3.13,3.10,3.10,3.05,3.13,3.21,3.27,3.25,3.25,3.21,3.18,3.16,4.17,3.81,3.65,3.48,3.61,3.59,3.58,3.57,3.53,3.54,3.53,3.52,3.51,3.50,3.49,3.55,3.47,3.37,3.31,3.22,3.16,3.14,3.07,3.08,3.09,3.18,3.29,3.29,3.36,3.30,3.32,3.27,4.08,3.86,3.71,3.60,3.54,3.55,3.56,3.57,3.51,3.51,3.53,3.53},
   {1.95,2.09,2.96,2.65,2.48,2.38,2.34,2.26,2.27,2.30,3.18,3.02,2.89,2.79,2.74,2.66,2.62,2.59,3.59,3.34,3.11,2.99,2.97,2.85,2.82,2.79,2.74,2.73,2.75,2.81,2.87,2.84,2.84,2.79,2.77,2.80,3.73,3.48,3.26,3.17,3.10,3.01,2.91,2.88,2.88,2.83,2.91,2.99,3.05,3.03,3.03,2.99,2.96,2.94,3.95,3.59,3.43,3.26,3.39,3.37,3.36,3.35,3.31,3.32,3.31,3.30,3.29,3.28,3.27,3.33,3.25,3.15,3.09,3.00,2.94,2.92,2.85,2.86,2.87,2.96,3.07,3.07,3.14,3.08,3.10,3.05,3.86,3.64,3.49,3.38,3.32,3.33,3.34,3.35,3.29,3.29,3.31,3.31},
   {1.86,2.00,2.87,2.56,2.39,2.29,2.25,2.17,2.18,2.21,3.09,2.93,2.80,2.70,2.65,2.57,2.53,2.50,3.50,3.25,3.02,2.90,2.88,2.76,2.73,2.70,2.65,2.64,2.66,2.72,2.78,2.75,2.75,2.70,2.68,2.71,3.64,3.39,3.17,3.08,3.01,2.92,2.82,2.79,2.79,2.74,2.82,2.90,2.96,2.94,2.94,2.90,2.87,2.85,3.86,3.50,3.34,3.17,3.30,3.28,3.27,3.26,3.22,3.23,3.22,3.21,3.20,3.19,3.18,3.24,3.16,3.06,3.00,2.91,2.85,2.83,2.76,2.77,2.78,2.87,2.98,2.98,3.05,2.99,3.01,2.96,3.77,3.55,3.40,3.29,3.23,3.24,3.25,3.26,3.20,3.20,3.22,3.22},
   {1.79,1.93,2.80,2.49,2.32,2.22,2.18,2.10,2.11,2.14,3.02,2.86,2.73,2.63,2.58,2.50,2.46,2.43,3.43,3.18,2.95,2.83,2.81,2.69,2.66,2.63,2.58,2.57,2.59,2.65,2.71,2.68,2.68,2.63,2.61,2.64,3.57,3.32,3.10,3.01,2.94,2.85,2.75,2.72,2.72,2.67,2.75,2.83,2.89,2.87,2.87,2.83,2.80,2.78,3.79,3.43,3.27,3.10,3.23,3.21,3.20,3.19,3.15,3.16,3.15,3.14,3.13,3.12,3.11,3.17,3.09,2.99,2.93,2.84,2.78,2.76,2.69,2.70,2.71,2.80,2.91,2.91,2.98,2.92,2.94,2.89,3.70,3.48,3.33,3.22,3.16,3.17,3.18,3.19,3.13,3.13,3.15,3.15},
   {1.70,1.84,2.71,2.40,2.23,2.13,2.09,2.01,2.02,2.05,2.93,2.77,2.64,2.54,2.49,2.41,2.37,2.34,3.34,3.09,2.86,2.74,2.72,2.60,2.57,2.54,2.49,2.48,2.50,2.56,2.62,2.59,2.59,2.54,2.52,2.55,3.48,3.23,3.01,2.92,2.85,2.76,2.66,2.63,2.63,2.58,2.66,2.74,2.80,2.78,2.78,2.74,2.71,2.69,3.70,3.34,3.18,3.01,3.14,3.12,3.11,3.10,3.06,3.07,3.06,3.05,3.04,3.03,3.02,3.08,3.00,2.90,2.84,2.75,2.69,2.67,2.60,2.61,2.62,2.71,2.82,2.82,2.89,2.83,2.85,2.80,3.61,3.39,3.24,3.13,3.07,3.08,3.09,3.10,3.04,3.04,3.06,3.06},
   {1.60,1.74,2.61,2.30,2.13,2.03,1.99,1.91,1.92,1.95,2.83,2.67,2.54,2.44,2.39,2.31,2.27,2.24,3.24,2.99,2.76,2.64,2.62,2.50,2.47,2.44,2.39,2.38,2.40,2.46,2.52,2.49,2.49,2.44,2.42,2.45,3.38,3.13,2.91,2.82,2.75,2.66,2.56,2.53,2.53,2.48,2.56,2.64,2.70,2.68,2.68,2.64,2.61,2.59,3.60,3.24,3.08,2.91,3.04,3.02,3.01,3.00,2.96,2.97,2.96,2.95,2.94,2.93,2.92,2.98,2.90,2.80,2.74,2.65,2.59,2.57,2.50,2.51,2.52,2.61,2.72,2.72,2.79,2.73,2.75,2.70,3.51,3.29,3.14,3.03,2.97,2.98,2.99,3.00,2.94,2.94,2.96,2.96},
   {1.57,1.71,2.58,2.27,2.10,2.00,1.96,1.88,1.89,1.92,2.80,2.64,2.51,2.41,2.36,2.28,2.24,2.21,3.21,2.96,2.73,2.61,2.59,2.47,2.44,2.41,2.36,2.35,2.37,2.43,2.49,2.46,2.46,2.41,2.39,2.42,3.35,3.10,2.88,2.79,2.72,2.63,2.53,2.50,2.50,2.45,2.53,2.61,2.67,2.65,2.65,2.61,2.58,2.56,3.57,3.21,3.05,2.88,3.01,2.99,2.98,2.97,2.93,2.94,2.93,2.92,2.91,2.90,2.89,2.95,2.87,2.77,2.71,2.62,2.56,2.54,2.47,2.48,2.49,2.58,2.69,2.69,2.76,2.70,2.72,2.67,3.48,3.26,3.11,3.00,2.94,2.95,2.96,2.97,2.91,2.91,2.93,2.93},
   {1.57,1.71,2.58,2.27,2.10,2.00,1.96,1.88,1.89,1.92,2.80,2.64,2.51,2.41,2.36,2.28,2.24,2.21,3.21,2.96,2.73,2.61,2.59,2.47,2.44,2.41,2.36,2.35,2.37,2.43,2.49,2.46,2.46,2.41,2.39,2.42,3.35,3.10,2.88,2.79,2.72,2.63,2.53,2.50,2.50,2.45,2.53,2.61,2.67,2.65,2.65,2.61,2.58,2.56,3.57,3.21,3.05,2.88,3.01,2.99,2.98,2.97,2.93,2.94,2.93,2.92,2.91,2.90,2.89,2.95,2.87,2.77,2.71,2.62,2.56,2.54,2.47,2.48,2.49,2.58,2.69,2.69,2.76,2.70,2.72,2.67,3.48,3.26,3.11,3.00,2.94,2.95,2.96,2.97,2.91,2.91,2.93,2.93},
   {1.52,1.66,2.53,2.22,2.05,1.95,1.91,1.83,1.84,1.87,2.75,2.59,2.46,2.36,2.31,2.23,2.19,2.16,3.16,2.91,2.68,2.56,2.54,2.42,2.39,2.36,2.31,2.30,2.32,2.38,2.44,2.41,2.41,2.36,2.34,2.37,3.30,3.05,2.83,2.74,2.67,2.58,2.48,2.45,2.45,2.40,2.48,2.56,2.62,2.60,2.60,2.56,2.53,2.51,3.52,3.16,3.00,2.83,2.96,2.94,2.93,2.92,2.88,2.89,2.88,2.87,2.86,2.85,2.84,2.90,2.82,2.72,2.66,2.57,2.51,2.49,2.42,2.43,2.44,2.53,2.64,2.64,2.71,2.65,2.67,2.62,3.43,3.21,3.06,2.95,2.89,2.90,2.91,2.92,2.86,2.86,2.88,2.88},
   {1.60,1.74,2.61,2.30,2.13,2.03,1.99,1.91,1.92,1.95,2.83,2.67,2.54,2.44,2.39,2.31,2.27,2.24,3.24,2.99,2.76,2.64,2.62,2.50,2.47,2.44,2.39,2.38,2.40,2.46,2.52,2.49,2.49,2.44,2.42,2.45,3.38,3.13,2.91,2.82,2.75,2.66,2.56,2.53,2.53,2.48,2.56,2.64,2.70,2.68,2.68,2.64,2.61,2.59,3.60,3.24,3.08,2.91,3.04,3.02,3.01,3.00,2.96,2.97,2.96,2.95,2.94,2.93,2.92,2.98,2.90,2.80,2.74,2.65,2.59,2.57,2.50,2.51,2.52,2.61,2.72,2.72,2.79,2.73,2.75,2.70,3.51,3.29,3.14,3.03,2.97,2.98,2.99,3.00,2.94,2.94,2.96,2.96},
   {1.68,1.82,2.69,2.38,2.21,2.11,2.07,1.99,2.00,2.03,2.91,2.75,2.62,2.52,2.47,2.39,2.35,2.32,3.32,3.07,2.84,2.72,2.70,2.58,2.55,2.52,2.47,2.46,2.48,2.54,2.60,2.57,2.57,2.52,2.50,2.53,3.46,3.21,2.99,2.90,2.83,2.74,2.64,2.61,2.61,2.56,2.64,2.72,2.78,2.76,2.76,2.72,2.69,2.67,3.68,3.32,3.16,2.99,3.12,3.10,3.09,3.08,3.04,3.05,3.04,3.03,3.02,3.01,3.00,3.06,2.98,2.88,2.82,2.73,2.67,2.65,2.58,2.59,2.60,2.69,2.80,2.80,2.87,2.81,2.83,2.78,3.59,3.37,3.22,3.11,3.05,3.06,3.07,3.08,3.02,3.02,3.04,3.04},
   {1.74,1.88,2.75,2.44,2.27,2.17,2.13,2.05,2.06,2.09,2.97,2.81,2.68,2.58,2.53,2.45,2.41,2.38,3.38,3.13,2.90,2.78,2.76,2.64,2.61,2.58,2.53,2.52,2.54,2.60,2.66,2.63,2.63,2.58,2.56,2.59,3.52,3.27,3.05,2.96,2.89,2.80,2.70,2.67,2.67,2.62,2.70,2.78,2.84,2.82,2.82,2.78,2.75,2.73,3.74,3.38,3.22,3.05,3.18,3.16,3.15,3.14,3.10,3.11,3.10,3.09,3.08,3.07,3.06,3.12,3.04,2.94,2.88,2.79,2.73,2.71,2.64,2.65,2.66,2.75,2.86,2.86,2.93,2.87,2.89,2.84,3.65,3.43,3.28,3.17,3.11,3.12,3.13,3.14,3.08,3.08,3.10,3.10},
   {1.72,1.86,2.73,2.42,2.25,2.15,2.11,2.03,2.04,2.07,2.95,2.79,2.66,2.56,2.51,2.43,2.39,2.36,3.36,3.11,2.88,2.76,2.74,2.62,2.59,2.56,2.51,2.50,2.52,2.58,2.64,2.61,2.61,2.56,2.54,2.57,3.50,3.25,3.03,2.94,2.87,2.78,2.68,2.65,2.65,2.60,2.68,2.76,2.82,2.80,2.80,2.76,2.73,2.71,3.72,3.36,3.20,3.03,3.16,3.14,3.13,3.12,3.08,3.09,3.08,3.07,3.06,3.05,3.04,3.10,3.02,2.92,2.86,2.77,2.71,2.69,2.62,2.63,2.64,2.73,2.84,2.84,2.91,2.85,2.87,2.82,3.63,3.41,3.26,3.15,3.09,3.10,3.11,3.12,3.06,3.06,3.08,3.08},
   {1.72,1.86,2.73,2.42,2.25,2.15,2.11,2.03,2.04,2.07,2.95,2.79,2.66,2.56,2.51,2.43,2.39,2.36,3.36,3.11,2.88,2.76,2.74,2.62,2.59,2.56,2.51,2.50,2.52,2.58,2.64,2.61,2.61,2.56,2.54,2.57,3.50,3.25,3.03,2.94,2.87,2.78,2.68,2.65,2.65,2.60,2.68,2.76,2.82,2.80,2.80,2.76,2.73,2.71,3.72,3.36,3.20,3.03,3.16,3.14,3.13,3.12,3.08,3.09,3.08,3.07,3.06,3.05,3.04,3.10,3.02,2.92,2.86,2.77,2.71,2.69,2.62,2.63,2.64,2.73,2.84,2.84,2.91,2.85,2.87,2.82,3.63,3.41,3.26,3.15,3.09,3.10,3.11,3.12,3.06,3.06,3.08,3.08},
   {1.68,1.82,2.69,2.38,2.21,2.11,2.07,1.99,2.00,2.03,2.91,2.75,2.62,2.52,2.47,2.39,2.35,2.32,3.32,3.07,2.84,2.72,2.70,2.58,2.55,2.52,2.47,2.46,2.48,2.54,2.60,2.57,2.57,2.52,2.50,2.53,3.46,3.21,2.99,2.90,2.83,2.74,2.64,2.61,2.61,2.56,2.64,2.72,2.78,2.76,2.76,2.72,2.69,2.67,3.68,3.32,3.16,2.99,3.12,3.10,3.09,3.08,3.04,3.05,3.04,3.03,3.02,3.01,3.00,3.06,2.98,2.88,2.82,2.73,2.67,2.65,2.58,2.59,2.60,2.69,2.80,2.80,2.87,2.81,2.83,2.78,3.59,3.37,3.22,3.11,3.05,3.06,3.07,3.08,3.02,3.02,3.04,3.04},
   {1.65,1.79,2.66,2.35,2.18,2.08,2.04,1.96,1.97,2.00,2.88,2.72,2.59,2.49,2.44,2.36,2.32,2.29,3.29,3.04,2.81,2.69,2.67,2.55,2.52,2.49,2.44,2.43,2.45,2.51,2.57,2.54,2.54,2.49,2.47,2.50,3.43,3.18,2.96,2.87,2.80,2.71,2.61,2.58,2.58,2.53,2.61,2.69,2.75,2.73,2.73,2.69,2.66,2.64,3.65,3.29,3.13,2.96,3.09,3.07,3.06,3.05,3.01,3.02,3.01,3.00,2.99,2.98,2.97,3.03,2.95,2.85,2.79,2.70,2.64,2.62,2.55,2.56,2.57,2.66,2.77,2.77,2.84,2.78,2.80,2.75,3.56,3.34,3.19,3.08,3.02,3.03,3.04,3.05,2.99,2.99,3.01,3.01},
   {1.63,1.77,2.64,2.33,2.16,2.06,2.02,1.94,1.95,1.98,2.86,2.70,2.57,2.47,2.42,2.34,2.30,2.27,3.27,3.02,2.79,2.67,2.65,2.53,2.50,2.47,2.42,2.41,2.43,2.49,2.55,2.52,2.52,2.47,2.45,2.48,3.41,3.16,2.94,2.85,2.78,2.69,2.59,2.56,2.56,2.51,2.59,2.67,2.73,2.71,2.71,2.67,2.64,2.62,3.63,3.27,3.11,2.94,3.07,3.05,3.04,3.03,2.99,3.00,2.99,2.98,2.97,2.96,2.95,3.01,2.93,2.83,2.77,2.68,2.62,2.60,2.53,2.54,2.55,2.64,2.75,2.75,2.82,2.76,2.78,2.73,3.54,3.32,3.17,3.06,3.00,3.01,3.02,3.03,2.97,2.97,2.99,2.99},
   {2.64,2.78,3.65,3.34,3.17,3.07,3.03,2.95,2.96,2.99,3.87,3.71,3.58,3.48,3.43,3.35,3.31,3.28,4.28,4.03,3.80,3.68,3.66,3.54,3.51,3.48,3.43,3.42,3.44,3.50,3.56,3.53,3.53,3.48,3.46,3.49,4.42,4.17,3.95,3.86,3.79,3.70,3.60,3.57,3.57,3.52,3.60,3.68,3.74,3.72,3.72,3.68,3.65,3.63,4.64,4.28,4.12,3.95,4.08,4.06,4.05,4.04,4.00,4.01,4.00,3.99,3.98,3.97,3.96,4.02,3.94,3.84,3.78,3.69,3.63,3.61,3.54,3.55,3.56,3.65,3.76,3.76,3.83,3.77,3.79,3.74,4.55,4.33,4.18,4.07,4.01,4.02,4.03,4.04,3.98,3.98,4.00,4.00},
   {2.28,2.42,3.29,2.98,2.81,2.71,2.67,2.59,2.60,2.63,3.51,3.35,3.22,3.12,3.07,2.99,2.95,2.92,3.92,3.67,3.44,3.32,3.30,3.18,3.15,3.12,3.07,3.06,3.08,3.14,3.20,3.17,3.17,3.12,3.10,3.13,4.06,3.81,3.59,3.50,3.43,3.34,3.24,3.21,3.21,3.16,3.24,3.32,3.38,3.36,3.36,3.32,3.29,3.27,4.28,3.92,3.76,3.59,3.72,3.70,3.69,3.68,3.64,3.65,3.64,3.63,3.62,3.61,3.60,3.66,3.58,3.48,3.42,3.33,3.27,3.25,3.18,3.19,3.20,3.29,3.40,3.40,3.47,3.41,3.43,3.38,4.19,3.97,3.82,3.71,3.65,3.66,3.67,3.68,3.62,3.62,3.64,3.64},
   {2.12,2.26,3.13,2.82,2.65,2.55,2.51,2.43,2.44,2.47,3.35,3.19,3.06,2.96,2.91,2.83,2.79,2.76,3.76,3.51,3.28,3.16,3.14,3.02,2.99,2.96,2.91,2.90,2.92,2.98,3.04,3.01,3.01,2.96,2.94,2.97,3.90,3.65,3.43,3.34,3.27,3.18,3.08,3.05,3.05,3.00,3.08,3.16,3.22,3.20,3.20,3.16,3.13,3.11,4.12,3.76,3.60,3.43,3.56,3.54,3.53,3.52,3.48,3.49,3.48,3.47,3.46,3.45,3.44,3.50,3.42,3.32,3.26,3.17,3.11,3.09,3.02,3.03,3.04,3.13,3.24,3.24,3.31,3.25,3.27,3.22,4.03,3.81,3.66,3.55,3.49,3.50,3.51,3.52,3.46,3.46,3.48,3.48},
   {1.95,2.09,2.96,2.65,2.48,2.38,2.34,2.26,2.27,2.30,3.18,3.02,2.89,2.79,2.74,2.66,2.62,2.59,3.59,3.34,3.11,2.99,2.97,2.85,2.82,2.79,2.74,2.73,2.75,2.81,2.87,2.84,2.84,2.79,2.77,2.80,3.73,3.48,3.26,3.17,3.10,3.01,2.91,2.88,2.88,2.83,2.91,2.99,3.05,3.03,3.03,2.99,2.96,2.94,3.95,3.59,3.43,3.26,3.39,3.37,3.36,3.35,3.31,3.32,3.31,3.30,3.29,3.28,3.27,3.33,3.25,3.15,3.09,3.00,2.94,2.92,2.85,2.86,2.87,2.96,3.07,3.07,3.14,3.08,3.10,3.05,3.86,3.64,3.49,3.38,3.32,3.33,3.34,3.35,3.29,3.29,3.31,3.31},
   {2.08,2.22,3.09,2.78,2.61,2.51,2.47,2.39,2.40,2.43,3.31,3.15,3.02,2.92,2.87,2.79,2.75,2.72,3.72,3.47,3.24,3.12,3.10,2.98,2.95,2.92,2.87,2.86,2.88,2.94,3.00,2.97,2.97,2.92,2.90,2.93,3.86,3.61,3.39,3.30,3.23,3.14,3.04,3.01,3.01,2.96,3.04,3.12,3.18,3.16,3.16,3.12,3.09,3.07,4.08,3.72,3.56,3.39,3.52,3.50,3.49,3.48,3.44,3.45,3.44,3.43,3.42,3.41,3.40,3.46,3.38,3.28,3.22,3.13,3.07,3.05,2.98,2.99,3.00,3.09,3.20,3.20,3.27,3.21,3.23,3.18,3.99,3.77,3.62,3.51,3.45,3.46,3.47,3.48,3.42,3.42,3.44,3.44},
   {2.06,2.20,3.07,2.76,2.59,2.49,2.45,2.37,2.38,2.41,3.29,3.13,3.00,2.90,2.85,2.77,2.73,2.70,3.70,3.45,3.22,3.10,3.08,2.96,2.93,2.90,2.85,2.84,2.86,2.92,2.98,2.95,2.95,2.90,2.88,2.91,3.84,3.59,3.37,3.28,3.21,3.12,3.02,2.99,2.99,2.94,3.02,3.10,3.16,3.14,3.14,3.10,3.07,3.05,4.06,3.70,3.54,3.37,3.50,3.48,3.47,3.46,3.42,3.43,3.42,3.41,3.40,3.39,3.38,3.44,3.36,3.26,3.20,3.11,3.05,3.03,2.96,2.97,2.98,3.07,3.18,3.18,3.25,3.19,3.21,3.16,3.97,3.75,3.60,3.49,3.43,3.44,3.45,3.46,3.40,3.40,3.42,3.42},
   {2.05,2.19,3.06,2.75,2.58,2.48,2.44,2.36,2.37,2.40,3.28,3.12,2.99,2.89,2.84,2.76,2.72,2.69,3.69,3.44,3.21,3.09,3.07,2.95,2.92,2.89,2.84,2.83,2.85,2.91,2.97,2.94,2.94,2.89,2.87,2.90,3.83,3.58,3.36,3.27,3.20,3.11,3.01,2.98,2.98,2.93,3.01,3.09,3.15,3.13,3.13,3.09,3.06,3.04,4.05,3.69,3.53,3.36,3.49,3.47,3.46,3.45,3.41,3.42,3.41,3.40,3.39,3.38,3.37,3.43,3.35,3.25,3.19,3.10,3.04,3.02,2.95,2.96,2.97,3.06,3.17,3.17,3.24,3.18,3.20,3.15,3.96,3.74,3.59,3.48,3.42,3.43,3.44,3.45,3.39,3.39,3.41,3.41},
   {2.04,2.18,3.05,2.74,2.57,2.47,2.43,2.35,2.36,2.39,3.27,3.11,2.98,2.88,2.83,2.75,2.71,2.68,3.68,3.43,3.20,3.08,3.06,2.94,2.91,2.88,2.83,2.82,2.84,2.90,2.96,2.93,2.93,2.88,2.86,2.89,3.82,3.57,3.35,3.26,3.19,3.10,3.00,2.97,2.97,2.92,3.00,3.08,3.14,3.12,3.12,3.08,3.05,3.03,4.04,3.68,3.52,3.35,3.48,3.46,3.45,3.44,3.40,3.41,3.40,3.39,3.38,3.37,3.36,3.42,3.34,3.24,3.18,3.09,3.03,3.01,2.94,2.95,2.96,3.05,3.16,3.16,3.23,3.17,3.19,3.14,3.95,3.73,3.58,3.47,3.41,3.42,3.43,3.44,3.38,3.38,3.40,3.40},
   {2.00,2.14,3.01,2.70,2.53,2.43,2.39,2.31,2.32,2.35,3.23,3.07,2.94,2.84,2.79,2.71,2.67,2.64,3.64,3.39,3.16,3.04,3.02,2.90,2.87,2.84,2.79,2.78,2.80,2.86,2.92,2.89,2.89,2.84,2.82,2.85,3.78,3.53,3.31,3.22,3.15,3.06,2.96,2.93,2.93,2.88,2.96,3.04,3.10,3.08,3.08,3.04,3.01,2.99,4.00,3.64,3.48,3.31,3.44,3.42,3.41,3.40,3.36,3.37,3.36,3.35,3.34,3.33,3.32,3.38,3.30,3.20,3.14,3.05,2.99,2.97,2.90,2.91,2.92,3.01,3.12,3.12,3.19,3.13,3.15,3.10,3.91,3.69,3.54,3.43,3.37,3.38,3.39,3.40,3.34,3.34,3.36,3.36},
   {2.01,2.15,3.02,2.71,2.54,2.44,2.40,2.32,2.33,2.36,3.24,3.08,2.95,2.85,2.80,2.72,2.68,2.65,3.65,3.40,3.17,3.05,3.03,2.91,2.88,2.85,2.80,2.79,2.81,2.87,2.93,2.90,2.90,2.85,2.83,2.86,3.79,3.54,3.32,3.23,3.16,3.07,2.97,2.94,2.94,2.89,2.97,3.05,3.11,3.09,3.09,3.05,3.02,3.00,4.01,3.65,3.49,3.32,3.45,3.43,3.42,3.41,3.37,3.38,3.37,3.36,3.35,3.34,3.33,3.39,3.31,3.21,3.15,3.06,3.00,2.98,2.91,2.92,2.93,3.02,3.13,3.13,3.20,3.14,3.16,3.11,3.92,3.70,3.55,3.44,3.38,3.39,3.40,3.41,3.35,3.35,3.37,3.37},
   {2.00,2.14,3.01,2.70,2.53,2.43,2.39,2.31,2.32,2.35,3.23,3.07,2.94,2.84,2.79,2.71,2.67,2.64,3.64,3.39,3.16,3.04,3.02,2.90,2.87,2.84,2.79,2.78,2.80,2.86,2.92,2.89,2.89,2.84,2.82,2.85,3.78,3.53,3.31,3.22,3.15,3.06,2.96,2.93,2.93,2.88,2.96,3.04,3.10,3.08,3.08,3.04,3.01,2.99,4.00,3.64,3.48,3.31,3.44,3.42,3.41,3.40,3.36,3.37,3.36,3.35,3.34,3.33,3.32,3.38,3.30,3.20,3.14,3.05,2.99,2.97,2.90,2.91,2.92,3.01,3.12,3.12,3.19,3.13,3.15,3.10,3.91,3.69,3.54,3.43,3.37,3.38,3.39,3.40,3.34,3.34,3.36,3.36},
   {1.99,2.13,3.00,2.69,2.52,2.42,2.38,2.30,2.31,2.34,3.22,3.06,2.93,2.83,2.78,2.70,2.66,2.63,3.63,3.38,3.15,3.03,3.01,2.89,2.86,2.83,2.78,2.77,2.79,2.85,2.91,2.88,2.88,2.83,2.81,2.84,3.77,3.52,3.30,3.21,3.14,3.05,2.95,2.92,2.92,2.87,2.95,3.03,3.09,3.07,3.07,3.03,3.00,2.98,3.99,3.63,3.47,3.30,3.43,3.41,3.40,3.39,3.35,3.36,3.35,3.34,3.33,3.32,3.31,3.37,3.29,3.19,3.13,3.04,2.98,2.96,2.89,2.90,2.91,3.00,3.11,3.11,3.18,3.12,3.14,3.09,3.90,3.68,3.53,3.42,3.36,3.37,3.38,3.39,3.33,3.33,3.35,3.35},
   {1.98,2.12,2.99,2.68,2.51,2.41,2.37,2.29,2.30,2.33,3.21,3.05,2.92,2.82,2.77,2.69,2.65,2.62,3.62,3.37,3.14,3.02,3.00,2.88,2.85,2.82,2.77,2.76,2.78,2.84,2.90,2.87,2.87,2.82,2.80,2.83,3.76,3.51,3.29,3.20,3.13,3.04,2.94,2.91,2.91,2.86,2.94,3.02,3.08,3.06,3.06,3.02,2.99,2.97,3.98,3.62,3.46,3.29,3.42,3.40,3.39,3.38,3.34,3.35,3.34,3.33,3.32,3.31,3.30,3.36,3.28,3.18,3.12,3.03,2.97,2.95,2.88,2.89,2.90,2.99,3.10,3.10,3.17,3.11,3.13,3.08,3.89,3.67,3.52,3.41,3.35,3.36,3.37,3.38,3.32,3.32,3.34,3.34},
   {1.97,2.11,2.98,2.67,2.50,2.40,2.36,2.28,2.29,2.32,3.20,3.04,2.91,2.81,2.76,2.68,2.64,2.61,3.61,3.36,3.13,3.01,2.99,2.87,2.84,2.81,2.76,2.75,2.77,2.83,2.89,2.86,2.86,2.81,2.79,2.82,3.75,3.50,3.28,3.19,3.12,3.03,2.93,2.90,2.90,2.85,2.93,3.01,3.07,3.05,3.05,3.01,2.98,2.96,3.97,3.61,3.45,3.28,3.41,3.39,3.38,3.37,3.33,3.34,3.33,3.32,3.31,3.30,3.29,3.35,3.27,3.17,3.11,3.02,2.96,2.94,2.87,2.88,2.89,2.98,3.09,3.09,3.16,3.10,3.12,3.07,3.88,3.66,3.51,3.40,3.34,3.35,3.36,3.37,3.31,3.31,3.33,3.33},
   {1.96,2.10,2.97,2.66,2.49,2.39,2.35,2.27,2.28,2.31,3.19,3.03,2.90,2.80,2.75,2.67,2.63,2.60,3.60,3.35,3.12,3.00,2.98,2.86,2.83,2.80,2.75,2.74,2.76,2.82,2.88,2.85,2.85,2.80,2.78,2.81,3.74,3.49,3.27,3.18,3.11,3.02,2.92,2.89,2.89,2.84,2.92,3.00,3.06,3.04,3.04,3.00,2.97,2.95,3.96,3.60,3.44,3.27,3.40,3.38,3.37,3.36,3.32,3.33,3.32,3.31,3.30,3.29,3.28,3.34,3.26,3.16,3.10,3.01,2.95,2.93,2.86,2.87,2.88,2.97,3.08,3.08,3.15,3.09,3.11,3.06,3.87,3.65,3.50,3.39,3.33,3.34,3.35,3.36,3.30,3.30,3.32,3.32},
   {2.02,2.16,3.03,2.72,2.55,2.45,2.41,2.33,2.34,2.37,3.25,3.09,2.96,2.86,2.81,2.73,2.69,2.66,3.66,3.41,3.18,3.06,3.04,2.92,2.89,2.86,2.81,2.80,2.82,2.88,2.94,2.91,2.91,2.86,2.84,2.87,3.80,3.55,3.33,3.24,3.17,3.08,2.98,2.95,2.95,2.90,2.98,3.06,3.12,3.10,3.10,3.06,3.03,3.01,4.02,3.66,3.50,3.33,3.46,3.44,3.43,3.42,3.38,3.39,3.38,3.37,3.36,3.35,3.34,3.40,3.32,3.22,3.16,3.07,3.01,2.99,2.92,2.93,2.94,3.03,3.14,3.14,3.21,3.15,3.17,3.12,3.93,3.71,3.56,3.45,3.39,3.40,3.41,3.42,3.36,3.36,3.38,3.38},
   {1.94,2.08,2.95,2.64,2.47,2.37,2.33,2.25,2.26,2.29,3.17,3.01,2.88,2.78,2.73,2.65,2.61,2.58,3.58,3.33,3.10,2.98,2.96,2.84,2.81,2.78,2.73,2.72,2.74,2.80,2.86,2.83,2.83,2.78,2.76,2.79,3.72,3.47,3.25,3.16,3.09,3.00,2.90,2.87,2.87,2.82,2.90,2.98,3.04,3.02,3.02,2.98,2.95,2.93,3.94,3.58,3.42,3.25,3.38,3.36,3.35,3.34,3.30,3.31,3.30,3.29,3.28,3.27,3.26,3.32,3.24,3.14,3.08,2.99,2.93,2.91,2.84,2.85,2.86,2.95,3.06,3.06,3.13,3.07,3.09,3.04,3.85,3.63,3.48,3.37,3.31,3.32,3.33,3.34,3.28,3.28,3.30,3.30},
   {1.84,1.98,2.85,2.54,2.37,2.27,2.23,2.15,2.16,2.19,3.07,2.91,2.78,2.68,2.63,2.55,2.51,2.48,3.48,3.23,3.00,2.88,2.86,2.74,2.71,2.68,2.63,2.62,2.64,2.70,2.76,2.73,2.73,2.68,2.66,2.69,3.62,3.37,3.15,3.06,2.99,2.90,2.80,2.77,2.77,2.72,2.80,2.88,2.94,2.92,2.92,2.88,2.85,2.83,3.84,3.48,3.32,3.15,3.28,3.26,3.25,3.24,3.20,3.21,3.20,3.19,3.18,3.17,3.16,3.22,3.14,3.04,2.98,2.89,2.83,2.81,2.74,2.75,2.76,2.85,2.96,2.96,3.03,2.97,2.99,2.94,3.75,3.53,3.38,3.27,3.21,3.22,3.23,3.24,3.18,3.18,3.20,3.20},
   {1.78,1.92,2.79,2.48,2.31,2.21,2.17,2.09,2.10,2.13,3.01,2.85,2.72,2.62,2.57,2.49,2.45,2.42,3.42,3.17,2.94,2.82,2.80,2.68,2.65,2.62,2.57,2.56,2.58,2.64,2.70,2.67,2.67,2.62,2.60,2.63,3.56,3.31,3.09,3.00,2.93,2.84,2.74,2.71,2.71,2.66,2.74,2.82,2.88,2.86,2.86,2.82,2.79,2.77,3.78,3.42,3.26,3.09,3.22,3.20,3.19,3.18,3.14,3.15,3.14,3.13,3.12,3.11,3.10,3.16,3.08,2.98,2.92,2.83,2.77,2.75,2.68,2.69,2.70,2.79,2.90,2.90,2.97,2.91,2.93,2.88,3.69,3.47,3.32,3.21,3.15,3.16,3.17,3.18,3.12,3.12,3.14,3.14},
   {1.69,1.83,2.70,2.39,2.22,2.12,2.08,2.00,2.01,2.04,2.92,2.76,2.63,2.53,2.48,2.40,2.36,2.33,3.33,3.08,2.85,2.73,2.71,2.59,2.56,2.53,2.48,2.47,2.49,2.55,2.61,2.58,2.58,2.53,2.51,2.54,3.47,3.22,3.00,2.91,2.84,2.75,2.65,2.62,2.62,2.57,2.65,2.73,2.79,2.77,2.77,2.73,2.70,2.68,3.69,3.33,3.17,3.00,3.13,3.11,3.10,3.09,3.05,3.06,3.05,3.04,3.03,3.02,3.01,3.07,2.99,2.89,2.83,2.74,2.68,2.66,2.59,2.60,2.61,2.70,2.81,2.81,2.88,2.82,2.84,2.79,3.60,3.38,3.23,3.12,3.06,3.07,3.08,3.09,3.03,3.03,3.05,3.05},
   {1.63,1.77,2.64,2.33,2.16,2.06,2.02,1.94,1.95,1.98,2.86,2.70,2.57,2.47,2.42,2.34,2.30,2.27,3.27,3.02,2.79,2.67,2.65,2.53,2.50,2.47,2.42,2.41,2.43,2.49,2.55,2.52,2.52,2.47,2.45,2.48,3.41,3.16,2.94,2.85,2.78,2.69,2.59,2.56,2.56,2.51,2.59,2.67,2.73,2.71,2.71,2.67,2.64,2.62,3.63,3.27,3.11,2.94,3.07,3.05,3.04,3.03,2.99,3.00,2.99,2.98,2.97,2.96,2.95,3.01,2.93,2.83,2.77,2.68,2.62,2.60,2.53,2.54,2.55,2.64,2.75,2.75,2.82,2.76,2.78,2.73,3.54,3.32,3.17,3.06,3.00,3.01,3.02,3.03,2.97,2.97,2.99,2.99},
   {1.61,1.75,2.62,2.31,2.14,2.04,2.00,1.92,1.93,1.96,2.84,2.68,2.55,2.45,2.40,2.32,2.28,2.25,3.25,3.00,2.77,2.65,2.63,2.51,2.48,2.45,2.40,2.39,2.41,2.47,2.53,2.50,2.50,2.45,2.43,2.46,3.39,3.14,2.92,2.83,2.76,2.67,2.57,2.54,2.54,2.49,2.57,2.65,2.71,2.69,2.69,2.65,2.62,2.60,3.61,3.25,3.09,2.92,3.05,3.03,3.02,3.01,2.97,2.98,2.97,2.96,2.95,2.94,2.93,2.99,2.91,2.81,2.75,2.66,2.60,2.58,2.51,2.52,2.53,2.62,2.73,2.73,2.80,2.74,2.76,2.71,3.52,3.30,3.15,3.04,2.98,2.99,3.00,3.01,2.95,2.95,2.97,2.97},
   {1.54,1.68,2.55,2.24,2.07,1.97,1.93,1.85,1.86,1.89,2.77,2.61,2.48,2.38,2.33,2.25,2.21,2.18,3.18,2.93,2.70,2.58,2.56,2.44,2.41,2.38,2.33,2.32,2.34,2.40,2.46,2.43,2.43,2.38,2.36,2.39,3.32,3.07,2.85,2.76,2.69,2.60,2.50,2.47,2.47,2.42,2.50,2.58,2.64,2.62,2.62,2.58,2.55,2.53,3.54,3.18,3.02,2.85,2.98,2.96,2.95,2.94,2.90,2.91,2.90,2.89,2.88,2.87,2.86,2.92,2.84,2.74,2.68,2.59,2.53,2.51,2.44,2.45,2.46,2.55,2.66,2.66,2.73,2.67,2.69,2.64,3.45,3.23,3.08,2.97,2.91,2.92,2.93,2.94,2.88,2.88,2.90,2.90},
   {1.55,1.69,2.56,2.25,2.08,1.98,1.94,1.86,1.87,1.90,2.78,2.62,2.49,2.39,2.34,2.26,2.22,2.19,3.19,2.94,2.71,2.59,2.57,2.45,2.42,2.39,2.34,2.33,2.35,2.41,2.47,2.44,2.44,2.39,2.37,2.40,3.33,3.08,2.86,2.77,2.70,2.61,2.51,2.48,2.48,2.43,2.51,2.59,2.65,2.63,2.63,2.59,2.56,2.54,3.55,3.19,3.03,2.86,2.99,2.97,2.96,2.95,2.91,2.92,2.91,2.90,2.89,2.88,2.87,2.93,2.85,2.75,2.69,2.60,2.54,2.52,2.45,2.46,2.47,2.56,2.67,2.67,2.74,2.68,2.70,2.65,3.46,3.24,3.09,2.98,2.92,2.93,2.94,2.95,2.89,2.89,2.91,2.91},
   {1.56,1.70,2.57,2.26,2.09,1.99,1.95,1.87,1.88,1.91,2.79,2.63,2.50,2.40,2.35,2.27,2.23,2.20,3.20,2.95,2.72,2.60,2.58,2.46,2.43,2.40,2.35,2.34,2.36,2.42,2.48,2.45,2.45,2.40,2.38,2.41,3.34,3.09,2.87,2.78,2.71,2.62,2.52,2.49,2.49,2.44,2.52,2.60,2.66,2.64,2.64,2.60,2.57,2.55,3.56,3.20,3.04,2.87,3.00,2.98,2.97,2.96,2.92,2.93,2.92,2.91,2.90,2.89,2.88,2.94,2.86,2.76,2.70,2.61,2.55,2.53,2.46,2.47,2.48,2.57,2.68,2.68,2.75,2.69,2.71,2.66,3.47,3.25,3.10,2.99,2.93,2.94,2.95,2.96,2.90,2.90,2.92,2.92},
   {1.65,1.79,2.66,2.35,2.18,2.08,2.04,1.96,1.97,2.00,2.88,2.72,2.59,2.49,2.44,2.36,2.32,2.29,3.29,3.04,2.81,2.69,2.67,2.55,2.52,2.49,2.44,2.43,2.45,2.51,2.57,2.54,2.54,2.49,2.47,2.50,3.43,3.18,2.96,2.87,2.80,2.71,2.61,2.58,2.58,2.53,2.61,2.69,2.75,2.73,2.73,2.69,2.66,2.64,3.65,3.29,3.13,2.96,3.09,3.07,3.06,3.05,3.01,3.02,3.01,3.00,2.99,2.98,2.97,3.03,2.95,2.85,2.79,2.70,2.64,2.62,2.55,2.56,2.57,2.66,2.77,2.77,2.84,2.78,2.80,2.75,3.56,3.34,3.19,3.08,3.02,3.03,3.04,3.05,2.99,2.99,3.01,3.01},
   {1.76,1.90,2.77,2.46,2.29,2.19,2.15,2.07,2.08,2.11,2.99,2.83,2.70,2.60,2.55,2.47,2.43,2.40,3.40,3.15,2.92,2.80,2.78,2.66,2.63,2.60,2.55,2.54,2.56,2.62,2.68,2.65,2.65,2.60,2.58,2.61,3.54,3.29,3.07,2.98,2.91,2.82,2.72,2.69,2.69,2.64,2.72,2.80,2.86,2.84,2.84,2.80,2.77,2.75,3.76,3.40,3.24,3.07,3.20,3.18,3.17,3.16,3.12,3.13,3.12,3.11,3.10,3.09,3.08,3.14,3.06,2.96,2.90,2.81,2.75,2.73,2.66,2.67,2.68,2.77,2.88,2.88,2.95,2.89,2.91,2.86,3.67,3.45,3.30,3.19,3.13,3.14,3.15,3.16,3.10,3.10,3.12,3.12},
   {1.76,1.90,2.77,2.46,2.29,2.19,2.15,2.07,2.08,2.11,2.99,2.83,2.70,2.60,2.55,2.47,2.43,2.40,3.40,3.15,2.92,2.80,2.78,2.66,2.63,2.60,2.55,2.54,2.56,2.62,2.68,2.65,2.65,2.60,2.58,2.61,3.54,3.29,3.07,2.98,2.91,2.82,2.72,2.69,2.69,2.64,2.72,2.80,2.86,2.84,2.84,2.80,2.77,2.75,3.76,3.40,3.24,3.07,3.20,3.18,3.17,3.16,3.12,3.13,3.12,3.11,3.10,3.09,3.08,3.14,3.06,2.96,2.90,2.81,2.75,2.73,2.66,2.67,2.68,2.77,2.88,2.88,2.95,2.89,2.91,2.86,3.67,3.45,3.30,3.19,3.13,3.14,3.15,3.16,3.10,3.10,3.12,3.12},
   {1.83,1.97,2.84,2.53,2.36,2.26,2.22,2.14,2.15,2.18,3.06,2.90,2.77,2.67,2.62,2.54,2.50,2.47,3.47,3.22,2.99,2.87,2.85,2.73,2.70,2.67,2.62,2.61,2.63,2.69,2.75,2.72,2.72,2.67,2.65,2.68,3.61,3.36,3.14,3.05,2.98,2.89,2.79,2.76,2.76,2.71,2.79,2.87,2.93,2.91,2.91,2.87,2.84,2.82,3.83,3.47,3.31,3.14,3.27,3.25,3.24,3.23,3.19,3.20,3.19,3.18,3.17,3.16,3.15,3.21,3.13,3.03,2.97,2.88,2.82,2.80,2.73,2.74,2.75,2.84,2.95,2.95,3.02,2.96,2.98,2.93,3.74,3.52,3.37,3.26,3.20,3.21,3.22,3.23,3.17,3.17,3.19,3.19},
   {1.77,1.91,2.78,2.47,2.30,2.20,2.16,2.08,2.09,2.12,3.00,2.84,2.71,2.61,2.56,2.48,2.44,2.41,3.41,3.16,2.93,2.81,2.79,2.67,2.64,2.61,2.56,2.55,2.57,2.63,2.69,2.66,2.66,2.61,2.59,2.62,3.55,3.30,3.08,2.99,2.92,2.83,2.73,2.70,2.70,2.65,2.73,2.81,2.87,2.85,2.85,2.81,2.78,2.76,3.77,3.41,3.25,3.08,3.21,3.19,3.18,3.17,3.13,3.14,3.13,3.12,3.11,3.10,3.09,3.15,3.07,2.97,2.91,2.82,2.76,2.74,2.67,2.68,2.69,2.78,2.89,2.89,2.96,2.90,2.92,2.87,3.68,3.46,3.31,3.20,3.14,3.15,3.16,3.17,3.11,3.11,3.13,3.13},
   {1.79,1.93,2.80,2.49,2.32,2.22,2.18,2.10,2.11,2.14,3.02,2.86,2.73,2.63,2.58,2.50,2.46,2.43,3.43,3.18,2.95,2.83,2.81,2.69,2.66,2.63,2.58,2.57,2.59,2.65,2.71,2.68,2.68,2.63,2.61,2.64,3.57,3.32,3.10,3.01,2.94,2.85,2.75,2.72,2.72,2.67,2.75,2.83,2.89,2.87,2.87,2.83,2.80,2.78,3.79,3.43,3.27,3.10,3.23,3.21,3.20,3.19,3.15,3.16,3.15,3.14,3.13,3.12,3.11,3.17,3.09,2.99,2.93,2.84,2.78,2.76,2.69,2.70,2.71,2.80,2.91,2.91,2.98,2.92,2.94,2.89,3.70,3.48,3.33,3.22,3.16,3.17,3.18,3.19,3.13,3.13,3.15,3.15},
   {1.74,1.88,2.75,2.44,2.27,2.17,2.13,2.05,2.06,2.09,2.97,2.81,2.68,2.58,2.53,2.45,2.41,2.38,3.38,3.13,2.90,2.78,2.76,2.64,2.61,2.58,2.53,2.52,2.54,2.60,2.66,2.63,2.63,2.58,2.56,2.59,3.52,3.27,3.05,2.96,2.89,2.80,2.70,2.67,2.67,2.62,2.70,2.78,2.84,2.82,2.82,2.78,2.75,2.73,3.74,3.38,3.22,3.05,3.18,3.16,3.15,3.14,3.10,3.11,3.10,3.09,3.08,3.07,3.06,3.12,3.04,2.94,2.88,2.79,2.73,2.71,2.64,2.65,2.66,2.75,2.86,2.86,2.93,2.87,2.89,2.84,3.65,3.43,3.28,3.17,3.11,3.12,3.13,3.14,3.08,3.08,3.10,3.10},
   {2.55,2.69,3.56,3.25,3.08,2.98,2.94,2.86,2.87,2.90,3.78,3.62,3.49,3.39,3.34,3.26,3.22,3.19,4.19,3.94,3.71,3.59,3.57,3.45,3.42,3.39,3.34,3.33,3.35,3.41,3.47,3.44,3.44,3.39,3.37,3.40,4.33,4.08,3.86,3.77,3.70,3.61,3.51,3.48,3.48,3.43,3.51,3.59,3.65,3.63,3.63,3.59,3.56,3.54,4.55,4.19,4.03,3.86,3.99,3.97,3.96,3.95,3.91,3.92,3.91,3.90,3.89,3.88,3.87,3.93,3.85,3.75,3.69,3.60,3.54,3.52,3.45,3.46,3.47,3.56,3.67,3.67,3.74,3.68,3.70,3.65,4.46,4.24,4.09,3.98,3.92,3.93,3.94,3.95,3.89,3.89,3.91,3.91},
   {2.33,2.47,3.34,3.03,2.86,2.76,2.72,2.64,2.65,2.68,3.56,3.40,3.27,3.17,3.12,3.04,3.00,2.97,3.97,3.72,3.49,3.37,3.35,3.23,3.20,3.17,3.12,3.11,3.13,3.19,3.25,3.22,3.22,3.17,3.15,3.18,4.11,3.86,3.64,3.55,3.48,3.39,3.29,3.26,3.26,3.21,3.29,3.37,3.43,3.41,3.41,3.37,3.34,3.32,4.33,3.97,3.81,3.64,3.77,3.75,3.74,3.73,3.69,3.70,3.69,3.68,3.67,3.66,3.65,3.71,3.63,3.53,3.47,3.38,3.32,3.30,3.23,3.24,3.25,3.34,3.45,3.45,3.52,3.46,3.48,3.43,4.24,4.02,3.87,3.76,3.70,3.71,3.72,3.73,3.67,3.67,3.69,3.69},
   {2.18,2.32,3.19,2.88,2.71,2.61,2.57,2.49,2.50,2.53,3.41,3.25,3.12,3.02,2.97,2.89,2.85,2.82,3.82,3.57,3.34,3.22,3.20,3.08,3.05,3.02,2.97,2.96,2.98,3.04,3.10,3.07,3.07,3.02,3.00,3.03,3.96,3.71,3.49,3.40,3.33,3.24,3.14,3.11,3.11,3.06,3.14,3.22,3.28,3.26,3.26,3.22,3.19,3.17,4.18,3.82,3.66,3.49,3.62,3.60,3.59,3.58,3.54,3.55,3.54,3.53,3.52,3.51,3.50,3.56,3.48,3.38,3.32,3.23,3.17,3.15,3.08,3.09,3.10,3.19,3.30,3.30,3.37,3.31,3.33,3.28,4.09,3.87,3.72,3.61,3.55,3.56,3.57,3.58,3.52,3.52,3.54,3.54},
   {2.07,2.21,3.08,2.77,2.60,2.50,2.46,2.38,2.39,2.42,3.30,3.14,3.01,2.91,2.86,2.78,2.74,2.71,3.71,3.46,3.23,3.11,3.09,2.97,2.94,2.91,2.86,2.85,2.87,2.93,2.99,2.96,2.96,2.91,2.89,2.92,3.85,3.60,3.38,3.29,3.22,3.13,3.03,3.00,3.00,2.95,3.03,3.11,3.17,3.15,3.15,3.11,3.08,3.06,4.07,3.71,3.55,3.38,3.51,3.49,3.48,3.47,3.43,3.44,3.43,3.42,3.41,3.40,3.39,3.45,3.37,3.27,3.21,3.12,3.06,3.04,2.97,2.98,2.99,3.08,3.19,3.19,3.26,3.20,3.22,3.17,3.98,3.76,3.61,3.50,3.44,3.45,3.46,3.47,3.41,3.41,3.43,3.43},
   {2.01,2.15,3.02,2.71,2.54,2.44,2.40,2.32,2.33,2.36,3.24,3.08,2.95,2.85,2.80,2.72,2.68,2.65,3.65,3.40,3.17,3.05,3.03,2.91,2.88,2.85,2.80,2.79,2.81,2.87,2.93,2.90,2.90,2.85,2.83,2.86,3.79,3.54,3.32,3.23,3.16,3.07,2.97,2.94,2.94,2.89,2.97,3.05,3.11,3.09,3.09,3.05,3.02,3.00,4.01,3.65,3.49,3.32,3.45,3.43,3.42,3.41,3.37,3.38,3.37,3.36,3.35,3.34,3.33,3.39,3.31,3.21,3.15,3.06,3.00,2.98,2.91,2.92,2.93,3.02,3.13,3.13,3.20,3.14,3.16,3.11,3.92,3.70,3.55,3.44,3.38,3.39,3.40,3.41,3.35,3.35,3.37,3.37},
   {2.02,2.16,3.03,2.72,2.55,2.45,2.41,2.33,2.34,2.37,3.25,3.09,2.96,2.86,2.81,2.73,2.69,2.66,3.66,3.41,3.18,3.06,3.04,2.92,2.89,2.86,2.81,2.80,2.82,2.88,2.94,2.91,2.91,2.86,2.84,2.87,3.80,3.55,3.33,3.24,3.17,3.08,2.98,2.95,2.95,2.90,2.98,3.06,3.12,3.10,3.10,3.06,3.03,3.01,4.02,3.66,3.50,3.33,3.46,3.44,3.43,3.42,3.38,3.39,3.38,3.37,3.36,3.35,3.34,3.40,3.32,3.22,3.16,3.07,3.01,2.99,2.92,2.93,2.94,3.03,3.14,3.14,3.21,3.15,3.17,3.12,3.93,3.71,3.56,3.45,3.39,3.40,3.41,3.42,3.36,3.36,3.38,3.38},
   {2.03,2.17,3.04,2.73,2.56,2.46,2.42,2.34,2.35,2.38,3.26,3.10,2.97,2.87,2.82,2.74,2.70,2.67,3.67,3.42,3.19,3.07,3.05,2.93,2.90,2.87,2.82,2.81,2.83,2.89,2.95,2.92,2.92,2.87,2.85,2.88,3.81,3.56,3.34,3.25,3.18,3.09,2.99,2.96,2.96,2.91,2.99,3.07,3.13,3.11,3.11,3.07,3.04,3.02,4.03,3.67,3.51,3.34,3.47,3.45,3.44,3.43,3.39,3.40,3.39,3.38,3.37,3.36,3.35,3.41,3.33,3.23,3.17,3.08,3.02,3.00,2.93,2.94,2.95,3.04,3.15,3.15,3.22,3.16,3.18,3.13,3.94,3.72,3.57,3.46,3.40,3.41,3.42,3.43,3.37,3.37,3.39,3.39},
   {2.04,2.18,3.05,2.74,2.57,2.47,2.43,2.35,2.36,2.39,3.27,3.11,2.98,2.88,2.83,2.75,2.71,2.68,3.68,3.43,3.20,3.08,3.06,2.94,2.91,2.88,2.83,2.82,2.84,2.90,2.96,2.93,2.93,2.88,2.86,2.89,3.82,3.57,3.35,3.26,3.19,3.10,3.00,2.97,2.97,2.92,3.00,3.08,3.14,3.12,3.12,3.08,3.05,3.03,4.04,3.68,3.52,3.35,3.48,3.46,3.45,3.44,3.40,3.41,3.40,3.39,3.38,3.37,3.36,3.42,3.34,3.24,3.18,3.09,3.03,3.01,2.94,2.95,2.96,3.05,3.16,3.16,3.23,3.17,3.19,3.14,3.95,3.73,3.58,3.47,3.41,3.42,3.43,3.44,3.38,3.38,3.40,3.40},
   {1.98,2.12,2.99,2.68,2.51,2.41,2.37,2.29,2.30,2.33,3.21,3.05,2.92,2.82,2.77,2.69,2.65,2.62,3.62,3.37,3.14,3.02,3.00,2.88,2.85,2.82,2.77,2.76,2.78,2.84,2.90,2.87,2.87,2.82,2.80,2.83,3.76,3.51,3.29,3.20,3.13,3.04,2.94,2.91,2.91,2.86,2.94,3.02,3.08,3.06,3.06,3.02,2.99,2.97,3.98,3.62,3.46,3.29,3.42,3.40,3.39,3.38,3.34,3.35,3.34,3.33,3.32,3.31,3.30,3.36,3.28,3.18,3.12,3.03,2.97,2.95,2.88,2.89,2.90,2.99,3.10,3.10,3.17,3.11,3.13,3.08,3.89,3.67,3.52,3.41,3.35,3.36,3.37,3.38,3.32,3.32,3.34,3.34},
   {1.98,2.12,2.99,2.68,2.51,2.41,2.37,2.29,2.30,2.33,3.21,3.05,2.92,2.82,2.77,2.69,2.65,2.62,3.62,3.37,3.14,3.02,3.00,2.88,2.85,2.82,2.77,2.76,2.78,2.84,2.90,2.87,2.87,2.82,2.80,2.83,3.76,3.51,3.29,3.20,3.13,3.04,2.94,2.91,2.91,2.86,2.94,3.02,3.08,3.06,3.06,3.02,2.99,2.97,3.98,3.62,3.46,3.29,3.42,3.40,3.39,3.38,3.34,3.35,3.34,3.33,3.32,3.31,3.30,3.36,3.28,3.18,3.12,3.03,2.97,2.95,2.88,2.89,2.90,2.99,3.10,3.10,3.17,3.11,3.13,3.08,3.89,3.67,3.52,3.41,3.35,3.36,3.37,3.38,3.32,3.32,3.34,3.34},
   {2.00,2.14,3.01,2.70,2.53,2.43,2.39,2.31,2.32,2.35,3.23,3.07,2.94,2.84,2.79,2.71,2.67,2.64,3.64,3.39,3.16,3.04,3.02,2.90,2.87,2.84,2.79,2.78,2.80,2.86,2.92,2.89,2.89,2.84,2.82,2.85,3.78,3.53,3.31,3.22,3.15,3.06,2.96,2.93,2.93,2.88,2.96,3.04,3.10,3.08,3.08,3.04,3.01,2.99,4.00,3.64,3.48,3.31,3.44,3.42,3.41,3.40,3.36,3.37,3.36,3.35,3.34,3.33,3.32,3.38,3.30,3.20,3.14,3.05,2.99,2.97,2.90,2.91,2.92,3.01,3.12,3.12,3.19,3.13,3.15,3.10,3.91,3.69,3.54,3.43,3.37,3.38,3.39,3.40,3.34,3.34,3.36,3.36},
   {2.00,2.14,3.01,2.70,2.53,2.43,2.39,2.31,2.32,2.35,3.23,3.07,2.94,2.84,2.79,2.71,2.67,2.64,3.64,3.39,3.16,3.04,3.02,2.90,2.87,2.84,2.79,2.78,2.80,2.86,2.92,2.89,2.89,2.84,2.82,2.85,3.78,3.53,3.31,3.22,3.15,3.06,2.96,2.93,2.93,2.88,2.96,3.04,3.10,3.08,3.08,3.04,3.01,2.99,4.00,3.64,3.48,3.31,3.44,3.42,3.41,3.40,3.36,3.37,3.36,3.35,3.34,3.33,3.32,3.38,3.30,3.20,3.14,3.05,2.99,2.97,2.90,2.91,2.92,3.01,3.12,3.12,3.19,3.13,3.15,3.10,3.91,3.69,3.54,3.43,3.37,3.38,3.39,3.40,3.34,3.34,3.36,3.36}
};

static float DoubleDis[NUMDIS][NUMDIS] = {
   {0.64,0.78,1.56,1.22,1.10,0.99,0.92,0.89,0.91,1.28,1.92,1.64,1.45,1.39,1.34,1.26,1.27,1.39,2.25,1.79,1.48,1.49,1.44,1.43,1.37,1.41,1.35,1.33,1.47,1.52,1.49,1.43,1.46,1.39,1.41,1.53,2.34,1.89,1.62,1.59,1.57,1.53,1.52,1.46,1.42,1.49,1.71,1.76,1.68,1.62,1.65,1.60,1.61,1.67,2.41,1.93,1.71,1.69,1.70,1.69,1.67,1.66,1.66,1.67,1.67,1.65,1.65,1.65,1.63,1.61,1.63,1.60,1.58,1.52,1.51,1.48,1.47,1.44,1.53,1.74,1.74,1.67,1.73,1.67,1.70,1.77,2.50,2.05,1.85,1.75,1.70,1.66,1.68,1.67,1.67,1.68,1.71,1.72},
   {0.78,0.92,1.70,1.36,1.24,1.13,1.06,1.03,1.05,1.42,2.06,1.78,1.59,1.53,1.48,1.40,1.41,1.53,2.39,1.93,1.62,1.63,1.58,1.57,1.51,1.55,1.49,1.47,1.61,1.66,1.63,1.57,1.60,1.53,1.55,1.67,2.48,2.03,1.76,1.73,1.71,1.67,1.66,1.60,1.56,1.63,1.85,1.90,1.82,1.76,1.79,1.74,1.75,1.81,2.55,2.07,1.85,1.83,1.84,1.83,1.81,1.80,1.80,1.81,1.81,1.79,1.79,1.79,1.77,1.75,1.77,1.74,1.72,1.66,1.65,1.62,1.61,1.58,1.67,1.88,1.88,1.81,1.87,1.81,1.84,1.91,2.64,2.19,1.99,1.89,1.84,1.80,1.82,1.81,1.81,1.82,1.85,1.86},
   {1.56,1.70,2.48,2.14,2.02,1.91,1.84,1.81,1.83,2.20,2.84,2.56,2.37,2.31,2.26,2.18,2.19,2.31,3.17,2.71,2.40,2.41,2.36,2.35,2.29,2.33,2.27,2.25,2.39,2.44,2.41,2.35,2.38,2.31,2.33,2.45,3.26,2.81,2.54,2.51,2.49,2.45,2.44,2.38,2.34,2.41,2.63,2.68,2.60,2.54,2.57,2.52,2.53,2.59,3.33,2.85,2.63,2.61,2.62,2.61,2.59,2.58,2.58,2.59,2.59,2.57,2.57,2.57,2.55,2.53,2.55,2.52,2.50,2.44,2.43,2.40,2.39,2.36,2.45,2.66,2.66,2.59,2.65,2.59,2.62,2.69,3.42,2.97,2.77,2.67,2.62,2.58,2.60,2.59,2.59,2.60,2.63,2.64},
   {1.22,1.36,2.14,1.80,1.68,1.57,1.50,1.47,1.49,1.86,2.50,2.22,2.03,1.97,1.92,1.84,1.85,1.97,2.83,2.37,2.06,2.07,2.02,2.01,1.95,1.99,1.93,1.91,2.05,2.10,2.07,2.01,2.04,1.97,1.99,2.11,2.92,2.47,2.20,2.17,2.15,2.11,2.10,2.04,2.00,2.07,2.29,2.34,2.26,2.20,2.23,2.18,2.19,2.25,2.99,2.51,2.29,2.27,2.28,2.27,2.25,2.24,2.24,2.25,2.25,2.23,2.23,2.23,2.21,2.19,2.21,2.18,2.16,2.10,2.09,2.06,2.05,2.02,2.11,2.32,2.32,2.25,2.31,2.25,2.28,2.35,3.08,2.63,2.43,2.33,2.28,2.24,2.26,2.25,2.25,2.26,2.29,2.30},
   {1.10,1.24,2.02,1.68,1.56,1.45,1.38,1.35,1.37,1.74,2.38,2.10,1.91,1.85,1.80,1.72,1.73,1.85,2.71,2.25,1.94,1.95,1.90,1.89,1.83,1.87,1.81,1.79,1.93,1.98,1.95,1.89,1.92,1.85,1.87,1.99,2.80,2.35,2.08,2.05,2.03,1.99,1.98,1.92,1.88,1.95,2.17,2.22,2.14,2.08,2.11,2.06,2.07,2.13,2.87,2.39,2.17,2.15,2.16,2.15,2.13,2.12,2.12,2.13,2.13,2.11,2.11,2.11,2.09,2.07,2.09,2.06,2.04,1.98,1.97,1.94,1.93,1.90,1.99,2.20,2.20,2.13,2.19,2.13,2.16,2.23,2.96,2.51,2.31,2.21,2.16,2.12,2.14,2.13,2.13,2.14,2.17,2.18},
   {0.99,1.13,1.91,1.57,1.45,1.34,1.27,1.24,1.26,1.63,2.27,1.99,1.80,1.74,1.69,1.61,1.62,1.74,2.60,2.14,1.83,1.84,1.79,1.78,1.72,1.76,1.70,1.68,1.82,1.87,1.84,1.78,1.81,1.74,1.76,1.88,2.69,2.24,1.97,1.94,1.92,1.88,1.87,1.81,1.77,1.84,2.06,2.11,2.03,1.97,2.00,1.95,1.96,2.02,2.76,2.28,2.06,2.04,2.05,2.04,2.02,2.01,2.01,2.02,2.02,2.00,2.00,2.00,1.98,1.96,1.98,1.95,1.93,1.87,1.86,1.83,1.82,1.79,1.88,2.09,2.09,2.02,2.08,2.02,2.05,2.12,2.85,2.40,2.20,2.10,2.05,2.01,2.03,2.02,2.02,2.03,2.06,2.07},
   {0.92,1.06,1.84,1.50,1.38,1.27,1.20,1.17,1.19,1.56,2.20,1.92,1.73,1.67,1.62,1.54,1.55,1.67,2.53,2.07,1.76,1.77,1.72,1.71,1.65,1.69,1.63,1.61,1.75,1.80,1.77,1.71,1.74,1.67,1.69,1.81,2.62,2.17,1.90,1.87,1.85,1.81,1.80,1.74,1.70,1.77,1.99,2.04,1.96,1.90,1.93,1.88,1.89,1.95,2.69,2.21,1.99,1.97,1.98,1.97,1.95,1.94,1.94,1.95,1.95,1.93,1.93,1.93,1.91,1.89,1.91,1.88,1.86,1.80,1.79,1.76,1.75,1.72,1.81,2.02,2.02,1.95,2.01,1.95,1.98,2.05,2.78,2.33,2.13,2.03,1.98,1.94,1.96,1.95,1.95,1.96,1.99,2.00},
   {0.89,1.03,1.81,1.47,1.35,1.24,1.17,1.14,1.16,1.53,2.17,1.89,1.70,1.64,1.59,1.51,1.52,1.64,2.50,2.04,1.73,1.74,1.69,1.68,1.62,1.66,1.60,1.58,1.72,1.77,1.74,1.68,1.71,1.64,1.66,1.78,2.59,2.14,1.87,1.84,1.82,1.78,1.77,1.71,1.67,1.74,1.96,2.01,1.93,1.87,1.90,1.85,1.86,1.92,2.66,2.18,1.96,1.94,1.95,1.94,1.92,1.91,1.91,1.92,1.92,1.90,1.90,1.90,1.88,1.86,1.88,1.85,1.83,1.77,1.76,1.73,1.72,1.69,1.78,1.99,1.99,1.92,1.98,1.92,1.95,2.02,2.75,2.30,2.10,2.00,1.95,1.91,1.93,1.92,1.92,1.93,1.96,1.97},
   {0.91,1.05,1.83,1.49,1.37,1.26,1.19,1.16,1.18,1.55,2.19,1.91,1.72,1.66,1.61,1.53,1.54,1.66,2.52,2.06,1.75,1.76,1.71,1.70,1.64,1.68,1.62,1.60,1.74,1.79,1.76,1.70,1.73,1.66,1.68,1.80,2.61,2.16,1.89,1.86,1.84,1.80,1.79,1.73,1.69,1.76,1.98,2.03,1.95,1.89,1.92,1.87,1.88,1.94,2.68,2.20,1.98,1.96,1.97,1.96,1.94,1.93,1.93,1.94,1.94,1.92,1.92,1.92,1.90,1.88,1.90,1.87,1.85,1.79,1.78,1.75,1.74,1.71,1.80,2.01,2.01,1.94,2.00,1.94,1.97,2.04,2.77,2.32,2.12,2.02,1.97,1.93,1.95,1.94,1.94,1.95,1.98,1.99},
   {1.28,1.42,2.20,1.86,1.74,1.63,1.56,1.53,1.55,1.92,2.56,2.28,2.09,2.03,1.98,1.90,1.91,2.03,2.89,2.43,2.12,2.13,2.08,2.07,2.01,2.05,1.99,1.97,2.11,2.16,2.13,2.07,2.10,2.03,2.05,2.17,2.98,2.53,2.26,2.23,2.21,2.17,2.16,2.10,2.06,2.13,2.35,2.40,2.32,2.26,2.29,2.24,2.25,2.31,3.05,2.57,2.35,2.33,2.34,2.33,2.31,2.30,2.30,2.31,2.31,2.29,2.29,2.29,2.27,2.25,2.27,2.24,2.22,2.16,2.15,2.12,2.11,2.08,2.17,2.38,2.38,2.31,2.37,2.31,2.34,2.41,3.14,2.69,2.49,2.39,2.34,2.30,2.32,2.31,2.31,2.32,2.35,2.36},
   {1.92,2.06,2.84,2.50,2.38,2.27,2.20,2.17,2.19,2.56,3.20,2.92,2.73,2.67,2.62,2.54,2.55,2.67,3.53,3.07,2.76,2.77,2.72,2.71,2.65,2.69,2.63,2.61,2.75,2.80,2.77,2.71,2.74,2.67,2.69,2.81,3.62,3.17,2.90,2.87,2.85,2.81,2.80,2.74,2.70,2.77,2.99,3.04,2.96,2.90,2.93,2.88,2.89,2.95,3.69,3.21,2.99,2.97,2.98,2.97,2.95,2.94,2.94,2.95,2.95,2.93,2.93,2.93,2.91,2.89,2.91,2.88,2.86,2.80,2.79,2.76,2.75,2.72,2.81,3.02,3.02,2.95,3.01,2.95,2.98,3.05,3.78,3.33,3.13,3.03,2.98,2.94,2.96,2.95,2.95,2.96,2.99,3.00},
   {1.64,1.78,2.56,2.22,2.10,1.99,1.92,1.89,1.91,2.28,2.92,2.64,2.45,2.39,2.34,2.26,2.27,2.39,3.25,2.79,2.48,2.49,2.44,2.43,2.37,2.41,2.35,2.33,2.47,2.52,2.49,2.43,2.46,2.39,2.41,2.53,3.34,2.89,2.62,2.59,2.57,2.53,2.52,2.46,2.42,2.49,2.71,2.76,2.68,2.62,2.65,2.60,2.61,2.67,3.41,2.93,2.71,2.69,2.70,2.69,2.67,2.66,2.66,2.67,2.67,2.65,2.65,2.65,2.63,2.61,2.63,2.60,2.58,2.52,2.51,2.48,2.47,2.44,2.53,2.74,2.74,2.67,2.73,2.67,2.70,2.77,3.50,3.05,2.85,2.75,2.70,2.66,2.68,2.67,2.67,2.68,2.71,2.72},
   {1.45,1.59,2.37,2.03,1.91,1.80,1.73,1.70,1.72,2.09,2.73,2.45,2.26,2.20,2.15,2.07,2.08,2.20,3.06,2.60,2.29,2.30,2.25,2.24,2.18,2.22,2.16,2.14,2.28,2.33,2.30,2.24,2.27,2.20,2.22,2.34,3.15,2.70,2.43,2.40,2.38,2.34,2.33,2.27,2.23,2.30,2.52,2.57,2.49,2.43,2.46,2.41,2.42,2.48,3.22,2.74,2.52,2.50,2.51,2.50,2.48,2.47,2.47,2.48,2.48,2.46,2.46,2.46,2.44,2.42,2.44,2.41,2.39,2.33,2.32,2.29,2.28,2.25,2.34,2.55,2.55,2.48,2.54,2.48,2.51,2.58,3.31,2.86,2.66,2.56,2.51,2.47,2.49,2.48,2.48,2.49,2.52,2.53},
   {1.39,1.53,2.31,1.97,1.85,1.74,1.67,1.64,1.66,2.03,2.67,2.39,2.20,2.14,2.09,2.01,2.02,2.14,3.00,2.54,2.23,2.24,2.19,2.18,2.12,2.16,2.10,2.08,2.22,2.27,2.24,2.18,2.21,2.14,2.16,2.28,3.09,2.64,2.37,2.34,2.32,2.28,2.27,2.21,2.17,2.24,2.46,2.51,2.43,2.37,2.40,2.35,2.36,2.42,3.16,2.68,2.46,2.44,2.45,2.44,2.42,2.41,2.41,2.42,2.42,2.40,2.40,2.40,2.38,2.36,2.38,2.35,2.33,2.27,2.26,2.23,2.22,2.19,2.28,2.49,2.49,2.42,2.48,2.42,2.45,2.52,3.25,2.80,2.60,2.50,2.45,2.41,2.43,2.42,2.42,2.43,2.46,2.47},
   {1.34,1.48,2.26,1.92,1.80,1.69,1.62,1.59,1.61,1.98,2.62,2.34,2.15,2.09,2.04,1.96,1.97,2.09,2.95,2.49,2.18,2.19,2.14,2.13,2.07,2.11,2.05,2.03,2.17,2.22,2.19,2.13,2.16,2.09,2.11,2.23,3.04,2.59,2.32,2.29,2.27,2.23,2.22,2.16,2.12,2.19,2.41,2.46,2.38,2.32,2.35,2.30,2.31,2.37,3.11,2.63,2.41,2.39,2.40,2.39,2.37,2.36,2.36,2.37,2.37,2.35,2.35,2.35,2.33,2.31,2.33,2.30,2.28,2.22,2.21,2.18,2.17,2.14,2.23,2.44,2.44,2.37,2.43,2.37,2.40,2.47,3.20,2.75,2.55,2.45,2.40,2.36,2.38,2.37,2.37,2.38,2.41,2.42},
   {1.26,1.40,2.18,1.84,1.72,1.61,1.54,1.51,1.53,1.90,2.54,2.26,2.07,2.01,1.96,1.88,1.89,2.01,2.87,2.41,2.10,2.11,2.06,2.05,1.99,2.03,1.97,1.95,2.09,2.14,2.11,2.05,2.08,2.01,2.03,2.15,2.96,2.51,2.24,2.21,2.19,2.15,2.14,2.08,2.04,2.11,2.33,2.38,2.30,2.24,2.27,2.22,2.23,2.29,3.03,2.55,2.33,2.31,2.32,2.31,2.29,2.28,2.28,2.29,2.29,2.27,2.27,2.27,2.25,2.23,2.25,2.22,2.20,2.14,2.13,2.10,2.09,2.06,2.15,2.36,2.36,2.29,2.35,2.29,2.32,2.39,3.12,2.67,2.47,2.37,2.32,2.28,2.30,2.29,2.29,2.30,2.33,2.34},
   {1.27,1.41,2.19,1.85,1.73,1.62,1.55,1.52,1.54,1.91,2.55,2.27,2.08,2.02,1.97,1.89,1.90,2.02,2.88,2.42,2.11,2.12,2.07,2.06,2.00,2.04,1.98,1.96,2.10,2.15,2.12,2.06,2.09,2.02,2.04,2.16,2.97,2.52,2.25,2.22,2.20,2.16,2.15,2.09,2.05,2.12,2.34,2.39,2.31,2.25,2.28,2.23,2.24,2.30,3.04,2.56,2.34,2.32,2.33,2.32,2.30,2.29,2.29,2.30,2.30,2.28,2.28,2.28,2.26,2.24,2.26,2.23,2.21,2.15,2.14,2.11,2.10,2.07,2.16,2.37,2.37,2.30,2.36,2.30,2.33,2.40,3.13,2.68,2.48,2.38,2.33,2.29,2.31,2.30,2.30,2.31,2.34,2.35},
   {1.39,1.53,2.31,1.97,1.85,1.74,1.67,1.64,1.66,2.03,2.67,2.39,2.20,2.14,2.09,2.01,2.02,2.14,3.00,2.54,2.23,2.24,2.19,2.18,2.12,2.16,2.10,2.08,2.22,2.27,2.24,2.18,2.21,2.14,2.16,2.28,3.09,2.64,2.37,2.34,2.32,2.28,2.27,2.21,2.17,2.24,2.46,2.51,2.43,2.37,2.40,2.35,2.36,2.42,3.16,2.68,2.46,2.44,2.45,2.44,2.42,2.41,2.41,2.42,2.42,2.40,2.40,2.40,2.38,2.36,2.38,2.35,2.33,2.27,2.26,2.23,2.22,2.19,2.28,2.49,2.49,2.42,2.48,2.42,2.45,2.52,3.25,2.80,2.60,2.50,2.45,2.41,2.43,2.42,2.42,2.43,2.46,2.47},
   {2.25,2.39,3.17,2.83,2.71,2.60,2.53,2.50,2.52,2.89,3.53,3.25,3.06,3.00,2.95,2.87,2.88,3.00,3.86,3.40,3.09,3.10,3.05,3.04,2.98,3.02,2.96,2.94,3.08,3.13,3.10,3.04,3.07,3.00,3.02,3.14,3.95,3.50,3.23,3.20,3.18,3.14,3.13,3.07,3.03,3.10,3.32,3.37,3.29,3.23,3.26,3.21,3.22,3.28,4.02,3.54,3.32,3.30,3.31,3.30,3.28,3.27,3.27,3.28,3.28,3.26,3.26,3.26,3.24,3.22,3.24,3.21,3.19,3.13,3.12,3.09,3.08,3.05,3.14,3.35,3.35,3.28,3.34,3.28,3.31,3.38,4.11,3.66,3.46,3.36,3.31,3.27,3.29,3.28,3.28,3.29,3.32,3.33},
   {1.79,1.93,2.71,2.37,2.25,2.14,2.07,2.04,2.06,2.43,3.07,2.79,2.60,2.54,2.49,2.41,2.42,2.54,3.40,2.94,2.63,2.64,2.59,2.58,2.52,2.56,2.50,2.48,2.62,2.67,2.64,2.58,2.61,2.54,2.56,2.68,3.49,3.04,2.77,2.74,2.72,2.68,2.67,2.61,2.57,2.64,2.86,2.91,2.83,2.77,2.80,2.75,2.76,2.82,3.56,3.08,2.86,2.84,2.85,2.84,2.82,2.81,2.81,2.82,2.82,2.80,2.80,2.80,2.78,2.76,2.78,2.75,2.73,2.67,2.66,2.63,2.62,2.59,2.68,2.89,2.89,2.82,2.88,2.82,2.85,2.92,3.65,3.20,3.00,2.90,2.85,2.81,2.83,2.82,2.82,2.83,2.86,2.87},
   {1.48,1.62,2.40,2.06,1.94,1.83,1.76,1.73,1.75,2.12,2.76,2.48,2.29,2.23,2.18,2.10,2.11,2.23,3.09,2.63,2.32,2.33,2.28,2.27,2.21,2.25,2.19,2.17,2.31,2.36,2.33,2.27,2.30,2.23,2.25,2.37,3.18,2.73,2.46,2.43,2.41,2.37,2.36,2.30,2.26,2.33,2.55,2.60,2.52,2.46,2.49,2.44,2.45,2.51,3.25,2.77,2.55,2.53,2.54,2.53,2.51,2.50,2.50,2.51,2.51,2.49,2.49,2.49,2.47,2.45,2.47,2.44,2.42,2.36,2.35,2.32,2.31,2.28,2.37,2.58,2.58,2.51,2.57,2.51,2.54,2.61,3.34,2.89,2.69,2.59,2.54,2.50,2.52,2.51,2.51,2.52,2.55,2.56},
   {1.49,1.63,2.41,2.07,1.95,1.84,1.77,1.74,1.76,2.13,2.77,2.49,2.30,2.24,2.19,2.11,2.12,2.24,3.10,2.64,2.33,2.34,2.29,2.28,2.22,2.26,2.20,2.18,2.32,2.37,2.34,2.28,2.31,2.24,2.26,2.38,3.19,2.74,2.47,2.44,2.42,2.38,2.37,2.31,2.27,2.34,2.56,2.61,2.53,2.47,2.50,2.45,2.46,2.52,3.26,2.78,2.56,2.54,2.55,2.54,2.52,2.51,2.51,2.52,2.52,2.50,2.50,2.50,2.48,2.46,2.48,2.45,2.43,2.37,2.36,2.33,2.32,2.29,2.38,2.59,2.59,2.52,2.58,2.52,2.55,2.62,3.35,2.90,2.70,2.60,2.55,2.51,2.53,2.52,2.52,2.53,2.56,2.57},
   {1.44,1.58,2.36,2.02,1.90,1.79,1.72,1.69,1.71,2.08,2.72,2.44,2.25,2.19,2.14,2.06,2.07,2.19,3.05,2.59,2.28,2.29,2.24,2.23,2.17,2.21,2.15,2.13,2.27,2.32,2.29,2.23,2.26,2.19,2.21,2.33,3.14,2.69,2.42,2.39,2.37,2.33,2.32,2.26,2.22,2.29,2.51,2.56,2.48,2.42,2.45,2.40,2.41,2.47,3.21,2.73,2.51,2.49,2.50,2.49,2.47,2.46,2.46,2.47,2.47,2.45,2.45,2.45,2.43,2.41,2.43,2.40,2.38,2.32,2.31,2.28,2.27,2.24,2.33,2.54,2.54,2.47,2.53,2.47,2.50,2.57,3.30,2.85,2.65,2.55,2.50,2.46,2.48,2.47,2.47,2.48,2.51,2.52},
   {1.43,1.57,2.35,2.01,1.89,1.78,1.71,1.68,1.70,2.07,2.71,2.43,2.24,2.18,2.13,2.05,2.06,2.18,3.04,2.58,2.27,2.28,2.23,2.22,2.16,2.20,2.14,2.12,2.26,2.31,2.28,2.22,2.25,2.18,2.20,2.32,3.13,2.68,2.41,2.38,2.36,2.32,2.31,2.25,2.21,2.28,2.50,2.55,2.47,2.41,2.44,2.39,2.40,2.46,3.20,2.72,2.50,2.48,2.49,2.48,2.46,2.45,2.45,2.46,2.46,2.44,2.44,2.44,2.42,2.40,2.42,2.39,2.37,2.31,2.30,2.27,2.26,2.23,2.32,2.53,2.53,2.46,2.52,2.46,2.49,2.56,3.29,2.84,2.64,2.54,2.49,2.45,2.47,2.46,2.46,2.47,2.50,2.51},
   {1.37,1.51,2.29,1.95,1.83,1.72,1.65,1.62,1.64,2.01,2.65,2.37,2.18,2.12,2.07,1.99,2.00,2.12,2.98,2.52,2.21,2.22,2.17,2.16,2.10,2.14,2.08,2.06,2.20,2.25,2.22,2.16,2.19,2.12,2.14,2.26,3.07,2.62,2.35,2.32,2.30,2.26,2.25,2.19,2.15,2.22,2.44,2.49,2.41,2.35,2.38,2.33,2.34,2.40,3.14,2.66,2.44,2.42,2.43,2.42,2.40,2.39,2.39,2.40,2.40,2.38,2.38,2.38,2.36,2.34,2.36,2.33,2.31,2.25,2.24,2.21,2.20,2.17,2.26,2.47,2.47,2.40,2.46,2.40,2.43,2.50,3.23,2.78,2.58,2.48,2.43,2.39,2.41,2.40,2.40,2.41,2.44,2.45},
   {1.41,1.55,2.33,1.99,1.87,1.76,1.69,1.66,1.68,2.05,2.69,2.41,2.22,2.16,2.11,2.03,2.04,2.16,3.02,2.56,2.25,2.26,2.21,2.20,2.14,2.18,2.12,2.10,2.24,2.29,2.26,2.20,2.23,2.16,2.18,2.30,3.11,2.66,2.39,2.36,2.34,2.30,2.29,2.23,2.19,2.26,2.48,2.53,2.45,2.39,2.42,2.37,2.38,2.44,3.18,2.70,2.48,2.46,2.47,2.46,2.44,2.43,2.43,2.44,2.44,2.42,2.42,2.42,2.40,2.38,2.40,2.37,2.35,2.29,2.28,2.25,2.24,2.21,2.30,2.51,2.51,2.44,2.50,2.44,2.47,2.54,3.27,2.82,2.62,2.52,2.47,2.43,2.45,2.44,2.44,2.45,2.48,2.49},
   {1.35,1.49,2.27,1.93,1.81,1.70,1.63,1.60,1.62,1.99,2.63,2.35,2.16,2.10,2.05,1.97,1.98,2.10,2.96,2.50,2.19,2.20,2.15,2.14,2.08,2.12,2.06,2.04,2.18,2.23,2.20,2.14,2.17,2.10,2.12,2.24,3.05,2.60,2.33,2.30,2.28,2.24,2.23,2.17,2.13,2.20,2.42,2.47,2.39,2.33,2.36,2.31,2.32,2.38,3.12,2.64,2.42,2.40,2.41,2.40,2.38,2.37,2.37,2.38,2.38,2.36,2.36,2.36,2.34,2.32,2.34,2.31,2.29,2.23,2.22,2.19,2.18,2.15,2.24,2.45,2.45,2.38,2.44,2.38,2.41,2.48,3.21,2.76,2.56,2.46,2.41,2.37,2.39,2.38,2.38,2.39,2.42,2.43},
   {1.33,1.47,2.25,1.91,1.79,1.68,1.61,1.58,1.60,1.97,2.61,2.33,2.14,2.08,2.03,1.95,1.96,2.08,2.94,2.48,2.17,2.18,2.13,2.12,2.06,2.10,2.04,2.02,2.16,2.21,2.18,2.12,2.15,2.08,2.10,2.22,3.03,2.58,2.31,2.28,2.26,2.22,2.21,2.15,2.11,2.18,2.40,2.45,2.37,2.31,2.34,2.29,2.30,2.36,3.10,2.62,2.40,2.38,2.39,2.38,2.36,2.35,2.35,2.36,2.36,2.34,2.34,2.34,2.32,2.30,2.32,2.29,2.27,2.21,2.20,2.17,2.16,2.13,2.22,2.43,2.43,2.36,2.42,2.36,2.39,2.46,3.19,2.74,2.54,2.44,2.39,2.35,2.37,2.36,2.36,2.37,2.40,2.41},
   {1.47,1.61,2.39,2.05,1.93,1.82,1.75,1.72,1.74,2.11,2.75,2.47,2.28,2.22,2.17,2.09,2.10,2.22,3.08,2.62,2.31,2.32,2.27,2.26,2.20,2.24,2.18,2.16,2.30,2.35,2.32,2.26,2.29,2.22,2.24,2.36,3.17,2.72,2.45,2.42,2.40,2.36,2.35,2.29,2.25,2.32,2.54,2.59,2.51,2.45,2.48,2.43,2.44,2.50,3.24,2.76,2.54,2.52,2.53,2.52,2.50,2.49,2.49,2.50,2.50,2.48,2.48,2.48,2.46,2.44,2.46,2.43,2.41,2.35,2.34,2.31,2.30,2.27,2.36,2.57,2.57,2.50,2.56,2.50,2.53,2.60,3.33,2.88,2.68,2.58,2.53,2.49,2.51,2.50,2.50,2.51,2.54,2.55},
   {1.52,1.66,2.44,2.10,1.98,1.87,1.80,1.77,1.79,2.16,2.80,2.52,2.33,2.27,2.22,2.14,2.15,2.27,3.13,2.67,2.36,2.37,2.32,2.31,2.25,2.29,2.23,2.21,2.35,2.40,2.37,2.31,2.34,2.27,2.29,2.41,3.22,2.77,2.50,2.47,2.45,2.41,2.40,2.34,2.30,2.37,2.59,2.64,2.56,2.50,2.53,2.48,2.49,2.55,3.29,2.81,2.59,2.57,2.58,2.57,2.55,2.54,2.54,2.55,2.55,2.53,2.53,2.53,2.51,2.49,2.51,2.48,2.46,2.40,2.39,2.36,2.35,2.32,2.41,2.62,2.62,2.55,2.61,2.55,2.58,2.65,3.38,2.93,2.73,2.63,2.58,2.54,2.56,2.55,2.55,2.56,2.59,2.60},
   {1.49,1.63,2.41,2.07,1.95,1.84,1.77,1.74,1.76,2.13,2.77,2.49,2.30,2.24,2.19,2.11,2.12,2.24,3.10,2.64,2.33,2.34,2.29,2.28,2.22,2.26,2.20,2.18,2.32,2.37,2.34,2.28,2.31,2.24,2.26,2.38,3.19,2.74,2.47,2.44,2.42,2.38,2.37,2.31,2.27,2.34,2.56,2.61,2.53,2.47,2.50,2.45,2.46,2.52,3.26,2.78,2.56,2.54,2.55,2.54,2.52,2.51,2.51,2.52,2.52,2.50,2.50,2.50,2.48,2.46,2.48,2.45,2.43,2.37,2.36,2.33,2.32,2.29,2.38,2.59,2.59,2.52,2.58,2.52,2.55,2.62,3.35,2.90,2.70,2.60,2.55,2.51,2.53,2.52,2.52,2.53,2.56,2.57},
   {1.43,1.57,2.35,2.01,1.89,1.78,1.71,1.68,1.70,2.07,2.71,2.43,2.24,2.18,2.13,2.05,2.06,2.18,3.04,2.58,2.27,2.28,2.23,2.22,2.16,2.20,2.14,2.12,2.26,2.31,2.28,2.22,2.25,2.18,2.20,2.32,3.13,2.68,2.41,2.38,2.36,2.32,2.31,2.25,2.21,2.28,2.50,2.55,2.47,2.41,2.44,2.39,2.40,2.46,3.20,2.72,2.50,2.48,2.49,2.48,2.46,2.45,2.45,2.46,2.46,2.44,2.44,2.44,2.42,2.40,2.42,2.39,2.37,2.31,2.30,2.27,2.26,2.23,2.32,2.53,2.53,2.46,2.52,2.46,2.49,2.56,3.29,2.84,2.64,2.54,2.49,2.45,2.47,2.46,2.46,2.47,2.50,2.51},
   {1.46,1.60,2.38,2.04,1.92,1.81,1.74,1.71,1.73,2.10,2.74,2.46,2.27,2.21,2.16,2.08,2.09,2.21,3.07,2.61,2.30,2.31,2.26,2.25,2.19,2.23,2.17,2.15,2.29,2.34,2.31,2.25,2.28,2.21,2.23,2.35,3.16,2.71,2.44,2.41,2.39,2.35,2.34,2.28,2.24,2.31,2.53,2.58,2.50,2.44,2.47,2.42,2.43,2.49,3.23,2.75,2.53,2.51,2.52,2.51,2.49,2.48,2.48,2.49,2.49,2.47,2.47,2.47,2.45,2.43,2.45,2.42,2.40,2.34,2.33,2.30,2.29,2.26,2.35,2.56,2.56,2.49,2.55,2.49,2.52,2.59,3.32,2.87,2.67,2.57,2.52,2.48,2.50,2.49,2.49,2.50,2.53,2.54},
   {1.39,1.53,2.31,1.97,1.85,1.74,1.67,1.64,1.66,2.03,2.67,2.39,2.20,2.14,2.09,2.01,2.02,2.14,3.00,2.54,2.23,2.24,2.19,2.18,2.12,2.16,2.10,2.08,2.22,2.27,2.24,2.18,2.21,2.14,2.16,2.28,3.09,2.64,2.37,2.34,2.32,2.28,2.27,2.21,2.17,2.24,2.46,2.51,2.43,2.37,2.40,2.35,2.36,2.42,3.16,2.68,2.46,2.44,2.45,2.44,2.42,2.41,2.41,2.42,2.42,2.40,2.40,2.40,2.38,2.36,2.38,2.35,2.33,2.27,2.26,2.23,2.22,2.19,2.28,2.49,2.49,2.42,2.48,2.42,2.45,2.52,3.25,2.80,2.60,2.50,2.45,2.41,2.43,2.42,2.42,2.43,2.46,2.47},
   {1.41,1.55,2.33,1.99,1.87,1.76,1.69,1.66,1.68,2.05,2.69,2.41,2.22,2.16,2.11,2.03,2.04,2.16,3.02,2.56,2.25,2.26,2.21,2.20,2.14,2.18,2.12,2.10,2.24,2.29,2.26,2.20,2.23,2.16,2.18,2.30,3.11,2.66,2.39,2.36,2.34,2.30,2.29,2.23,2.19,2.26,2.48,2.53,2.45,2.39,2.42,2.37,2.38,2.44,3.18,2.70,2.48,2.46,2.47,2.46,2.44,2.43,2.43,2.44,2.44,2.42,2.42,2.42,2.40,2.38,2.40,2.37,2.35,2.29,2.28,2.25,2.24,2.21,2.30,2.51,2.51,2.44,2.50,2.44,2.47,2.54,3.27,2.82,2.62,2.52,2.47,2.43,2.45,2.44,2.44,2.45,2.48,2.49},
   {1.53,1.67,2.45,2.11,1.99,1.88,1.81,1.78,1.80,2.17,2.81,2.53,2.34,2.28,2.23,2.15,2.16,2.28,3.14,2.68,2.37,2.38,2.33,2.32,2.26,2.30,2.24,2.22,2.36,2.41,2.38,2.32,2.35,2.28,2.30,2.42,3.23,2.78,2.51,2.48,2.46,2.42,2.41,2.35,2.31,2.38,2.60,2.65,2.57,2.51,2.54,2.49,2.50,2.56,3.30,2.82,2.60,2.58,2.59,2.58,2.56,2.55,2.55,2.56,2.56,2.54,2.54,2.54,2.52,2.50,2.52,2.49,2.47,2.41,2.40,2.37,2.36,2.33,2.42,2.63,2.63,2.56,2.62,2.56,2.59,2.66,3.39,2.94,2.74,2.64,2.59,2.55,2.57,2.56,2.56,2.57,2.60,2.61},
   {2.34,2.48,3.26,2.92,2.80,2.69,2.62,2.59,2.61,2.98,3.62,3.34,3.15,3.09,3.04,2.96,2.97,3.09,3.95,3.49,3.18,3.19,3.14,3.13,3.07,3.11,3.05,3.03,3.17,3.22,3.19,3.13,3.16,3.09,3.11,3.23,4.04,3.59,3.32,3.29,3.27,3.23,3.22,3.16,3.12,3.19,3.41,3.46,3.38,3.32,3.35,3.30,3.31,3.37,4.11,3.63,3.41,3.39,3.40,3.39,3.37,3.36,3.36,3.37,3.37,3.35,3.35,3.35,3.33,3.31,3.33,3.30,3.28,3.22,3.21,3.18,3.17,3.14,3.23,3.44,3.44,3.37,3.43,3.37,3.40,3.47,4.20,3.75,3.55,3.45,3.40,3.36,3.38,3.37,3.37,3.38,3.41,3.42},
   {1.89,2.03,2.81,2.47,2.35,2.24,2.17,2.14,2.16,2.53,3.17,2.89,2.70,2.64,2.59,2.51,2.52,2.64,3.50,3.04,2.73,2.74,2.69,2.68,2.62,2.66,2.60,2.58,2.72,2.77,2.74,2.68,2.71,2.64,2.66,2.78,3.59,3.14,2.87,2.84,2.82,2.78,2.77,2.71,2.67,2.74,2.96,3.01,2.93,2.87,2.90,2.85,2.86,2.92,3.66,3.18,2.96,2.94,2.95,2.94,2.92,2.91,2.91,2.92,2.92,2.90,2.90,2.90,2.88,2.86,2.88,2.85,2.83,2.77,2.76,2.73,2.72,2.69,2.78,2.99,2.99,2.92,2.98,2.92,2.95,3.02,3.75,3.30,3.10,3.00,2.95,2.91,2.93,2.92,2.92,2.93,2.96,2.97},
   {1.62,1.76,2.54,2.20,2.08,1.97,1.90,1.87,1.89,2.26,2.90,2.62,2.43,2.37,2.32,2.24,2.25,2.37,3.23,2.77,2.46,2.47,2.42,2.41,2.35,2.39,2.33,2.31,2.45,2.50,2.47,2.41,2.44,2.37,2.39,2.51,3.32,2.87,2.60,2.57,2.55,2.51,2.50,2.44,2.40,2.47,2.69,2.74,2.66,2.60,2.63,2.58,2.59,2.65,3.39,2.91,2.69,2.67,2.68,2.67,2.65,2.64,2.64,2.65,2.65,2.63,2.63,2.63,2.61,2.59,2.61,2.58,2.56,2.50,2.49,2.46,2.45,2.42,2.51,2.72,2.72,2.65,2.71,2.65,2.68,2.75,3.48,3.03,2.83,2.73,2.68,2.64,2.66,2.65,2.65,2.66,2.69,2.70},
   {1.59,1.73,2.51,2.17,2.05,1.94,1.87,1.84,1.86,2.23,2.87,2.59,2.40,2.34,2.29,2.21,2.22,2.34,3.20,2.74,2.43,2.44,2.39,2.38,2.32,2.36,2.30,2.28,2.42,2.47,2.44,2.38,2.41,2.34,2.36,2.48,3.29,2.84,2.57,2.54,2.52,2.48,2.47,2.41,2.37,2.44,2.66,2.71,2.63,2.57,2.60,2.55,2.56,2.62,3.36,2.88,2.66,2.64,2.65,2.64,2.62,2.61,2.61,2.62,2.62,2.60,2.60,2.60,2.58,2.56,2.58,2.55,2.53,2.47,2.46,2.43,2.42,2.39,2.48,2.69,2.69,2.62,2.68,2.62,2.65,2.72,3.45,3.00,2.80,2.70,2.65,2.61,2.63,2.62,2.62,2.63,2.66,2.67},
   {1.57,1.71,2.49,2.15,2.03,1.92,1.85,1.82,1.84,2.21,2.85,2.57,2.38,2.32,2.27,2.19,2.20,2.32,3.18,2.72,2.41,2.42,2.37,2.36,2.30,2.34,2.28,2.26,2.40,2.45,2.42,2.36,2.39,2.32,2.34,2.46,3.27,2.82,2.55,2.52,2.50,2.46,2.45,2.39,2.35,2.42,2.64,2.69,2.61,2.55,2.58,2.53,2.54,2.60,3.34,2.86,2.64,2.62,2.63,2.62,2.60,2.59,2.59,2.60,2.60,2.58,2.58,2.58,2.56,2.54,2.56,2.53,2.51,2.45,2.44,2.41,2.40,2.37,2.46,2.67,2.67,2.60,2.66,2.60,2.63,2.70,3.43,2.98,2.78,2.68,2.63,2.59,2.61,2.60,2.60,2.61,2.64,2.65},
   {1.53,1.67,2.45,2.11,1.99,1.88,1.81,1.78,1.80,2.17,2.81,2.53,2.34,2.28,2.23,2.15,2.16,2.28,3.14,2.68,2.37,2.38,2.33,2.32,2.26,2.30,2.24,2.22,2.36,2.41,2.38,2.32,2.35,2.28,2.30,2.42,3.23,2.78,2.51,2.48,2.46,2.42,2.41,2.35,2.31,2.38,2.60,2.65,2.57,2.51,2.54,2.49,2.50,2.56,3.30,2.82,2.60,2.58,2.59,2.58,2.56,2.55,2.55,2.56,2.56,2.54,2.54,2.54,2.52,2.50,2.52,2.49,2.47,2.41,2.40,2.37,2.36,2.33,2.42,2.63,2.63,2.56,2.62,2.56,2.59,2.66,3.39,2.94,2.74,2.64,2.59,2.55,2.57,2.56,2.56,2.57,2.60,2.61},
   {1.52,1.66,2.44,2.10,1.98,1.87,1.80,1.77,1.79,2.16,2.80,2.52,2.33,2.27,2.22,2.14,2.15,2.27,3.13,2.67,2.36,2.37,2.32,2.31,2.25,2.29,2.23,2.21,2.35,2.40,2.37,2.31,2.34,2.27,2.29,2.41,3.22,2.77,2.50,2.47,2.45,2.41,2.40,2.34,2.30,2.37,2.59,2.64,2.56,2.50,2.53,2.48,2.49,2.55,3.29,2.81,2.59,2.57,2.58,2.57,2.55,2.54,2.54,2.55,2.55,2.53,2.53,2.53,2.51,2.49,2.51,2.48,2.46,2.40,2.39,2.36,2.35,2.32,2.41,2.62,2.62,2.55,2.61,2.55,2.58,2.65,3.38,2.93,2.73,2.63,2.58,2.54,2.56,2.55,2.55,2.56,2.59,2.60},
   {1.46,1.60,2.38,2.04,1.92,1.81,1.74,1.71,1.73,2.10,2.74,2.46,2.27,2.21,2.16,2.08,2.09,2.21,3.07,2.61,2.30,2.31,2.26,2.25,2.19,2.23,2.17,2.15,2.29,2.34,2.31,2.25,2.28,2.21,2.23,2.35,3.16,2.71,2.44,2.41,2.39,2.35,2.34,2.28,2.24,2.31,2.53,2.58,2.50,2.44,2.47,2.42,2.43,2.49,3.23,2.75,2.53,2.51,2.52,2.51,2.49,2.48,2.48,2.49,2.49,2.47,2.47,2.47,2.45,2.43,2.45,2.42,2.40,2.34,2.33,2.30,2.29,2.26,2.35,2.56,2.56,2.49,2.55,2.49,2.52,2.59,3.32,2.87,2.67,2.57,2.52,2.48,2.50,2.49,2.49,2.50,2.53,2.54},
   {1.42,1.56,2.34,2.00,1.88,1.77,1.70,1.67,1.69,2.06,2.70,2.42,2.23,2.17,2.12,2.04,2.05,2.17,3.03,2.57,2.26,2.27,2.22,2.21,2.15,2.19,2.13,2.11,2.25,2.30,2.27,2.21,2.24,2.17,2.19,2.31,3.12,2.67,2.40,2.37,2.35,2.31,2.30,2.24,2.20,2.27,2.49,2.54,2.46,2.40,2.43,2.38,2.39,2.45,3.19,2.71,2.49,2.47,2.48,2.47,2.45,2.44,2.44,2.45,2.45,2.43,2.43,2.43,2.41,2.39,2.41,2.38,2.36,2.30,2.29,2.26,2.25,2.22,2.31,2.52,2.52,2.45,2.51,2.45,2.48,2.55,3.28,2.83,2.63,2.53,2.48,2.44,2.46,2.45,2.45,2.46,2.49,2.50},
   {1.49,1.63,2.41,2.07,1.95,1.84,1.77,1.74,1.76,2.13,2.77,2.49,2.30,2.24,2.19,2.11,2.12,2.24,3.10,2.64,2.33,2.34,2.29,2.28,2.22,2.26,2.20,2.18,2.32,2.37,2.34,2.28,2.31,2.24,2.26,2.38,3.19,2.74,2.47,2.44,2.42,2.38,2.37,2.31,2.27,2.34,2.56,2.61,2.53,2.47,2.50,2.45,2.46,2.52,3.26,2.78,2.56,2.54,2.55,2.54,2.52,2.51,2.51,2.52,2.52,2.50,2.50,2.50,2.48,2.46,2.48,2.45,2.43,2.37,2.36,2.33,2.32,2.29,2.38,2.59,2.59,2.52,2.58,2.52,2.55,2.62,3.35,2.90,2.70,2.60,2.55,2.51,2.53,2.52,2.52,2.53,2.56,2.57},
   {1.71,1.85,2.63,2.29,2.17,2.06,1.99,1.96,1.98,2.35,2.99,2.71,2.52,2.46,2.41,2.33,2.34,2.46,3.32,2.86,2.55,2.56,2.51,2.50,2.44,2.48,2.42,2.40,2.54,2.59,2.56,2.50,2.53,2.46,2.48,2.60,3.41,2.96,2.69,2.66,2.64,2.60,2.59,2.53,2.49,2.56,2.78,2.83,2.75,2.69,2.72,2.67,2.68,2.74,3.48,3.00,2.78,2.76,2.77,2.76,2.74,2.73,2.73,2.74,2.74,2.72,2.72,2.72,2.70,2.68,2.70,2.67,2.65,2.59,2.58,2.55,2.54,2.51,2.60,2.81,2.81,2.74,2.80,2.74,2.77,2.84,3.57,3.12,2.92,2.82,2.77,2.73,2.75,2.74,2.74,2.75,2.78,2.79},
   {1.76,1.90,2.68,2.34,2.22,2.11,2.04,2.01,2.03,2.40,3.04,2.76,2.57,2.51,2.46,2.38,2.39,2.51,3.37,2.91,2.60,2.61,2.56,2.55,2.49,2.53,2.47,2.45,2.59,2.64,2.61,2.55,2.58,2.51,2.53,2.65,3.46,3.01,2.74,2.71,2.69,2.65,2.64,2.58,2.54,2.61,2.83,2.88,2.80,2.74,2.77,2.72,2.73,2.79,3.53,3.05,2.83,2.81,2.82,2.81,2.79,2.78,2.78,2.79,2.79,2.77,2.77,2.77,2.75,2.73,2.75,2.72,2.70,2.64,2.63,2.60,2.59,2.56,2.65,2.86,2.86,2.79,2.85,2.79,2.82,2.89,3.62,3.17,2.97,2.87,2.82,2.78,2.80,2.79,2.79,2.80,2.83,2.84},
   {1.68,1.82,2.60,2.26,2.14,2.03,1.96,1.93,1.95,2.32,2.96,2.68,2.49,2.43,2.38,2.30,2.31,2.43,3.29,2.83,2.52,2.53,2.48,2.47,2.41,2.45,2.39,2.37,2.51,2.56,2.53,2.47,2.50,2.43,2.45,2.57,3.38,2.93,2.66,2.63,2.61,2.57,2.56,2.50,2.46,2.53,2.75,2.80,2.72,2.66,2.69,2.64,2.65,2.71,3.45,2.97,2.75,2.73,2.74,2.73,2.71,2.70,2.70,2.71,2.71,2.69,2.69,2.69,2.67,2.65,2.67,2.64,2.62,2.56,2.55,2.52,2.51,2.48,2.57,2.78,2.78,2.71,2.77,2.71,2.74,2.81,3.54,3.09,2.89,2.79,2.74,2.70,2.72,2.71,2.71,2.72,2.75,2.76},
   {1.62,1.76,2.54,2.20,2.08,1.97,1.90,1.87,1.89,2.26,2.90,2.62,2.43,2.37,2.32,2.24,2.25,2.37,3.23,2.77,2.46,2.47,2.42,2.41,2.35,2.39,2.33,2.31,2.45,2.50,2.47,2.41,2.44,2.37,2.39,2.51,3.32,2.87,2.60,2.57,2.55,2.51,2.50,2.44,2.40,2.47,2.69,2.74,2.66,2.60,2.63,2.58,2.59,2.65,3.39,2.91,2.69,2.67,2.68,2.67,2.65,2.64,2.64,2.65,2.65,2.63,2.63,2.63,2.61,2.59,2.61,2.58,2.56,2.50,2.49,2.46,2.45,2.42,2.51,2.72,2.72,2.65,2.71,2.65,2.68,2.75,3.48,3.03,2.83,2.73,2.68,2.64,2.66,2.65,2.65,2.66,2.69,2.70},
   {1.65,1.79,2.57,2.23,2.11,2.00,1.93,1.90,1.92,2.29,2.93,2.65,2.46,2.40,2.35,2.27,2.28,2.40,3.26,2.80,2.49,2.50,2.45,2.44,2.38,2.42,2.36,2.34,2.48,2.53,2.50,2.44,2.47,2.40,2.42,2.54,3.35,2.90,2.63,2.60,2.58,2.54,2.53,2.47,2.43,2.50,2.72,2.77,2.69,2.63,2.66,2.61,2.62,2.68,3.42,2.94,2.72,2.70,2.71,2.70,2.68,2.67,2.67,2.68,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.61,2.59,2.53,2.52,2.49,2.48,2.45,2.54,2.75,2.75,2.68,2.74,2.68,2.71,2.78,3.51,3.06,2.86,2.76,2.71,2.67,2.69,2.68,2.68,2.69,2.72,2.73},
   {1.60,1.74,2.52,2.18,2.06,1.95,1.88,1.85,1.87,2.24,2.88,2.60,2.41,2.35,2.30,2.22,2.23,2.35,3.21,2.75,2.44,2.45,2.40,2.39,2.33,2.37,2.31,2.29,2.43,2.48,2.45,2.39,2.42,2.35,2.37,2.49,3.30,2.85,2.58,2.55,2.53,2.49,2.48,2.42,2.38,2.45,2.67,2.72,2.64,2.58,2.61,2.56,2.57,2.63,3.37,2.89,2.67,2.65,2.66,2.65,2.63,2.62,2.62,2.63,2.63,2.61,2.61,2.61,2.59,2.57,2.59,2.56,2.54,2.48,2.47,2.44,2.43,2.40,2.49,2.70,2.70,2.63,2.69,2.63,2.66,2.73,3.46,3.01,2.81,2.71,2.66,2.62,2.64,2.63,2.63,2.64,2.67,2.68},
   {1.61,1.75,2.53,2.19,2.07,1.96,1.89,1.86,1.88,2.25,2.89,2.61,2.42,2.36,2.31,2.23,2.24,2.36,3.22,2.76,2.45,2.46,2.41,2.40,2.34,2.38,2.32,2.30,2.44,2.49,2.46,2.40,2.43,2.36,2.38,2.50,3.31,2.86,2.59,2.56,2.54,2.50,2.49,2.43,2.39,2.46,2.68,2.73,2.65,2.59,2.62,2.57,2.58,2.64,3.38,2.90,2.68,2.66,2.67,2.66,2.64,2.63,2.63,2.64,2.64,2.62,2.62,2.62,2.60,2.58,2.60,2.57,2.55,2.49,2.48,2.45,2.44,2.41,2.50,2.71,2.71,2.64,2.70,2.64,2.67,2.74,3.47,3.02,2.82,2.72,2.67,2.63,2.65,2.64,2.64,2.65,2.68,2.69},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {2.41,2.55,3.33,2.99,2.87,2.76,2.69,2.66,2.68,3.05,3.69,3.41,3.22,3.16,3.11,3.03,3.04,3.16,4.02,3.56,3.25,3.26,3.21,3.20,3.14,3.18,3.12,3.10,3.24,3.29,3.26,3.20,3.23,3.16,3.18,3.30,4.11,3.66,3.39,3.36,3.34,3.30,3.29,3.23,3.19,3.26,3.48,3.53,3.45,3.39,3.42,3.37,3.38,3.44,4.18,3.70,3.48,3.46,3.47,3.46,3.44,3.43,3.43,3.44,3.44,3.42,3.42,3.42,3.40,3.38,3.40,3.37,3.35,3.29,3.28,3.25,3.24,3.21,3.30,3.51,3.51,3.44,3.50,3.44,3.47,3.54,4.27,3.82,3.62,3.52,3.47,3.43,3.45,3.44,3.44,3.45,3.48,3.49},
   {1.93,2.07,2.85,2.51,2.39,2.28,2.21,2.18,2.20,2.57,3.21,2.93,2.74,2.68,2.63,2.55,2.56,2.68,3.54,3.08,2.77,2.78,2.73,2.72,2.66,2.70,2.64,2.62,2.76,2.81,2.78,2.72,2.75,2.68,2.70,2.82,3.63,3.18,2.91,2.88,2.86,2.82,2.81,2.75,2.71,2.78,3.00,3.05,2.97,2.91,2.94,2.89,2.90,2.96,3.70,3.22,3.00,2.98,2.99,2.98,2.96,2.95,2.95,2.96,2.96,2.94,2.94,2.94,2.92,2.90,2.92,2.89,2.87,2.81,2.80,2.77,2.76,2.73,2.82,3.03,3.03,2.96,3.02,2.96,2.99,3.06,3.79,3.34,3.14,3.04,2.99,2.95,2.97,2.96,2.96,2.97,3.00,3.01},
   {1.71,1.85,2.63,2.29,2.17,2.06,1.99,1.96,1.98,2.35,2.99,2.71,2.52,2.46,2.41,2.33,2.34,2.46,3.32,2.86,2.55,2.56,2.51,2.50,2.44,2.48,2.42,2.40,2.54,2.59,2.56,2.50,2.53,2.46,2.48,2.60,3.41,2.96,2.69,2.66,2.64,2.60,2.59,2.53,2.49,2.56,2.78,2.83,2.75,2.69,2.72,2.67,2.68,2.74,3.48,3.00,2.78,2.76,2.77,2.76,2.74,2.73,2.73,2.74,2.74,2.72,2.72,2.72,2.70,2.68,2.70,2.67,2.65,2.59,2.58,2.55,2.54,2.51,2.60,2.81,2.81,2.74,2.80,2.74,2.77,2.84,3.57,3.12,2.92,2.82,2.77,2.73,2.75,2.74,2.74,2.75,2.78,2.79},
   {1.69,1.83,2.61,2.27,2.15,2.04,1.97,1.94,1.96,2.33,2.97,2.69,2.50,2.44,2.39,2.31,2.32,2.44,3.30,2.84,2.53,2.54,2.49,2.48,2.42,2.46,2.40,2.38,2.52,2.57,2.54,2.48,2.51,2.44,2.46,2.58,3.39,2.94,2.67,2.64,2.62,2.58,2.57,2.51,2.47,2.54,2.76,2.81,2.73,2.67,2.70,2.65,2.66,2.72,3.46,2.98,2.76,2.74,2.75,2.74,2.72,2.71,2.71,2.72,2.72,2.70,2.70,2.70,2.68,2.66,2.68,2.65,2.63,2.57,2.56,2.53,2.52,2.49,2.58,2.79,2.79,2.72,2.78,2.72,2.75,2.82,3.55,3.10,2.90,2.80,2.75,2.71,2.73,2.72,2.72,2.73,2.76,2.77},
   {1.70,1.84,2.62,2.28,2.16,2.05,1.98,1.95,1.97,2.34,2.98,2.70,2.51,2.45,2.40,2.32,2.33,2.45,3.31,2.85,2.54,2.55,2.50,2.49,2.43,2.47,2.41,2.39,2.53,2.58,2.55,2.49,2.52,2.45,2.47,2.59,3.40,2.95,2.68,2.65,2.63,2.59,2.58,2.52,2.48,2.55,2.77,2.82,2.74,2.68,2.71,2.66,2.67,2.73,3.47,2.99,2.77,2.75,2.76,2.75,2.73,2.72,2.72,2.73,2.73,2.71,2.71,2.71,2.69,2.67,2.69,2.66,2.64,2.58,2.57,2.54,2.53,2.50,2.59,2.80,2.80,2.73,2.79,2.73,2.76,2.83,3.56,3.11,2.91,2.81,2.76,2.72,2.74,2.73,2.73,2.74,2.77,2.78},
   {1.69,1.83,2.61,2.27,2.15,2.04,1.97,1.94,1.96,2.33,2.97,2.69,2.50,2.44,2.39,2.31,2.32,2.44,3.30,2.84,2.53,2.54,2.49,2.48,2.42,2.46,2.40,2.38,2.52,2.57,2.54,2.48,2.51,2.44,2.46,2.58,3.39,2.94,2.67,2.64,2.62,2.58,2.57,2.51,2.47,2.54,2.76,2.81,2.73,2.67,2.70,2.65,2.66,2.72,3.46,2.98,2.76,2.74,2.75,2.74,2.72,2.71,2.71,2.72,2.72,2.70,2.70,2.70,2.68,2.66,2.68,2.65,2.63,2.57,2.56,2.53,2.52,2.49,2.58,2.79,2.79,2.72,2.78,2.72,2.75,2.82,3.55,3.10,2.90,2.80,2.75,2.71,2.73,2.72,2.72,2.73,2.76,2.77},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.66,1.80,2.58,2.24,2.12,2.01,1.94,1.91,1.93,2.30,2.94,2.66,2.47,2.41,2.36,2.28,2.29,2.41,3.27,2.81,2.50,2.51,2.46,2.45,2.39,2.43,2.37,2.35,2.49,2.54,2.51,2.45,2.48,2.41,2.43,2.55,3.36,2.91,2.64,2.61,2.59,2.55,2.54,2.48,2.44,2.51,2.73,2.78,2.70,2.64,2.67,2.62,2.63,2.69,3.43,2.95,2.73,2.71,2.72,2.71,2.69,2.68,2.68,2.69,2.69,2.67,2.67,2.67,2.65,2.63,2.65,2.62,2.60,2.54,2.53,2.50,2.49,2.46,2.55,2.76,2.76,2.69,2.75,2.69,2.72,2.79,3.52,3.07,2.87,2.77,2.72,2.68,2.70,2.69,2.69,2.70,2.73,2.74},
   {1.66,1.80,2.58,2.24,2.12,2.01,1.94,1.91,1.93,2.30,2.94,2.66,2.47,2.41,2.36,2.28,2.29,2.41,3.27,2.81,2.50,2.51,2.46,2.45,2.39,2.43,2.37,2.35,2.49,2.54,2.51,2.45,2.48,2.41,2.43,2.55,3.36,2.91,2.64,2.61,2.59,2.55,2.54,2.48,2.44,2.51,2.73,2.78,2.70,2.64,2.67,2.62,2.63,2.69,3.43,2.95,2.73,2.71,2.72,2.71,2.69,2.68,2.68,2.69,2.69,2.67,2.67,2.67,2.65,2.63,2.65,2.62,2.60,2.54,2.53,2.50,2.49,2.46,2.55,2.76,2.76,2.69,2.75,2.69,2.72,2.79,3.52,3.07,2.87,2.77,2.72,2.68,2.70,2.69,2.69,2.70,2.73,2.74},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.65,1.79,2.57,2.23,2.11,2.00,1.93,1.90,1.92,2.29,2.93,2.65,2.46,2.40,2.35,2.27,2.28,2.40,3.26,2.80,2.49,2.50,2.45,2.44,2.38,2.42,2.36,2.34,2.48,2.53,2.50,2.44,2.47,2.40,2.42,2.54,3.35,2.90,2.63,2.60,2.58,2.54,2.53,2.47,2.43,2.50,2.72,2.77,2.69,2.63,2.66,2.61,2.62,2.68,3.42,2.94,2.72,2.70,2.71,2.70,2.68,2.67,2.67,2.68,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.61,2.59,2.53,2.52,2.49,2.48,2.45,2.54,2.75,2.75,2.68,2.74,2.68,2.71,2.78,3.51,3.06,2.86,2.76,2.71,2.67,2.69,2.68,2.68,2.69,2.72,2.73},
   {1.65,1.79,2.57,2.23,2.11,2.00,1.93,1.90,1.92,2.29,2.93,2.65,2.46,2.40,2.35,2.27,2.28,2.40,3.26,2.80,2.49,2.50,2.45,2.44,2.38,2.42,2.36,2.34,2.48,2.53,2.50,2.44,2.47,2.40,2.42,2.54,3.35,2.90,2.63,2.60,2.58,2.54,2.53,2.47,2.43,2.50,2.72,2.77,2.69,2.63,2.66,2.61,2.62,2.68,3.42,2.94,2.72,2.70,2.71,2.70,2.68,2.67,2.67,2.68,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.61,2.59,2.53,2.52,2.49,2.48,2.45,2.54,2.75,2.75,2.68,2.74,2.68,2.71,2.78,3.51,3.06,2.86,2.76,2.71,2.67,2.69,2.68,2.68,2.69,2.72,2.73},
   {1.65,1.79,2.57,2.23,2.11,2.00,1.93,1.90,1.92,2.29,2.93,2.65,2.46,2.40,2.35,2.27,2.28,2.40,3.26,2.80,2.49,2.50,2.45,2.44,2.38,2.42,2.36,2.34,2.48,2.53,2.50,2.44,2.47,2.40,2.42,2.54,3.35,2.90,2.63,2.60,2.58,2.54,2.53,2.47,2.43,2.50,2.72,2.77,2.69,2.63,2.66,2.61,2.62,2.68,3.42,2.94,2.72,2.70,2.71,2.70,2.68,2.67,2.67,2.68,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.61,2.59,2.53,2.52,2.49,2.48,2.45,2.54,2.75,2.75,2.68,2.74,2.68,2.71,2.78,3.51,3.06,2.86,2.76,2.71,2.67,2.69,2.68,2.68,2.69,2.72,2.73},
   {1.63,1.77,2.55,2.21,2.09,1.98,1.91,1.88,1.90,2.27,2.91,2.63,2.44,2.38,2.33,2.25,2.26,2.38,3.24,2.78,2.47,2.48,2.43,2.42,2.36,2.40,2.34,2.32,2.46,2.51,2.48,2.42,2.45,2.38,2.40,2.52,3.33,2.88,2.61,2.58,2.56,2.52,2.51,2.45,2.41,2.48,2.70,2.75,2.67,2.61,2.64,2.59,2.60,2.66,3.40,2.92,2.70,2.68,2.69,2.68,2.66,2.65,2.65,2.66,2.66,2.64,2.64,2.64,2.62,2.60,2.62,2.59,2.57,2.51,2.50,2.47,2.46,2.43,2.52,2.73,2.73,2.66,2.72,2.66,2.69,2.76,3.49,3.04,2.84,2.74,2.69,2.65,2.67,2.66,2.66,2.67,2.70,2.71},
   {1.61,1.75,2.53,2.19,2.07,1.96,1.89,1.86,1.88,2.25,2.89,2.61,2.42,2.36,2.31,2.23,2.24,2.36,3.22,2.76,2.45,2.46,2.41,2.40,2.34,2.38,2.32,2.30,2.44,2.49,2.46,2.40,2.43,2.36,2.38,2.50,3.31,2.86,2.59,2.56,2.54,2.50,2.49,2.43,2.39,2.46,2.68,2.73,2.65,2.59,2.62,2.57,2.58,2.64,3.38,2.90,2.68,2.66,2.67,2.66,2.64,2.63,2.63,2.64,2.64,2.62,2.62,2.62,2.60,2.58,2.60,2.57,2.55,2.49,2.48,2.45,2.44,2.41,2.50,2.71,2.71,2.64,2.70,2.64,2.67,2.74,3.47,3.02,2.82,2.72,2.67,2.63,2.65,2.64,2.64,2.65,2.68,2.69},
   {1.63,1.77,2.55,2.21,2.09,1.98,1.91,1.88,1.90,2.27,2.91,2.63,2.44,2.38,2.33,2.25,2.26,2.38,3.24,2.78,2.47,2.48,2.43,2.42,2.36,2.40,2.34,2.32,2.46,2.51,2.48,2.42,2.45,2.38,2.40,2.52,3.33,2.88,2.61,2.58,2.56,2.52,2.51,2.45,2.41,2.48,2.70,2.75,2.67,2.61,2.64,2.59,2.60,2.66,3.40,2.92,2.70,2.68,2.69,2.68,2.66,2.65,2.65,2.66,2.66,2.64,2.64,2.64,2.62,2.60,2.62,2.59,2.57,2.51,2.50,2.47,2.46,2.43,2.52,2.73,2.73,2.66,2.72,2.66,2.69,2.76,3.49,3.04,2.84,2.74,2.69,2.65,2.67,2.66,2.66,2.67,2.70,2.71},
   {1.60,1.74,2.52,2.18,2.06,1.95,1.88,1.85,1.87,2.24,2.88,2.60,2.41,2.35,2.30,2.22,2.23,2.35,3.21,2.75,2.44,2.45,2.40,2.39,2.33,2.37,2.31,2.29,2.43,2.48,2.45,2.39,2.42,2.35,2.37,2.49,3.30,2.85,2.58,2.55,2.53,2.49,2.48,2.42,2.38,2.45,2.67,2.72,2.64,2.58,2.61,2.56,2.57,2.63,3.37,2.89,2.67,2.65,2.66,2.65,2.63,2.62,2.62,2.63,2.63,2.61,2.61,2.61,2.59,2.57,2.59,2.56,2.54,2.48,2.47,2.44,2.43,2.40,2.49,2.70,2.70,2.63,2.69,2.63,2.66,2.73,3.46,3.01,2.81,2.71,2.66,2.62,2.64,2.63,2.63,2.64,2.67,2.68},
   {1.58,1.72,2.50,2.16,2.04,1.93,1.86,1.83,1.85,2.22,2.86,2.58,2.39,2.33,2.28,2.20,2.21,2.33,3.19,2.73,2.42,2.43,2.38,2.37,2.31,2.35,2.29,2.27,2.41,2.46,2.43,2.37,2.40,2.33,2.35,2.47,3.28,2.83,2.56,2.53,2.51,2.47,2.46,2.40,2.36,2.43,2.65,2.70,2.62,2.56,2.59,2.54,2.55,2.61,3.35,2.87,2.65,2.63,2.64,2.63,2.61,2.60,2.60,2.61,2.61,2.59,2.59,2.59,2.57,2.55,2.57,2.54,2.52,2.46,2.45,2.42,2.41,2.38,2.47,2.68,2.68,2.61,2.67,2.61,2.64,2.71,3.44,2.99,2.79,2.69,2.64,2.60,2.62,2.61,2.61,2.62,2.65,2.66},
   {1.52,1.66,2.44,2.10,1.98,1.87,1.80,1.77,1.79,2.16,2.80,2.52,2.33,2.27,2.22,2.14,2.15,2.27,3.13,2.67,2.36,2.37,2.32,2.31,2.25,2.29,2.23,2.21,2.35,2.40,2.37,2.31,2.34,2.27,2.29,2.41,3.22,2.77,2.50,2.47,2.45,2.41,2.40,2.34,2.30,2.37,2.59,2.64,2.56,2.50,2.53,2.48,2.49,2.55,3.29,2.81,2.59,2.57,2.58,2.57,2.55,2.54,2.54,2.55,2.55,2.53,2.53,2.53,2.51,2.49,2.51,2.48,2.46,2.40,2.39,2.36,2.35,2.32,2.41,2.62,2.62,2.55,2.61,2.55,2.58,2.65,3.38,2.93,2.73,2.63,2.58,2.54,2.56,2.55,2.55,2.56,2.59,2.60},
   {1.51,1.65,2.43,2.09,1.97,1.86,1.79,1.76,1.78,2.15,2.79,2.51,2.32,2.26,2.21,2.13,2.14,2.26,3.12,2.66,2.35,2.36,2.31,2.30,2.24,2.28,2.22,2.20,2.34,2.39,2.36,2.30,2.33,2.26,2.28,2.40,3.21,2.76,2.49,2.46,2.44,2.40,2.39,2.33,2.29,2.36,2.58,2.63,2.55,2.49,2.52,2.47,2.48,2.54,3.28,2.80,2.58,2.56,2.57,2.56,2.54,2.53,2.53,2.54,2.54,2.52,2.52,2.52,2.50,2.48,2.50,2.47,2.45,2.39,2.38,2.35,2.34,2.31,2.40,2.61,2.61,2.54,2.60,2.54,2.57,2.64,3.37,2.92,2.72,2.62,2.57,2.53,2.55,2.54,2.54,2.55,2.58,2.59},
   {1.48,1.62,2.40,2.06,1.94,1.83,1.76,1.73,1.75,2.12,2.76,2.48,2.29,2.23,2.18,2.10,2.11,2.23,3.09,2.63,2.32,2.33,2.28,2.27,2.21,2.25,2.19,2.17,2.31,2.36,2.33,2.27,2.30,2.23,2.25,2.37,3.18,2.73,2.46,2.43,2.41,2.37,2.36,2.30,2.26,2.33,2.55,2.60,2.52,2.46,2.49,2.44,2.45,2.51,3.25,2.77,2.55,2.53,2.54,2.53,2.51,2.50,2.50,2.51,2.51,2.49,2.49,2.49,2.47,2.45,2.47,2.44,2.42,2.36,2.35,2.32,2.31,2.28,2.37,2.58,2.58,2.51,2.57,2.51,2.54,2.61,3.34,2.89,2.69,2.59,2.54,2.50,2.52,2.51,2.51,2.52,2.55,2.56},
   {1.47,1.61,2.39,2.05,1.93,1.82,1.75,1.72,1.74,2.11,2.75,2.47,2.28,2.22,2.17,2.09,2.10,2.22,3.08,2.62,2.31,2.32,2.27,2.26,2.20,2.24,2.18,2.16,2.30,2.35,2.32,2.26,2.29,2.22,2.24,2.36,3.17,2.72,2.45,2.42,2.40,2.36,2.35,2.29,2.25,2.32,2.54,2.59,2.51,2.45,2.48,2.43,2.44,2.50,3.24,2.76,2.54,2.52,2.53,2.52,2.50,2.49,2.49,2.50,2.50,2.48,2.48,2.48,2.46,2.44,2.46,2.43,2.41,2.35,2.34,2.31,2.30,2.27,2.36,2.57,2.57,2.50,2.56,2.50,2.53,2.60,3.33,2.88,2.68,2.58,2.53,2.49,2.51,2.50,2.50,2.51,2.54,2.55},
   {1.44,1.58,2.36,2.02,1.90,1.79,1.72,1.69,1.71,2.08,2.72,2.44,2.25,2.19,2.14,2.06,2.07,2.19,3.05,2.59,2.28,2.29,2.24,2.23,2.17,2.21,2.15,2.13,2.27,2.32,2.29,2.23,2.26,2.19,2.21,2.33,3.14,2.69,2.42,2.39,2.37,2.33,2.32,2.26,2.22,2.29,2.51,2.56,2.48,2.42,2.45,2.40,2.41,2.47,3.21,2.73,2.51,2.49,2.50,2.49,2.47,2.46,2.46,2.47,2.47,2.45,2.45,2.45,2.43,2.41,2.43,2.40,2.38,2.32,2.31,2.28,2.27,2.24,2.33,2.54,2.54,2.47,2.53,2.47,2.50,2.57,3.30,2.85,2.65,2.55,2.50,2.46,2.48,2.47,2.47,2.48,2.51,2.52},
   {1.53,1.67,2.45,2.11,1.99,1.88,1.81,1.78,1.80,2.17,2.81,2.53,2.34,2.28,2.23,2.15,2.16,2.28,3.14,2.68,2.37,2.38,2.33,2.32,2.26,2.30,2.24,2.22,2.36,2.41,2.38,2.32,2.35,2.28,2.30,2.42,3.23,2.78,2.51,2.48,2.46,2.42,2.41,2.35,2.31,2.38,2.60,2.65,2.57,2.51,2.54,2.49,2.50,2.56,3.30,2.82,2.60,2.58,2.59,2.58,2.56,2.55,2.55,2.56,2.56,2.54,2.54,2.54,2.52,2.50,2.52,2.49,2.47,2.41,2.40,2.37,2.36,2.33,2.42,2.63,2.63,2.56,2.62,2.56,2.59,2.66,3.39,2.94,2.74,2.64,2.59,2.55,2.57,2.56,2.56,2.57,2.60,2.61},
   {1.74,1.88,2.66,2.32,2.20,2.09,2.02,1.99,2.01,2.38,3.02,2.74,2.55,2.49,2.44,2.36,2.37,2.49,3.35,2.89,2.58,2.59,2.54,2.53,2.47,2.51,2.45,2.43,2.57,2.62,2.59,2.53,2.56,2.49,2.51,2.63,3.44,2.99,2.72,2.69,2.67,2.63,2.62,2.56,2.52,2.59,2.81,2.86,2.78,2.72,2.75,2.70,2.71,2.77,3.51,3.03,2.81,2.79,2.80,2.79,2.77,2.76,2.76,2.77,2.77,2.75,2.75,2.75,2.73,2.71,2.73,2.70,2.68,2.62,2.61,2.58,2.57,2.54,2.63,2.84,2.84,2.77,2.83,2.77,2.80,2.87,3.60,3.15,2.95,2.85,2.80,2.76,2.78,2.77,2.77,2.78,2.81,2.82},
   {1.74,1.88,2.66,2.32,2.20,2.09,2.02,1.99,2.01,2.38,3.02,2.74,2.55,2.49,2.44,2.36,2.37,2.49,3.35,2.89,2.58,2.59,2.54,2.53,2.47,2.51,2.45,2.43,2.57,2.62,2.59,2.53,2.56,2.49,2.51,2.63,3.44,2.99,2.72,2.69,2.67,2.63,2.62,2.56,2.52,2.59,2.81,2.86,2.78,2.72,2.75,2.70,2.71,2.77,3.51,3.03,2.81,2.79,2.80,2.79,2.77,2.76,2.76,2.77,2.77,2.75,2.75,2.75,2.73,2.71,2.73,2.70,2.68,2.62,2.61,2.58,2.57,2.54,2.63,2.84,2.84,2.77,2.83,2.77,2.80,2.87,3.60,3.15,2.95,2.85,2.80,2.76,2.78,2.77,2.77,2.78,2.81,2.82},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.73,1.87,2.65,2.31,2.19,2.08,2.01,1.98,2.00,2.37,3.01,2.73,2.54,2.48,2.43,2.35,2.36,2.48,3.34,2.88,2.57,2.58,2.53,2.52,2.46,2.50,2.44,2.42,2.56,2.61,2.58,2.52,2.55,2.48,2.50,2.62,3.43,2.98,2.71,2.68,2.66,2.62,2.61,2.55,2.51,2.58,2.80,2.85,2.77,2.71,2.74,2.69,2.70,2.76,3.50,3.02,2.80,2.78,2.79,2.78,2.76,2.75,2.75,2.76,2.76,2.74,2.74,2.74,2.72,2.70,2.72,2.69,2.67,2.61,2.60,2.57,2.56,2.53,2.62,2.83,2.83,2.76,2.82,2.76,2.79,2.86,3.59,3.14,2.94,2.84,2.79,2.75,2.77,2.76,2.76,2.77,2.80,2.81},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.70,1.84,2.62,2.28,2.16,2.05,1.98,1.95,1.97,2.34,2.98,2.70,2.51,2.45,2.40,2.32,2.33,2.45,3.31,2.85,2.54,2.55,2.50,2.49,2.43,2.47,2.41,2.39,2.53,2.58,2.55,2.49,2.52,2.45,2.47,2.59,3.40,2.95,2.68,2.65,2.63,2.59,2.58,2.52,2.48,2.55,2.77,2.82,2.74,2.68,2.71,2.66,2.67,2.73,3.47,2.99,2.77,2.75,2.76,2.75,2.73,2.72,2.72,2.73,2.73,2.71,2.71,2.71,2.69,2.67,2.69,2.66,2.64,2.58,2.57,2.54,2.53,2.50,2.59,2.80,2.80,2.73,2.79,2.73,2.76,2.83,3.56,3.11,2.91,2.81,2.76,2.72,2.74,2.73,2.73,2.74,2.77,2.78},
   {1.77,1.91,2.69,2.35,2.23,2.12,2.05,2.02,2.04,2.41,3.05,2.77,2.58,2.52,2.47,2.39,2.40,2.52,3.38,2.92,2.61,2.62,2.57,2.56,2.50,2.54,2.48,2.46,2.60,2.65,2.62,2.56,2.59,2.52,2.54,2.66,3.47,3.02,2.75,2.72,2.70,2.66,2.65,2.59,2.55,2.62,2.84,2.89,2.81,2.75,2.78,2.73,2.74,2.80,3.54,3.06,2.84,2.82,2.83,2.82,2.80,2.79,2.79,2.80,2.80,2.78,2.78,2.78,2.76,2.74,2.76,2.73,2.71,2.65,2.64,2.61,2.60,2.57,2.66,2.87,2.87,2.80,2.86,2.80,2.83,2.90,3.63,3.18,2.98,2.88,2.83,2.79,2.81,2.80,2.80,2.81,2.84,2.85},
   {2.50,2.64,3.42,3.08,2.96,2.85,2.78,2.75,2.77,3.14,3.78,3.50,3.31,3.25,3.20,3.12,3.13,3.25,4.11,3.65,3.34,3.35,3.30,3.29,3.23,3.27,3.21,3.19,3.33,3.38,3.35,3.29,3.32,3.25,3.27,3.39,4.20,3.75,3.48,3.45,3.43,3.39,3.38,3.32,3.28,3.35,3.57,3.62,3.54,3.48,3.51,3.46,3.47,3.53,4.27,3.79,3.57,3.55,3.56,3.55,3.53,3.52,3.52,3.53,3.53,3.51,3.51,3.51,3.49,3.47,3.49,3.46,3.44,3.38,3.37,3.34,3.33,3.30,3.39,3.60,3.60,3.53,3.59,3.53,3.56,3.63,4.36,3.91,3.71,3.61,3.56,3.52,3.54,3.53,3.53,3.54,3.57,3.58},
   {2.05,2.19,2.97,2.63,2.51,2.40,2.33,2.30,2.32,2.69,3.33,3.05,2.86,2.80,2.75,2.67,2.68,2.80,3.66,3.20,2.89,2.90,2.85,2.84,2.78,2.82,2.76,2.74,2.88,2.93,2.90,2.84,2.87,2.80,2.82,2.94,3.75,3.30,3.03,3.00,2.98,2.94,2.93,2.87,2.83,2.90,3.12,3.17,3.09,3.03,3.06,3.01,3.02,3.08,3.82,3.34,3.12,3.10,3.11,3.10,3.08,3.07,3.07,3.08,3.08,3.06,3.06,3.06,3.04,3.02,3.04,3.01,2.99,2.93,2.92,2.89,2.88,2.85,2.94,3.15,3.15,3.08,3.14,3.08,3.11,3.18,3.91,3.46,3.26,3.16,3.11,3.07,3.09,3.08,3.08,3.09,3.12,3.13},
   {1.85,1.99,2.77,2.43,2.31,2.20,2.13,2.10,2.12,2.49,3.13,2.85,2.66,2.60,2.55,2.47,2.48,2.60,3.46,3.00,2.69,2.70,2.65,2.64,2.58,2.62,2.56,2.54,2.68,2.73,2.70,2.64,2.67,2.60,2.62,2.74,3.55,3.10,2.83,2.80,2.78,2.74,2.73,2.67,2.63,2.70,2.92,2.97,2.89,2.83,2.86,2.81,2.82,2.88,3.62,3.14,2.92,2.90,2.91,2.90,2.88,2.87,2.87,2.88,2.88,2.86,2.86,2.86,2.84,2.82,2.84,2.81,2.79,2.73,2.72,2.69,2.68,2.65,2.74,2.95,2.95,2.88,2.94,2.88,2.91,2.98,3.71,3.26,3.06,2.96,2.91,2.87,2.89,2.88,2.88,2.89,2.92,2.93},
   {1.75,1.89,2.67,2.33,2.21,2.10,2.03,2.00,2.02,2.39,3.03,2.75,2.56,2.50,2.45,2.37,2.38,2.50,3.36,2.90,2.59,2.60,2.55,2.54,2.48,2.52,2.46,2.44,2.58,2.63,2.60,2.54,2.57,2.50,2.52,2.64,3.45,3.00,2.73,2.70,2.68,2.64,2.63,2.57,2.53,2.60,2.82,2.87,2.79,2.73,2.76,2.71,2.72,2.78,3.52,3.04,2.82,2.80,2.81,2.80,2.78,2.77,2.77,2.78,2.78,2.76,2.76,2.76,2.74,2.72,2.74,2.71,2.69,2.63,2.62,2.59,2.58,2.55,2.64,2.85,2.85,2.78,2.84,2.78,2.81,2.88,3.61,3.16,2.96,2.86,2.81,2.77,2.79,2.78,2.78,2.79,2.82,2.83},
   {1.70,1.84,2.62,2.28,2.16,2.05,1.98,1.95,1.97,2.34,2.98,2.70,2.51,2.45,2.40,2.32,2.33,2.45,3.31,2.85,2.54,2.55,2.50,2.49,2.43,2.47,2.41,2.39,2.53,2.58,2.55,2.49,2.52,2.45,2.47,2.59,3.40,2.95,2.68,2.65,2.63,2.59,2.58,2.52,2.48,2.55,2.77,2.82,2.74,2.68,2.71,2.66,2.67,2.73,3.47,2.99,2.77,2.75,2.76,2.75,2.73,2.72,2.72,2.73,2.73,2.71,2.71,2.71,2.69,2.67,2.69,2.66,2.64,2.58,2.57,2.54,2.53,2.50,2.59,2.80,2.80,2.73,2.79,2.73,2.76,2.83,3.56,3.11,2.91,2.81,2.76,2.72,2.74,2.73,2.73,2.74,2.77,2.78},
   {1.66,1.80,2.58,2.24,2.12,2.01,1.94,1.91,1.93,2.30,2.94,2.66,2.47,2.41,2.36,2.28,2.29,2.41,3.27,2.81,2.50,2.51,2.46,2.45,2.39,2.43,2.37,2.35,2.49,2.54,2.51,2.45,2.48,2.41,2.43,2.55,3.36,2.91,2.64,2.61,2.59,2.55,2.54,2.48,2.44,2.51,2.73,2.78,2.70,2.64,2.67,2.62,2.63,2.69,3.43,2.95,2.73,2.71,2.72,2.71,2.69,2.68,2.68,2.69,2.69,2.67,2.67,2.67,2.65,2.63,2.65,2.62,2.60,2.54,2.53,2.50,2.49,2.46,2.55,2.76,2.76,2.69,2.75,2.69,2.72,2.79,3.52,3.07,2.87,2.77,2.72,2.68,2.70,2.69,2.69,2.70,2.73,2.74},
   {1.68,1.82,2.60,2.26,2.14,2.03,1.96,1.93,1.95,2.32,2.96,2.68,2.49,2.43,2.38,2.30,2.31,2.43,3.29,2.83,2.52,2.53,2.48,2.47,2.41,2.45,2.39,2.37,2.51,2.56,2.53,2.47,2.50,2.43,2.45,2.57,3.38,2.93,2.66,2.63,2.61,2.57,2.56,2.50,2.46,2.53,2.75,2.80,2.72,2.66,2.69,2.64,2.65,2.71,3.45,2.97,2.75,2.73,2.74,2.73,2.71,2.70,2.70,2.71,2.71,2.69,2.69,2.69,2.67,2.65,2.67,2.64,2.62,2.56,2.55,2.52,2.51,2.48,2.57,2.78,2.78,2.71,2.77,2.71,2.74,2.81,3.54,3.09,2.89,2.79,2.74,2.70,2.72,2.71,2.71,2.72,2.75,2.76},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.67,1.81,2.59,2.25,2.13,2.02,1.95,1.92,1.94,2.31,2.95,2.67,2.48,2.42,2.37,2.29,2.30,2.42,3.28,2.82,2.51,2.52,2.47,2.46,2.40,2.44,2.38,2.36,2.50,2.55,2.52,2.46,2.49,2.42,2.44,2.56,3.37,2.92,2.65,2.62,2.60,2.56,2.55,2.49,2.45,2.52,2.74,2.79,2.71,2.65,2.68,2.63,2.64,2.70,3.44,2.96,2.74,2.72,2.73,2.72,2.70,2.69,2.69,2.70,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.63,2.61,2.55,2.54,2.51,2.50,2.47,2.56,2.77,2.77,2.70,2.76,2.70,2.73,2.80,3.53,3.08,2.88,2.78,2.73,2.69,2.71,2.70,2.70,2.71,2.74,2.75},
   {1.68,1.82,2.60,2.26,2.14,2.03,1.96,1.93,1.95,2.32,2.96,2.68,2.49,2.43,2.38,2.30,2.31,2.43,3.29,2.83,2.52,2.53,2.48,2.47,2.41,2.45,2.39,2.37,2.51,2.56,2.53,2.47,2.50,2.43,2.45,2.57,3.38,2.93,2.66,2.63,2.61,2.57,2.56,2.50,2.46,2.53,2.75,2.80,2.72,2.66,2.69,2.64,2.65,2.71,3.45,2.97,2.75,2.73,2.74,2.73,2.71,2.70,2.70,2.71,2.71,2.69,2.69,2.69,2.67,2.65,2.67,2.64,2.62,2.56,2.55,2.52,2.51,2.48,2.57,2.78,2.78,2.71,2.77,2.71,2.74,2.81,3.54,3.09,2.89,2.79,2.74,2.70,2.72,2.71,2.71,2.72,2.75,2.76},
   {1.71,1.85,2.63,2.29,2.17,2.06,1.99,1.96,1.98,2.35,2.99,2.71,2.52,2.46,2.41,2.33,2.34,2.46,3.32,2.86,2.55,2.56,2.51,2.50,2.44,2.48,2.42,2.40,2.54,2.59,2.56,2.50,2.53,2.46,2.48,2.60,3.41,2.96,2.69,2.66,2.64,2.60,2.59,2.53,2.49,2.56,2.78,2.83,2.75,2.69,2.72,2.67,2.68,2.74,3.48,3.00,2.78,2.76,2.77,2.76,2.74,2.73,2.73,2.74,2.74,2.72,2.72,2.72,2.70,2.68,2.70,2.67,2.65,2.59,2.58,2.55,2.54,2.51,2.60,2.81,2.81,2.74,2.80,2.74,2.77,2.84,3.57,3.12,2.92,2.82,2.77,2.73,2.75,2.74,2.74,2.75,2.78,2.79},
   {1.72,1.86,2.64,2.30,2.18,2.07,2.00,1.97,1.99,2.36,3.00,2.72,2.53,2.47,2.42,2.34,2.35,2.47,3.33,2.87,2.56,2.57,2.52,2.51,2.45,2.49,2.43,2.41,2.55,2.60,2.57,2.51,2.54,2.47,2.49,2.61,3.42,2.97,2.70,2.67,2.65,2.61,2.60,2.54,2.50,2.57,2.79,2.84,2.76,2.70,2.73,2.68,2.69,2.75,3.49,3.01,2.79,2.77,2.78,2.77,2.75,2.74,2.74,2.75,2.75,2.73,2.73,2.73,2.71,2.69,2.71,2.68,2.66,2.60,2.59,2.56,2.55,2.52,2.61,2.82,2.82,2.75,2.81,2.75,2.78,2.85,3.58,3.13,2.93,2.83,2.78,2.74,2.76,2.75,2.75,2.76,2.79,2.80}
};

static float TripleDis[NUMDIS][NUMDIS] = {
   {0.64,0.78,1.56,1.17,1.05,0.92,0.86,0.85,0.85,1.28,1.92,1.59,1.43,1.34,1.26,1.27,1.25,1.28,2.25,1.65,1.46,1.40,1.38,1.35,1.35,1.34,1.28,1.33,1.52,1.52,1.53,1.46,1.38,1.39,1.42,1.40,2.34,1.71,1.56,1.53,1.48,1.45,1.42,1.35,1.38,1.44,1.69,1.76,1.78,1.64,1.59,1.53,1.57,1.54,2.41,1.81,1.71,1.63,1.60,1.69,1.67,1.66,1.66,1.64,1.67,1.65,1.65,1.65,1.63,1.61,1.63,1.54,1.51,1.47,1.42,1.41,1.39,1.42,1.55,1.74,1.82,1.69,1.67,1.61,1.70,1.65,2.50,1.91,1.72,1.68,1.61,1.50,1.48,1.67,1.67,1.68,1.71,1.72},
   {0.78,0.92,1.70,1.31,1.19,1.06,1.00,0.99,0.99,1.42,2.06,1.73,1.57,1.48,1.40,1.41,1.39,1.42,2.39,1.79,1.60,1.54,1.52,1.49,1.49,1.48,1.42,1.47,1.66,1.66,1.67,1.60,1.52,1.53,1.56,1.54,2.48,1.85,1.70,1.67,1.62,1.59,1.56,1.49,1.52,1.58,1.83,1.90,1.92,1.78,1.73,1.67,1.71,1.68,2.55,1.95,1.85,1.77,1.74,1.83,1.81,1.80,1.80,1.78,1.81,1.79,1.79,1.79,1.77,1.75,1.77,1.68,1.65,1.61,1.56,1.55,1.53,1.56,1.69,1.88,1.96,1.83,1.81,1.75,1.84,1.79,2.64,2.05,1.86,1.82,1.75,1.64,1.62,1.81,1.81,1.82,1.85,1.86},
   {1.56,1.70,2.48,2.09,1.97,1.84,1.78,1.77,1.77,2.20,2.84,2.51,2.35,2.26,2.18,2.19,2.17,2.20,3.17,2.57,2.38,2.32,2.30,2.27,2.27,2.26,2.20,2.25,2.44,2.44,2.45,2.38,2.30,2.31,2.34,2.32,3.26,2.63,2.48,2.45,2.40,2.37,2.34,2.27,2.30,2.36,2.61,2.68,2.70,2.56,2.51,2.45,2.49,2.46,3.33,2.73,2.63,2.55,2.52,2.61,2.59,2.58,2.58,2.56,2.59,2.57,2.57,2.57,2.55,2.53,2.55,2.46,2.43,2.39,2.34,2.33,2.31,2.34,2.47,2.66,2.74,2.61,2.59,2.53,2.62,2.57,3.42,2.83,2.64,2.60,2.53,2.42,2.40,2.59,2.59,2.60,2.63,2.64},
   {1.17,1.31,2.09,1.70,1.58,1.45,1.39,1.38,1.38,1.81,2.45,2.12,1.96,1.87,1.79,1.80,1.78,1.81,2.78,2.18,1.99,1.93,1.91,1.88,1.88,1.87,1.81,1.86,2.05,2.05,2.06,1.99,1.91,1.92,1.95,1.93,2.87,2.24,2.09,2.06,2.01,1.98,1.95,1.88,1.91,1.97,2.22,2.29,2.31,2.17,2.12,2.06,2.10,2.07,2.94,2.34,2.24,2.16,2.13,2.22,2.20,2.19,2.19,2.17,2.20,2.18,2.18,2.18,2.16,2.14,2.16,2.07,2.04,2.00,1.95,1.94,1.92,1.95,2.08,2.27,2.35,2.22,2.20,2.14,2.23,2.18,3.03,2.44,2.25,2.21,2.14,2.03,2.01,2.20,2.20,2.21,2.24,2.25},
   {1.05,1.19,1.97,1.58,1.46,1.33,1.27,1.26,1.26,1.69,2.33,2.00,1.84,1.75,1.67,1.68,1.66,1.69,2.66,2.06,1.87,1.81,1.79,1.76,1.76,1.75,1.69,1.74,1.93,1.93,1.94,1.87,1.79,1.80,1.83,1.81,2.75,2.12,1.97,1.94,1.89,1.86,1.83,1.76,1.79,1.85,2.10,2.17,2.19,2.05,2.00,1.94,1.98,1.95,2.82,2.22,2.12,2.04,2.01,2.10,2.08,2.07,2.07,2.05,2.08,2.06,2.06,2.06,2.04,2.02,2.04,1.95,1.92,1.88,1.83,1.82,1.80,1.83,1.96,2.15,2.23,2.10,2.08,2.02,2.11,2.06,2.91,2.32,2.13,2.09,2.02,1.91,1.89,2.08,2.08,2.09,2.12,2.13},
   {0.92,1.06,1.84,1.45,1.33,1.20,1.14,1.13,1.13,1.56,2.20,1.87,1.71,1.62,1.54,1.55,1.53,1.56,2.53,1.93,1.74,1.68,1.66,1.63,1.63,1.62,1.56,1.61,1.80,1.80,1.81,1.74,1.66,1.67,1.70,1.68,2.62,1.99,1.84,1.81,1.76,1.73,1.70,1.63,1.66,1.72,1.97,2.04,2.06,1.92,1.87,1.81,1.85,1.82,2.69,2.09,1.99,1.91,1.88,1.97,1.95,1.94,1.94,1.92,1.95,1.93,1.93,1.93,1.91,1.89,1.91,1.82,1.79,1.75,1.70,1.69,1.67,1.70,1.83,2.02,2.10,1.97,1.95,1.89,1.98,1.93,2.78,2.19,2.00,1.96,1.89,1.78,1.76,1.95,1.95,1.96,1.99,2.00},
   {0.86,1.00,1.78,1.39,1.27,1.14,1.08,1.07,1.07,1.50,2.14,1.81,1.65,1.56,1.48,1.49,1.47,1.50,2.47,1.87,1.68,1.62,1.60,1.57,1.57,1.56,1.50,1.55,1.74,1.74,1.75,1.68,1.60,1.61,1.64,1.62,2.56,1.93,1.78,1.75,1.70,1.67,1.64,1.57,1.60,1.66,1.91,1.98,2.00,1.86,1.81,1.75,1.79,1.76,2.63,2.03,1.93,1.85,1.82,1.91,1.89,1.88,1.88,1.86,1.89,1.87,1.87,1.87,1.85,1.83,1.85,1.76,1.73,1.69,1.64,1.63,1.61,1.64,1.77,1.96,2.04,1.91,1.89,1.83,1.92,1.87,2.72,2.13,1.94,1.90,1.83,1.72,1.70,1.89,1.89,1.90,1.93,1.94},
   {0.85,0.99,1.77,1.38,1.26,1.13,1.07,1.06,1.06,1.49,2.13,1.80,1.64,1.55,1.47,1.48,1.46,1.49,2.46,1.86,1.67,1.61,1.59,1.56,1.56,1.55,1.49,1.54,1.73,1.73,1.74,1.67,1.59,1.60,1.63,1.61,2.55,1.92,1.77,1.74,1.69,1.66,1.63,1.56,1.59,1.65,1.90,1.97,1.99,1.85,1.80,1.74,1.78,1.75,2.62,2.02,1.92,1.84,1.81,1.90,1.88,1.87,1.87,1.85,1.88,1.86,1.86,1.86,1.84,1.82,1.84,1.75,1.72,1.68,1.63,1.62,1.60,1.63,1.76,1.95,2.03,1.90,1.88,1.82,1.91,1.86,2.71,2.12,1.93,1.89,1.82,1.71,1.69,1.88,1.88,1.89,1.92,1.93},
   {0.85,0.99,1.77,1.38,1.26,1.13,1.07,1.06,1.06,1.49,2.13,1.80,1.64,1.55,1.47,1.48,1.46,1.49,2.46,1.86,1.67,1.61,1.59,1.56,1.56,1.55,1.49,1.54,1.73,1.73,1.74,1.67,1.59,1.60,1.63,1.61,2.55,1.92,1.77,1.74,1.69,1.66,1.63,1.56,1.59,1.65,1.90,1.97,1.99,1.85,1.80,1.74,1.78,1.75,2.62,2.02,1.92,1.84,1.81,1.90,1.88,1.87,1.87,1.85,1.88,1.86,1.86,1.86,1.84,1.82,1.84,1.75,1.72,1.68,1.63,1.62,1.60,1.63,1.76,1.95,2.03,1.90,1.88,1.82,1.91,1.86,2.71,2.12,1.93,1.89,1.82,1.71,1.69,1.88,1.88,1.89,1.92,1.93},
   {1.28,1.42,2.20,1.81,1.69,1.56,1.50,1.49,1.49,1.92,2.56,2.23,2.07,1.98,1.90,1.91,1.89,1.92,2.89,2.29,2.10,2.04,2.02,1.99,1.99,1.98,1.92,1.97,2.16,2.16,2.17,2.10,2.02,2.03,2.06,2.04,2.98,2.35,2.20,2.17,2.12,2.09,2.06,1.99,2.02,2.08,2.33,2.40,2.42,2.28,2.23,2.17,2.21,2.18,3.05,2.45,2.35,2.27,2.24,2.33,2.31,2.30,2.30,2.28,2.31,2.29,2.29,2.29,2.27,2.25,2.27,2.18,2.15,2.11,2.06,2.05,2.03,2.06,2.19,2.38,2.46,2.33,2.31,2.25,2.34,2.29,3.14,2.55,2.36,2.32,2.25,2.14,2.12,2.31,2.31,2.32,2.35,2.36},
   {1.92,2.06,2.84,2.45,2.33,2.20,2.14,2.13,2.13,2.56,3.20,2.87,2.71,2.62,2.54,2.55,2.53,2.56,3.53,2.93,2.74,2.68,2.66,2.63,2.63,2.62,2.56,2.61,2.80,2.80,2.81,2.74,2.66,2.67,2.70,2.68,3.62,2.99,2.84,2.81,2.76,2.73,2.70,2.63,2.66,2.72,2.97,3.04,3.06,2.92,2.87,2.81,2.85,2.82,3.69,3.09,2.99,2.91,2.88,2.97,2.95,2.94,2.94,2.92,2.95,2.93,2.93,2.93,2.91,2.89,2.91,2.82,2.79,2.75,2.70,2.69,2.67,2.70,2.83,3.02,3.10,2.97,2.95,2.89,2.98,2.93,3.78,3.19,3.00,2.96,2.89,2.78,2.76,2.95,2.95,2.96,2.99,3.00},
   {1.59,1.73,2.51,2.12,2.00,1.87,1.81,1.80,1.80,2.23,2.87,2.54,2.38,2.29,2.21,2.22,2.20,2.23,3.20,2.60,2.41,2.35,2.33,2.30,2.30,2.29,2.23,2.28,2.47,2.47,2.48,2.41,2.33,2.34,2.37,2.35,3.29,2.66,2.51,2.48,2.43,2.40,2.37,2.30,2.33,2.39,2.64,2.71,2.73,2.59,2.54,2.48,2.52,2.49,3.36,2.76,2.66,2.58,2.55,2.64,2.62,2.61,2.61,2.59,2.62,2.60,2.60,2.60,2.58,2.56,2.58,2.49,2.46,2.42,2.37,2.36,2.34,2.37,2.50,2.69,2.77,2.64,2.62,2.56,2.65,2.60,3.45,2.86,2.67,2.63,2.56,2.45,2.43,2.62,2.62,2.63,2.66,2.67},
   {1.43,1.57,2.35,1.96,1.84,1.71,1.65,1.64,1.64,2.07,2.71,2.38,2.22,2.13,2.05,2.06,2.04,2.07,3.04,2.44,2.25,2.19,2.17,2.14,2.14,2.13,2.07,2.12,2.31,2.31,2.32,2.25,2.17,2.18,2.21,2.19,3.13,2.50,2.35,2.32,2.27,2.24,2.21,2.14,2.17,2.23,2.48,2.55,2.57,2.43,2.38,2.32,2.36,2.33,3.20,2.60,2.50,2.42,2.39,2.48,2.46,2.45,2.45,2.43,2.46,2.44,2.44,2.44,2.42,2.40,2.42,2.33,2.30,2.26,2.21,2.20,2.18,2.21,2.34,2.53,2.61,2.48,2.46,2.40,2.49,2.44,3.29,2.70,2.51,2.47,2.40,2.29,2.27,2.46,2.46,2.47,2.50,2.51},
   {1.34,1.48,2.26,1.87,1.75,1.62,1.56,1.55,1.55,1.98,2.62,2.29,2.13,2.04,1.96,1.97,1.95,1.98,2.95,2.35,2.16,2.10,2.08,2.05,2.05,2.04,1.98,2.03,2.22,2.22,2.23,2.16,2.08,2.09,2.12,2.10,3.04,2.41,2.26,2.23,2.18,2.15,2.12,2.05,2.08,2.14,2.39,2.46,2.48,2.34,2.29,2.23,2.27,2.24,3.11,2.51,2.41,2.33,2.30,2.39,2.37,2.36,2.36,2.34,2.37,2.35,2.35,2.35,2.33,2.31,2.33,2.24,2.21,2.17,2.12,2.11,2.09,2.12,2.25,2.44,2.52,2.39,2.37,2.31,2.40,2.35,3.20,2.61,2.42,2.38,2.31,2.20,2.18,2.37,2.37,2.38,2.41,2.42},
   {1.26,1.40,2.18,1.79,1.67,1.54,1.48,1.47,1.47,1.90,2.54,2.21,2.05,1.96,1.88,1.89,1.87,1.90,2.87,2.27,2.08,2.02,2.00,1.97,1.97,1.96,1.90,1.95,2.14,2.14,2.15,2.08,2.00,2.01,2.04,2.02,2.96,2.33,2.18,2.15,2.10,2.07,2.04,1.97,2.00,2.06,2.31,2.38,2.40,2.26,2.21,2.15,2.19,2.16,3.03,2.43,2.33,2.25,2.22,2.31,2.29,2.28,2.28,2.26,2.29,2.27,2.27,2.27,2.25,2.23,2.25,2.16,2.13,2.09,2.04,2.03,2.01,2.04,2.17,2.36,2.44,2.31,2.29,2.23,2.32,2.27,3.12,2.53,2.34,2.30,2.23,2.12,2.10,2.29,2.29,2.30,2.33,2.34},
   {1.27,1.41,2.19,1.80,1.68,1.55,1.49,1.48,1.48,1.91,2.55,2.22,2.06,1.97,1.89,1.90,1.88,1.91,2.88,2.28,2.09,2.03,2.01,1.98,1.98,1.97,1.91,1.96,2.15,2.15,2.16,2.09,2.01,2.02,2.05,2.03,2.97,2.34,2.19,2.16,2.11,2.08,2.05,1.98,2.01,2.07,2.32,2.39,2.41,2.27,2.22,2.16,2.20,2.17,3.04,2.44,2.34,2.26,2.23,2.32,2.30,2.29,2.29,2.27,2.30,2.28,2.28,2.28,2.26,2.24,2.26,2.17,2.14,2.10,2.05,2.04,2.02,2.05,2.18,2.37,2.45,2.32,2.30,2.24,2.33,2.28,3.13,2.54,2.35,2.31,2.24,2.13,2.11,2.30,2.30,2.31,2.34,2.35},
   {1.25,1.39,2.17,1.78,1.66,1.53,1.47,1.46,1.46,1.89,2.53,2.20,2.04,1.95,1.87,1.88,1.86,1.89,2.86,2.26,2.07,2.01,1.99,1.96,1.96,1.95,1.89,1.94,2.13,2.13,2.14,2.07,1.99,2.00,2.03,2.01,2.95,2.32,2.17,2.14,2.09,2.06,2.03,1.96,1.99,2.05,2.30,2.37,2.39,2.25,2.20,2.14,2.18,2.15,3.02,2.42,2.32,2.24,2.21,2.30,2.28,2.27,2.27,2.25,2.28,2.26,2.26,2.26,2.24,2.22,2.24,2.15,2.12,2.08,2.03,2.02,2.00,2.03,2.16,2.35,2.43,2.30,2.28,2.22,2.31,2.26,3.11,2.52,2.33,2.29,2.22,2.11,2.09,2.28,2.28,2.29,2.32,2.33},
   {1.28,1.42,2.20,1.81,1.69,1.56,1.50,1.49,1.49,1.92,2.56,2.23,2.07,1.98,1.90,1.91,1.89,1.92,2.89,2.29,2.10,2.04,2.02,1.99,1.99,1.98,1.92,1.97,2.16,2.16,2.17,2.10,2.02,2.03,2.06,2.04,2.98,2.35,2.20,2.17,2.12,2.09,2.06,1.99,2.02,2.08,2.33,2.40,2.42,2.28,2.23,2.17,2.21,2.18,3.05,2.45,2.35,2.27,2.24,2.33,2.31,2.30,2.30,2.28,2.31,2.29,2.29,2.29,2.27,2.25,2.27,2.18,2.15,2.11,2.06,2.05,2.03,2.06,2.19,2.38,2.46,2.33,2.31,2.25,2.34,2.29,3.14,2.55,2.36,2.32,2.25,2.14,2.12,2.31,2.31,2.32,2.35,2.36},
   {2.25,2.39,3.17,2.78,2.66,2.53,2.47,2.46,2.46,2.89,3.53,3.20,3.04,2.95,2.87,2.88,2.86,2.89,3.86,3.26,3.07,3.01,2.99,2.96,2.96,2.95,2.89,2.94,3.13,3.13,3.14,3.07,2.99,3.00,3.03,3.01,3.95,3.32,3.17,3.14,3.09,3.06,3.03,2.96,2.99,3.05,3.30,3.37,3.39,3.25,3.20,3.14,3.18,3.15,4.02,3.42,3.32,3.24,3.21,3.30,3.28,3.27,3.27,3.25,3.28,3.26,3.26,3.26,3.24,3.22,3.24,3.15,3.12,3.08,3.03,3.02,3.00,3.03,3.16,3.35,3.43,3.30,3.28,3.22,3.31,3.26,4.11,3.52,3.33,3.29,3.22,3.11,3.09,3.28,3.28,3.29,3.32,3.33},
   {1.65,1.79,2.57,2.18,2.06,1.93,1.87,1.86,1.86,2.29,2.93,2.60,2.44,2.35,2.27,2.28,2.26,2.29,3.26,2.66,2.47,2.41,2.39,2.36,2.36,2.35,2.29,2.34,2.53,2.53,2.54,2.47,2.39,2.40,2.43,2.41,3.35,2.72,2.57,2.54,2.49,2.46,2.43,2.36,2.39,2.45,2.70,2.77,2.79,2.65,2.60,2.54,2.58,2.55,3.42,2.82,2.72,2.64,2.61,2.70,2.68,2.67,2.67,2.65,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.55,2.52,2.48,2.43,2.42,2.40,2.43,2.56,2.75,2.83,2.70,2.68,2.62,2.71,2.66,3.51,2.92,2.73,2.69,2.62,2.51,2.49,2.68,2.68,2.69,2.72,2.73},
   {1.46,1.60,2.38,1.99,1.87,1.74,1.68,1.67,1.67,2.10,2.74,2.41,2.25,2.16,2.08,2.09,2.07,2.10,3.07,2.47,2.28,2.22,2.20,2.17,2.17,2.16,2.10,2.15,2.34,2.34,2.35,2.28,2.20,2.21,2.24,2.22,3.16,2.53,2.38,2.35,2.30,2.27,2.24,2.17,2.20,2.26,2.51,2.58,2.60,2.46,2.41,2.35,2.39,2.36,3.23,2.63,2.53,2.45,2.42,2.51,2.49,2.48,2.48,2.46,2.49,2.47,2.47,2.47,2.45,2.43,2.45,2.36,2.33,2.29,2.24,2.23,2.21,2.24,2.37,2.56,2.64,2.51,2.49,2.43,2.52,2.47,3.32,2.73,2.54,2.50,2.43,2.32,2.30,2.49,2.49,2.50,2.53,2.54},
   {1.40,1.54,2.32,1.93,1.81,1.68,1.62,1.61,1.61,2.04,2.68,2.35,2.19,2.10,2.02,2.03,2.01,2.04,3.01,2.41,2.22,2.16,2.14,2.11,2.11,2.10,2.04,2.09,2.28,2.28,2.29,2.22,2.14,2.15,2.18,2.16,3.10,2.47,2.32,2.29,2.24,2.21,2.18,2.11,2.14,2.20,2.45,2.52,2.54,2.40,2.35,2.29,2.33,2.30,3.17,2.57,2.47,2.39,2.36,2.45,2.43,2.42,2.42,2.40,2.43,2.41,2.41,2.41,2.39,2.37,2.39,2.30,2.27,2.23,2.18,2.17,2.15,2.18,2.31,2.50,2.58,2.45,2.43,2.37,2.46,2.41,3.26,2.67,2.48,2.44,2.37,2.26,2.24,2.43,2.43,2.44,2.47,2.48},
   {1.38,1.52,2.30,1.91,1.79,1.66,1.60,1.59,1.59,2.02,2.66,2.33,2.17,2.08,2.00,2.01,1.99,2.02,2.99,2.39,2.20,2.14,2.12,2.09,2.09,2.08,2.02,2.07,2.26,2.26,2.27,2.20,2.12,2.13,2.16,2.14,3.08,2.45,2.30,2.27,2.22,2.19,2.16,2.09,2.12,2.18,2.43,2.50,2.52,2.38,2.33,2.27,2.31,2.28,3.15,2.55,2.45,2.37,2.34,2.43,2.41,2.40,2.40,2.38,2.41,2.39,2.39,2.39,2.37,2.35,2.37,2.28,2.25,2.21,2.16,2.15,2.13,2.16,2.29,2.48,2.56,2.43,2.41,2.35,2.44,2.39,3.24,2.65,2.46,2.42,2.35,2.24,2.22,2.41,2.41,2.42,2.45,2.46},
   {1.35,1.49,2.27,1.88,1.76,1.63,1.57,1.56,1.56,1.99,2.63,2.30,2.14,2.05,1.97,1.98,1.96,1.99,2.96,2.36,2.17,2.11,2.09,2.06,2.06,2.05,1.99,2.04,2.23,2.23,2.24,2.17,2.09,2.10,2.13,2.11,3.05,2.42,2.27,2.24,2.19,2.16,2.13,2.06,2.09,2.15,2.40,2.47,2.49,2.35,2.30,2.24,2.28,2.25,3.12,2.52,2.42,2.34,2.31,2.40,2.38,2.37,2.37,2.35,2.38,2.36,2.36,2.36,2.34,2.32,2.34,2.25,2.22,2.18,2.13,2.12,2.10,2.13,2.26,2.45,2.53,2.40,2.38,2.32,2.41,2.36,3.21,2.62,2.43,2.39,2.32,2.21,2.19,2.38,2.38,2.39,2.42,2.43},
   {1.35,1.49,2.27,1.88,1.76,1.63,1.57,1.56,1.56,1.99,2.63,2.30,2.14,2.05,1.97,1.98,1.96,1.99,2.96,2.36,2.17,2.11,2.09,2.06,2.06,2.05,1.99,2.04,2.23,2.23,2.24,2.17,2.09,2.10,2.13,2.11,3.05,2.42,2.27,2.24,2.19,2.16,2.13,2.06,2.09,2.15,2.40,2.47,2.49,2.35,2.30,2.24,2.28,2.25,3.12,2.52,2.42,2.34,2.31,2.40,2.38,2.37,2.37,2.35,2.38,2.36,2.36,2.36,2.34,2.32,2.34,2.25,2.22,2.18,2.13,2.12,2.10,2.13,2.26,2.45,2.53,2.40,2.38,2.32,2.41,2.36,3.21,2.62,2.43,2.39,2.32,2.21,2.19,2.38,2.38,2.39,2.42,2.43},
   {1.34,1.48,2.26,1.87,1.75,1.62,1.56,1.55,1.55,1.98,2.62,2.29,2.13,2.04,1.96,1.97,1.95,1.98,2.95,2.35,2.16,2.10,2.08,2.05,2.05,2.04,1.98,2.03,2.22,2.22,2.23,2.16,2.08,2.09,2.12,2.10,3.04,2.41,2.26,2.23,2.18,2.15,2.12,2.05,2.08,2.14,2.39,2.46,2.48,2.34,2.29,2.23,2.27,2.24,3.11,2.51,2.41,2.33,2.30,2.39,2.37,2.36,2.36,2.34,2.37,2.35,2.35,2.35,2.33,2.31,2.33,2.24,2.21,2.17,2.12,2.11,2.09,2.12,2.25,2.44,2.52,2.39,2.37,2.31,2.40,2.35,3.20,2.61,2.42,2.38,2.31,2.20,2.18,2.37,2.37,2.38,2.41,2.42},
   {1.28,1.42,2.20,1.81,1.69,1.56,1.50,1.49,1.49,1.92,2.56,2.23,2.07,1.98,1.90,1.91,1.89,1.92,2.89,2.29,2.10,2.04,2.02,1.99,1.99,1.98,1.92,1.97,2.16,2.16,2.17,2.10,2.02,2.03,2.06,2.04,2.98,2.35,2.20,2.17,2.12,2.09,2.06,1.99,2.02,2.08,2.33,2.40,2.42,2.28,2.23,2.17,2.21,2.18,3.05,2.45,2.35,2.27,2.24,2.33,2.31,2.30,2.30,2.28,2.31,2.29,2.29,2.29,2.27,2.25,2.27,2.18,2.15,2.11,2.06,2.05,2.03,2.06,2.19,2.38,2.46,2.33,2.31,2.25,2.34,2.29,3.14,2.55,2.36,2.32,2.25,2.14,2.12,2.31,2.31,2.32,2.35,2.36},
   {1.33,1.47,2.25,1.86,1.74,1.61,1.55,1.54,1.54,1.97,2.61,2.28,2.12,2.03,1.95,1.96,1.94,1.97,2.94,2.34,2.15,2.09,2.07,2.04,2.04,2.03,1.97,2.02,2.21,2.21,2.22,2.15,2.07,2.08,2.11,2.09,3.03,2.40,2.25,2.22,2.17,2.14,2.11,2.04,2.07,2.13,2.38,2.45,2.47,2.33,2.28,2.22,2.26,2.23,3.10,2.50,2.40,2.32,2.29,2.38,2.36,2.35,2.35,2.33,2.36,2.34,2.34,2.34,2.32,2.30,2.32,2.23,2.20,2.16,2.11,2.10,2.08,2.11,2.24,2.43,2.51,2.38,2.36,2.30,2.39,2.34,3.19,2.60,2.41,2.37,2.30,2.19,2.17,2.36,2.36,2.37,2.40,2.41},
   {1.52,1.66,2.44,2.05,1.93,1.80,1.74,1.73,1.73,2.16,2.80,2.47,2.31,2.22,2.14,2.15,2.13,2.16,3.13,2.53,2.34,2.28,2.26,2.23,2.23,2.22,2.16,2.21,2.40,2.40,2.41,2.34,2.26,2.27,2.30,2.28,3.22,2.59,2.44,2.41,2.36,2.33,2.30,2.23,2.26,2.32,2.57,2.64,2.66,2.52,2.47,2.41,2.45,2.42,3.29,2.69,2.59,2.51,2.48,2.57,2.55,2.54,2.54,2.52,2.55,2.53,2.53,2.53,2.51,2.49,2.51,2.42,2.39,2.35,2.30,2.29,2.27,2.30,2.43,2.62,2.70,2.57,2.55,2.49,2.58,2.53,3.38,2.79,2.60,2.56,2.49,2.38,2.36,2.55,2.55,2.56,2.59,2.60},
   {1.52,1.66,2.44,2.05,1.93,1.80,1.74,1.73,1.73,2.16,2.80,2.47,2.31,2.22,2.14,2.15,2.13,2.16,3.13,2.53,2.34,2.28,2.26,2.23,2.23,2.22,2.16,2.21,2.40,2.40,2.41,2.34,2.26,2.27,2.30,2.28,3.22,2.59,2.44,2.41,2.36,2.33,2.30,2.23,2.26,2.32,2.57,2.64,2.66,2.52,2.47,2.41,2.45,2.42,3.29,2.69,2.59,2.51,2.48,2.57,2.55,2.54,2.54,2.52,2.55,2.53,2.53,2.53,2.51,2.49,2.51,2.42,2.39,2.35,2.30,2.29,2.27,2.30,2.43,2.62,2.70,2.57,2.55,2.49,2.58,2.53,3.38,2.79,2.60,2.56,2.49,2.38,2.36,2.55,2.55,2.56,2.59,2.60},
   {1.53,1.67,2.45,2.06,1.94,1.81,1.75,1.74,1.74,2.17,2.81,2.48,2.32,2.23,2.15,2.16,2.14,2.17,3.14,2.54,2.35,2.29,2.27,2.24,2.24,2.23,2.17,2.22,2.41,2.41,2.42,2.35,2.27,2.28,2.31,2.29,3.23,2.60,2.45,2.42,2.37,2.34,2.31,2.24,2.27,2.33,2.58,2.65,2.67,2.53,2.48,2.42,2.46,2.43,3.30,2.70,2.60,2.52,2.49,2.58,2.56,2.55,2.55,2.53,2.56,2.54,2.54,2.54,2.52,2.50,2.52,2.43,2.40,2.36,2.31,2.30,2.28,2.31,2.44,2.63,2.71,2.58,2.56,2.50,2.59,2.54,3.39,2.80,2.61,2.57,2.50,2.39,2.37,2.56,2.56,2.57,2.60,2.61},
   {1.46,1.60,2.38,1.99,1.87,1.74,1.68,1.67,1.67,2.10,2.74,2.41,2.25,2.16,2.08,2.09,2.07,2.10,3.07,2.47,2.28,2.22,2.20,2.17,2.17,2.16,2.10,2.15,2.34,2.34,2.35,2.28,2.20,2.21,2.24,2.22,3.16,2.53,2.38,2.35,2.30,2.27,2.24,2.17,2.20,2.26,2.51,2.58,2.60,2.46,2.41,2.35,2.39,2.36,3.23,2.63,2.53,2.45,2.42,2.51,2.49,2.48,2.48,2.46,2.49,2.47,2.47,2.47,2.45,2.43,2.45,2.36,2.33,2.29,2.24,2.23,2.21,2.24,2.37,2.56,2.64,2.51,2.49,2.43,2.52,2.47,3.32,2.73,2.54,2.50,2.43,2.32,2.30,2.49,2.49,2.50,2.53,2.54},
   {1.38,1.52,2.30,1.91,1.79,1.66,1.60,1.59,1.59,2.02,2.66,2.33,2.17,2.08,2.00,2.01,1.99,2.02,2.99,2.39,2.20,2.14,2.12,2.09,2.09,2.08,2.02,2.07,2.26,2.26,2.27,2.20,2.12,2.13,2.16,2.14,3.08,2.45,2.30,2.27,2.22,2.19,2.16,2.09,2.12,2.18,2.43,2.50,2.52,2.38,2.33,2.27,2.31,2.28,3.15,2.55,2.45,2.37,2.34,2.43,2.41,2.40,2.40,2.38,2.41,2.39,2.39,2.39,2.37,2.35,2.37,2.28,2.25,2.21,2.16,2.15,2.13,2.16,2.29,2.48,2.56,2.43,2.41,2.35,2.44,2.39,3.24,2.65,2.46,2.42,2.35,2.24,2.22,2.41,2.41,2.42,2.45,2.46},
   {1.39,1.53,2.31,1.92,1.80,1.67,1.61,1.60,1.60,2.03,2.67,2.34,2.18,2.09,2.01,2.02,2.00,2.03,3.00,2.40,2.21,2.15,2.13,2.10,2.10,2.09,2.03,2.08,2.27,2.27,2.28,2.21,2.13,2.14,2.17,2.15,3.09,2.46,2.31,2.28,2.23,2.20,2.17,2.10,2.13,2.19,2.44,2.51,2.53,2.39,2.34,2.28,2.32,2.29,3.16,2.56,2.46,2.38,2.35,2.44,2.42,2.41,2.41,2.39,2.42,2.40,2.40,2.40,2.38,2.36,2.38,2.29,2.26,2.22,2.17,2.16,2.14,2.17,2.30,2.49,2.57,2.44,2.42,2.36,2.45,2.40,3.25,2.66,2.47,2.43,2.36,2.25,2.23,2.42,2.42,2.43,2.46,2.47},
   {1.42,1.56,2.34,1.95,1.83,1.70,1.64,1.63,1.63,2.06,2.70,2.37,2.21,2.12,2.04,2.05,2.03,2.06,3.03,2.43,2.24,2.18,2.16,2.13,2.13,2.12,2.06,2.11,2.30,2.30,2.31,2.24,2.16,2.17,2.20,2.18,3.12,2.49,2.34,2.31,2.26,2.23,2.20,2.13,2.16,2.22,2.47,2.54,2.56,2.42,2.37,2.31,2.35,2.32,3.19,2.59,2.49,2.41,2.38,2.47,2.45,2.44,2.44,2.42,2.45,2.43,2.43,2.43,2.41,2.39,2.41,2.32,2.29,2.25,2.20,2.19,2.17,2.20,2.33,2.52,2.60,2.47,2.45,2.39,2.48,2.43,3.28,2.69,2.50,2.46,2.39,2.28,2.26,2.45,2.45,2.46,2.49,2.50},
   {1.40,1.54,2.32,1.93,1.81,1.68,1.62,1.61,1.61,2.04,2.68,2.35,2.19,2.10,2.02,2.03,2.01,2.04,3.01,2.41,2.22,2.16,2.14,2.11,2.11,2.10,2.04,2.09,2.28,2.28,2.29,2.22,2.14,2.15,2.18,2.16,3.10,2.47,2.32,2.29,2.24,2.21,2.18,2.11,2.14,2.20,2.45,2.52,2.54,2.40,2.35,2.29,2.33,2.30,3.17,2.57,2.47,2.39,2.36,2.45,2.43,2.42,2.42,2.40,2.43,2.41,2.41,2.41,2.39,2.37,2.39,2.30,2.27,2.23,2.18,2.17,2.15,2.18,2.31,2.50,2.58,2.45,2.43,2.37,2.46,2.41,3.26,2.67,2.48,2.44,2.37,2.26,2.24,2.43,2.43,2.44,2.47,2.48},
   {2.34,2.48,3.26,2.87,2.75,2.62,2.56,2.55,2.55,2.98,3.62,3.29,3.13,3.04,2.96,2.97,2.95,2.98,3.95,3.35,3.16,3.10,3.08,3.05,3.05,3.04,2.98,3.03,3.22,3.22,3.23,3.16,3.08,3.09,3.12,3.10,4.04,3.41,3.26,3.23,3.18,3.15,3.12,3.05,3.08,3.14,3.39,3.46,3.48,3.34,3.29,3.23,3.27,3.24,4.11,3.51,3.41,3.33,3.30,3.39,3.37,3.36,3.36,3.34,3.37,3.35,3.35,3.35,3.33,3.31,3.33,3.24,3.21,3.17,3.12,3.11,3.09,3.12,3.25,3.44,3.52,3.39,3.37,3.31,3.40,3.35,4.20,3.61,3.42,3.38,3.31,3.20,3.18,3.37,3.37,3.38,3.41,3.42},
   {1.71,1.85,2.63,2.24,2.12,1.99,1.93,1.92,1.92,2.35,2.99,2.66,2.50,2.41,2.33,2.34,2.32,2.35,3.32,2.72,2.53,2.47,2.45,2.42,2.42,2.41,2.35,2.40,2.59,2.59,2.60,2.53,2.45,2.46,2.49,2.47,3.41,2.78,2.63,2.60,2.55,2.52,2.49,2.42,2.45,2.51,2.76,2.83,2.85,2.71,2.66,2.60,2.64,2.61,3.48,2.88,2.78,2.70,2.67,2.76,2.74,2.73,2.73,2.71,2.74,2.72,2.72,2.72,2.70,2.68,2.70,2.61,2.58,2.54,2.49,2.48,2.46,2.49,2.62,2.81,2.89,2.76,2.74,2.68,2.77,2.72,3.57,2.98,2.79,2.75,2.68,2.57,2.55,2.74,2.74,2.75,2.78,2.79},
   {1.56,1.70,2.48,2.09,1.97,1.84,1.78,1.77,1.77,2.20,2.84,2.51,2.35,2.26,2.18,2.19,2.17,2.20,3.17,2.57,2.38,2.32,2.30,2.27,2.27,2.26,2.20,2.25,2.44,2.44,2.45,2.38,2.30,2.31,2.34,2.32,3.26,2.63,2.48,2.45,2.40,2.37,2.34,2.27,2.30,2.36,2.61,2.68,2.70,2.56,2.51,2.45,2.49,2.46,3.33,2.73,2.63,2.55,2.52,2.61,2.59,2.58,2.58,2.56,2.59,2.57,2.57,2.57,2.55,2.53,2.55,2.46,2.43,2.39,2.34,2.33,2.31,2.34,2.47,2.66,2.74,2.61,2.59,2.53,2.62,2.57,3.42,2.83,2.64,2.60,2.53,2.42,2.40,2.59,2.59,2.60,2.63,2.64},
   {1.53,1.67,2.45,2.06,1.94,1.81,1.75,1.74,1.74,2.17,2.81,2.48,2.32,2.23,2.15,2.16,2.14,2.17,3.14,2.54,2.35,2.29,2.27,2.24,2.24,2.23,2.17,2.22,2.41,2.41,2.42,2.35,2.27,2.28,2.31,2.29,3.23,2.60,2.45,2.42,2.37,2.34,2.31,2.24,2.27,2.33,2.58,2.65,2.67,2.53,2.48,2.42,2.46,2.43,3.30,2.70,2.60,2.52,2.49,2.58,2.56,2.55,2.55,2.53,2.56,2.54,2.54,2.54,2.52,2.50,2.52,2.43,2.40,2.36,2.31,2.30,2.28,2.31,2.44,2.63,2.71,2.58,2.56,2.50,2.59,2.54,3.39,2.80,2.61,2.57,2.50,2.39,2.37,2.56,2.56,2.57,2.60,2.61},
   {1.48,1.62,2.40,2.01,1.89,1.76,1.70,1.69,1.69,2.12,2.76,2.43,2.27,2.18,2.10,2.11,2.09,2.12,3.09,2.49,2.30,2.24,2.22,2.19,2.19,2.18,2.12,2.17,2.36,2.36,2.37,2.30,2.22,2.23,2.26,2.24,3.18,2.55,2.40,2.37,2.32,2.29,2.26,2.19,2.22,2.28,2.53,2.60,2.62,2.48,2.43,2.37,2.41,2.38,3.25,2.65,2.55,2.47,2.44,2.53,2.51,2.50,2.50,2.48,2.51,2.49,2.49,2.49,2.47,2.45,2.47,2.38,2.35,2.31,2.26,2.25,2.23,2.26,2.39,2.58,2.66,2.53,2.51,2.45,2.54,2.49,3.34,2.75,2.56,2.52,2.45,2.34,2.32,2.51,2.51,2.52,2.55,2.56},
   {1.45,1.59,2.37,1.98,1.86,1.73,1.67,1.66,1.66,2.09,2.73,2.40,2.24,2.15,2.07,2.08,2.06,2.09,3.06,2.46,2.27,2.21,2.19,2.16,2.16,2.15,2.09,2.14,2.33,2.33,2.34,2.27,2.19,2.20,2.23,2.21,3.15,2.52,2.37,2.34,2.29,2.26,2.23,2.16,2.19,2.25,2.50,2.57,2.59,2.45,2.40,2.34,2.38,2.35,3.22,2.62,2.52,2.44,2.41,2.50,2.48,2.47,2.47,2.45,2.48,2.46,2.46,2.46,2.44,2.42,2.44,2.35,2.32,2.28,2.23,2.22,2.20,2.23,2.36,2.55,2.63,2.50,2.48,2.42,2.51,2.46,3.31,2.72,2.53,2.49,2.42,2.31,2.29,2.48,2.48,2.49,2.52,2.53},
   {1.42,1.56,2.34,1.95,1.83,1.70,1.64,1.63,1.63,2.06,2.70,2.37,2.21,2.12,2.04,2.05,2.03,2.06,3.03,2.43,2.24,2.18,2.16,2.13,2.13,2.12,2.06,2.11,2.30,2.30,2.31,2.24,2.16,2.17,2.20,2.18,3.12,2.49,2.34,2.31,2.26,2.23,2.20,2.13,2.16,2.22,2.47,2.54,2.56,2.42,2.37,2.31,2.35,2.32,3.19,2.59,2.49,2.41,2.38,2.47,2.45,2.44,2.44,2.42,2.45,2.43,2.43,2.43,2.41,2.39,2.41,2.32,2.29,2.25,2.20,2.19,2.17,2.20,2.33,2.52,2.60,2.47,2.45,2.39,2.48,2.43,3.28,2.69,2.50,2.46,2.39,2.28,2.26,2.45,2.45,2.46,2.49,2.50},
   {1.35,1.49,2.27,1.88,1.76,1.63,1.57,1.56,1.56,1.99,2.63,2.30,2.14,2.05,1.97,1.98,1.96,1.99,2.96,2.36,2.17,2.11,2.09,2.06,2.06,2.05,1.99,2.04,2.23,2.23,2.24,2.17,2.09,2.10,2.13,2.11,3.05,2.42,2.27,2.24,2.19,2.16,2.13,2.06,2.09,2.15,2.40,2.47,2.49,2.35,2.30,2.24,2.28,2.25,3.12,2.52,2.42,2.34,2.31,2.40,2.38,2.37,2.37,2.35,2.38,2.36,2.36,2.36,2.34,2.32,2.34,2.25,2.22,2.18,2.13,2.12,2.10,2.13,2.26,2.45,2.53,2.40,2.38,2.32,2.41,2.36,3.21,2.62,2.43,2.39,2.32,2.21,2.19,2.38,2.38,2.39,2.42,2.43},
   {1.38,1.52,2.30,1.91,1.79,1.66,1.60,1.59,1.59,2.02,2.66,2.33,2.17,2.08,2.00,2.01,1.99,2.02,2.99,2.39,2.20,2.14,2.12,2.09,2.09,2.08,2.02,2.07,2.26,2.26,2.27,2.20,2.12,2.13,2.16,2.14,3.08,2.45,2.30,2.27,2.22,2.19,2.16,2.09,2.12,2.18,2.43,2.50,2.52,2.38,2.33,2.27,2.31,2.28,3.15,2.55,2.45,2.37,2.34,2.43,2.41,2.40,2.40,2.38,2.41,2.39,2.39,2.39,2.37,2.35,2.37,2.28,2.25,2.21,2.16,2.15,2.13,2.16,2.29,2.48,2.56,2.43,2.41,2.35,2.44,2.39,3.24,2.65,2.46,2.42,2.35,2.24,2.22,2.41,2.41,2.42,2.45,2.46},
   {1.44,1.58,2.36,1.97,1.85,1.72,1.66,1.65,1.65,2.08,2.72,2.39,2.23,2.14,2.06,2.07,2.05,2.08,3.05,2.45,2.26,2.20,2.18,2.15,2.15,2.14,2.08,2.13,2.32,2.32,2.33,2.26,2.18,2.19,2.22,2.20,3.14,2.51,2.36,2.33,2.28,2.25,2.22,2.15,2.18,2.24,2.49,2.56,2.58,2.44,2.39,2.33,2.37,2.34,3.21,2.61,2.51,2.43,2.40,2.49,2.47,2.46,2.46,2.44,2.47,2.45,2.45,2.45,2.43,2.41,2.43,2.34,2.31,2.27,2.22,2.21,2.19,2.22,2.35,2.54,2.62,2.49,2.47,2.41,2.50,2.45,3.30,2.71,2.52,2.48,2.41,2.30,2.28,2.47,2.47,2.48,2.51,2.52},
   {1.69,1.83,2.61,2.22,2.10,1.97,1.91,1.90,1.90,2.33,2.97,2.64,2.48,2.39,2.31,2.32,2.30,2.33,3.30,2.70,2.51,2.45,2.43,2.40,2.40,2.39,2.33,2.38,2.57,2.57,2.58,2.51,2.43,2.44,2.47,2.45,3.39,2.76,2.61,2.58,2.53,2.50,2.47,2.40,2.43,2.49,2.74,2.81,2.83,2.69,2.64,2.58,2.62,2.59,3.46,2.86,2.76,2.68,2.65,2.74,2.72,2.71,2.71,2.69,2.72,2.70,2.70,2.70,2.68,2.66,2.68,2.59,2.56,2.52,2.47,2.46,2.44,2.47,2.60,2.79,2.87,2.74,2.72,2.66,2.75,2.70,3.55,2.96,2.77,2.73,2.66,2.55,2.53,2.72,2.72,2.73,2.76,2.77},
   {1.76,1.90,2.68,2.29,2.17,2.04,1.98,1.97,1.97,2.40,3.04,2.71,2.55,2.46,2.38,2.39,2.37,2.40,3.37,2.77,2.58,2.52,2.50,2.47,2.47,2.46,2.40,2.45,2.64,2.64,2.65,2.58,2.50,2.51,2.54,2.52,3.46,2.83,2.68,2.65,2.60,2.57,2.54,2.47,2.50,2.56,2.81,2.88,2.90,2.76,2.71,2.65,2.69,2.66,3.53,2.93,2.83,2.75,2.72,2.81,2.79,2.78,2.78,2.76,2.79,2.77,2.77,2.77,2.75,2.73,2.75,2.66,2.63,2.59,2.54,2.53,2.51,2.54,2.67,2.86,2.94,2.81,2.79,2.73,2.82,2.77,3.62,3.03,2.84,2.80,2.73,2.62,2.60,2.79,2.79,2.80,2.83,2.84},
   {1.78,1.92,2.70,2.31,2.19,2.06,2.00,1.99,1.99,2.42,3.06,2.73,2.57,2.48,2.40,2.41,2.39,2.42,3.39,2.79,2.60,2.54,2.52,2.49,2.49,2.48,2.42,2.47,2.66,2.66,2.67,2.60,2.52,2.53,2.56,2.54,3.48,2.85,2.70,2.67,2.62,2.59,2.56,2.49,2.52,2.58,2.83,2.90,2.92,2.78,2.73,2.67,2.71,2.68,3.55,2.95,2.85,2.77,2.74,2.83,2.81,2.80,2.80,2.78,2.81,2.79,2.79,2.79,2.77,2.75,2.77,2.68,2.65,2.61,2.56,2.55,2.53,2.56,2.69,2.88,2.96,2.83,2.81,2.75,2.84,2.79,3.64,3.05,2.86,2.82,2.75,2.64,2.62,2.81,2.81,2.82,2.85,2.86},
   {1.64,1.78,2.56,2.17,2.05,1.92,1.86,1.85,1.85,2.28,2.92,2.59,2.43,2.34,2.26,2.27,2.25,2.28,3.25,2.65,2.46,2.40,2.38,2.35,2.35,2.34,2.28,2.33,2.52,2.52,2.53,2.46,2.38,2.39,2.42,2.40,3.34,2.71,2.56,2.53,2.48,2.45,2.42,2.35,2.38,2.44,2.69,2.76,2.78,2.64,2.59,2.53,2.57,2.54,3.41,2.81,2.71,2.63,2.60,2.69,2.67,2.66,2.66,2.64,2.67,2.65,2.65,2.65,2.63,2.61,2.63,2.54,2.51,2.47,2.42,2.41,2.39,2.42,2.55,2.74,2.82,2.69,2.67,2.61,2.70,2.65,3.50,2.91,2.72,2.68,2.61,2.50,2.48,2.67,2.67,2.68,2.71,2.72},
   {1.59,1.73,2.51,2.12,2.00,1.87,1.81,1.80,1.80,2.23,2.87,2.54,2.38,2.29,2.21,2.22,2.20,2.23,3.20,2.60,2.41,2.35,2.33,2.30,2.30,2.29,2.23,2.28,2.47,2.47,2.48,2.41,2.33,2.34,2.37,2.35,3.29,2.66,2.51,2.48,2.43,2.40,2.37,2.30,2.33,2.39,2.64,2.71,2.73,2.59,2.54,2.48,2.52,2.49,3.36,2.76,2.66,2.58,2.55,2.64,2.62,2.61,2.61,2.59,2.62,2.60,2.60,2.60,2.58,2.56,2.58,2.49,2.46,2.42,2.37,2.36,2.34,2.37,2.50,2.69,2.77,2.64,2.62,2.56,2.65,2.60,3.45,2.86,2.67,2.63,2.56,2.45,2.43,2.62,2.62,2.63,2.66,2.67},
   {1.53,1.67,2.45,2.06,1.94,1.81,1.75,1.74,1.74,2.17,2.81,2.48,2.32,2.23,2.15,2.16,2.14,2.17,3.14,2.54,2.35,2.29,2.27,2.24,2.24,2.23,2.17,2.22,2.41,2.41,2.42,2.35,2.27,2.28,2.31,2.29,3.23,2.60,2.45,2.42,2.37,2.34,2.31,2.24,2.27,2.33,2.58,2.65,2.67,2.53,2.48,2.42,2.46,2.43,3.30,2.70,2.60,2.52,2.49,2.58,2.56,2.55,2.55,2.53,2.56,2.54,2.54,2.54,2.52,2.50,2.52,2.43,2.40,2.36,2.31,2.30,2.28,2.31,2.44,2.63,2.71,2.58,2.56,2.50,2.59,2.54,3.39,2.80,2.61,2.57,2.50,2.39,2.37,2.56,2.56,2.57,2.60,2.61},
   {1.57,1.71,2.49,2.10,1.98,1.85,1.79,1.78,1.78,2.21,2.85,2.52,2.36,2.27,2.19,2.20,2.18,2.21,3.18,2.58,2.39,2.33,2.31,2.28,2.28,2.27,2.21,2.26,2.45,2.45,2.46,2.39,2.31,2.32,2.35,2.33,3.27,2.64,2.49,2.46,2.41,2.38,2.35,2.28,2.31,2.37,2.62,2.69,2.71,2.57,2.52,2.46,2.50,2.47,3.34,2.74,2.64,2.56,2.53,2.62,2.60,2.59,2.59,2.57,2.60,2.58,2.58,2.58,2.56,2.54,2.56,2.47,2.44,2.40,2.35,2.34,2.32,2.35,2.48,2.67,2.75,2.62,2.60,2.54,2.63,2.58,3.43,2.84,2.65,2.61,2.54,2.43,2.41,2.60,2.60,2.61,2.64,2.65},
   {1.54,1.68,2.46,2.07,1.95,1.82,1.76,1.75,1.75,2.18,2.82,2.49,2.33,2.24,2.16,2.17,2.15,2.18,3.15,2.55,2.36,2.30,2.28,2.25,2.25,2.24,2.18,2.23,2.42,2.42,2.43,2.36,2.28,2.29,2.32,2.30,3.24,2.61,2.46,2.43,2.38,2.35,2.32,2.25,2.28,2.34,2.59,2.66,2.68,2.54,2.49,2.43,2.47,2.44,3.31,2.71,2.61,2.53,2.50,2.59,2.57,2.56,2.56,2.54,2.57,2.55,2.55,2.55,2.53,2.51,2.53,2.44,2.41,2.37,2.32,2.31,2.29,2.32,2.45,2.64,2.72,2.59,2.57,2.51,2.60,2.55,3.40,2.81,2.62,2.58,2.51,2.40,2.38,2.57,2.57,2.58,2.61,2.62},
   {2.41,2.55,3.33,2.94,2.82,2.69,2.63,2.62,2.62,3.05,3.69,3.36,3.20,3.11,3.03,3.04,3.02,3.05,4.02,3.42,3.23,3.17,3.15,3.12,3.12,3.11,3.05,3.10,3.29,3.29,3.30,3.23,3.15,3.16,3.19,3.17,4.11,3.48,3.33,3.30,3.25,3.22,3.19,3.12,3.15,3.21,3.46,3.53,3.55,3.41,3.36,3.30,3.34,3.31,4.18,3.58,3.48,3.40,3.37,3.46,3.44,3.43,3.43,3.41,3.44,3.42,3.42,3.42,3.40,3.38,3.40,3.31,3.28,3.24,3.19,3.18,3.16,3.19,3.32,3.51,3.59,3.46,3.44,3.38,3.47,3.42,4.27,3.68,3.49,3.45,3.38,3.27,3.25,3.44,3.44,3.45,3.48,3.49},
   {1.81,1.95,2.73,2.34,2.22,2.09,2.03,2.02,2.02,2.45,3.09,2.76,2.60,2.51,2.43,2.44,2.42,2.45,3.42,2.82,2.63,2.57,2.55,2.52,2.52,2.51,2.45,2.50,2.69,2.69,2.70,2.63,2.55,2.56,2.59,2.57,3.51,2.88,2.73,2.70,2.65,2.62,2.59,2.52,2.55,2.61,2.86,2.93,2.95,2.81,2.76,2.70,2.74,2.71,3.58,2.98,2.88,2.80,2.77,2.86,2.84,2.83,2.83,2.81,2.84,2.82,2.82,2.82,2.80,2.78,2.80,2.71,2.68,2.64,2.59,2.58,2.56,2.59,2.72,2.91,2.99,2.86,2.84,2.78,2.87,2.82,3.67,3.08,2.89,2.85,2.78,2.67,2.65,2.84,2.84,2.85,2.88,2.89},
   {1.71,1.85,2.63,2.24,2.12,1.99,1.93,1.92,1.92,2.35,2.99,2.66,2.50,2.41,2.33,2.34,2.32,2.35,3.32,2.72,2.53,2.47,2.45,2.42,2.42,2.41,2.35,2.40,2.59,2.59,2.60,2.53,2.45,2.46,2.49,2.47,3.41,2.78,2.63,2.60,2.55,2.52,2.49,2.42,2.45,2.51,2.76,2.83,2.85,2.71,2.66,2.60,2.64,2.61,3.48,2.88,2.78,2.70,2.67,2.76,2.74,2.73,2.73,2.71,2.74,2.72,2.72,2.72,2.70,2.68,2.70,2.61,2.58,2.54,2.49,2.48,2.46,2.49,2.62,2.81,2.89,2.76,2.74,2.68,2.77,2.72,3.57,2.98,2.79,2.75,2.68,2.57,2.55,2.74,2.74,2.75,2.78,2.79},
   {1.63,1.77,2.55,2.16,2.04,1.91,1.85,1.84,1.84,2.27,2.91,2.58,2.42,2.33,2.25,2.26,2.24,2.27,3.24,2.64,2.45,2.39,2.37,2.34,2.34,2.33,2.27,2.32,2.51,2.51,2.52,2.45,2.37,2.38,2.41,2.39,3.33,2.70,2.55,2.52,2.47,2.44,2.41,2.34,2.37,2.43,2.68,2.75,2.77,2.63,2.58,2.52,2.56,2.53,3.40,2.80,2.70,2.62,2.59,2.68,2.66,2.65,2.65,2.63,2.66,2.64,2.64,2.64,2.62,2.60,2.62,2.53,2.50,2.46,2.41,2.40,2.38,2.41,2.54,2.73,2.81,2.68,2.66,2.60,2.69,2.64,3.49,2.90,2.71,2.67,2.60,2.49,2.47,2.66,2.66,2.67,2.70,2.71},
   {1.60,1.74,2.52,2.13,2.01,1.88,1.82,1.81,1.81,2.24,2.88,2.55,2.39,2.30,2.22,2.23,2.21,2.24,3.21,2.61,2.42,2.36,2.34,2.31,2.31,2.30,2.24,2.29,2.48,2.48,2.49,2.42,2.34,2.35,2.38,2.36,3.30,2.67,2.52,2.49,2.44,2.41,2.38,2.31,2.34,2.40,2.65,2.72,2.74,2.60,2.55,2.49,2.53,2.50,3.37,2.77,2.67,2.59,2.56,2.65,2.63,2.62,2.62,2.60,2.63,2.61,2.61,2.61,2.59,2.57,2.59,2.50,2.47,2.43,2.38,2.37,2.35,2.38,2.51,2.70,2.78,2.65,2.63,2.57,2.66,2.61,3.46,2.87,2.68,2.64,2.57,2.46,2.44,2.63,2.63,2.64,2.67,2.68},
   {1.69,1.83,2.61,2.22,2.10,1.97,1.91,1.90,1.90,2.33,2.97,2.64,2.48,2.39,2.31,2.32,2.30,2.33,3.30,2.70,2.51,2.45,2.43,2.40,2.40,2.39,2.33,2.38,2.57,2.57,2.58,2.51,2.43,2.44,2.47,2.45,3.39,2.76,2.61,2.58,2.53,2.50,2.47,2.40,2.43,2.49,2.74,2.81,2.83,2.69,2.64,2.58,2.62,2.59,3.46,2.86,2.76,2.68,2.65,2.74,2.72,2.71,2.71,2.69,2.72,2.70,2.70,2.70,2.68,2.66,2.68,2.59,2.56,2.52,2.47,2.46,2.44,2.47,2.60,2.79,2.87,2.74,2.72,2.66,2.75,2.70,3.55,2.96,2.77,2.73,2.66,2.55,2.53,2.72,2.72,2.73,2.76,2.77},
   {1.67,1.81,2.59,2.20,2.08,1.95,1.89,1.88,1.88,2.31,2.95,2.62,2.46,2.37,2.29,2.30,2.28,2.31,3.28,2.68,2.49,2.43,2.41,2.38,2.38,2.37,2.31,2.36,2.55,2.55,2.56,2.49,2.41,2.42,2.45,2.43,3.37,2.74,2.59,2.56,2.51,2.48,2.45,2.38,2.41,2.47,2.72,2.79,2.81,2.67,2.62,2.56,2.60,2.57,3.44,2.84,2.74,2.66,2.63,2.72,2.70,2.69,2.69,2.67,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.57,2.54,2.50,2.45,2.44,2.42,2.45,2.58,2.77,2.85,2.72,2.70,2.64,2.73,2.68,3.53,2.94,2.75,2.71,2.64,2.53,2.51,2.70,2.70,2.71,2.74,2.75},
   {1.66,1.80,2.58,2.19,2.07,1.94,1.88,1.87,1.87,2.30,2.94,2.61,2.45,2.36,2.28,2.29,2.27,2.30,3.27,2.67,2.48,2.42,2.40,2.37,2.37,2.36,2.30,2.35,2.54,2.54,2.55,2.48,2.40,2.41,2.44,2.42,3.36,2.73,2.58,2.55,2.50,2.47,2.44,2.37,2.40,2.46,2.71,2.78,2.80,2.66,2.61,2.55,2.59,2.56,3.43,2.83,2.73,2.65,2.62,2.71,2.69,2.68,2.68,2.66,2.69,2.67,2.67,2.67,2.65,2.63,2.65,2.56,2.53,2.49,2.44,2.43,2.41,2.44,2.57,2.76,2.84,2.71,2.69,2.63,2.72,2.67,3.52,2.93,2.74,2.70,2.63,2.52,2.50,2.69,2.69,2.70,2.73,2.74},
   {1.66,1.80,2.58,2.19,2.07,1.94,1.88,1.87,1.87,2.30,2.94,2.61,2.45,2.36,2.28,2.29,2.27,2.30,3.27,2.67,2.48,2.42,2.40,2.37,2.37,2.36,2.30,2.35,2.54,2.54,2.55,2.48,2.40,2.41,2.44,2.42,3.36,2.73,2.58,2.55,2.50,2.47,2.44,2.37,2.40,2.46,2.71,2.78,2.80,2.66,2.61,2.55,2.59,2.56,3.43,2.83,2.73,2.65,2.62,2.71,2.69,2.68,2.68,2.66,2.69,2.67,2.67,2.67,2.65,2.63,2.65,2.56,2.53,2.49,2.44,2.43,2.41,2.44,2.57,2.76,2.84,2.71,2.69,2.63,2.72,2.67,3.52,2.93,2.74,2.70,2.63,2.52,2.50,2.69,2.69,2.70,2.73,2.74},
   {1.64,1.78,2.56,2.17,2.05,1.92,1.86,1.85,1.85,2.28,2.92,2.59,2.43,2.34,2.26,2.27,2.25,2.28,3.25,2.65,2.46,2.40,2.38,2.35,2.35,2.34,2.28,2.33,2.52,2.52,2.53,2.46,2.38,2.39,2.42,2.40,3.34,2.71,2.56,2.53,2.48,2.45,2.42,2.35,2.38,2.44,2.69,2.76,2.78,2.64,2.59,2.53,2.57,2.54,3.41,2.81,2.71,2.63,2.60,2.69,2.67,2.66,2.66,2.64,2.67,2.65,2.65,2.65,2.63,2.61,2.63,2.54,2.51,2.47,2.42,2.41,2.39,2.42,2.55,2.74,2.82,2.69,2.67,2.61,2.70,2.65,3.50,2.91,2.72,2.68,2.61,2.50,2.48,2.67,2.67,2.68,2.71,2.72},
   {1.67,1.81,2.59,2.20,2.08,1.95,1.89,1.88,1.88,2.31,2.95,2.62,2.46,2.37,2.29,2.30,2.28,2.31,3.28,2.68,2.49,2.43,2.41,2.38,2.38,2.37,2.31,2.36,2.55,2.55,2.56,2.49,2.41,2.42,2.45,2.43,3.37,2.74,2.59,2.56,2.51,2.48,2.45,2.38,2.41,2.47,2.72,2.79,2.81,2.67,2.62,2.56,2.60,2.57,3.44,2.84,2.74,2.66,2.63,2.72,2.70,2.69,2.69,2.67,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.57,2.54,2.50,2.45,2.44,2.42,2.45,2.58,2.77,2.85,2.72,2.70,2.64,2.73,2.68,3.53,2.94,2.75,2.71,2.64,2.53,2.51,2.70,2.70,2.71,2.74,2.75},
   {1.65,1.79,2.57,2.18,2.06,1.93,1.87,1.86,1.86,2.29,2.93,2.60,2.44,2.35,2.27,2.28,2.26,2.29,3.26,2.66,2.47,2.41,2.39,2.36,2.36,2.35,2.29,2.34,2.53,2.53,2.54,2.47,2.39,2.40,2.43,2.41,3.35,2.72,2.57,2.54,2.49,2.46,2.43,2.36,2.39,2.45,2.70,2.77,2.79,2.65,2.60,2.54,2.58,2.55,3.42,2.82,2.72,2.64,2.61,2.70,2.68,2.67,2.67,2.65,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.55,2.52,2.48,2.43,2.42,2.40,2.43,2.56,2.75,2.83,2.70,2.68,2.62,2.71,2.66,3.51,2.92,2.73,2.69,2.62,2.51,2.49,2.68,2.68,2.69,2.72,2.73},
   {1.65,1.79,2.57,2.18,2.06,1.93,1.87,1.86,1.86,2.29,2.93,2.60,2.44,2.35,2.27,2.28,2.26,2.29,3.26,2.66,2.47,2.41,2.39,2.36,2.36,2.35,2.29,2.34,2.53,2.53,2.54,2.47,2.39,2.40,2.43,2.41,3.35,2.72,2.57,2.54,2.49,2.46,2.43,2.36,2.39,2.45,2.70,2.77,2.79,2.65,2.60,2.54,2.58,2.55,3.42,2.82,2.72,2.64,2.61,2.70,2.68,2.67,2.67,2.65,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.55,2.52,2.48,2.43,2.42,2.40,2.43,2.56,2.75,2.83,2.70,2.68,2.62,2.71,2.66,3.51,2.92,2.73,2.69,2.62,2.51,2.49,2.68,2.68,2.69,2.72,2.73},
   {1.65,1.79,2.57,2.18,2.06,1.93,1.87,1.86,1.86,2.29,2.93,2.60,2.44,2.35,2.27,2.28,2.26,2.29,3.26,2.66,2.47,2.41,2.39,2.36,2.36,2.35,2.29,2.34,2.53,2.53,2.54,2.47,2.39,2.40,2.43,2.41,3.35,2.72,2.57,2.54,2.49,2.46,2.43,2.36,2.39,2.45,2.70,2.77,2.79,2.65,2.60,2.54,2.58,2.55,3.42,2.82,2.72,2.64,2.61,2.70,2.68,2.67,2.67,2.65,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.55,2.52,2.48,2.43,2.42,2.40,2.43,2.56,2.75,2.83,2.70,2.68,2.62,2.71,2.66,3.51,2.92,2.73,2.69,2.62,2.51,2.49,2.68,2.68,2.69,2.72,2.73},
   {1.63,1.77,2.55,2.16,2.04,1.91,1.85,1.84,1.84,2.27,2.91,2.58,2.42,2.33,2.25,2.26,2.24,2.27,3.24,2.64,2.45,2.39,2.37,2.34,2.34,2.33,2.27,2.32,2.51,2.51,2.52,2.45,2.37,2.38,2.41,2.39,3.33,2.70,2.55,2.52,2.47,2.44,2.41,2.34,2.37,2.43,2.68,2.75,2.77,2.63,2.58,2.52,2.56,2.53,3.40,2.80,2.70,2.62,2.59,2.68,2.66,2.65,2.65,2.63,2.66,2.64,2.64,2.64,2.62,2.60,2.62,2.53,2.50,2.46,2.41,2.40,2.38,2.41,2.54,2.73,2.81,2.68,2.66,2.60,2.69,2.64,3.49,2.90,2.71,2.67,2.60,2.49,2.47,2.66,2.66,2.67,2.70,2.71},
   {1.61,1.75,2.53,2.14,2.02,1.89,1.83,1.82,1.82,2.25,2.89,2.56,2.40,2.31,2.23,2.24,2.22,2.25,3.22,2.62,2.43,2.37,2.35,2.32,2.32,2.31,2.25,2.30,2.49,2.49,2.50,2.43,2.35,2.36,2.39,2.37,3.31,2.68,2.53,2.50,2.45,2.42,2.39,2.32,2.35,2.41,2.66,2.73,2.75,2.61,2.56,2.50,2.54,2.51,3.38,2.78,2.68,2.60,2.57,2.66,2.64,2.63,2.63,2.61,2.64,2.62,2.62,2.62,2.60,2.58,2.60,2.51,2.48,2.44,2.39,2.38,2.36,2.39,2.52,2.71,2.79,2.66,2.64,2.58,2.67,2.62,3.47,2.88,2.69,2.65,2.58,2.47,2.45,2.64,2.64,2.65,2.68,2.69},
   {1.63,1.77,2.55,2.16,2.04,1.91,1.85,1.84,1.84,2.27,2.91,2.58,2.42,2.33,2.25,2.26,2.24,2.27,3.24,2.64,2.45,2.39,2.37,2.34,2.34,2.33,2.27,2.32,2.51,2.51,2.52,2.45,2.37,2.38,2.41,2.39,3.33,2.70,2.55,2.52,2.47,2.44,2.41,2.34,2.37,2.43,2.68,2.75,2.77,2.63,2.58,2.52,2.56,2.53,3.40,2.80,2.70,2.62,2.59,2.68,2.66,2.65,2.65,2.63,2.66,2.64,2.64,2.64,2.62,2.60,2.62,2.53,2.50,2.46,2.41,2.40,2.38,2.41,2.54,2.73,2.81,2.68,2.66,2.60,2.69,2.64,3.49,2.90,2.71,2.67,2.60,2.49,2.47,2.66,2.66,2.67,2.70,2.71},
   {1.54,1.68,2.46,2.07,1.95,1.82,1.76,1.75,1.75,2.18,2.82,2.49,2.33,2.24,2.16,2.17,2.15,2.18,3.15,2.55,2.36,2.30,2.28,2.25,2.25,2.24,2.18,2.23,2.42,2.42,2.43,2.36,2.28,2.29,2.32,2.30,3.24,2.61,2.46,2.43,2.38,2.35,2.32,2.25,2.28,2.34,2.59,2.66,2.68,2.54,2.49,2.43,2.47,2.44,3.31,2.71,2.61,2.53,2.50,2.59,2.57,2.56,2.56,2.54,2.57,2.55,2.55,2.55,2.53,2.51,2.53,2.44,2.41,2.37,2.32,2.31,2.29,2.32,2.45,2.64,2.72,2.59,2.57,2.51,2.60,2.55,3.40,2.81,2.62,2.58,2.51,2.40,2.38,2.57,2.57,2.58,2.61,2.62},
   {1.51,1.65,2.43,2.04,1.92,1.79,1.73,1.72,1.72,2.15,2.79,2.46,2.30,2.21,2.13,2.14,2.12,2.15,3.12,2.52,2.33,2.27,2.25,2.22,2.22,2.21,2.15,2.20,2.39,2.39,2.40,2.33,2.25,2.26,2.29,2.27,3.21,2.58,2.43,2.40,2.35,2.32,2.29,2.22,2.25,2.31,2.56,2.63,2.65,2.51,2.46,2.40,2.44,2.41,3.28,2.68,2.58,2.50,2.47,2.56,2.54,2.53,2.53,2.51,2.54,2.52,2.52,2.52,2.50,2.48,2.50,2.41,2.38,2.34,2.29,2.28,2.26,2.29,2.42,2.61,2.69,2.56,2.54,2.48,2.57,2.52,3.37,2.78,2.59,2.55,2.48,2.37,2.35,2.54,2.54,2.55,2.58,2.59},
   {1.47,1.61,2.39,2.00,1.88,1.75,1.69,1.68,1.68,2.11,2.75,2.42,2.26,2.17,2.09,2.10,2.08,2.11,3.08,2.48,2.29,2.23,2.21,2.18,2.18,2.17,2.11,2.16,2.35,2.35,2.36,2.29,2.21,2.22,2.25,2.23,3.17,2.54,2.39,2.36,2.31,2.28,2.25,2.18,2.21,2.27,2.52,2.59,2.61,2.47,2.42,2.36,2.40,2.37,3.24,2.64,2.54,2.46,2.43,2.52,2.50,2.49,2.49,2.47,2.50,2.48,2.48,2.48,2.46,2.44,2.46,2.37,2.34,2.30,2.25,2.24,2.22,2.25,2.38,2.57,2.65,2.52,2.50,2.44,2.53,2.48,3.33,2.74,2.55,2.51,2.44,2.33,2.31,2.50,2.50,2.51,2.54,2.55},
   {1.42,1.56,2.34,1.95,1.83,1.70,1.64,1.63,1.63,2.06,2.70,2.37,2.21,2.12,2.04,2.05,2.03,2.06,3.03,2.43,2.24,2.18,2.16,2.13,2.13,2.12,2.06,2.11,2.30,2.30,2.31,2.24,2.16,2.17,2.20,2.18,3.12,2.49,2.34,2.31,2.26,2.23,2.20,2.13,2.16,2.22,2.47,2.54,2.56,2.42,2.37,2.31,2.35,2.32,3.19,2.59,2.49,2.41,2.38,2.47,2.45,2.44,2.44,2.42,2.45,2.43,2.43,2.43,2.41,2.39,2.41,2.32,2.29,2.25,2.20,2.19,2.17,2.20,2.33,2.52,2.60,2.47,2.45,2.39,2.48,2.43,3.28,2.69,2.50,2.46,2.39,2.28,2.26,2.45,2.45,2.46,2.49,2.50},
   {1.41,1.55,2.33,1.94,1.82,1.69,1.63,1.62,1.62,2.05,2.69,2.36,2.20,2.11,2.03,2.04,2.02,2.05,3.02,2.42,2.23,2.17,2.15,2.12,2.12,2.11,2.05,2.10,2.29,2.29,2.30,2.23,2.15,2.16,2.19,2.17,3.11,2.48,2.33,2.30,2.25,2.22,2.19,2.12,2.15,2.21,2.46,2.53,2.55,2.41,2.36,2.30,2.34,2.31,3.18,2.58,2.48,2.40,2.37,2.46,2.44,2.43,2.43,2.41,2.44,2.42,2.42,2.42,2.40,2.38,2.40,2.31,2.28,2.24,2.19,2.18,2.16,2.19,2.32,2.51,2.59,2.46,2.44,2.38,2.47,2.42,3.27,2.68,2.49,2.45,2.38,2.27,2.25,2.44,2.44,2.45,2.48,2.49},
   {1.39,1.53,2.31,1.92,1.80,1.67,1.61,1.60,1.60,2.03,2.67,2.34,2.18,2.09,2.01,2.02,2.00,2.03,3.00,2.40,2.21,2.15,2.13,2.10,2.10,2.09,2.03,2.08,2.27,2.27,2.28,2.21,2.13,2.14,2.17,2.15,3.09,2.46,2.31,2.28,2.23,2.20,2.17,2.10,2.13,2.19,2.44,2.51,2.53,2.39,2.34,2.28,2.32,2.29,3.16,2.56,2.46,2.38,2.35,2.44,2.42,2.41,2.41,2.39,2.42,2.40,2.40,2.40,2.38,2.36,2.38,2.29,2.26,2.22,2.17,2.16,2.14,2.17,2.30,2.49,2.57,2.44,2.42,2.36,2.45,2.40,3.25,2.66,2.47,2.43,2.36,2.25,2.23,2.42,2.42,2.43,2.46,2.47},
   {1.42,1.56,2.34,1.95,1.83,1.70,1.64,1.63,1.63,2.06,2.70,2.37,2.21,2.12,2.04,2.05,2.03,2.06,3.03,2.43,2.24,2.18,2.16,2.13,2.13,2.12,2.06,2.11,2.30,2.30,2.31,2.24,2.16,2.17,2.20,2.18,3.12,2.49,2.34,2.31,2.26,2.23,2.20,2.13,2.16,2.22,2.47,2.54,2.56,2.42,2.37,2.31,2.35,2.32,3.19,2.59,2.49,2.41,2.38,2.47,2.45,2.44,2.44,2.42,2.45,2.43,2.43,2.43,2.41,2.39,2.41,2.32,2.29,2.25,2.20,2.19,2.17,2.20,2.33,2.52,2.60,2.47,2.45,2.39,2.48,2.43,3.28,2.69,2.50,2.46,2.39,2.28,2.26,2.45,2.45,2.46,2.49,2.50},
   {1.55,1.69,2.47,2.08,1.96,1.83,1.77,1.76,1.76,2.19,2.83,2.50,2.34,2.25,2.17,2.18,2.16,2.19,3.16,2.56,2.37,2.31,2.29,2.26,2.26,2.25,2.19,2.24,2.43,2.43,2.44,2.37,2.29,2.30,2.33,2.31,3.25,2.62,2.47,2.44,2.39,2.36,2.33,2.26,2.29,2.35,2.60,2.67,2.69,2.55,2.50,2.44,2.48,2.45,3.32,2.72,2.62,2.54,2.51,2.60,2.58,2.57,2.57,2.55,2.58,2.56,2.56,2.56,2.54,2.52,2.54,2.45,2.42,2.38,2.33,2.32,2.30,2.33,2.46,2.65,2.73,2.60,2.58,2.52,2.61,2.56,3.41,2.82,2.63,2.59,2.52,2.41,2.39,2.58,2.58,2.59,2.62,2.63},
   {1.74,1.88,2.66,2.27,2.15,2.02,1.96,1.95,1.95,2.38,3.02,2.69,2.53,2.44,2.36,2.37,2.35,2.38,3.35,2.75,2.56,2.50,2.48,2.45,2.45,2.44,2.38,2.43,2.62,2.62,2.63,2.56,2.48,2.49,2.52,2.50,3.44,2.81,2.66,2.63,2.58,2.55,2.52,2.45,2.48,2.54,2.79,2.86,2.88,2.74,2.69,2.63,2.67,2.64,3.51,2.91,2.81,2.73,2.70,2.79,2.77,2.76,2.76,2.74,2.77,2.75,2.75,2.75,2.73,2.71,2.73,2.64,2.61,2.57,2.52,2.51,2.49,2.52,2.65,2.84,2.92,2.79,2.77,2.71,2.80,2.75,3.60,3.01,2.82,2.78,2.71,2.60,2.58,2.77,2.77,2.78,2.81,2.82},
   {1.82,1.96,2.74,2.35,2.23,2.10,2.04,2.03,2.03,2.46,3.10,2.77,2.61,2.52,2.44,2.45,2.43,2.46,3.43,2.83,2.64,2.58,2.56,2.53,2.53,2.52,2.46,2.51,2.70,2.70,2.71,2.64,2.56,2.57,2.60,2.58,3.52,2.89,2.74,2.71,2.66,2.63,2.60,2.53,2.56,2.62,2.87,2.94,2.96,2.82,2.77,2.71,2.75,2.72,3.59,2.99,2.89,2.81,2.78,2.87,2.85,2.84,2.84,2.82,2.85,2.83,2.83,2.83,2.81,2.79,2.81,2.72,2.69,2.65,2.60,2.59,2.57,2.60,2.73,2.92,3.00,2.87,2.85,2.79,2.88,2.83,3.68,3.09,2.90,2.86,2.79,2.68,2.66,2.85,2.85,2.86,2.89,2.90},
   {1.69,1.83,2.61,2.22,2.10,1.97,1.91,1.90,1.90,2.33,2.97,2.64,2.48,2.39,2.31,2.32,2.30,2.33,3.30,2.70,2.51,2.45,2.43,2.40,2.40,2.39,2.33,2.38,2.57,2.57,2.58,2.51,2.43,2.44,2.47,2.45,3.39,2.76,2.61,2.58,2.53,2.50,2.47,2.40,2.43,2.49,2.74,2.81,2.83,2.69,2.64,2.58,2.62,2.59,3.46,2.86,2.76,2.68,2.65,2.74,2.72,2.71,2.71,2.69,2.72,2.70,2.70,2.70,2.68,2.66,2.68,2.59,2.56,2.52,2.47,2.46,2.44,2.47,2.60,2.79,2.87,2.74,2.72,2.66,2.75,2.70,3.55,2.96,2.77,2.73,2.66,2.55,2.53,2.72,2.72,2.73,2.76,2.77},
   {1.67,1.81,2.59,2.20,2.08,1.95,1.89,1.88,1.88,2.31,2.95,2.62,2.46,2.37,2.29,2.30,2.28,2.31,3.28,2.68,2.49,2.43,2.41,2.38,2.38,2.37,2.31,2.36,2.55,2.55,2.56,2.49,2.41,2.42,2.45,2.43,3.37,2.74,2.59,2.56,2.51,2.48,2.45,2.38,2.41,2.47,2.72,2.79,2.81,2.67,2.62,2.56,2.60,2.57,3.44,2.84,2.74,2.66,2.63,2.72,2.70,2.69,2.69,2.67,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.57,2.54,2.50,2.45,2.44,2.42,2.45,2.58,2.77,2.85,2.72,2.70,2.64,2.73,2.68,3.53,2.94,2.75,2.71,2.64,2.53,2.51,2.70,2.70,2.71,2.74,2.75},
   {1.61,1.75,2.53,2.14,2.02,1.89,1.83,1.82,1.82,2.25,2.89,2.56,2.40,2.31,2.23,2.24,2.22,2.25,3.22,2.62,2.43,2.37,2.35,2.32,2.32,2.31,2.25,2.30,2.49,2.49,2.50,2.43,2.35,2.36,2.39,2.37,3.31,2.68,2.53,2.50,2.45,2.42,2.39,2.32,2.35,2.41,2.66,2.73,2.75,2.61,2.56,2.50,2.54,2.51,3.38,2.78,2.68,2.60,2.57,2.66,2.64,2.63,2.63,2.61,2.64,2.62,2.62,2.62,2.60,2.58,2.60,2.51,2.48,2.44,2.39,2.38,2.36,2.39,2.52,2.71,2.79,2.66,2.64,2.58,2.67,2.62,3.47,2.88,2.69,2.65,2.58,2.47,2.45,2.64,2.64,2.65,2.68,2.69},
   {1.70,1.84,2.62,2.23,2.11,1.98,1.92,1.91,1.91,2.34,2.98,2.65,2.49,2.40,2.32,2.33,2.31,2.34,3.31,2.71,2.52,2.46,2.44,2.41,2.41,2.40,2.34,2.39,2.58,2.58,2.59,2.52,2.44,2.45,2.48,2.46,3.40,2.77,2.62,2.59,2.54,2.51,2.48,2.41,2.44,2.50,2.75,2.82,2.84,2.70,2.65,2.59,2.63,2.60,3.47,2.87,2.77,2.69,2.66,2.75,2.73,2.72,2.72,2.70,2.73,2.71,2.71,2.71,2.69,2.67,2.69,2.60,2.57,2.53,2.48,2.47,2.45,2.48,2.61,2.80,2.88,2.75,2.73,2.67,2.76,2.71,3.56,2.97,2.78,2.74,2.67,2.56,2.54,2.73,2.73,2.74,2.77,2.78},
   {1.65,1.79,2.57,2.18,2.06,1.93,1.87,1.86,1.86,2.29,2.93,2.60,2.44,2.35,2.27,2.28,2.26,2.29,3.26,2.66,2.47,2.41,2.39,2.36,2.36,2.35,2.29,2.34,2.53,2.53,2.54,2.47,2.39,2.40,2.43,2.41,3.35,2.72,2.57,2.54,2.49,2.46,2.43,2.36,2.39,2.45,2.70,2.77,2.79,2.65,2.60,2.54,2.58,2.55,3.42,2.82,2.72,2.64,2.61,2.70,2.68,2.67,2.67,2.65,2.68,2.66,2.66,2.66,2.64,2.62,2.64,2.55,2.52,2.48,2.43,2.42,2.40,2.43,2.56,2.75,2.83,2.70,2.68,2.62,2.71,2.66,3.51,2.92,2.73,2.69,2.62,2.51,2.49,2.68,2.68,2.69,2.72,2.73},
   {2.50,2.64,3.42,3.03,2.91,2.78,2.72,2.71,2.71,3.14,3.78,3.45,3.29,3.20,3.12,3.13,3.11,3.14,4.11,3.51,3.32,3.26,3.24,3.21,3.21,3.20,3.14,3.19,3.38,3.38,3.39,3.32,3.24,3.25,3.28,3.26,4.20,3.57,3.42,3.39,3.34,3.31,3.28,3.21,3.24,3.30,3.55,3.62,3.64,3.50,3.45,3.39,3.43,3.40,4.27,3.67,3.57,3.49,3.46,3.55,3.53,3.52,3.52,3.50,3.53,3.51,3.51,3.51,3.49,3.47,3.49,3.40,3.37,3.33,3.28,3.27,3.25,3.28,3.41,3.60,3.68,3.55,3.53,3.47,3.56,3.51,4.36,3.77,3.58,3.54,3.47,3.36,3.34,3.53,3.53,3.54,3.57,3.58},
   {1.91,2.05,2.83,2.44,2.32,2.19,2.13,2.12,2.12,2.55,3.19,2.86,2.70,2.61,2.53,2.54,2.52,2.55,3.52,2.92,2.73,2.67,2.65,2.62,2.62,2.61,2.55,2.60,2.79,2.79,2.80,2.73,2.65,2.66,2.69,2.67,3.61,2.98,2.83,2.80,2.75,2.72,2.69,2.62,2.65,2.71,2.96,3.03,3.05,2.91,2.86,2.80,2.84,2.81,3.68,3.08,2.98,2.90,2.87,2.96,2.94,2.93,2.93,2.91,2.94,2.92,2.92,2.92,2.90,2.88,2.90,2.81,2.78,2.74,2.69,2.68,2.66,2.69,2.82,3.01,3.09,2.96,2.94,2.88,2.97,2.92,3.77,3.18,2.99,2.95,2.88,2.77,2.75,2.94,2.94,2.95,2.98,2.99},
   {1.72,1.86,2.64,2.25,2.13,2.00,1.94,1.93,1.93,2.36,3.00,2.67,2.51,2.42,2.34,2.35,2.33,2.36,3.33,2.73,2.54,2.48,2.46,2.43,2.43,2.42,2.36,2.41,2.60,2.60,2.61,2.54,2.46,2.47,2.50,2.48,3.42,2.79,2.64,2.61,2.56,2.53,2.50,2.43,2.46,2.52,2.77,2.84,2.86,2.72,2.67,2.61,2.65,2.62,3.49,2.89,2.79,2.71,2.68,2.77,2.75,2.74,2.74,2.72,2.75,2.73,2.73,2.73,2.71,2.69,2.71,2.62,2.59,2.55,2.50,2.49,2.47,2.50,2.63,2.82,2.90,2.77,2.75,2.69,2.78,2.73,3.58,2.99,2.80,2.76,2.69,2.58,2.56,2.75,2.75,2.76,2.79,2.80},
   {1.68,1.82,2.60,2.21,2.09,1.96,1.90,1.89,1.89,2.32,2.96,2.63,2.47,2.38,2.30,2.31,2.29,2.32,3.29,2.69,2.50,2.44,2.42,2.39,2.39,2.38,2.32,2.37,2.56,2.56,2.57,2.50,2.42,2.43,2.46,2.44,3.38,2.75,2.60,2.57,2.52,2.49,2.46,2.39,2.42,2.48,2.73,2.80,2.82,2.68,2.63,2.57,2.61,2.58,3.45,2.85,2.75,2.67,2.64,2.73,2.71,2.70,2.70,2.68,2.71,2.69,2.69,2.69,2.67,2.65,2.67,2.58,2.55,2.51,2.46,2.45,2.43,2.46,2.59,2.78,2.86,2.73,2.71,2.65,2.74,2.69,3.54,2.95,2.76,2.72,2.65,2.54,2.52,2.71,2.71,2.72,2.75,2.76},
   {1.61,1.75,2.53,2.14,2.02,1.89,1.83,1.82,1.82,2.25,2.89,2.56,2.40,2.31,2.23,2.24,2.22,2.25,3.22,2.62,2.43,2.37,2.35,2.32,2.32,2.31,2.25,2.30,2.49,2.49,2.50,2.43,2.35,2.36,2.39,2.37,3.31,2.68,2.53,2.50,2.45,2.42,2.39,2.32,2.35,2.41,2.66,2.73,2.75,2.61,2.56,2.50,2.54,2.51,3.38,2.78,2.68,2.60,2.57,2.66,2.64,2.63,2.63,2.61,2.64,2.62,2.62,2.62,2.60,2.58,2.60,2.51,2.48,2.44,2.39,2.38,2.36,2.39,2.52,2.71,2.79,2.66,2.64,2.58,2.67,2.62,3.47,2.88,2.69,2.65,2.58,2.47,2.45,2.64,2.64,2.65,2.68,2.69},
   {1.50,1.64,2.42,2.03,1.91,1.78,1.72,1.71,1.71,2.14,2.78,2.45,2.29,2.20,2.12,2.13,2.11,2.14,3.11,2.51,2.32,2.26,2.24,2.21,2.21,2.20,2.14,2.19,2.38,2.38,2.39,2.32,2.24,2.25,2.28,2.26,3.20,2.57,2.42,2.39,2.34,2.31,2.28,2.21,2.24,2.30,2.55,2.62,2.64,2.50,2.45,2.39,2.43,2.40,3.27,2.67,2.57,2.49,2.46,2.55,2.53,2.52,2.52,2.50,2.53,2.51,2.51,2.51,2.49,2.47,2.49,2.40,2.37,2.33,2.28,2.27,2.25,2.28,2.41,2.60,2.68,2.55,2.53,2.47,2.56,2.51,3.36,2.77,2.58,2.54,2.47,2.36,2.34,2.53,2.53,2.54,2.57,2.58},
   {1.48,1.62,2.40,2.01,1.89,1.76,1.70,1.69,1.69,2.12,2.76,2.43,2.27,2.18,2.10,2.11,2.09,2.12,3.09,2.49,2.30,2.24,2.22,2.19,2.19,2.18,2.12,2.17,2.36,2.36,2.37,2.30,2.22,2.23,2.26,2.24,3.18,2.55,2.40,2.37,2.32,2.29,2.26,2.19,2.22,2.28,2.53,2.60,2.62,2.48,2.43,2.37,2.41,2.38,3.25,2.65,2.55,2.47,2.44,2.53,2.51,2.50,2.50,2.48,2.51,2.49,2.49,2.49,2.47,2.45,2.47,2.38,2.35,2.31,2.26,2.25,2.23,2.26,2.39,2.58,2.66,2.53,2.51,2.45,2.54,2.49,3.34,2.75,2.56,2.52,2.45,2.34,2.32,2.51,2.51,2.52,2.55,2.56},
   {1.67,1.81,2.59,2.20,2.08,1.95,1.89,1.88,1.88,2.31,2.95,2.62,2.46,2.37,2.29,2.30,2.28,2.31,3.28,2.68,2.49,2.43,2.41,2.38,2.38,2.37,2.31,2.36,2.55,2.55,2.56,2.49,2.41,2.42,2.45,2.43,3.37,2.74,2.59,2.56,2.51,2.48,2.45,2.38,2.41,2.47,2.72,2.79,2.81,2.67,2.62,2.56,2.60,2.57,3.44,2.84,2.74,2.66,2.63,2.72,2.70,2.69,2.69,2.67,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.57,2.54,2.50,2.45,2.44,2.42,2.45,2.58,2.77,2.85,2.72,2.70,2.64,2.73,2.68,3.53,2.94,2.75,2.71,2.64,2.53,2.51,2.70,2.70,2.71,2.74,2.75},
   {1.67,1.81,2.59,2.20,2.08,1.95,1.89,1.88,1.88,2.31,2.95,2.62,2.46,2.37,2.29,2.30,2.28,2.31,3.28,2.68,2.49,2.43,2.41,2.38,2.38,2.37,2.31,2.36,2.55,2.55,2.56,2.49,2.41,2.42,2.45,2.43,3.37,2.74,2.59,2.56,2.51,2.48,2.45,2.38,2.41,2.47,2.72,2.79,2.81,2.67,2.62,2.56,2.60,2.57,3.44,2.84,2.74,2.66,2.63,2.72,2.70,2.69,2.69,2.67,2.70,2.68,2.68,2.68,2.66,2.64,2.66,2.57,2.54,2.50,2.45,2.44,2.42,2.45,2.58,2.77,2.85,2.72,2.70,2.64,2.73,2.68,3.53,2.94,2.75,2.71,2.64,2.53,2.51,2.70,2.70,2.71,2.74,2.75},
   {1.68,1.82,2.60,2.21,2.09,1.96,1.90,1.89,1.89,2.32,2.96,2.63,2.47,2.38,2.30,2.31,2.29,2.32,3.29,2.69,2.50,2.44,2.42,2.39,2.39,2.38,2.32,2.37,2.56,2.56,2.57,2.50,2.42,2.43,2.46,2.44,3.38,2.75,2.60,2.57,2.52,2.49,2.46,2.39,2.42,2.48,2.73,2.80,2.82,2.68,2.63,2.57,2.61,2.58,3.45,2.85,2.75,2.67,2.64,2.73,2.71,2.70,2.70,2.68,2.71,2.69,2.69,2.69,2.67,2.65,2.67,2.58,2.55,2.51,2.46,2.45,2.43,2.46,2.59,2.78,2.86,2.73,2.71,2.65,2.74,2.69,3.54,2.95,2.76,2.72,2.65,2.54,2.52,2.71,2.71,2.72,2.75,2.76},
   {1.71,1.85,2.63,2.24,2.12,1.99,1.93,1.92,1.92,2.35,2.99,2.66,2.50,2.41,2.33,2.34,2.32,2.35,3.32,2.72,2.53,2.47,2.45,2.42,2.42,2.41,2.35,2.40,2.59,2.59,2.60,2.53,2.45,2.46,2.49,2.47,3.41,2.78,2.63,2.60,2.55,2.52,2.49,2.42,2.45,2.51,2.76,2.83,2.85,2.71,2.66,2.60,2.64,2.61,3.48,2.88,2.78,2.70,2.67,2.76,2.74,2.73,2.73,2.71,2.74,2.72,2.72,2.72,2.70,2.68,2.70,2.61,2.58,2.54,2.49,2.48,2.46,2.49,2.62,2.81,2.89,2.76,2.74,2.68,2.77,2.72,3.57,2.98,2.79,2.75,2.68,2.57,2.55,2.74,2.74,2.75,2.78,2.79},
   {1.72,1.86,2.64,2.25,2.13,2.00,1.94,1.93,1.93,2.36,3.00,2.67,2.51,2.42,2.34,2.35,2.33,2.36,3.33,2.73,2.54,2.48,2.46,2.43,2.43,2.42,2.36,2.41,2.60,2.60,2.61,2.54,2.46,2.47,2.50,2.48,3.42,2.79,2.64,2.61,2.56,2.53,2.50,2.43,2.46,2.52,2.77,2.84,2.86,2.72,2.67,2.61,2.65,2.62,3.49,2.89,2.79,2.71,2.68,2.77,2.75,2.74,2.74,2.72,2.75,2.73,2.73,2.73,2.71,2.69,2.71,2.62,2.59,2.55,2.50,2.49,2.47,2.50,2.63,2.82,2.90,2.77,2.75,2.69,2.78,2.73,3.58,2.99,2.80,2.76,2.69,2.58,2.56,2.75,2.75,2.76,2.79,2.80}
	};

static char *elements[] = {
	"Bq","H","He","Li","Be","B","C","N","O","F","Ne",
	"Na","Mg","Al","Si","P","S","Cl","Ar",
	"K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu",
	"Zn","Ga","Ge","As","Se","Br","Kr",
	"Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag",
	"Cd","In","Sn","Sb","Te","I","Xe",
	"Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy",
	"Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt",
	"Au","Hg","Tl","Pb","Bi","Po","At","Rn",
	"Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","X"};

static char *elemts[] = { " H","He",
      "Li","Be"," B"," C"," N"," O"," F","Ne",
      "Na","Mg","Al","Si"," P"," S","Cl","Ar",
      " K","Ca","Sc","Ti"," V","Cr","Mn","Fe","Co","Ni","Cu",
      "Zn","Ga","Ge","As","Se","Br","Kr",
      "Rb","Sr"," Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag",
      "Cd","In","Sn","Sb","Te"," I","Xe",
      "Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy",
      "Ho","Er","Tm","Yb","Lu","Hf","Ta"," W","Re","Os","Ir","Pt",
      "Au","Hg","Tl","Pb","Bi","Po","At","Rn",
      "Fr","Ra","Ac","Th","Pa"," U","Np","Pu","Am","Cm","Bk","Cf",
      "XX","  "};

static char *ATYPE[] = {
	"    ",".1  ",".2  ",".3  ",".4  ",".ar ",".cat",
	".am ",".pl3",".co2",".spc",".t3p",".O  ",".O2 "};

static int IHBT[] = {
	3     ,  1   ,  2   ,  3   ,  3   ,  4   ,  4   ,
	3     ,  3   ,  2   ,  3   ,  3   ,  2   ,  2 };

#define ZC_DEF 1
#define ZC_CONN 0
#define ZC_AT1 3
#define ZC_AT2 4
#define ZC_MARK -7
#define ZC_VAR  ZC_DEF
#define ZC_CONST -4
#define ZC_LINK -13

#define MAXFRPNT 3000
typedef struct { Window win;
		 double *fpts;
                 int *x;
                 int *y;
                 int *index;
                 int npts;
		 int current;
		 int yelev;
		 int color;
		 int wide;
		 int high;
                } FRSTRU;

void drwgra(FRSTRU *tabptr,int yelev,Window gwin,int wide,int high,int *isav,double *fpts,int jbeg,int jend,int nents,double fmax,double fmin,double flim,int icol,int ifr,char *xstr,char *ystr,char *labstr,int isdash,int init,int notsav,int ityp);
void parse_motion(FRSTRU *tabptr);
static char *frsym[MAXFRQ];
static int nfr = 0;

static FRSTRU scfEfirst = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};
static FRSTRU scfElast = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};

static FRSTRU geoFmax = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};
static FRSTRU geoFrms = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};
static FRSTRU geoSmax = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};
static FRSTRU geoSrms = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};
static FRSTRU geoE = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};

static FRSTRU spect = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};
static FRSTRU docksco = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};

static FRSTRU RamaStru = { 0, NULL, NULL, NULL, NULL,-1,0,0,0,0,0};

static int *npmfs;
static double *ewin = NULL;

/* Spectrum variables */
#define SPBHIGH  90
static int SPECWIDE = 600;
static int SPECHIGH = 300;
#define NSBUTTS 7
static int nsbutts = 6;
static BSTRU spbut[NSBUTTS];
static char *pktyp[] = {"Gaussian", "Lorentzian"};
static char *sptyp[] = {"Infra Red", "Raman"};
static char *nmrsptyp[] = {"1H", "13C"};
static char *uvsptyp[] = {"UV spectrum"};
static double *spint;
static float *spfrq;
static int *spnfrq;
static int nspqbox = 5;
static double *out_spec = NULL;
static char *splab = NULL;
static char *forlab = "Frequency";
static char *uvlab = "Excitation Energy (nm)";
static char *nmrlab = "Shift (ppm)";
static float NMRbas = 100.0;
static int NMRnuc = 1;
static int specsize = 0;
static int lorentzian = 1;
static int spmode = 0;
static double hwhm = 20.0;
static double spec_mx;
static double spec_mn;
static double freq_step = 1.0;
static double freq_scale = 1.0;
static int min_freq = 0;
static int max_freq = 4000;
static int n_freqs = 2;
static int specps = 0;
static FILE *spout;

#define mxcpl 5
#define mxpeak 2*2*2*2*2
static float *peaks  = NULL;
static double *inten  = NULL;
static int npks = 0;
static float jcut  = 1.0;
static float nmr1Href  = 32.78;
static float nmr13Cref  = 194.47;
static float nmr1Hstep = 0.001;
static float nmr13Cstep = 0.01;
static float *nmrref  = &nmr1Href;
static int NMRup = 0;
void FRQextr();
void INTextr();

void updcallb(char *str);
void disp_map(char *str);
void srfprop();
void deletebox();

/* pmf score variables */
#define NSCBUTTS 6
static BSTRU scbut[NSCBUTTS];

#define NPBUTTS 1
static BSTRU pbut[NPBUTTS];

static double *pmfmn;
static double *pmfmx;
static double *pmflga;
static int *ipmfmn;
static int *ipmfmx;
static int *npmfmx;
static int *ialtyp = NULL;
static int *iscst;
static int *iocnt;
static int *ipmfm;
static int *ipmfh;
static int *levcol;

static int *logo;
static int *nscnd;
static int *dolabs;
static int *forces_yes_no;
static int *ifogl;
static int *ifdogl;
static int *fullgl;
static int *icst;
static int *ibox;
static int *igfmap;
static int *iresrd;
static int srfsep;
static int srftyp;
static int *doesp;
static int *doshad;
static int *ihasex;
static int *noshad;
static int *ionoff;
static int *icommf;

#define AVG(a,b) (((a) + (b))/2)
#define MIDDLEX(f,x,str) ((x)-XTextWidth(f,str,strlen(str))/2)
#define MIDDLEY(f,y) ((y)-((f->ascent+f->descent)/2)+f->ascent)
#define VIERKANT(x,y,rx,ry,rw,rh) \
           ((x)>=(rx) && (y)>=(ry) && (x)<=(rx)+(rw) && (y)<=(ry)+(rh))
#define SPACING 3
#define ASCENT   (mfinfo->ascent)
#define DESCENT  (mfinfo->descent)
#define CHIGH    (ASCENT + DESCENT)
#define LINEHIGH (CHIGH + SPACING)
#define WINCWIDE  260
#define WINCHIGH  435
#define DEFWINCGEOM "-130+80"

#define CNTCOL -15
#ifdef DOGL
#define NBUTTS   35 
#else
#define NBUTTS   34 
#endif

#define BPSI     0
#define BHOMO    1
#define BLUMO    2
#define BNDEN    3
#define BBONDS   4
#define BATOM    5
#define BOVRLP   6
#define BPOST    7
#define BMOLMOD  8
#define BQUIT    9
#define BEUCL    10
#define B3D      11
#define BINCRS   12
#define BDECRS   13
#define BCONT    14
#define BMOL     15
#define BCOMM    16
#define BORI     17
#define BSTEP    18
#define BCUT     19
#define BWRBAS   20
#define BRDBAS   21
#define B3DX     22
#define BSPACE   23
#define BFILL    24
#define BELPOT   25
#define BMAXMIN  26
#define BVRML2   27
#define BLAPL    28
#define BSRF2    29
#define BCUBE    30
#define BGIF2    31
#define BLOCAL   32
#define BELF     33
#define BOGL     34

#define NBUTTS2  47 

#define BFIRST   0
#define BNEXT    1
#define BSOLID   2
#define BPOSTT   3 
#define BDENMOD  4 
#define BQUITT   5 
#define BFORC    6 
#define BINCRF   7 
#define BDECRF   8 
#define BUNSC    9
#define BDIST    10
#define BANGLE   11
#define BDIHED   12
#define BAUTH    13
#define BLABEL   14
#define BCONV    15
#define BGEOM    16
#define BZOOMIN  17
#define BZOOMOUT 18
#define BSHADE   19
#define BBACKB   20
#define BATCOL   21
#define BPERSP   22
#define BLEFT    23
#define BRIGHT   24
#define BUP      25
#define BDOWN    26
#define BMOVIE   27
#define BZMAT    28
#define BREADF   29
#define BHBOND   30
#define BPACE    31
#define BGIF     32
#define BPAL     33
#define BCELL    34
#define BORIG    35
#define BSURF    36
#define BVRML    37
#define BHYD     38
#define BWRITF   39
#define BALIGN   40
#define BBALL    41
#define BHOUR    42
#define BMOLF    43
#define BPREV    44
#define BJCPL    45
#define BMOV     46

#define NBUTTR   7 

#define BDIR      0
#define BCAN      1
#define BREP      2
#define BADD      3
#define BPDB      4
#define BSPDB     5
#define BSHOW     6


#define NQBOX  105

#define QORB     0
#define QCOMM    1
#define QPOST    2
#define QSPAC    3
#define QSTEP    4
#define QCUT     5
#define QPOSTT   6
#define QRESI    7
#define QHBOND   8
#define QREADF   9
#define QBZMAT  10
#define QFRAG   11
#define QVRML   12
#define QCSPACE 13
#define QMXYZ   14
#define QGLIN1  15
#define QGLIN2  16
#define QGTITL  17
#define QJNAME  18
#define QQNAME  19
#define QENAME  20
#define QTIME   21
#define QRADI   22
#define QCPA    23
#define QCPB    24
#define QCPC    25
#define QCPAL   26
#define QCPBE   27
#define QCPGA   28
#define QCPSPGN 29
#define QCPSPGS 30
#define QSRFW   31
#define QSRFR   32
#define QEDGE   33
#define QVALC1  34
#define QVALC2  35
#define QVALC3  36
#define QNPTS   37
#define QCHARG  38
#define QRSD    39
#define QATOM   40
#define QPHI    41
#define QPSI    42
#define QPROT   43
#define QGRD    44
#define QARCH   45
#define QTNKJN  46
#define QMAXIT  47
#define QCUBE   48
#define QCTA    49
#define QCTB    50
#define QCTC    51
#define QNSCAL  52
#define QVFILE  53
#define QMFILE  54
#define QCNTVAL 55
#define QCOLVAL1 56
#define QCOLVAL2 57
#define QCOLVAL3 58
#define QCOLVAL4 59
#define QCOLVAL5 60
#define QPOLVAL1 61
#define QPOLVAL2 62
#define QSVFILE  63
#define QSCNT    64
#define QHW      65
#define QMINF    66
#define QMAXF    67
#define QSSCAL   68
#define QIMAX    69
#define QTMS     70
#define QFREQ    71
#define QSFIL    72
#define QDEL     73
#define QCNT     74
#define QHBMIN   75
#define QHBMAX   76
#define QHAMIN   77
#define QHAMAX   78
#define QPDB     79
#define QCNT2    80
#define QSUBSTR  81
#define QMOV     82
#define QSRCH    83
#define QCHRG2   84
#define QRESF    85
#define QQUERY   86
#define QNRES    87
#define QSDFO    88
#define QPHRMT   89
#define QPHRMR   90
#define QSCSDF   91
#define QCRIND   92
#define QDCKFI   93
#define QDCKSL   94
#define QDCKOUT  95
#define QQSAR    96
#define QQSARO   97
#define QQSARB   98
#define QQSARP   99
#define QQSARMN 100
#define QQSARMX 101
#define QQSARVW 102
#define QQSAREL 103
#define QEDIT   104

#define NBUTSS  16

#define SMETH   0
#define SCLOS   1
#define SSUBM   2
#define STASK   3
#define SBASS   4
#define SCHAR   5
#define SSPIN   6
#define SMOLD   7
#define SDIRE   8
#define SBATC   9
#define SHESS  10
#define SREST  11
#define SQUEU  12
#define SZMAT  13
#define SWXYZ  14
#define SONI   15

#define NBUTCP  2
#define NBUTCT  4
#define BCPAPP  0
#define BCPCAN  1

#define NCLBUT  5
#define BMONI   0
#define BCLR    1
#define BCLOSE  2
#define BCNTCT  3
#define BCONN   4

static BSTRU dbut[NBUTTS];
static BSTRU cbut[NBUTTS2];
static BSTRU rbut[NBUTTR];
static BSTRU clbut[NCLBUT];
static BSTRU obut[2];
static BSTRU sbut[NBUTSS];
static BSTRU cpbut[NBUTCP];
static BSTRU ctbut[NBUTCT];
static FSELSTRU fsel;
static FSELSTRU gsel;
static FSELSTRU dsel;
static LISTSTRU flist;
static LISTSTRU dirlist;
static LISTSTRU frlist;
static LISTSTRU elist;
static LISTSTRU fftlist;
static LISTSTRU srchlist;
static LISTSTRU pmflistmx;
static LISTSTRU pmflistmn;
static LISTSTRU flxlist;
static LISTSTRU strlist;
static LISTSTRU str2list;
static LISTSTRU strclist;
static LISTSTRU FILElist;
static QBOXSTRU qboxes[NQBOX];

static int *Sinct;
static int *Sincp;

#define MAXFILELEN 1024
#define NFLS 13
static int    lpnt = 0;
static int    selfil = 0;
static int    firstreadf = 1;
static int    nfilesstart = 0;
static char   firstfile[MAXFILELEN];
static char   *pdbcode = NULL;
static char   *pdbcbck = NULL;
#define DIRX 35
#define DIRY 40
#define DIRW 255
#define DIRH 200

#define NDRS 4
static int    seldir = 0;
#define DDIRX 35
#define DDIRY 250
#define DDIRW 255
#define DDIRH 76
static int Fwinopt = BREP;

#define BOFFX 14

#define PLOFFX 0
#define PLOFFY 0
#define MSOFFX 0
#define MSOFFY 219
#define SPOFFX 0
#define SPOFFY 342
#define PMOFFX 139
#define PMOFFY 0
#define D3OFFX 139
#define D3OFFY 94
#define CNOFFX 139
#define CNOFFY 219
#define BSOFFX 139
#define BSOFFY 293
#define QOFFX 139
#define QOFFY 367
#define S2OFFX 5
#define S2OFFY 403

#define POFFX 0
#define POFFY 0
#define MOFFX 0
#define MOFFY 100
#define DMOFFX 0
#define DMOFFY 224

#define MIOFFX 107
#define MIOFFY 0
#define MICONY 5
#define SOFFX 5
#define SOFFY 412

#define FOFFX 141
#define FOFFY 0
#define CLOFFX 141
#define CLOFFY 145
#define CVOFFX 141
#define CVOFFY 240
#define XOFFX 107
#define XOFFY 314

#define WINMCWIDE  248
#define WINMCHIGH  445
#define DEFWINMCGEOM "-130+80"
static int DowinC = 1;
static int DowinMC = 1;
static int DoactC = 1;
static int DoactMC = 1;
static Bool DEBUG = 0;

#define BUTTW   60
#define BUTTH   19
#define BUTTN   24
#define TOGGWH  19

static int dogif = 0;
static int picnum = 0;
static int *picmax;
static char *GifFile = "mol";
 
static Pixmap grayStip; 
static unsigned int  dispDEEP;

float rama_area1[16][2] = {
	{-177.5f,-180.0f},
	{-177.5f,-177.5f},
	{-172.5f,-177.5f},
	{-172.5f,-172.5f},
	{-167.5f,-172.5f},
	{-167.5f,-167.5f},
	{-127.5f,-167.5f},
	{-127.5f,-172.5f},
	{-97.5f,-172.5f},
	{-97.5f,-167.5f},
	{-77.5f,-167.5f},
	{-77.5f,-172.5f},
	{-72.5f,-172.5f},
	{-72.5f,-177.5f},
	{-67.5f,-177.5f},
	{-67.5f,-180.0f},
};

float rama_area2[25][2] = {
	{57.5f,67.5f},
	{57.5f,62.5f},
	{62.5f,62.5f},
	{62.5f,57.5f},
	{67.5f,57.5f},
	{67.5f,47.5f},
	{72.5f,47.5f},
	{72.5f,32.5f},
	{77.5f,32.5f},
	{77.5f,2.5f},
	{62.5f,2.5f},
	{62.5f,7.5f},
	{57.5f,7.5f},
	{57.5f,12.5f},
	{52.5f,12.5f},
	{52.5f,22.5f},
	{47.5f,22.5f},
	{47.5f,27.5f},
	{42.5f,27.5f},
	{42.5f,37.5f},
	{37.5f,37.5f},
	{37.5f,62.5f},
	{42.5f,62.5f},
	{42.5f,67.5f},
	{57.5f,67.5f}
};

float rama_area3[108][2] = {
	{-62.5f,180.0f},
	{-62.5f,172.5f},
	{-57.5f,172.5f},
	{-57.5f,167.5f},
	{-52.5f,167.5f},
	{-52.5f,157.5f},
	{-47.5f,157.5f},
	{-47.5f,147.5f},
	{-42.5f,147.5f},
	{-42.5f,137.5f},
	{-37.5f,137.5f},
	{-37.5f,122.5f},
	{-42.5f,122.5f},
	{-42.5f,117.5f},
	{-47.5f,117.5f},
	{-47.5f,112.5f},
	{-57.5f,112.5f},
	{-57.5f,107.5f},
	{-62.5f,107.5f},
	{-62.5f,102.5f},
	{-67.5f,102.5f},
	{-67.5f,97.5f},
	{-72.5f,97.5f},
	{-72.5f,62.5f},
	{-77.5f,62.5f},
	{-77.5f,52.5f},
	{-87.5f,52.5f},
	{-87.5f,47.5f},
	{-92.5f,47.5f},
	{-92.5f,52.5f},
	{-97.5f,52.5f},
	{-97.5f,67.5f},
	{-102.5f,67.5f},
	{-102.5f,77.5f},
	{-107.5f,77.5f},
	{-107.5f,82.5f},
	{-112.5f,82.5f},
	{-112.5f,72.5f},
	{-117.5f,72.5f},
	{-117.5f,62.5f},
	{-122.5f,62.5f},
	{-122.5f,52.5f},
	{-127.5f,52.5f},
	{-127.5f,47.5f},
	{-112.5f,47.5f},
	{-112.5f,42.5f},
	{-102.5f,42.5f},
	{-102.5f,37.5f},
	{-92.5f,37.5f},
	{-92.5f,32.5f},
	{-87.5f,32.5f},
	{-87.5f,22.5f},
	{-82.5f,22.5f},
	{-82.5f,17.5f},
	{-77.5f,17.5f},
	{-77.5f,12.5f},
	{-67.5f,12.5f},
	{-67.5f,7.5f},
	{-62.5f,7.5f},
	{-62.5f,2.5f},
	{-57.5f,2.5f},
	{-57.5f,-7.5f},
	{-52.5f,-7.5f},
	{-52.5f,-12.5f},
	{-47.5f,-12.5f},
	{-47.5f,-22.5f},
	{-42.5f,-22.5f},
	{-42.5f,-32.5f},
	{-37.5f,-32.5f},
	{-37.5f,-62.5f},
	{-42.5f,-62.5f},
	{-42.5f,-67.5f},
	{-77.5f,-67.5f},
	{-77.5f,-62.5f},
	{-117.5f,-62.5f},
	{-117.5f,-57.5f},
	{-122.5f,-57.5f},
	{-122.5f,-47.5f},
	{-127.5f,-47.5f},
	{-127.5f,-37.5f},
	{-132.5f,-37.5f},
	{-132.5f,-17.5f},
	{-137.5f,-17.5f},
	{-137.5f,2.5f},
	{-142.5f,2.5f},
	{-142.5f,32.5f},
	{-137.5f,32.5f},
	{-137.5f,52.5f},
	{-142.5f,52.5f},
	{-142.5f,57.5f},
	{-147.5f,57.5f},
	{-147.5f,67.5f},
	{-152.5f,67.5f},
	{-152.5f,77.5f},
	{-147.5f,77.5f},
	{-147.5f,87.5f},
	{-152.5f,87.5f},
	{-152.5f,97.5f},
	{-157.5f,97.5f},
	{-157.5f,112.5f},
	{-162.5f,112.5f},
	{-162.5f,122.5f},
	{-167.5f,122.5f},
	{-167.5f,132.5f},
	{-172.5f,132.5f},
	{-172.5f,142.5f},
	{-180.0f,142.5f},
	{-180.0f,180.0f}
};

float rama_area4[108][2] = {
	{-42.5f,180.0f},
	{-42.5f,172.5f},
	{-42.5f,172.5f},
	{-37.5f,172.5f},
	{-37.5f,167.5f},
	{-32.5f,167.5f},
	{-32.5f,157.5f},
	{-27.5f,157.5f},
	{-27.5f,147.5f},
	{-22.5f,147.5f},
	{-22.5f,127.5f},
	{-17.5f,127.5f},
	{-17.5f,112.5f},
	{-22.5f,112.5f},
	{-22.5f,107.5f},
	{-27.5f,107.5f},
	{-27.5f,102.5f},
	{-32.5f,102.5f},
	{-32.5f,97.5f},
	{-47.5f,97.5f},
	{-47.5f,92.5f},
	{-52.5f,92.5f},
	{-52.5f,72.5f},
	{-57.5f,72.5f},
	{-57.5f,42.5f},
	{-62.5f,42.5f},
	{-62.5f,27.5f},
	{-57.5f,27.5f},
	{-57.5f,22.5f},
	{-52.5f,22.5f},
	{-52.5f,12.5f},
	{-47.5f,12.5f},
	{-47.5f,7.5f},
	{-42.5f,7.5f},
	{-42.5f,2.5f},
	{-37.5f,2.5f},
	{-37.5f,-7.5f},
	{-32.5f,-7.5f},
	{-32.5f,-12.5f},
	{-27.5f,-12.5f},
	{-27.5f,-27.5f},
	{-22.5f,-27.5f},
	{-22.5f,-47.5f},
	{-17.5f,-47.5f},
	{-17.5f,-67.5f},
	{-22.5f,-67.5f},
	{-22.5f,-77.5f},
	{-27.5f,-77.5f},
	{-27.5f,-82.5f},
	{-47.5f,-82.5f},
	{-47.5f,-87.5f},
	{-77.5f,-87.5f},
	{-77.5f,-92.5f},
	{-87.5f,-92.5f},
	{-87.5f,-112.5f},
	{-92.5f,-112.5f},
	{-92.5f,-122.5f},
	{-97.5f,-122.5f},
	{-97.5f,-137.5f},
	{-92.5f,-137.5f},
	{-92.5f,-142.5f},
	{-82.5f,-142.5f},
	{-82.5f,-147.5f},
	{-72.5f,-147.5f},
	{-72.5f,-152.5f},
	{-67.5f,-152.5f},
	{-67.5f,-157.5f},
	{-62.5f,-157.5f},
	{-62.5f,-162.5f},
	{-57.5f,-162.5f},
	{-57.5f,-167.5f},
	{-52.5f,-167.5f},
	{-52.5f,-172.5f},
	{-47.5f,-172.5f},
	{-47.5f,-177.5f},
	{-42.5f,-177.5f},
	{-42.5f,-180.0f},
	{-180.0f,-180.0f},
	{-180.0f,-147.5f},
	{-177.5f,-147.5f},
	{-167.5f,-147.5f},
	{-167.5f,-142.5f},
	{-157.5f,-142.5f},
	{-157.5f,-137.5f},
	{-147.5f,-137.5f},
	{-147.5f,-132.5f},
	{-142.5f,-132.5f},
	{-142.5f,-127.5f},
	{-147.5f,-127.5f},
	{-147.5f,-97.5f},
	{-152.5f,-97.5f},
	{-152.5f,-92.5f},
	{-157.5f,-92.5f},
	{-157.5f,-82.5f},
	{-162.5f,-82.5f},
	{-162.5f,-52.5f},
	{-157.5f,-52.5f},
	{-157.5f,-37.5f},
	{-162.5f,-37.5f},
	{-162.5f,-7.5f},
	{-167.5f,-7.5f},
	{-167.5f,32.5f},
	{-172.5f,32.5f},
	{-172.5f,52.5f},
	{-177.5f,52.5f},
	{-177.5f,77.5f},
	{-180.0f,77.5f},
	{-180.0f,180.0f}
};

float rama_area5[67][2] = {
	{82.5f,57.5f},
	{87.5f,57.5f},
	{87.5f,42.5f},
	{92.5f,42.5f},
	{92.5f,22.5f},
	{97.5f,22.5f},
	{97.5f,-17.5f},
	{92.5f,-17.5f},
	{92.5f,-22.5f},
	{87.5f,-22.5f},
	{87.5f,-27.5f},
	{82.5f,-27.5f},
	{82.5f,-37.5f},
	{87.5f,-37.5f},
	{87.5f,-47.5f},
	{92.5f,-47.5f},
	{92.5f,-57.5f},
	{87.5f,-57.5f},
	{87.5f,-67.5f},
	{82.5f,-67.5f},
	{82.5f,-72.5f},
	{77.5f,-72.5f},
	{77.5f,-77.5f},
	{62.5f,-77.5f},
	{62.5f,-72.5f},
	{57.5f,-72.5f},
	{57.5f,-67.5f},
	{52.5f,-67.5f},
	{52.5f,-37.5f},
	{57.5f,-37.5f},
	{57.5f,-27.5f},
	{62.5f,-27.5f},
	{62.5f,-22.5f},
	{57.5f,-22.5f},
	{57.5f,-12.5f},
	{52.5f,-12.5f},
	{52.5f,-7.5f},
	{47.5f,-7.5f},
	{47.5f,-2.5f},
	{42.5f,-2.5f},
	{42.5f,2.5f},
	{37.5f,2.5f},
	{37.5f,12.5f},
	{32.5f,12.5f},
	{32.5f,22.5f},
	{27.5f,22.5f},
	{27.5f,32.5f},
	{22.5f,32.5f},
	{22.5f,47.5f},
	{17.5f,47.5f},
	{17.5f,67.5f},
	{22.5f,67.5f},
	{22.5f,77.5f},
	{27.5f,77.5f},
	{27.5f,82.5f},
	{32.5f,82.5f},
	{32.5f,87.5f},
	{47.5f,87.5f},
	{47.5f,92.5f},
	{67.5f,92.5f},
	{67.5f,87.5f},
	{72.5f,87.5f},
	{72.5f,82.5f},
	{77.5f,82.5f},
	{77.5f,77.5f},
	{82.5f,77.5f},
	{82.5f,57.5f},
};

float rama_area6[10][2] = {
	{77.5f,180.0f},
	{77.5f,162.5f},
	{82.5f,162.5f},
	{82.5f,147.5f},
	{72.5f,147.5f},
	{72.5f,157.5f},
	{67.5f,157.5f},
	{67.5f,167.5f},
	{62.5f,167.5f},
	{62.5f,180.0f} 
};

float rama_area7[28][2] = {
	{57.5f,-180.0f},
	{57.5f,-167.5f},
	{52.5f,-167.5f},
	{52.5f,-162.5f},
	{47.5f,-162.5f},
	{47.5f,-157.5f},
	{42.5f,-157.5f},
	{42.5f,-152.5f},
	{37.5f,-152.5f},
	{37.5f,-142.5f},
	{32.5f,-142.5f},
	{32.5f,-107.5f},
	{37.5f,-107.5f},
	{37.5f,-102.5f},
	{42.5f,-102.5f},
	{42.5f,-97.5f},
	{52.5f,-97.5f},
	{52.5f,-92.5f},
	{62.5f,-92.5f},
	{62.5f,-97.5f},
	{67.5f,-97.5f},
	{67.5f,-102.5f},
	{72.5f,-102.5f},
	{72.5f,-112.5f},
	{77.5f,-112.5f},
	{77.5f,-157.5f},
	{72.5f,-157.5f},
	{72.5f,-180.0f}
};

float rama_area8[10][2] = {
	{162.5f,180.0f},
	{162.5f,147.5f},
	{167.5f,147.5f},
	{167.5f,132.5f},
	{172.5f,132.5f},
	{172.5f,117.5f},
	{177.5f,117.5f},
	{177.5f,77.5f},
	{180.0f,77.5f},
	{180.0f,180.0f}
};

float rama_area9[10][2] = {
	{162.5f,-180.0f},
	{162.5f,-177.5f},
	{167.5f,-177.5f},
	{167.5f,-167.5f},
	{172.5f,-167.5f},
	{172.5f,-157.5f},
	{177.5f,-157.5f},
	{177.5f,-147.5f},
	{180.0f,-147.5f},
	{180.0f,-180.0f}
};

static Atom atom_DELWIN = 0;
static Atom atom_PROTOCOLS = 0;

void StoreDeleteWindowProp (win)
     Window win;
{
  if (! atom_DELWIN)
    atom_DELWIN = XInternAtom (display, "WM_DELETE_WINDOW", False);

  if (! atom_PROTOCOLS)
    atom_PROTOCOLS = XInternAtom (display, "WM_PROTOCOLS", False);

  if (atom_PROTOCOLS == None) return;

  XChangeProperty(display, win, atom_PROTOCOLS, XA_ATOM, 32,
                  PropModeReplace, (unsigned char *) &atom_DELWIN, 1);
}

int X_Error_Message_CB (Display *display, XErrorEvent *err)
{
   char msg[80];
   XGetErrorText(display, err->error_code, msg, 80);
   printf("X error code %s\n", msg);


/*
   Timer(10000000,0);
*/


/* you can Control-C here in the debugger, when the time is activated */
   return 0;
}

Window CreateWindow(xname,geom,w,h,fg,bg,Parwin)
char         *xname, *geom;
unsigned int  w,h;
unsigned long fg, bg;
Window Parwin;
{
  Window               hwin;
  XSetWindowAttributes hxswa;
  unsigned int         xswamask;
  XWMHints             xwmh;
  XSizeHints           hints;
  int                  i,x,y;

  if (DEBUG) fprintf(stderr,"CreateWindow in\n");

  if (Parwin) {
	xswamask = CWBackPixel | CWBorderPixel | CWBackingStore | CWBackingPlanes;
	hxswa.background_pixel = bg;
	hxswa.border_pixel     = fg;
	hxswa.save_under       = False;
	hxswa.backing_store    = NotUseful;
	hxswa.backing_planes   = 0;

	x = 0; y = 0;

	if (has_opengl) {
	   hwin = XCreateWindow(display, Parwin, x, y, w, h, 
			2, vi->depth, InputOutput,
			vi->visual, xswamask, &hxswa);
	} else {
	   hwin = XCreateWindow(display, Parwin, x, y, w, h, 
			2, CopyFromParent, InputOutput,
			CopyFromParent, xswamask, &hxswa);
	}
	if (!hwin) return(hwin);   /* leave immediately if couldn't create */

	XSelectInput(display, hwin, ExposureMask | VisibilityChangeMask | EnterWindowMask);
	XSetTransientForHint(display, hwin, Parwin);
  }
  else {
  /* note that only x,y are gotten from geom spec.  w,h are fixed */
	x = y = 1;
	i = XParseGeometry(geom,&x,&y,&w,&h);

	if (i&XValue || i&YValue) hints.flags = USPosition;  
                       else hints.flags = PPosition;

	hints.flags |= USSize;

	if (i&XValue && i&XNegative)
	  x = DisplayWidth(display,screen) - w - abs(x);
	if (i&YValue && i&YNegative)
	  y = DisplayHeight(display,screen) - h - abs(y);

	hints.x = x;                  hints.y = y;
	hints.width = w;              hints.height = h;
	hints.min_width  = w;         hints.min_height = h;
	hints.max_width  = w;         hints.max_height = h;
	hints.flags |= PMaxSize | PMinSize;
	xswa.background_pixel = bg;
	xswa.border_pixel     = fg;
	hxswa.background_pixel = bg;
	hxswa.border_pixel     = fg;
	hxswa.backing_store    = NotUseful;
	hxswa.backing_planes   = 0;

	if (has_opengl) {
	    hwin = XCreateWindow(display, RootWindow(display,vi->screen), 
			x, y, w, h, 2, vi->depth, InputOutput,
			vi->visual, 
			(CWBorderPixel | CWBackPixel | CWColormap | CWEventMask | CWBackingStore | CWBackingPlanes), &xswa);
	} else {
	    hwin = XCreateWindow(display, RootWindow(display,screen), 
			x, y, w, h, 2, CopyFromParent, CopyFromParent,
			CopyFromParent, 
			(CWBorderPixel | CWBackPixel | CWBackingStore | CWBackingPlanes), &hxswa);
	}
	if (!hwin) return(hwin);   /* leave immediately if couldn't create */

	XSetStandardProperties(display, hwin, xname, xname, None, NULL, 0, &hints);

	xwmh.input = True;
	xwmh.flags = InputHint;
	XSetWMHints(display, hwin, &xwmh);

	StoreDeleteWindowProp(hwin);

  }

  if (setcmap) XSetWindowColormap(display,hwin,cmap);

  if (DEBUG) fprintf(stderr,"CreateWindow out\n");
  return(hwin);
}

#define PI   3.14159265358979323846

double lorentz(double rel_offset) {
  return 1.0 / (1.0 + rel_offset * rel_offset);
}

double gauss(double rel_offset) {
  const double nln2 = -log(2.0);
  return exp(nln2 * rel_offset * rel_offset);
}

static double Tsin[361],Tcos[361];

void SetupTable()
{
  int alpha;

  for ( alpha=0; alpha < 361; alpha++ ) {
	Tsin[alpha] = sin((PI*alpha)/180.0);
	Tcos[alpha] = cos((PI*alpha)/180.0);
  }
}

void Get_Tsin(int dg, double *sina, double *cosa)
{
   int deg;

   if (dg >= 0) {
	*sina = Tsin[dg]; *cosa = Tcos[dg];
   } else {
        deg = dg + 360;
	*sina = Tsin[deg]; *cosa = Tcos[deg];
   }
}
   
void Get_FTsin(int dg, float *sina, float *cosa)
{
   int deg;

   if (dg >= 0) {
	*sina = (float) Tsin[dg]; *cosa = (float) Tcos[dg];
   } else {
        deg = dg + 360;
	*sina = (float) Tsin[deg]; *cosa = (float) Tcos[deg];
   }
}
   
void rotat(currx,curry)
int currx;
int curry;
{
    float tangy,rsqx,rsqy;

    hold = 1;
    holdt = 0;
    holdp = 0;
    rsqx = (int) (width / 2 - currx);
    rsqy = (int) (height / 2 - curry);
    if (rsqx*rsqx+rsqy*rsqy < 3000) {
	holdt = -1; holdp = 1;
	if ((event.xbutton.state & ControlMask) ||
	    (event.xbutton.state & ShiftMask)) holdp = -1;
	return;
    }
    if (rsqx == 0 && rsqy == 0){ hold = 0; return;}
    if (rsqx == 0) { 
	holdt = -2;
	if (rsqy > 0) holdp = -1;
	if (rsqy < 0) holdp =  1;
	return;
    }
    if (rsqy == 0) { 
	holdt = -3;
	if (rsqx > 0) holdp =  1;
	if (rsqx < 0) holdp = -1;
	return;
     }
     tangy = rsqy / rsqx;
     if (rsqx > 0) {
	if (tangy <= 1 && tangy >= -1) {
	    holdt = -3; holdp = -1;
	}
	else if (tangy > 1) {
	    holdt = -2; holdp = 1;
	}
	else { 
	    holdt = -2; holdp = -1;
	}
     } else if (rsqx < 0) {
	if (tangy <= 1 && tangy >= -1) {
	    holdt = -3; holdp = 1;
	}
	else if (tangy > 1) {
	    holdt = -2; holdp = -1;
	}
	else { 
	    holdt = -2; holdp = 1;
	}
     }
}

char *DOSpath(UNIXpath)
char *UNIXpath;
{
  char dospath[MAXDIRLEN] = "";
  char *pathptr;
  int i,n;

  if (strstr(UNIXpath,"/cygdrive/")) {
	pathptr = strstr(UNIXpath,"/cygdrive/");
	strcpy(dospath,"");
	strncpy(dospath,pathptr+10,1);
	strcat(dospath,":");
	strcat(dospath,pathptr+11);
	n = strlen(dospath);
	for (i=0; i<n; i++)
	   if (dospath[i] == '/') dospath[i] = '\\';
	strcpy(UNIXpath,dospath);
/*        fprintf(stderr,"DOSPath %s\n",dospath);*/
  }
  return UNIXpath;
}

int IsBinary(strname)
char *strname;
{
   char line[MAXCMD+1];
   int i,j,il,ret,jmin,jmax,nbin,ncr;
   FILE *f;
   struct stat st_record;

   stat(strname, &st_record);
   if (st_record.st_size <= 1) {
	fprintf(stderr,"Empty file !\n");
	return(0);
   }

   f = fopen(strname,"r");
   fgets(line,MAXCMD,f);
   il = strlen(line);
   if (il > 0) line[il-1] = '\0';
   fclose(f);

   ret = 0;
   jmax = 0;
   jmin = 256;
   nbin = 0;
   ncr = 0;

   for (i = 0; i < strlen(line); i++) {
	j = (int) line[i];
	if (j > jmax && j != 9 && j != 27) jmax = j;
	if (j < jmin && j != 9 && j != 27) jmin = j;
	if (j > 126 || j < 32) nbin++;
	if (j == 13) ncr++;
   }

   if ( jmax > 126 || jmin < 32) {
	if (ncr != nbin) ret = 1;
   }

   return(ret);
}

void lViewer(ogfil)
char *ogfil;
{
    int pid;

#ifdef DARWIN
    pid = fork();
#else
    pid = vfork();
#endif
    switch(pid) {
    case -1:
          fprintf(stderr,"Couldnt Fork\n");
          break;
    case 0:       /*child */
#ifdef __CYGWIN__
	  if (access("./mogl",F_OK) == 0) {
             execlp("./mogl","mogl",DOSpath(ogfil),NULL);
	  } else {
	     sprintf(cmdstr,"mogl \"%s\"",DOSpath(ogfil));
	     system(cmdstr);
	  }
#else
          execlp("moldenogl","moldenogl",ogfil,NULL);
#endif
	  _exit(0);
          break;
    default:      /*parent*/
          break;
    }
}

void excmd(str,spid)
char *str;
int *spid;
{
    int pid;

#ifdef DARWIN
    *spid = fork();
#else
    *spid = vfork();
#endif

    switch(*spid) {
    case -1:
          fprintf(stderr,"Couldnt Fork\n");
          break;
    case 0:       /*child */
	  system(str);
	  _exit(0);
          break;
    default:      /*parent*/
          break;
    }
}

#ifdef GCC_FORTRAN_H

extern int _gfortran_iargc(void);

#if defined(VMS) || defined(UNDERSC)
int iargc()
#else
#ifdef CRAY
int IARGC()
#else
int iargc_()
#endif
#endif
{
   return _gfortran_iargc();
}

#endif

#if defined(VMS) || defined(UNDERSC)
void tounx()
#else
#ifdef CRAY
void TOUNX()
#else
void tounx_()
#endif
#endif
{
   if (xison) {
    if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
	"Molden cant handle DOS files very well.\n Convert file to Unix format ?",1)) {
	dos2u(strname);
    }
   } else {
	dos2u(strname);
   }
}

int izz(i,j)
int i;
int j;
{
 int result;

 result = *(zmptrp->iz + (i*4) + j);

 return(result);

}

int *pizz(i,j)
int i;
int j;
{
 int *result;

 result = (zmptrp->iz + (i*4) + j);

 return(result);

}

int fndchr(line,chr)
char *line;
char chr;
{
   int n,i;

   n = strlen(line);
   for (i=0; i<n; i++)
	if (line[i] == chr) return(i);

   return(0);
}

/* shadow C routines for Fortran routines to pass Z-matrix pointers */

#if defined(VMS) || defined(UNDERSC)
void plinzz(isel,istat)
#else
#ifdef CRAY
void PLINZZ(isel,istat)
#else
void plinzz_(isel,istat)
#endif
#endif
int *isel;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
   plinz(isel,istat,
#else
#ifdef CRAY
   PLINZ(isel,istat,
#else
   plinz_(isel,istat,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	xyzp->lwrit,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void dumlin(isel,blv,alphv,betv)
#else
#ifdef CRAY
void DUMLIN(isel,blv,alphv,betv)
#else
void dumlin_(isel,blv,alphv,betv)
#endif
#endif
int *isel;
double *blv;
double *alphv;
double *betv;
{

#if defined(VMS) || defined(UNDERSC)
	dumliz(isel,blv,alphv,betv,
#else
#ifdef CRAY
	DUMLIZ(isel,blv,alphv,betv,
#else
	dumliz_(isel,blv,alphv,betv,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	xyzp->lwrit,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void wline(iun,iopt,igamb)
#else
#ifdef CRAY
void WLINE(iun,iopt,igamb)
#else
void wline_(iun,iopt,igamb)
#endif
#endif
int *iun;
int *iopt;
int *igamb;
{

#if defined(VMS) || defined(UNDERSC)
	wlinz(iun,iopt,igamb,
#else
#ifdef CRAY
	WLINZ(iun,iopt,igamb,
#else
	wlinz_(iun,iopt,igamb,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	xyzp->iconn,xyzp->ianz,xyzp->ityp,xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void wrzmat(iun,iopt)
#else
#ifdef CRAY
void WRZMAT(iun,iopt)
#else
void wrzmat_(iun,iopt)
#endif
#endif
int *iun;
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	wrzmaz(iun,iopt,
#else
#ifdef CRAY
	WRZMAZ(iun,iopt,
#else
	wrzmaz_(iun,iopt,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	geop->epoints,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void mapxzz(iun,imod,iff,izmtmp,istat)
#else
#ifdef CRAY
void MAPXZZ(iun,imod,iff,izmtmp,istat)
#else
void mapxzz_(iun,imod,iff,izmtmp,istat)
#endif
#endif
int *iun;
int *imod;
int *iff;
int *izmtmp;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	mapzzz(iun,imod,iff,izmtmp,istat,
#else
#ifdef CRAY
	MAPZZZ(iun,imod,iff,izmtmp,istat,
#else
	mapzzz_(iun,imod,iff,izmtmp,istat,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void fndmaz(ixyz,istat)
#else
#ifdef CRAY
void FNDMAZ(ixyz,istat)
#else
void fndmaz_(ixyz,istat)
#endif
#endif
int *ixyz;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	fndmzz(ixyz,istat,zmptrp->imap);
#else
#ifdef CRAY
	FNDMZZ(ixyz,istat,zmptrp->imap);
#else
	fndmzz_(ixyz,istat,zmptrp->imap);
#endif
#endif

}

#if defined(VMS) || defined(UNDERSC)
void chkmaz(istat)
#else
#ifdef CRAY
void CHKMAZ(istat)
#else
void chkmaz_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	chkmzz(istat,
#else
#ifdef CRAY
	CHKMZZ(istat,
#else
	chkmzz_(istat,
#endif
#endif
	xyzp->qat,xyzp->rzp,zmptrp->ianz,zmptrp->imap,
	xyzp->ianz,xyzp->lring,xyzp->ityp,xyzp->ipdbt);

}

#if defined(VMS) || defined(UNDERSC)
void prtzm()
#else
#ifdef CRAY
void PRTZM()
#else
void prtzm_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	prtzz(
#else
#ifdef CRAY
	PRTZZ(
#else
	prtzz_(
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz);

}

#if defined(VMS) || defined(UNDERSC)
void getzmz(istat)
#else
#ifdef CRAY
void GETZMZ(istat)
#else
void getzmz_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getzzz(istat,
#else
#ifdef CRAY
	GETZZZ(istat,
#else
	getzzz_(istat,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz);

}

#if defined(VMS) || defined(UNDERSC)
void dumzm(cc,ianc,nnatoms)
#else
#ifdef CRAY
void DUMZM(cc,ianc,nnatoms)
#else
void dumzm_(cc,ianc,nnatoms)
#endif
#endif
double *cc;
int *ianc;
int *nnatoms;
{
	int part;

	part = zmpart->ipart;

#if defined(VMS) || defined(UNDERSC)
	dumzz(cc,ianc,nnatoms,
#else
#ifdef CRAY
	DUMZZ(cc,ianc,nnatoms,
#else
	dumzz_(cc,ianc,nnatoms,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet, zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	stocp->cstoc,stocp->czstoc,stocp->astoc,stocp->bstoc,stocp->ianstc,
	xyzp->coo,xyzp->iresid,&calfptr->issdon);

}

#if defined(VMS) || defined(UNDERSC)
void convzmat(cc,ianc,nnatoms,igo,ico,ido)
#else
#ifdef CRAY
void CONVZMAT(cc,ianc,nnatoms,igo,ico,ido)
#else
void convzmat_(cc,ianc,nnatoms,igo,ico,ido)
#endif
#endif
double *cc;
int *ianc;
int *nnatoms;
int *igo;
int *ico;
int *ido;
{

#if defined(VMS) || defined(UNDERSC)
	convzmzz(cc,ianc,nnatoms,igo,ico,ido,
#else
#ifdef CRAY
	CONVZMZZ(cc,ianc,nnatoms,igo,ico,ido,
#else
	convzmzz_(cc,ianc,nnatoms,igo,ico,ido,
#endif
#endif
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	stocp->cstoc,stocp->czstoc,stocp->astoc,stocp->bstoc,stocp->ianstc);

}

#if defined(VMS) || defined(UNDERSC)
void getmop(nnatoms,heat,igo,ico,istat)
#else
#ifdef CRAY
void GETMOP(nnatoms,heat,igo,ico,istat)
#else
void getmop_(nnatoms,heat,igo,ico,istat)
#endif
#endif
int *nnatoms;
int *igo;
int *ico;
double *heat;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getmdp(nnatoms,heat,igo,ico,istat,
#else
#ifdef CRAY
	GETMDP(nnatoms,heat,igo,ico,istat,
#else
	getmdp_(nnatoms,heat,igo,ico,istat,
#endif
#endif
        xyzp->coo,xyzp->ianz,
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	stocp->cstoc,stocp->czstoc,stocp->astoc,stocp->bstoc,stocp->ianstc);

}

#if defined(VMS) || defined(UNDERSC)
void getzm(nnatoms,igo,ico,istat)
#else
#ifdef CRAY
void GETZM(nnatoms,igo,ico,istat)
#else
void getzm_(nnatoms,igo,ico,istat)
#endif
#endif
int *nnatoms;
int *igo;
int *ico;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getzd(nnatoms,igo,ico,istat,
#else
#ifdef CRAY
	GETZD(nnatoms,igo,ico,istat,
#else
	getzd_(nnatoms,igo,ico,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,
	zmptrp->bl,zmptrp->alph,zmptrp->bet,zmptrp->ibl,zmptrp->ialph,
	zmptrp->ibet,zmptrp->imap,zmptrp->ianz,zmptrp->iz,
	stocp->cstoc,stocp->czstoc,stocp->astoc,stocp->bstoc,stocp->ianstc);

}

/* END shadow C routines for Fortran routines to pass Z-matrix pointers */

/* shadow C routines for Fortran routines to pass orbital pointers */

#if defined(VMS) || defined(UNDERSC)
void adffun(x,y,z,psi)
#else
#ifdef CRAY
void ADFFUN(x,y,z,psi)
#else
void adffun_(x,y,z,psi)
#endif
#endif
double *x;
double *y;
double *z;
double *psi;
{

#if defined(VMS) || defined(UNDERSC)
	adffud(x,y,z,psi,
#else
#ifdef CRAY
	ADFFUD(x,y,z,psi,
#else
	adffud_(x,y,z,psi,
#endif
#endif
	dorbp->stoalfa,dorbp->stobnorm,dorbp->istos,dorbp->naorbs);

}

#if defined(VMS) || defined(UNDERSC)
void atdd(imo,ipsi,iao)
#else
#ifdef CRAY
void ATDD(imo,ipsi,iao)
#else
void atdd_(imo,ipsi,iao)
#endif
#endif
int *imo;
int *ipsi;
int *iao;
{

#if defined(VMS) || defined(UNDERSC)
	addd(imo,ipsi,iao,
#else
#ifdef CRAY
	ADDD(imo,ipsi,iao,
#else
	addd_(imo,ipsi,iao,
#endif
#endif
	dorbp->p,dorbp->paa,orbp->pd);

}

#if defined(VMS) || defined(UNDERSC)
void denmad(ido)
#else
#ifdef CRAY
void DENMAD(ido)
#else
void denmad_(ido)
#endif
#endif
int *ido;
{

#if defined(VMS) || defined(UNDERSC)
	denmdd(ido,
#else
#ifdef CRAY
	DENMDD(ido,
#else
	denmdd_(ido,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->p,dorbp->paa,
	dorbp->averag,orbp->qd);

}

#if defined(VMS) || defined(UNDERSC)
void densmat(ido)
#else
#ifdef CRAY
void DENSMAT(ido)
#else
void densmat_(ido)
#endif
#endif
int *ido;
{

#if defined(VMS) || defined(UNDERSC)
	densmad(ido,
#else
#ifdef CRAY
	DENSMAD(ido,
#else
	densmad_(ido,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->p,dorbp->nocc);

}

#if defined(VMS) || defined(UNDERSC)
void densmto(ido)
#else
#ifdef CRAY
void DENSMTO(ido)
#else
void densmto_(ido)
#endif
#endif
int *ido;
{

#if defined(VMS) || defined(UNDERSC)
	densmtd(ido,
#else
#ifdef CRAY
	DENSMTD(ido,
#else
	densmtd_(ido,
#endif
#endif
	dorbp->vectrs,dorbp->focc,dorbp->p,dorbp->nocc);

}

#if defined(VMS) || defined(UNDERSC)
void espot(x,y,z,epot,idebug)
#else
#ifdef CRAY
void ESPOT(x,y,z,epot,idebug)
#else
void espot_(x,y,z,epot,idebug)
#endif
#endif
double *x;
double *y;
double *z;
double *epot;
int *idebug;
{

#if defined(VMS) || defined(UNDERSC)
	espod(x,y,z,epot,idebug,
#else
#ifdef CRAY
	ESPOD(x,y,z,epot,idebug,
#else
	espod_(x,y,z,epot,idebug,
#endif
#endif
	dorbp->p);

}

#if defined(VMS) || defined(UNDERSC)
void espgrd(npts1,npts2,npts3,idebug)
#else
#ifdef CRAY
void ESPGRD(npts1,npts2,npts3,idebug)
#else
void espgrd_(npts1,npts2,npts3,idebug)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *idebug;
{
   int ZSize,memstat;
   double d;

   ZSize = *sgrd.mx3d;
   memstat = 1;

   if (fsgrd.xden == NULL) {
       if ((fsgrd.xden = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) 
		== NULL) {
		memstat = 0;
       }
       if ((fsgrd.yden = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) 
		== NULL) {
		memstat = 0;
       }
       if ((fsgrd.zden = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) 
		== NULL) {
		memstat = 0;
       }
   }

#if defined(VMS) || defined(UNDERSC)
	espgrdd(npts1,npts2,npts3,idebug,
#else
#ifdef CRAY
	ESPGRDD(npts1,npts2,npts3,idebug,
#else
	espgrdd_(npts1,npts2,npts3,idebug,
#endif
#endif
	sgrd.denn,dorbp->p,fsgrd.xden,fsgrd.yden,fsgrd.zden);

}

#if defined(VMS) || defined(UNDERSC)
void newdenmak()
#else
#ifdef CRAY
void NEWDENMAK()
#else
void newdenmak_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	newdenmad(dorbp->p,orbp->qd);
#else
#ifdef CRAY
	NEWDENMAD(dorbp->p,orbp->qd);
#else
	newdenmad_(dorbp->p,orbp->qd);
#endif
#endif

}

#if defined(VMS) || defined(UNDERSC)
void calhes(psi,grd,hess,den,g,hes)
#else
#ifdef CRAY
void CALHES(psi,grd,hess,den,g,hes)
#else
void calhes_(psi,grd,hess,den,g,hes)
#endif
#endif
double *psi;
double *grd;
double *hess;
double *den;
double *g;
double *hes;
{

#if defined(VMS) || defined(UNDERSC)
	calhed(psi,grd,hess,den,g,hes,
#else
#ifdef CRAY
	CALHED(psi,grd,hess,den,g,hes,
#else
	calhed_(psi,grd,hess,den,g,hes,
#endif
#endif
	dorbp->p);

}

#if defined(VMS) || defined(UNDERSC)
void grdcal(dens,npts1,npts2,iprnt,space)
#else
#ifdef CRAY
void GRDCAL(dens,npts1,npts2,iprnt,space)
#else
void grdcal_(dens,npts1,npts2,iprnt,space)
#endif
#endif
double *dens;
int *npts1;
int *npts2;
int *iprnt;
int *space;
{

#if defined(VMS) || defined(UNDERSC)
	grdcad(dens,npts1,npts2,iprnt,space,
#else
#ifdef CRAY
	GRDCAD(dens,npts1,npts2,iprnt,space,
#else
	grdcad_(dens,npts1,npts2,iprnt,space,
#endif
#endif
	dorbp->p,dorbp->paa,orbp->pd,orbp->gd,orbp->hd,
	dorbp->phi,dorbp->dphi,dorbp->dxpsi,dorbp->dypsi,dorbp->dzpsi,
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb);

}

#if defined(VMS) || defined(UNDERSC)
void prtvec()
#else
#ifdef CRAY
void PRTVEC()
#else
void prtvec_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	prtved(
#else
#ifdef CRAY
	PRTVED(
#else
	prtved_(
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->eiga,dorbp->eigb,
	dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void stint()
#else
#ifdef CRAY
void STINT()
#else
void stint_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	stind(dorbp->p,xyzp->qat);
#else
#ifdef CRAY
	STIND(dorbp->p,xyzp->qat);
#else
	stind_(dorbp->p,xyzp->qat);
#endif
#endif

}

#if defined(VMS) || defined(UNDERSC)
void muldmd(vdwr,moddma,idm,idd)
#else
#ifdef CRAY
void MULDMD(vdwr,moddma,idm,idd)
#else
void muldmd_(vdwr,moddma,idm,idd)
#endif
#endif
double *vdwr;
int *moddma;
int *idm;
int *idd;
{

#if defined(VMS) || defined(UNDERSC)
	mulddd(vdwr,moddma,idm,idd,
#else
#ifdef CRAY
	MULDDD(vdwr,moddma,idm,idd,
#else
	mulddd_(vdwr,moddma,idm,idd,
#endif
#endif
	dorbp->p,xyzp->qat,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void dipole()
#else
#ifdef CRAY
void DIPOLE()
#else
void dipole_()
#endif
#endif
{
   int ZSize,ntt,i;
   double d;

   ZSize = *dorbp->mxorb;
   if ((dmao = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	fprintf(stderr,"Out of memory\n");
   }
   if ((nor = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	fprintf(stderr,"Out of memory\n");
   }

   ntt = NAT->norbs*(NAT->norbs+1)/2;


#if defined(VMS) || defined(UNDERSC)
	dipold(
#else
#ifdef CRAY
	DIPOLD(
#else
	dipold_(
#endif
#endif
	&ntt,nor,dmao,dorbp->focc,dorbp->focb,dorbp->vectrs,dorbp->vectrb,dorbp->p);

}

#if defined(VMS) || defined(UNDERSC)
void boys(norb,nor,dmao,vecs)
#else
#ifdef CRAY
void BOYS(norb,nor,dmao,vecs)
#else
void boys_(norb,nor,dmao,vecs)
#endif
#endif
int *norb;
int *nor;
double *dmao;
double *vecs;
{
   int i,ZSize,ntt,memstat,nbasis;
   double d;
   double *cl,*rij,*qpix,*qpjx;
   int *iord,*iir;

   memstat = 1;
   nbasis = NAT->norbs;
   ntt = nbasis*(nbasis+1)/2;

   boy.dmao = dmao;
   boy.nor = nor;

   if ((cl = (double *) malloc((sizeof d)*nbasis*nbasis)) == NULL) {
        memstat = 0;
	fprintf(stderr,"cl Out of memory\n");
   }
   boy.cl = cl;

   if ((rij = (double *) malloc((sizeof d)*ntt*3)) == NULL) {
        memstat = 0;
	fprintf(stderr,"rij Out of memory\n");
   }
   boy.rij = rij;

   if ((qpix = (double *) malloc((sizeof d)*nbasis)) == NULL) {
        memstat = 0;
	fprintf(stderr,"qpix Out of memory\n");
   }
   boy.qpix = qpix;

   if ((qpjx = (double *) malloc((sizeof d)*nbasis)) == NULL) {
        memstat = 0;
	fprintf(stderr,"qpjx Out of memory\n");
   }
   boy.qpjx = qpjx;

   if ((iord = (int *) malloc((sizeof i)*nbasis)) == NULL) {
        memstat = 0;
	fprintf(stderr,"iord Out of memory\n");
   }
   boy.iord = iord;

   if ((iir = (int *) malloc((sizeof i)*nbasis)) == NULL) {
        memstat = 0;
	fprintf(stderr,"irr Out of memory\n");
   }
   boy.iir = iir;

#if defined(VMS) || defined(UNDERSC)
	boyd(norb,nor,dmao,vecs,
#else
#ifdef CRAY
	BOYS(norb,nor,dmao,vecs,
#else
	boyd_(norb,nor,dmao,vecs,
#endif
#endif
	&nbasis,&ntt,cl,iord,iir,rij,qpix,qpjx);

}

#if defined(VMS) || defined(UNDERSC)
int mseed()
#else
#ifdef CRAY
int MSEED()
#else
int mseed_()
#endif
#endif
{
  return (int)(((long)time(NULL)+(long)getpid()) % (long)1000000);
}

#if defined(VMS) || defined(UNDERSC)
void mopin(istat,ibin,impas)
#else
#ifdef CRAY
void MOPIN(istat,ibin,impas)
#else
void mopin_(istat,ibin,impas)
#endif
#endif
int *istat;
int *ibin;
int *impas;
{

#if defined(VMS) || defined(UNDERSC)
	mopdd(istat,ibin,impas,
#else
#ifdef CRAY
	MOPDD(istat,ibin,impas,
#else
	mopdd_(istat,ibin,impas,
#endif
#endif
	dorbp->vectrs,dorbp->averag,dorbp->p,dorbp->focc,dorbp->eiga,
	orbp->qd,orbp->pd,dorbp->nocc,dorbp->ncols);

}


#if defined(VMS) || defined(UNDERSC)
void rdgad(idebug,ibefo,istatio,ioxyz,irtype,istats)
#else
#ifdef CRAY
void RDGAD(idebug,ibefo,istatio,ioxyz,irtype,istats)
#else
void rdgad_(idebug,ibefo,istatio,ioxyz,irtype,istats)
#endif
#endif
int *idebug;
int *ibefo;
int *istatio;
int *ioxyz;
int *irtype;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdgdd(idebug,ibefo,istatio,ioxyz,irtype,istats,
#else
#ifdef CRAY
	RDGDD(idebug,ibefo,istatio,ioxyz,irtype,istats,
#else
	rdgdd_(idebug,ibefo,istatio,ioxyz,irtype,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->eiga,
	dorbp->eigb,dorbp->nocc,dorbp->nocb,dorbp->ncols,dorbp->ncolb,
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void rdgamd(idebug,ibefo,istatio,irtype,ihsend,istats)
#else
#ifdef CRAY
void RDGAMD(idebug,ibefo,istatio,irtype,ihsend,istats)
#else
void rdgamd_(idebug,ibefo,istatio,irtype,ihsend,istats)
#endif
#endif
int *idebug;
int *ibefo;
int *istatio;
int *irtype;
int *ihsend;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdgadd(idebug,ibefo,istatio,irtype,ihsend,istats,
#else
#ifdef CRAY
	RDGADD(idebug,ibefo,istatio,irtype,ihsend,istats,
#else
	rdgadd_(idebug,ibefo,istatio,irtype,ihsend,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->eiga,
	dorbp->eigb,dorbp->nocc,dorbp->nocb,dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void rdgaud(idebug,ibefo,istatio,irtype,istats)
#else
#ifdef CRAY
void RDGAUD(idebug,ibefo,istatio,irtype,istats)
#else
void rdgaud_(idebug,ibefo,istatio,irtype,istats)
#endif
#endif
int *idebug;
int *ibefo;
int *istatio;
int *irtype;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdgdud(idebug,ibefo,istatio,irtype,istats,
#else
#ifdef CRAY
	RDGDUD(idebug,ibefo,istatio,irtype,istats,
#else
	rdgdud_(idebug,ibefo,istatio,irtype,istats,
#endif
#endif
	dorbp->focc,dorbp->focb,dorbp->nocc,dorbp->nocb,dorbp->ncols,
	dorbp->ncolb,xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void rdqchm(idebug,irtype,istats)
#else
#ifdef CRAY
void RDQCHM(idebug,irtype,istats)
#else
void rdqchm_(idebug,irtype,istats)
#endif
#endif
int *idebug;
int *irtype;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdqchd(idebug,irtype,istats,
#else
#ifdef CRAY
	RDQCHD(idebug,irtype,istats,
#else
	rdqchd_(idebug,irtype,istats,
#endif
#endif
	dorbp->focc,dorbp->focb,dorbp->nocc,dorbp->nocb,
	dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void rdorca(idebug,irtype,istats)
#else
#ifdef CRAY
void RDORCA(idebug,irtype,istats)
#else
void rdorca_(idebug,irtype,istats)
#endif
#endif
int *idebug;
int *irtype;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdorcd(idebug,irtype,istats,
#else
#ifdef CRAY
	RDORCD(idebug,irtype,istats,
#else
	rdorcd_(idebug,irtype,istats,
#endif
#endif
	xyzp->ianz,xyzp->iatoms,
	dorbp->focc,dorbp->focb,dorbp->nocc,dorbp->nocb,
	dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void rdnwch(idebug,irtype,istats)
#else
#ifdef CRAY
void RDNWCH(idebug,irtype,istats)
#else
void rdnwch_(idebug,irtype,istats)
#endif
#endif
int *idebug;
int *irtype;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdnwcd(idebug,irtype,istats,
#else
#ifdef CRAY
	RDNWCD(idebug,irtype,istats,
#else
	rdnwcd_(idebug,irtype,istats,
#endif
#endif
	xyzp->ianz,xyzp->iatoms,
	dorbp->focc,dorbp->focb,dorbp->nocc,dorbp->nocb,
	dorbp->ncols,dorbp->ncolb,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rdmaud(idebug,istatio,istats)
#else
#ifdef CRAY
void RDMAUD(idebug,istatio,istats)
#else
void rdmaud_(idebug,istatio,istats)
#endif
#endif
int *idebug;
int *istatio;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdmadd(idebug,istatio,istats,
#else
#ifdef CRAY
	RDMADD(idebug,istatio,istats,
#else
	rdmadd_(idebug,istatio,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->eiga,
	dorbp->eigb,dorbp->averag,dorbp->p,orbp->qd,orbp->pd,
	dorbp->nocc,dorbp->nocb,dorbp->ncols,dorbp->ncolb,
	geop->formax,geop->forrms,geop->dismax,geop->disrms,
	geop->epoints,geop->isav,xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void rdmold(idebug,istatio,irtype,iesp,istats)
#else
#ifdef CRAY
void RDMOLD(idebug,istatio,irtype,iesp,istats)
#else
void rdmold_(idebug,istatio,irtype,iesp,istats)
#endif
#endif
int *idebug;
int *istatio;
int *irtype;
int *iesp;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdmodd(idebug,istatio,irtype,iesp,istats,
#else
#ifdef CRAY
	RDMODD(idebug,istatio,irtype,iesp,istats,
#else
	rdmodd_(idebug,istatio,irtype,iesp,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->eiga,
	dorbp->eigb,dorbp->nocc,dorbp->nocb,dorbp->ncols,dorbp->ncolb,
	dorbp->stoalfa,dorbp->stobnorm,dorbp->istos,dorbp->naorbs,
	geop->formax,geop->forrms,geop->dismax,geop->disrms,
	geop->epoints,geop->isav);

}

#if defined(VMS) || defined(UNDERSC)
void prtmolf(iun,ihaszm,ipoints)
#else
#ifdef CRAY
void PRTMOLF(iun,ihaszm,ipoints)
#else
void prtmolf_(iun,ihaszm,ipoints)
#endif
#endif
int *iun;
int *ihaszm;
int *ipoints;
{

#if defined(VMS) || defined(UNDERSC)
	prtmold(iun,ihaszm,ipoints,
#else
#ifdef CRAY
	PRTMOLD(iun,ihaszm,ipoints,
#else
	prtmold_(iun,ihaszm,ipoints,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->eiga,
	dorbp->eigb,dorbp->nocc,dorbp->nocb,dorbp->ncols,dorbp->ncolb,
	dorbp->stoalfa,dorbp->stobnorm,dorbp->istos,dorbp->naorbs,
	geop->formax,geop->forrms,geop->dismax,geop->disrms,
	geop->epoints,geop->isav,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void rdvct(idebug,istats)
#else
#ifdef CRAY
void RDVCT(idebug,istats)
#else
void rdvct_(idebug,istats)
#endif
#endif
int *idebug;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdvcd(idebug,istats,
#else
#ifdef CRAY
	RDVCD(idebug,istats,
#else
	rdvcd_(idebug,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,
	dorbp->eiga,dorbp->eigb,
	dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void rdvect(idebug,ig94,istats)
#else
#ifdef CRAY
void RDVECT(idebug,ig94,istats)
#else
void rdvect_(idebug,ig94,istats)
#endif
#endif
int *idebug;
int *ig94;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdvecd(idebug,ig94,istats,
#else
#ifdef CRAY
	RDVECD(idebug,ig94,istats,
#else
	rdvecd_(idebug,ig94,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->eiga,dorbp->eigb,
	dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void exxtop(npr,norbs)
#else
#ifdef CRAY
void EXXTOP(npr,norbs)
#else
void exxtop_(npr,norbs)
#endif
#endif
int *npr;
int *norbs;
{

#if defined(VMS) || defined(UNDERSC)
	exxtod(npr,norbs,
#else
#ifdef CRAY
	EXXTOD(npr,norbs,
#else
	exxtod_(npr,norbs,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,
	dorbp->eiga,dorbp->eigb);

}

#if defined(VMS) || defined(UNDERSC)
void rdqvec(idebug,istats)
#else
#ifdef CRAY
void RDQVEC(idebug,istats)
#else
void rdqvec_(idebug,istats)
#endif
#endif
int *idebug;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdqvcd(idebug,istats,
#else
#ifdef CRAY
	RDQVCD(idebug,istats,
#else
	rdqvcd_(idebug,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->eiga,dorbp->eigb,
	dorbp->ncols,dorbp->ncolb);

}

#if defined(VMS) || defined(UNDERSC)
void denfst(summ,psi)
#else
#ifdef CRAY
void DENFST(summ,psi)
#else
void denfst_(summ,psi)
#endif
#endif
double *summ;
double *psi;
{

#if defined(VMS) || defined(UNDERSC)
	denfsd(summ,psi,
#else
#ifdef CRAY
	DENFSD(summ,psi,
#else
	denfsd_(summ,psi,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb);

}

#if defined(VMS) || defined(UNDERSC)
void datin(npts1,npts2,npts3)
#else
#ifdef CRAY
void DATIN(npts1,npts2,npts3)
#else
void datin_(npts1,npts2,npts3)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
{

#if defined(VMS) || defined(UNDERSC)
	datid(npts1,npts2,npts3,
#else
#ifdef CRAY
	DATID(npts1,npts2,npts3,
#else
	datid_(npts1,npts2,npts3,
#endif
#endif
	dorbp->ncols,dorbp->ncolb,dorbp->focc,dorbp->focb,dorbp->eiga,dorbp->eigb);

}

#if defined(VMS) || defined(UNDERSC)
void homo(ipsi)
#else
#ifdef CRAY
void HOMO(ipsi)
#else
void homo_(ipsi)
#endif
#endif
int *ipsi;
{

#if defined(VMS) || defined(UNDERSC)
	homod(ipsi,
#else
#ifdef CRAY
	HOMOD(ipsi,
#else
	homod_(ipsi,
#endif
#endif
	dorbp->focc,dorbp->focb,dorbp->eiga,dorbp->eigb);

}

#if defined(VMS) || defined(UNDERSC)
void lumo(ipsi)
#else
#ifdef CRAY
void LUMO(ipsi)
#else
void lumo_(ipsi)
#endif
#endif
int *ipsi;
{

#if defined(VMS) || defined(UNDERSC)
	lumod(ipsi,
#else
#ifdef CRAY
	LUMOD(ipsi,
#else
	lumod_(ipsi,
#endif
#endif
	dorbp->focc,dorbp->focb,dorbp->eiga,dorbp->eigb);

}

#if defined(VMS) || defined(UNDERSC)
void occup(istat)
#else
#ifdef CRAY
void OCCUP(istat)
#else
void occup_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	occupd(istat,
#else
#ifdef CRAY
	OCCUPD(istat,
#else
	occupd_(istat,
#endif
#endif
	dorbp->focc,dorbp->focb);

}

/* END shadow C routines for Fortran routines to pass orbital pointers */

/* shadow C routines for Fortran routines to pass grid pointers */

#if defined(VMS) || defined(UNDERSC)
void asurf(idomap,idocal)
#else
#ifdef CRAY
void ASURF(idomap,idocal)
#else
void asurf_(idomap,idocal)
#endif
#endif
int *idomap;
int *idocal;
{
       int mapit,idum;
 
       mapit = 1;

#if defined(VMS) || defined(UNDERSC)
       if (*idomap) almgrd();
       if (*idocal) srfcal(idomap,sgrd.denn,mgrd.fmap,xyzp->coo,
			xyzp->lwrit,xyzp->ityp,xyzp->icont,xyzp->ncont);
       else mapsrf(sgrd.denn,mgrd.fmap,&mapit);
#else
#ifdef CRAY
       if (*idomap) ALMGRD();
       if (*idocal) SRFCAL(idomap,sgrd.denn,mgrd.fmap,xyzp->coo,
			xyzp->lwrit,xyzp->ityp,xyzp->icont,xyzp->ncont);
       else MAPSRF(sgrd.denn,mgrd.fmap,&mapit);
#else
       if (*idomap) almgrd_();
       if (*idocal) srfcal_(idomap,sgrd.denn,mgrd.fmap,xyzp->coo,
			xyzp->lwrit,xyzp->ityp,xyzp->icont,xyzp->ncont);
       else mapsrf_(sgrd.denn,mgrd.fmap,&mapit);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void cntour(a,mdim,imax,jmax,pz,value,r11,id)
#else
#ifdef CRAY
void CNTOUR(a,mdim,imax,jmax,pz,value,r11,id)
#else
void cntour_(a,mdim,imax,jmax,pz,value,r11,id)
#endif
#endif
double *a;
int *mdim;
int *imax;
int *jmax;
double *pz;
double *value;
double *r11;
int *id;
{

#if defined(VMS) || defined(UNDERSC)
	cntoud(a,mdim,imax,jmax,pz,value,r11,id,
#else
#ifdef CRAY
	CNTOUD(a,mdim,imax,jmax,pz,value,r11,id,
#else
	cntoud_(a,mdim,imax,jmax,pz,value,r11,id,
#endif
#endif
	sgrd.ix);

}

#if defined(VMS) || defined(UNDERSC)
void den3d(npts1,npts2,scale)
#else
#ifdef CRAY
void DEN3D(npts1,npts2,scale)
#else
void den3d_(npts1,npts2,scale)
#endif
#endif
int *npts1;
int *npts2;
double *scale;
{

#if defined(VMS) || defined(UNDERSC)
	dendd(npts1,npts2,scale,
#else
#ifdef CRAY
	DENDD(npts1,npts2,scale,
#else
	dendd_(npts1,npts2,scale,
#endif
#endif
	sgrd.dens,sgrd.edx,sgrd.edy,sgrd.iedlog);

}

#if defined(VMS) || defined(UNDERSC)
void dencnt(npts1,npts2,fcnt)
#else
#ifdef CRAY
void DENCNT(npts1,npts2,fcnt)
#else
void dencnt_(npts1,npts2,fcnt)
#endif
#endif
int *npts1;
int *npts2;
double *fcnt;
{

#if defined(VMS) || defined(UNDERSC)
	dencnd(npts1,npts2,fcnt,
#else
#ifdef CRAY
	DENCND(npts1,npts2,fcnt,
#else
	dencnd_(npts1,npts2,fcnt,
#endif
#endif
	sgrd.dens,sgrd.iedlog);

}

#if defined(VMS) || defined(UNDERSC)
void grdcl(npts1,npts2,iprnt,space)
#else
#ifdef CRAY
void GRDCL(npts1,npts2,iprnt,space)
#else
void grdcl_(npts1,npts2,iprnt,space)
#endif
#endif
int *npts1;
int *npts2;
int *iprnt;
double *space;
{

#if defined(VMS) || defined(UNDERSC)
	grdcd(npts1,npts2,iprnt,space,
#else
#ifdef CRAY
	GRDCD(npts1,npts2,iprnt,space,
#else
	grdcd_(npts1,npts2,iprnt,space,
#endif
#endif
	sgrd.dens);
}

#if defined(VMS) || defined(UNDERSC)
void resedl()
#else
#ifdef CRAY
void RESEDL()
#else
void resedl_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	resedd(sgrd.iedlog);
#else
#ifdef CRAY
	RESEDD(sgrd.iedlog);
#else
	resedd_(sgrd.iedlog);
#endif
#endif

}

typedef struct {
	int init;
	int nhetz[MXHETA];
	int istz[MXHETA]; } HETTMPSTRU;
static HETTMPSTRU HetTmp = {.init = 0};

void iniHetTmp()
{
   int i,j;

	for (j=0; j<hetptr.NHetAtm; j++) {
	    HetTmp.nhetz[j] = 0;
	    HetTmp.istz[j] = -1;
	}

        for (i=0; i<*xyzp->iatoms; i++) {
	   for (j=4; j<hetptr.NHetAtm; j++) {
		if (xyzp->iresid[i] == -j) {
		   if (HetTmp.istz[j] == -1) HetTmp.istz[j] = i;
		   HetTmp.nhetz[j]++;
		}
	   }
	}
	HetTmp.init = 1;
}

void ChkHetCoo(opt)
int opt;
{
   int i,j,k,l;
   double x,y,z,tol,tol2;
   int confl[MXHETA];

   tol = 0.1;
   tol2 = tol*tol;

   for (i=0; i<MXHETA; i++) confl[i] = 0;

   for (i=HetTmp.istz[opt]; i<HetTmp.istz[opt]+HetTmp.nhetz[opt]; i++) {
	for (j=4; j<hetptr.NHetAtm; j++) {
	   if (j != opt) {
		for (k=HetTmp.istz[j]; k<HetTmp.istz[j]+HetTmp.nhetz[j]; k++) {
		   x = xyzp->coo[k*3  ] - xyzp->coo[i*3  ];
		   y = xyzp->coo[k*3+1] - xyzp->coo[i*3+1];
		   z = xyzp->coo[k*3+2] - xyzp->coo[i*3+2];
		   if (x*x + y*y + z*z < tol2) {
			fprintf(stderr,"Residue %s, atom %d: Distance to atom %d  of residue %s is nearly zero!\n",hetptr.HetAtm[opt],i,k,hetptr.HetAtm[j]);
			confl[j] = 1;
		   }
		}
	   }
	}
   }

   for (i=4; i<MXHETA; i++)  {
	if (confl[i]) {
	    sprintf(cmdstr,
	"Conflict Ligand %s and ligand %s\nAtoms overlap: Remove ligand %s from pdb file,\nif you want Molden to correctly add hydrogens",
		hetptr.HetAtm[opt],hetptr.HetAtm[i],hetptr.HetAtm[i]);
	    if (DoCan(event.xbutton.x_root,event.xbutton.y_root,cmdstr,
		0)) {}

	}
   }
}

#if defined(VMS) || defined(UNDERSC)
void maxmin(npts1,npts2,scale)
#else
#ifdef CRAY
void MAXMIN(npts1,npts2,scale)
#else
void maxmin_(npts1,npts2,scale)
#endif
#endif
int *npts1;
int *npts2;
double *scale;
{

#if defined(VMS) || defined(UNDERSC)
	maxmid(npts1,npts2,scale,
#else
#ifdef CRAY
	MAXMID(npts1,npts2,scale,
#else
	maxmid_(npts1,npts2,scale,
#endif
#endif
	sgrd.dens);
}

#if defined(VMS) || defined(UNDERSC)
void plden(ndim1,ndim2,scale,icells,adjus,idisml)
#else
#ifdef CRAY
void PLDEN(ndim1,ndim2,scale,icells,adjus,idisml)
#else
void plden_(ndim1,ndim2,scale,icells,adjus,idisml)
#endif
#endif
int *ndim1;
int *ndim2;
double *scale;
int *icells;
double *adjus;
int *idisml;
{

#if defined(VMS) || defined(UNDERSC)
	plded(ndim1,ndim2,scale,icells,adjus,idisml,
#else
#ifdef CRAY
	PLDED(ndim1,ndim2,scale,icells,adjus,idisml,
#else
	plded_(ndim1,ndim2,scale,icells,adjus,idisml,
#endif
#endif
	sgrd.dens,sgrd.ix,sgrd.iy,sgrd.rz);
}

#if defined(VMS) || defined(UNDERSC)
void p3dv(iun,scale,ndimx,ndimz,adjus)
#else
#ifdef CRAY
void P3DV(iun,scale,ndimx,ndimz,adjus)
#else
void p3dv_(iun,scale,ndimx,ndimz,adjus)
#endif
#endif
int *iun;
double *scale;
int *ndimx;
int *ndimz;
double *adjus;
{

#if defined(VMS) || defined(UNDERSC)
	p3dd(iun,scale,ndimx,ndimz,adjus,
#else
#ifdef CRAY
	P3DD(iun,scale,ndimx,ndimz,adjus,
#else
	p3dd_(iun,scale,ndimx,ndimz,adjus,
#endif
#endif
	sgrd.dens);
}

#if defined(VMS) || defined(UNDERSC)
void rdcube(npts1,npts2,npts3,iposng,ipsi,istat,iun,idebug)
#else
#ifdef CRAY
void RDCUBE(npts1,npts2,npts3,iposng,ipsi,istat,iun,idebug)
#else
void rdcube_(npts1,npts2,npts3,iposng,ipsi,istat,iun,idebug)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *iposng;
int *ipsi;
int *istat;
int *iun;
int *idebug;
{

#if defined(VMS) || defined(UNDERSC)
	rdcubd(npts1,npts2,npts3,iposng,ipsi,istat,iun,idebug,
#else
#ifdef CRAY
	RDCUBD(npts1,npts2,npts3,iposng,ipsi,istat,iun,idebug,
#else
	rdcubd_(npts1,npts2,npts3,iposng,ipsi,istat,iun,idebug,
#endif
#endif
	sgrd.denn,sgrd.pmnn);

}

#if defined(VMS) || defined(UNDERSC)
void wrcube(npts1,npts2,npts3,ipsi)
#else
#ifdef CRAY
void WRCUBE(npts1,npts2,npts3,ipsi)
#else
void wrcube_(npts1,npts2,npts3,ipsi)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *ipsi;
{

#if defined(VMS) || defined(UNDERSC)
	wrcubd(npts1,npts2,npts3,ipsi,
#else
#ifdef CRAY
	WRCUBD(npts1,npts2,npts3,ipsi,
#else
	wrcubd_(npts1,npts2,npts3,ipsi,
#endif
#endif
	sgrd.denn);

}

#if defined(VMS) || defined(UNDERSC)
void rdgrd(npts1,npts2,npts3,iun,istat)
#else
#ifdef CRAY
void RDGRD(npts1,npts2,npts3,iun,istat)
#else
void rdgrd_(npts1,npts2,npts3,iun,istat)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *istat;
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	rdgrdd(npts1,npts2,npts3,iun,istat,
#else
#ifdef CRAY
	RDGRDD(npts1,npts2,npts3,iun,istat,
#else
	rdgrdd_(npts1,npts2,npts3,iun,istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,sgrd.denst,&cell->ichx);

}

#if defined(VMS) || defined(UNDERSC)
void rdomap(npts1,npts2,npts3,iun,istat)
#else
#ifdef CRAY
void RDOMAP(npts1,npts2,npts3,iun,istat)
#else
void rdomap_(npts1,npts2,npts3,iun,istat)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *istat;
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	rdomad(npts1,npts2,npts3,iun,istat,
#else
#ifdef CRAY
	RDOMAD(npts1,npts2,npts3,iun,istat,
#else
	rdomad_(npts1,npts2,npts3,iun,istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx);

}

#if defined(VMS) || defined(UNDERSC)
void rdccp4(npts1,npts2,npts3,iun,istat)
#else
#ifdef CRAY
void RDCCP4(npts1,npts2,npts3,iun,istat)
#else
void rdccp4_(npts1,npts2,npts3,iun,istat)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *istat;
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	rdccpd(npts1,npts2,npts3,iun,istat,
#else
#ifdef CRAY
	RDCCPD(npts1,npts2,npts3,iun,istat,
#else
	rdccpd_(npts1,npts2,npts3,iun,istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);

}

#if defined(VMS) || defined(UNDERSC)
void rdplt(npts1,npts2,npts3,iun,istat,iopt)
#else
#ifdef CRAY
void RDPLT(npts1,npts2,npts3,iun,istat,iopt)
#else
void rdplt_(npts1,npts2,npts3,iun,istat,iopt)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *istat;
int *iun;
int *iopt;
{

    if (*iopt == 0) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(npts1,npts2,npts3,iun,istat,
#else
#ifdef CRAY
	RDPLD(npts1,npts2,npts3,iun,istat,
#else
	rdpld_(npts1,npts2,npts3,iun,istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
    } else {
#if defined(VMS) || defined(UNDERSC)
	rdpld(npts1,npts2,npts3,iun,istat,
#else
#ifdef CRAY
	RDPLD(npts1,npts2,npts3,iun,istat,
#else
	rdpld_(npts1,npts2,npts3,iun,istat,
#endif
#endif
	sgrd.denn2,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
    }

}

static XColor extdef[256];

void GetExact()
{
    int i,r,g,b,ret;

    for (i=0; i<256; i++) {   
	extdef[i].pixel = colors[i];
	XQueryColor(display,cmap,&extdef[i]);
    }
}

int ApproxCol(r0,g0,b0)
int r0;
int b0;
int g0;
{
    int i,r,g,b,ret;
    int dr,dg,db,dx;
    XColor exact_def;

    dx = 1000;
    ret = 0;

    for (i=0; i<256; i++) {   
        r = (int) extdef[i].red>>8;
        g = (int) extdef[i].green>>8;
        b = (int) extdef[i].blue>>8;
	dr = ABS(r0-r); dg = ABS(g0-g); db = ABS(b0-b);
	if (dr+dg+db < dx) {
	   dx = dr+dg+db;
	   ret = i;
	}
    }
    return(ret);
}

char * mkext(str,ext)
char *str;
char *ext;
{
   char *xstr1;
   char *last1;
   char *dot1;
   int l,n1=0;

   if (str != NULL) {
	last1 = str;
	l = strlen(last1);
	xstr1 = (char *) malloc(sizeof(char)*(l+6));
	if (xstr1 == NULL) return(NULL);
	if (last1 != NULL) {
	   dot1 = strrchr(last1,'.');
	   if (dot1 != NULL) {
		n1 = (int) (dot1 - last1);
		strncpy(xstr1,last1,n1);
		xstr1[n1] = '\0';
		strcat(xstr1,ext);
	   } else {
		return(NULL);
	   }
	} else {
	   return(NULL);
	}
   } else {
	return(NULL);
   }

   return(xstr1);
}

void Cvt2SVG()
{
  char str[500];
  int n,i,pid;

  if (getob()) {
	if (OBloc == 1) {
	   sprintf(str,
	   "%sobabel -imol /tmp/tmpje.mol --gen2D -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
	   exepath[0]);

	} else if (OBloc == 2) {
	   sprintf(str,
	   "/usr/bin/obabel -imol /tmp/tmpje.mol --gen2D -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &");
	} else {
	   sprintf(str,
	   "/usr/local/bin/obabel -imol /tmp/tmpje.mol --gen2D -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &");
	}

	n = strlen(str);
	system(str);

 	DCKsvg = (SVGFSTRUC *) malloc(sizeof(SVGFSTRUC));

	GetExact();
	rdsvg(DCKsvg,"/tmp/b.svg",-1);

	DrawSVG(10, 10, 50 , 50,*DCKsvg,windock);
	DCKSVG = 1;
  }

}

int rdsvgs()
{
   int i,j,n,ntits,ncmd,itmp;
   int fd;
   char *xstr1;

   xstr1 = mkext(COO[istruct]->fname,".svgs");

   fd = open(xstr1,O_RDONLY,0644);
	
   if (fd < 0) {
	fprintf(stderr,"rdsvgs: Error opening file %s\n",xstr1);
 	return(1);
   }

   read(fd,&ntits,sizeof(int));

   if (COO[istruct]->ntits != ntits) {
	fprintf(stderr,"ntits read %d not equal ntits in memory %d\n",
		ntits,COO[istruct]->ntits);
	return(1);
   }

   COO[istruct]->svgs =
	(SVGFSTRUC *) malloc(sizeof(SVGFSTRUC)*(ntits));

   for (i = 0; i < COO[istruct]->ntits; i++) {
	read(fd,&COO[istruct]->svgs[i],sizeof(SVGFSTRUC));
	ncmd = COO[istruct]->svgs[i].ncmd;
	if (ncmd == 0) {
	   if (i > 0) bcksvg.CurSVG = i - 1;
	   close(fd);
	   return(1);
	}
	COO[istruct]->svgs[i].array = 
		(SVGSTRUC *) malloc(sizeof(SVGSTRUC)*(ncmd));
	for (j = 0; j < ncmd; j++) {
	   read(fd,&COO[istruct]->svgs[i].array[j],sizeof(SVGSTRUC));
	}
	for (j = 0; j < ncmd; j++) {
	   if (COO[istruct]->svgs[i].array[j].type != 1) {
		COO[istruct]->svgs[i].array[j].str = NULL;
		read(fd,&itmp,sizeof(int));
	   } else {
		read(fd,&n,sizeof(int));
		COO[istruct]->svgs[i].array[j].str = 
			(char *) malloc(sizeof(char)*(n+1));
		read(fd,COO[istruct]->svgs[i].array[j].str,sizeof(char)*n);
		COO[istruct]->svgs[i].array[j].str[n] = '\0';
	   }
	}
   }

   close(fd);
   COO[istruct]->svgdone = 1;
   return(0);

}

int wrsvgs(char *fname)
{
   SVGSTRUC rec;
   int i,j,n;
   int fd;
   char xstr1[MAXCMD];
   char *last1;
   char *dot1;
   int n1=0;

   if (COO[bcksvg.istruct]->svgs == NULL) return(1);

   last1 = fname;
   if (last1 != NULL) {
	dot1 = strrchr(last1,'.');
	if (dot1 != NULL) {
	   n1 = (int) (dot1 - last1);
	   strncpy(xstr1,last1,n1);
	   xstr1[n1] = '\0';
	   strcat(xstr1,".svgs");
	} else {
	   return(1);
	}
   } else {
	return(1);
   }

   
   fd = open(xstr1,O_WRONLY|O_CREAT,0644);
	
   if (fd < 0) {
	fprintf(stderr,"wrsvgs: Error opening file %s\n",xstr1);
 	return(1);
   }

   write(fd,&COO[bcksvg.istruct]->ntits,sizeof(int));

   for (i = 0; i < COO[bcksvg.istruct]->ntits; i++) {
	write(fd,&COO[bcksvg.istruct]->svgs[i],sizeof(SVGFSTRUC));
	for (j = 0; j < COO[bcksvg.istruct]->svgs[i].ncmd; j++) {
	   write(fd,&COO[bcksvg.istruct]->svgs[i].array[j],sizeof(SVGSTRUC));
	}
	for (j = 0; j < COO[bcksvg.istruct]->svgs[i].ncmd; j++) {
	   if (COO[bcksvg.istruct]->svgs[i].array[j].type != 1) {
		write(fd,&MONE,sizeof(int));
	   } else {
		n = strlen(COO[bcksvg.istruct]->svgs[i].array[j].str);
		write(fd,&n,sizeof(int));
		write(fd,COO[bcksvg.istruct]->svgs[i].array[j].str,sizeof(char)*n);
	   }
	}
   }

   close(fd);
   return(0);
}

int rdsvg(svgfile,str,imol)
SVGFSTRUC *svgfile;
char *str;
int imol;
{
   FILE *f;
   SVGSTRUC rec;
   char strmax[1000];
   char *strp;
   char *strpe;
   int ncmd = 0;
   int icmd,i,j;
   int type = 0;
   int n,r,g,b;

   f = fopen(str,"r");
	
   if (f == NULL) {
	fprintf(stderr,"Error opening file %s\n",str);
 	return(0);
   }

   ncmd = 0;
   svgfile->w = 0.0;
   svgfile->h = 0.0;
   while(1) {
	if (fgets(strmax,1000,f) == NULL) break;
	if (strstr(strmax,"xmlns")) {
	   strp = strstr(strmax,"width=");
	   if (strp != NULL) {
		strp++;strp++;strp++;strp++;
		strp++;strp++;strp++;
		sscanf(strp,"%f",&svgfile->w);
	   }
	   strp = strstr(strmax,"height=");
	   if (strp != NULL) {
		strp++;strp++;strp++;strp++;
		strp++;strp++;strp++;strp++;
		sscanf(strp,"%f",&svgfile->h);
	   }
	}
	if (strstr(strmax,"<line") || strstr(strmax,"<text") ||
	    strstr(strmax,"<polygon")) ncmd++;
   }
   rewind(f);

   if (imol != -1) {
	svgfile->ncmd = ncmd + 1;
	svgfile->array = (SVGSTRUC *) malloc(sizeof(SVGSTRUC)*(ncmd+1));
   } else {
	svgfile->ncmd = ncmd;
	svgfile->array = (SVGSTRUC *) malloc(sizeof(SVGSTRUC)*(ncmd));
   }

   i = -1;
   while(1) {
	if (fgets(strmax,1000,f) == NULL) break;
	if (strstr(strmax,"<line") || strstr(strmax,"<text") || 
	    strstr(strmax,"<polyg")) {
	   i++;
	   if (strstr(strmax,"<line")) {
		rec.type = 0;
		rec.col = 0;

		rec.x1 = 0.0;
		strp = strstr(strmax,"x1=");
		if (strp != NULL) {
		   strp++;strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.x1);
		}

		rec.y1 = 0.0;
		strp = strstr(strmax,"y1=");
		if (strp != NULL) {
		   strp++;strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.y1);
		}

		rec.x2 = 0.0;
		strp = strstr(strmax,"x2=");
		if (strp != NULL) {
		   strp++;strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.x2);
		}

		rec.y2 = 0.0;
		strp = strstr(strmax,"y2=");
		if (strp != NULL) {
		   strp++;strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.y2);
		}
	   } else if (strstr(strmax,"<text")) {
		rec.type = 1;
		rec.col = 0;

		rec.x1 = 0.0;
		strp = strstr(strmax,"x=");
		if (strp != NULL) {
		   strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.x1);
		}

		rec.y1 = 0.0;
		strp = strstr(strmax,"y=");
		if (strp != NULL) {
		   strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.y1);
		}

		rec.str = NULL;
		if (rec.type == 1) {
		   strp = strstr(strmax,">");
		   if (strp != NULL) {
			strp++;
			strpe = strstr(strp,"<");
			if (strpe != NULL) {
			   n = strpe - strp;
			   rec.str = (char *) malloc(sizeof(char)*(n+1));
			   strncpy(rec.str, strp,n);
			   rec.str[n] = '\0';
			}
		   }
		}

		r = 0; g = 0; b = 0;
		strp = strstr(strmax,"rgb(");
		if (strp != NULL) {
		   strp++;strp++;strp++;strp++;
		   sscanf(strp,"%d",&r);
		   strp = strstr(strp,",");
		   if (strp != NULL) {
			strp++;
			sscanf(strp,"%d",&g);
			strp = strstr(strp,",");
			if (strp != NULL) {
			   strp++;
			   sscanf(strp,"%d",&b);
			}
		   }
		   rec.col = ApproxCol(r,g,b);
  		}

	   } else {
		rec.type = 2;
		rec.col = 0;

		strp = strstr(strmax,"points=");
		if (strp != NULL) {
		   strp++;strp++;strp++;strp++;
		   strp++;strp++;strp++;strp++;
		   sscanf(strp,"%f",&rec.poly[0]);
		   strp = strstr(strp," ");
		   if (strp != NULL) {
			strp++;
			sscanf(strp,"%f",&rec.poly[1]);
		        strp = strstr(strp," ");
		        if (strp != NULL) {
			   strp++;
			   sscanf(strp,"%f",&rec.poly[2]);
		           strp = strstr(strp," ");
			   if (strp != NULL) {
				strp++;
				sscanf(strp,"%f",&rec.poly[3]);
		        	strp = strstr(strp," ");
				if (strp != NULL) {
				   strp++;
				   sscanf(strp,"%f",&rec.poly[4]);
		        	   strp = strstr(strp," ");
				   if (strp != NULL) {
					strp++;
					sscanf(strp,"%f",&rec.poly[5]);
				   }
				}
			   }
			}
		   }
		}

	   } 
	   svgfile->array[i] = rec;
	}
   }


   if (imol != -1) {
	rec.str = (char *) malloc(sizeof(char)*(5+1));
	sprintf(strp,"%5d",imol);
	strncpy(rec.str, strp,5);
	rec.str[5] = '\0';
	rec.col = 1;
	rec.type = 1;
	rec.x1 = -1.0;
	rec.y1 = -1.0;
	svgfile->array[ncmd] = rec;
   }

   fclose(f);
   return(1);
}

void DrawSVG(x,y,w0,h0,svgfile,win)
int x;
int y;
int w0;
int h0;
SVGFSTRUC svgfile;
Window win;
{
   int i,j,n;
   float w,h,wr,hr;
   XPoint poly[3];
   
   w = svgfile.w;
   h = svgfile.h;
   
   wr = (float) w0 / w;
   hr = (float) h0 / h;
   wr = hr;

   XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);

   if (svgfile.ncmd == 0 || svgfile.array == NULL) return;

   for (i = 0; i < svgfile.ncmd; i++) {
	if (svgfile.array[i].type == 1) {
	   if (svgfile.array[i].str != NULL) {
              XSetForeground(display, gc1, colors[svgfile.array[i].col]);
	      if (svgfile.array[i].x1 == -1.0 && 
		  svgfile.array[i].y1 == -1.0) {
	          XDrawString(display,win,gc1,
		  x + 220,
		  y + 20,
		  svgfile.array[i].str,strlen(svgfile.array[i].str));
	      } else {
	          XDrawString(display,win,gc1,
		  x + (int) svgfile.array[i].x1*wr,
		  y + (int) svgfile.array[i].y1*hr,
		  svgfile.array[i].str,strlen(svgfile.array[i].str));
	      }
	   }
	} else if (svgfile.array[i].type == 2) {
	   for (j = 0; j < 3; j++) {
		poly[j].x = x + (int) svgfile.array[i].poly[j*2]*wr;
		poly[j].y = y + (int) svgfile.array[i].poly[j*2+1]*hr;
	   }
           XSetForeground(display, gc, colors[svgfile.array[i].col]);
	   XFillPolygon(display,win,gc,poly,3,Convex,CoordModeOrigin);
	} else {
           XSetForeground(display, gc, colors[0]);
	   XDrawLine(display,win,gc,
		x + (int) svgfile.array[i].x1*wr,
		y + (int) svgfile.array[i].y1*hr,
		x + (int) svgfile.array[i].x2*wr,
		y + (int) svgfile.array[i].y2*hr);
	}
   }
   XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
}

void disp_map(char *str)
{
	int i,idopn,srft;

	srft = NSurf[istruct];
	NSurf[istruct] = omapsrf;
	*vlcnt = omapcnt1;
	idopn = 0;
	if (omapPandN && !(*rng1 >= 0.0) ) {
	   idopn = 1;
	   *vlcnt2 = omapcnt2;
	} else {
	   *vlcnt2 = -omapcnt1;
	}
#if defined(VMS) || defined(UNDERSC)
	dpomap(&idopn);
#else
#ifdef CRAY
	DPOMAP(&idopn);
#else
	dpomap_(&idopn);
#endif
#endif
#ifdef DOGL
	srfprop();
	if (srft > omapsrf) NSurf[istruct] = srft;

	ogbox();
#endif
	update_struct();
}

#if defined(VMS) || defined(UNDERSC)
void dpomap(iopt)
#else
#ifdef CRAY
void DPOMAP(iopt)
#else
void dpomap_(iopt)
#endif
#endif
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	dpomad(iopt,
#else
#ifdef CRAY
	DPOMAD(iopt,
#else
	dpomad_(iopt,
#endif
#endif
	sgrd.denn);

}

void change_iso(int iop)
{

  if (!has_box) return;

  if (iop) {
	omapcnt1 = omapcnt1 + 0.05;
	if (omapcnt1 > *rng2) omapcnt1 = *rng2;
  } else {
	omapcnt1 = omapcnt1 - 0.05;
	if (omapcnt1 < 0.0) omapcnt1 = 0.0;
  }
  sprintf(qboxes[QCNT].str,"%5.2f", omapcnt1);
  PromptBox(&qboxes[QCNT]);
  disp_map(NULL);
  XSync(display, True);
}

void getcval()
{
	omapcnt1 = (*rng2 / 10.0);
	sprintf(stemp,"%5.2f",omapcnt1);
	qboxstr(&qboxes[QCNT],&OMAPwin,1,0,-1,20,180,
	   50,QBOXHIGH, 0,NULL,stemp,
	   0,3,2000,-1,disp_map);
	qboxes[QCNT].dflt = &omapcnt1;


	if (omapPandN && !(*rng1 >= 0.0) ) {
	   omapcnt2 = *rng1 / 2.0;
	   sprintf(stemp,"%5.2f",omapcnt2);
	   qboxstr(&qboxes[QCNT2],&OMAPwin,0,0,-1,20,210,
	   50,QBOXHIGH, 0,NULL,stemp,
	   0,3,2000,-1,disp_map);
	   qboxes[QCNT2].dflt = &omapcnt2;
	}
	has_box = 1;
}

int omap()
{
    if (!*ipdbon) {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"Electron density maps are only available for PDB files.",0);
	return(1);
    } else {
	if (pdbcode == NULL) {
	     qboxstr(&qboxes[QSRFW],NULL,1,0,-1,
			DEFQX,DEFQY,QBOXWIDE,QBOXHIGH,0,
			"CCP4 Filename ? ",NULL,0,0,
			585,1,dummyproc);
			return(1);
	} else {
	     if (omapr == 1) {
		 if (!OMAPup) InitOmap(0);
	     } else {
		 if (OMAPup) DeleteOMAP();
		 if (!CheckWGET()) 
		      if (!GetOMAPWWW(pdbcode,strname)) return(1);
	     }
	}
   }
   return(0);
}

void calcab(double vx[3], double vy[3], double vz[3], double vn[3], double fr[3])
{
   double nz[3],vyn[3],vyx[3],vxn[3],vxy[3],nzvyn,nzvyx,nzvxn,nzvxy;
   double vnp[3],vnpl[3];

   crossprd(vx,vy,nz);
   CROSS(vn,nz,vnpl);
   CROSS(vnpl,nz,vnp);
   dimprod(vn,vz,&fr[2]);

   CROSS(vy,vnp,vyn);
   improduct(nz,vyn,&nzvyn);
   CROSS(vy,vx,vyx);
   improduct(nz,vyx,&nzvyx);
   fr[0] = ABS(nzvyn/nzvyx);

   CROSS(vx,vnp,vxn);
   improduct(nz,vxn,&nzvxn);
   CROSS(vx,vy,vxy);
   improduct(nz,vxy,&nzvxy);
   fr[1] = ABS(nzvxn/nzvxy);

}

void res_dens(int Ca,int opt)
{
   int i,l;
   double ca[3],t[3];
   double slice[3];
   double fr[3];
   double tmpo[3];
   double devx[3],devy[3],devz[3];

   for (i = 0; i < 3; i++) tmpo[i] = comsrfptr->vo[i];

   if (opt) {
	l = calfptr->icalf[Ca][0]-1;
	omapCa = l;
   } else {
	l = Ca;
   }

   for (i = 0; i < 3; i++) {
	ca[i] = xyzp->coo[l*3+i] - tmpo[i];
	devx[i] = comsrfptr->v1[i]*comsrfptr->r[0];
	devy[i] = comsrfptr->v2[i]*comsrfptr->r[1];
	devz[i] = comsrfptr->v3[i]*comsrfptr->r[2];
   }

   calcab(devx,devy,devz,ca,fr);
   fr[2] = ca[2]/comsrfptr->r[2];

// This currently setup for alpha,beta,gamma = 90 AND
// alpha,beta = 90 and gamma != 90
// PDBCODE 1mep does not work

// Y direction

   slice[2] = comsrfptr->r[2]/10.0;
   EQ[0] = vox[2] + extnt[2]*fr[2];
   omaprat[0] = (float) (fr[2] + 0.1);
   EQ[0] = EQ[0] + slice[2];
   if (omaprat[0] > 1.0) omaprat[0] = 1.0;
   if (omaprat[0] < 0.0) omaprat[0] = 0.0;

   omaprat[1] =  (float) 2.0*slice[2]/extnt[2];
   if (omaprat[1] < 0.0) omaprat[1] = 0.0;
   if (omaprat[1] > 1.0) omaprat[1] = 1.0;
   slab[0] = 2.0*slice[2];

// X direction

   slice[0] = comsrfptr->r[0]/10.0;
   EQ[1] = vox[0] + extnt[0]*fr[0];
   omaprat[2] = (float) (fr[0] + 0.1);
   EQ[1] = EQ[1] + slice[0];
   if (omaprat[2] > 1.0) omaprat[2] = 1.0;
   if (omaprat[2] < 0.0) omaprat[2] = 0.0;

   omaprat[3] = (float) 2.0*slice[0]/extnt[0];
   if (omaprat[3] < 0.0) omaprat[3] = 0.0;
   if (omaprat[3] > 1.0) omaprat[3] = 1.0;
   slab[1] = 2.0*slice[0];

// Z direction

   slice[1] = comsrfptr->r[1]/10.0;
   EQ[2] = vox[1] + extnt[1]*fr[1];
   omaprat[4] = (float) (fr[1] + 0.1);
   EQ[2] = EQ[2] + slice[1];
   if (omaprat[4] > 1.0) omaprat[4] = 1.0;
   if (omaprat[4] < 0.0) omaprat[4] = 0.0;

   omaprat[5] = 2.0*slice[1]/extnt[1];
   if (omaprat[5] < 0.0) omaprat[5] = 0.0;
   if (omaprat[5] > 1.0) omaprat[5] = 1.0;
   slab[2] = 2.0*slice[1];
   
   omapwpos[0] = (int) ((float) omapwn[0]*omaprat[0]);
   omapwpos[2] = (int) ((float) omapwn[2]*omaprat[2]);
   omapwpos[4] = (int) ((float) omapwn[4]*omaprat[4]);

   RedrawSlide(&omapscr[0]);
   RedrawSlide(&omapscr[2]);
   RedrawSlide(&omapscr[4]);

   omapwpos[1] = (int) ((float) omapwn[1]*omaprat[1]);
   omapwpos[3] = (int) ((float) omapwn[3]*omaprat[3]);
   omapwpos[5] = (int) ((float) omapwn[5]*omaprat[5]);

   RedrawSlide(&omapscr[1]);
   RedrawSlide(&omapscr[3]);
   RedrawSlide(&omapscr[5]);

   update_struct();
}

void UpdateOMAP1()
{

   EQ[0] = vox[2] + extnt[2]*omaprat[0];

   update_struct();
   
}

void UpdateSLAB1()
{

   slab[0] = extnt[2]*omaprat[1];

   update_struct();
   
}

void UpdateOMAP2()
{


   EQ[1] = vox[0] + extnt[0]*omaprat[2];

   update_struct();
   
}

void UpdateSLAB2()
{

   slab[1] = extnt[0]*omaprat[3];

   update_struct();
   
}

void UpdateOMAP3()
{

   EQ[2] = vox[1] + extnt[1]*omaprat[4];

   update_struct();
   
}

void UpdateSLAB3()
{

   slab[2] = extnt[1]*omaprat[5];

   update_struct();
   
}

void RedrawOMAP()
{
   int i;

   if (!OMAPup) return;

   butje(OMAPwin,0,0,230,300,4,0,-15,1,None,0,0,0,0);
   ULineString(OMAPwin,"Clip Planes:",20,20);
   LineString(OMAPwin,"Position",20,35);
   LineString(OMAPwin,"Separation",140,35);

   LineString(OMAPwin,"Z",25,48);
   LineString(OMAPwin,"X",55,48);
   LineString(OMAPwin,"Y",85,48);

   LineString(OMAPwin,"Z",145,48);
   LineString(OMAPwin,"X",175,48);
   LineString(OMAPwin,"Y",205,48);

   sprintf(atemp,"Contour Value [ 0.0 - %5.2f]:",*rng2);
   ULineString(OMAPwin,atemp,20,170);

   LineString(OMAPwin,"Residue",180,195);
   LineString(OMAPwin,"Follow",180,205);

   LineString(OMAPwin,"Use Shift Scroll Wheel",20,225);
   LineString(OMAPwin,"Transparent/Lined surface",40,253);

   for (i=0; i<6; i++) RedrawSlide(&omapscr[i]);

   PromptBox(&qboxes[QCNT]);
   if (omapPandN) PromptBox(&qboxes[QCNT2]);

   for (i=0; i<4; i++) DrwBut(&butomap[i]);

}

#ifdef DOGL
static GLdouble theEQ1[4] = {  0.0,  0.0, -1.0, 0.0};
static GLdouble theEQ2[4] = {  0.0,  0.0,  1.0, 0.0};
static GLdouble theEQ3[4] = { -1.0,  0.0,  0.0, 0.0};
static GLdouble theEQ4[4] = {  1.0,  0.0,  0.0, 0.0};
static GLdouble theEQ5[4] = {  0.0, -1.0,  0.0, 0.0};
static GLdouble theEQ6[4] = {  0.0,  1.0,  0.0, 0.0};
#else
static double theEQ1[4] = {  0.0,  0.0, -1.0, 0.0};
static double theEQ2[4] = {  0.0,  0.0,  1.0, 0.0};
static double theEQ3[4] = { -1.0,  0.0,  0.0, 0.0};
static double theEQ4[4] = {  1.0,  0.0,  0.0, 0.0};
static double theEQ5[4] = {  0.0, -1.0,  0.0, 0.0};
static double theEQ6[4] = {  0.0,  1.0,  0.0, 0.0};
#endif

void InitOmap(iopt)
int iopt;
{
   int i;
#ifdef DOGL
   GLdouble d[3];
#else
   double d[3];
#endif
   
   OMAPup = 1;
   OMAPtype = 0;

   omapPandN = iopt;

   OMAPwin = CreateWindow("CCP4 display","-30+30",230,300,
	 		 infobg,infofg,(Window)0);

   subOMAP = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],OMAPwin);
   XSelectInput(display, OMAPwin, 
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask 
		| ButtonMotionMask | LeaveWindowMask | EnterWindowMask);
   XMapWindow(display,OMAPwin);

   WinObj[24].win = &OMAPwin;
   WinObj[24].subwin = &subOMAP;
   WinObj[24].butarr = butomap;
   WinObj[24].numbut = 4;
   WinObj[24].winup = &OMAPup;
   WinObj[24].init = InitOmap;
   WinObj[24].redraw = RedrawOMAP;

   getcval();

   DefBut(&butomap[0], OMAPwin, 100, 265, 50, 23,
	"Close", infobg, -15);

   DefBut(&butomap[2], OMAPwin, 75, 180, 50, 23,
	"Apply", infobg, -15);

   DefBut(&butomap[1], OMAPwin, 155, 185, 15, 15,
	"", infobg, -15);

   DefBut(&butomap[3], OMAPwin, 20, 240, 15, 15,
	"", infobg, -15);

   omapwn[0] = 100; omapwpos[0] = 100;
   DefSlide(&omapscr[0],OMAPwin,20,50,20,100,10,&omapwn[0],&omapwpos[0],
	&omaprat[0], UpdateOMAP1);

   omapwn[1] = 100; omapwpos[1] = 100;
   DefSlide(&omapscr[1],OMAPwin,140,50,20,100,10,
	&omapwn[1],&omapwpos[1],
	&omaprat[1], UpdateSLAB1);

   omapwn[2] = 100; omapwpos[2] = 100;
   DefSlide(&omapscr[2],OMAPwin,50,50,20,100,10,
	&omapwn[2],&omapwpos[2],
	&omaprat[2], UpdateOMAP2);

   omapwn[3] = 100; omapwpos[3] = 100;
   DefSlide(&omapscr[3],OMAPwin,170,50,20,100,10,&omapwn[3],&omapwpos[3],
	&omaprat[3], UpdateSLAB2);

   omapwn[4] = 100; omapwpos[4] = 100;
   DefSlide(&omapscr[4],OMAPwin,80,50,20,100,10,
	&omapwn[4],&omapwpos[4],
	&omaprat[4], UpdateOMAP3);

   omapwn[5] = 100; omapwpos[5] = 100;
   DefSlide(&omapscr[5],OMAPwin,200,50,20,100,10,
	&omapwn[5],&omapwpos[5],
	&omaprat[5], UpdateSLAB3);

// 

   crossprd(comsrfptr->v2,comsrfptr->v1,d);
#ifdef DOGL
   improduct(d,comsrfptr->vo,&vox[2]);
#endif
   for (i=0; i<3; i++) {
	theEQ1[i] = -d[i];
	theEQ2[i] =  d[i];
   }

//

   crossprd(comsrfptr->v1,comsrfptr->v3,d);
#ifdef DOGL
   improduct(d,comsrfptr->vo,&vox[1]);
#endif
   for (i=0; i<3; i++) {
	theEQ5[i] = -d[i];
	theEQ6[i] =  d[i];
   }

//

   crossprd(comsrfptr->v3,comsrfptr->v2,d);
#ifdef DOGL
   improduct(d,comsrfptr->vo,&vox[0]);
#endif

   for (i=0; i<3; i++) {
	theEQ3[i] = -d[i];
	theEQ4[i] =  d[i];
   }

   extnt[0] = comsrfptr->r[0];
   extnt[1] = comsrfptr->r[1];
   extnt[2] = comsrfptr->r[2];

   slab[0] = extnt[2];
   EQ[0] = vox[2] + slab[0];

   slab[1] = extnt[0];
   EQ[1] = vox[0] + slab[1];

   slab[2] = extnt[1];
   EQ[2] = vox[1] + slab[2];

   omapsrf = NSurf[istruct];
   NSurf[istruct]++;
   if (omapPandN && !(*rng1 >= 0.0) ) NSurf[istruct]++;

   omapcnt1 = atof(qboxes[QCNT].str);
   disp_map(NULL);

}

void DeleteOMAP()
{
   int i;

   XSync(display, False);
   XDestroyWindow(display,OMAPwin);
   XSync(display, False);
   omapfol = 0;
   omapCa = -1;
   if (omaplck) {
  	for (i=0; i<3; i++) rotptr->t[i] = omapt[i];
	omaplck = 0;
   }
   OMAPup = 0;
#ifdef DOGL
   DeleteSurface(omapsrf);
   deletebox();
#endif
   update_struct();
}


static COMSRFSTRU clpsrf;

void UpdOMAP1()
{

/*
   EQ[0] is set here but it is not actually used anymore
   same goes for updOMAP1, just the equation in dispsf is used
*/
   EQ[0] = rotptr->t[2] + 2.0*scalptr->scali*omaprat[0];

   update_struct();
   
}

void RedrwOMAP()
{
   int i;

   if (!OMAPup) return;

   butje(OMAPwin,0,0,230,280,4,0,-15,1,None,0,0,0,0);
   ULineString(OMAPwin,"Clip Planes:",20,20);

   LineString(OMAPwin,"Near",23,45);

   LineString(OMAPwin,"Far",143,45);

   RedrawSlide(&omapscr[0]);
   RedrawSlide(&omapscr[1]);

   DrwBut(&butomap[0]);

}

void IniOmap()
{
   int i;
   double tmp2[3];
   
   OMAPup = 1;
   OMAPtype = 1;
   omapsrf = -1;

   OMAPwin = CreateWindow("OMAP display","-30+30",230,280,
	 		 infobg,infofg,(Window)0);

   subOMAP = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],OMAPwin);
   XSelectInput(display, OMAPwin, 
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask 
		| ButtonMotionMask | LeaveWindowMask | EnterWindowMask);
   XMapWindow(display,OMAPwin);

   WinObj[24].win = &OMAPwin;
   WinObj[24].subwin = &subOMAP;
   WinObj[24].butarr = butomap;
   WinObj[24].numbut = 1;
   WinObj[24].winup = &OMAPup;
   WinObj[24].init = IniOmap;
   WinObj[24].redraw = RedrwOMAP;

   DefBut(&butomap[0], OMAPwin, 100, 245, 50, 23,
	"Close", infobg, -15);

   omapwn[1] = 100; omapwpos[1] = 100;
   DefSlide(&omapscr[1],OMAPwin,20,50,20,100,10,&omapwn[1],&omapwpos[1],
	&omaprat[1], UpdateSLAB1);

   omapwn[0] = 100; omapwpos[0] = 0;
   DefSlide(&omapscr[0],OMAPwin,140,50,20,100,10,&omapwn[0],&omapwpos[0],
	&omaprat[0], UpdOMAP1);

   theEQ1[2] = -1.0*theEQ1[2];
   theEQ2[2] = -1.0*theEQ2[2];


   extnt[2] = 2.0*scalptr->scali;
   slab[0] = extnt[2];
   EQ[0] = rotptr->t[2] + 2.0*scalptr->scali;

/*
   EQ[0] is set here but it is not actually used anymore
   same goes for updOMAP1
*/

   if (denmode) {
     slab[1] = 2.0*scalptr->scali;
     EQ[1] = rotptr->t[0] - scalptr->scali + slab[1];
   } else {
     slab[1] = 2.0*scl[istruct];
     EQ[1] = rotptr->t[0] - scl[istruct] + slab[1];
   }

   if (denmode) {
     slab[2] = 2.0*scalptr->scali;
     EQ[2] = rotptr->t[1] - scalptr->scali + slab[2];
   } else {
     slab[2] = 2.0*scl[istruct];
     EQ[2] = rotptr->t[1] - scl[istruct] + slab[2];
   }


   for (i=0; i<NSurf[istruct]; i++) {
	if (SSon[istruct][i]) clp[istruct][i] = 1;
   }

}


#if defined(VMS) || defined(UNDERSC)
void rdvasp(npts1,npts2,npts3,iposng,istat,lenf,idocub,idebug)
#else
#ifdef CRAY
void RDVASP(npts1,npts2,npts3,iposng,istat,lenf,idocub,idebug)
#else
void rdvasp_(npts1,npts2,npts3,iposng,istat,lenf,idocub,idebug)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *iposng;
int *istat;
int *lenf;
int *idocub;
int *idebug;
{

#if defined(VMS) || defined(UNDERSC)
	rdvasd(npts1,npts2,npts3,iposng,istat,lenf,idocub,idebug,
#else
#ifdef CRAY
	RDVASD(npts1,npts2,npts3,iposng,istat,lenf,idocub,idebug,
#else
	rdvasd_(npts1,npts2,npts3,iposng,istat,lenf,idocub,idebug,
#endif
#endif
	sgrd.denn,sgrd.pmnn,sgrd.bucket,
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	&cell->natc,&cell->norg,&cell->icent,&cell->inorm,
	&cell->ncon,&cell->nspg,&cell->ichx,
	&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdinfo(npts1,npts2,isubtr,istat)
#else
#ifdef CRAY
void RDINFO(npts1,npts2,isubtr,istat)
#else
void rdinfo_(npts1,npts2,isubtr,istat)
#endif
#endif
int *npts1;
int *npts2;
int *isubtr;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdinfd(npts1,npts2,isubtr,istat,
#else
#ifdef CRAY
	RDINFD(npts1,npts2,isubtr,istat,
#else
	rdinfd_(npts1,npts2,isubtr,istat,
#endif
#endif
	sgrd.dens,sgrd.denst);
}

#if defined(VMS) || defined(UNDERSC)
void rd3inf(npts1,npts2,npts3,isubtr,adjus,istat)
#else
#ifdef CRAY
void RD3INF(npts1,npts2,npts3,isubtr,adjus,istat)
#else
void rd3inf_(npts1,npts2,npts3,isubtr,adjus,istat)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *isubtr;
double *adjus;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rd3ind(npts1,npts2,npts3,isubtr,adjus,istat,
#else
#ifdef CRAY
	RD3IND(npts1,npts2,npts3,isubtr,adjus,istat,
#else
	rd3ind_(npts1,npts2,npts3,isubtr,adjus,istat,
#endif
#endif
	sgrd.denn,sgrd.pmnn,sgrd.denst);
}

#if defined(VMS) || defined(UNDERSC)
void rd3chk(npts1,npts2,npts3,igauss,impas,istat)
#else
#ifdef CRAY
void RD3CHK(npts1,npts2,npts3,igauss,impas,istat)
#else
void rd3chk_(npts1,npts2,npts3,igauss,impas,istat)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
int *igauss;
int *impas;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rd3chd(npts1,npts2,npts3,igauss,impas,istat,
#else
#ifdef CRAY
	RD3CHD(npts1,npts2,npts3,igauss,impas,istat,
#else
	rd3chd_(npts1,npts2,npts3,igauss,impas,istat,
#endif
#endif
	mgrd.fmap);
}

#if defined(VMS) || defined(UNDERSC)
void oginid(double *r, double *adjus, int *natoms, int *nat, int *icol,
#else
#ifdef CRAY
void OGINID(double *r, double *adjus, int *natoms, int *nat, int *icol,
#else
void oginid_(double *r, double *adjus, int *natoms, int *nat, int *icol,
#endif
#endif
       double *xsym, double *ysym, double *zsym, double *vdwr,
       double *cnst, int *nnpts1, int *nnpts2, int *iorb, double *dens);

#if defined(VMS) || defined(UNDERSC)
void oginit(r,adjus,natoms,nat,icol,xsym,ysym,zsym,vdwr,cnst,npts1,npts2,iorb)
#else
#ifdef CRAY
void OGINIT(r,adjus,natoms,nat,icol,xsym,ysym,zsym,vdwr,cnst,npts1,npts2,iorb)
#else
void oginit_(r,adjus,natoms,nat,icol,xsym,ysym,zsym,vdwr,cnst,npts1,npts2,iorb)
#endif
#endif
double *r, *adjus;
int *natoms, *nat, *icol;
double *xsym, *ysym, *zsym;
double *vdwr;
double *cnst;
int *npts1;
int *npts2;
int *iorb;
{

#if defined(VMS) || defined(UNDERSC)
        oginid(r,adjus,natoms,nat,icol,xsym,ysym,zsym,vdwr,cnst,npts1,
		npts2,iorb,sgrd.dens);
#else
#ifdef CRAY
        OGINID(r,adjus,natoms,nat,icol,xsym,ysym,zsym,vdwr,cnst,npts1,
		npts2,iorb,sgrd.dens);
#else
        oginid_(r,adjus,natoms,nat,icol,xsym,ysym,zsym,vdwr,cnst,npts1,
		npts2,iorb,sgrd.dens);
#endif
#endif

}

#if defined(VMS) || defined(UNDERSC)
void wrinfo(npts1,npts2)
#else
#ifdef CRAY
void WRINFO(npts1,npts2)
#else
void wrinfo_(npts1,npts2)
#endif
#endif
int *npts1;
int *npts2;
{

#if defined(VMS) || defined(UNDERSC)
	wrinfd(npts1,npts2,
#else
#ifdef CRAY
	WRINFD(npts1,npts2,
#else
	wrinfd_(npts1,npts2,
#endif
#endif
	sgrd.dens);
}

#if defined(VMS) || defined(UNDERSC)
void wr3inf(npts1,npts2,npts3,adjus)
#else
#ifdef CRAY
void WR3INF(npts1,npts2,npts3,adjus)
#else
void wr3inf_(npts1,npts2,npts3,adjus)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
double *adjus;
{

#if defined(VMS) || defined(UNDERSC)
	wr3ind(npts1,npts2,npts3,adjus,
#else
#ifdef CRAY
	WR3IND(npts1,npts2,npts3,adjus,
#else
	wr3ind_(npts1,npts2,npts3,adjus,
#endif
#endif
	sgrd.denn);
}

#if defined(VMS) || defined(UNDERSC)
void spaced(npts1,npts2,npts3,valcnt,idofil,adjus,ipsprt,idisml,idvrml,mapit)
#else
#ifdef CRAY
void SPACED(npts1,npts2,npts3,valcnt,idofil,adjus,ipsprt,idisml,idvrml,mapit)
#else
void spaced_(npts1,npts2,npts3,valcnt,idofil,adjus,ipsprt,idisml,idvrml,mapit)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
double *valcnt;
int *idofil;
double *adjus;
int *ipsprt;
int *idisml;
int *idvrml;
int *mapit;
{

#if defined(VMS) || defined(UNDERSC)
   spacdd(npts1,npts2,npts3,valcnt,idofil,adjus,ipsprt,idisml,idvrml,mapit,
#else
#ifdef CRAY
   SPACDD(npts1,npts2,npts3,valcnt,idofil,adjus,ipsprt,idisml,idvrml,mapit,
#else
   spacdd_(npts1,npts2,npts3,valcnt,idofil,adjus,ipsprt,idisml,idvrml,mapit,
#endif
#endif
	sgrd.denn,sgrd.pmnn,sgrd.iedlog,mgrd.fmap);
}

#if defined(VMS) || defined(UNDERSC)
void spasrf(npts1,npts2,npts3,valcnt)
#else
#ifdef CRAY
void SPASRF(npts1,npts2,npts3,valcnt)
#else
void spasrf_(npts1,npts2,npts3,valcnt)
#endif
#endif
int *npts1;
int *npts2;
int *npts3;
double *valcnt;
{

#if defined(VMS) || defined(UNDERSC)
	spasrd(npts1,npts2,npts3,valcnt,
#else
#ifdef CRAY
	SPASRD(npts1,npts2,npts3,valcnt,
#else
	spasrd_(npts1,npts2,npts3,valcnt,
#endif
#endif
	sgrd.denn,sgrd.pmnn,sgrd.dens,sgrd.iedlog);
}

#if defined(VMS) || defined(UNDERSC)
void isoden(valc,nvalc,scincr,nespt,iwhere)
#else
#ifdef CRAY
void ISODEN(valc,nvalc,scincr,nespt,iwhere)
#else
void isoden_(valc,nvalc,scincr,nespt,iwhere)
#endif
#endif
double *valc;
int *nvalc;
double *scincr;
int *nespt;
int *iwhere;
{

#if defined(VMS) || defined(UNDERSC)
	isoded(valc,nvalc,scincr,nespt,iwhere,
#else
#ifdef CRAY
	ISODED(valc,nvalc,scincr,nespt,iwhere,
#else
	isoded_(valc,nvalc,scincr,nespt,iwhere,
#endif
#endif
	sgrd.dens,sgrd.iedlog);
}

#if defined(VMS) || defined(UNDERSC)
void rdcpmdd(idebug,ibefo,istatio,ioxyz,irtype,ihsend,istats)
#else
#ifdef CRAY
void RDCPMDD(idebug,ibefo,istatio,ioxyz,irtype,ihsend,istats)
#else
void rdcpmdd_(idebug,ibefo,istatio,ioxyz,irtype,ihsend,istats)
#endif
#endif
int *idebug;
int *ibefo;
int *istatio;
int *ioxyz;
int *irtype;
int *ihsend;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdcpmddd(idebug,ibefo,istatio,ioxyz,irtype,ihsend,istats,
#else
#ifdef CRAY
	RDCPMDDD(idebug,ibefo,istatio,ioxyz,irtype,ihsend,istats,
#else
	rdcpmddd_(idebug,ibefo,istatio,ioxyz,irtype,ihsend,istats,
#endif
#endif
	dorbp->vectrs,dorbp->vectrb,dorbp->focc,dorbp->focb,dorbp->eiga,
	dorbp->eigb,dorbp->nocc,dorbp->nocb,dorbp->ncols,dorbp->ncolb);

}

/* END shadow C routines for Fortran routines to pass grid pointers */

/* shadow C routines for Fortran routines to pass coordinate pointers */

void anim()
{
#if defined(VMS) || defined(UNDERSC)
	anid(xyzp->coo,xyzp->ianz);
#else
#ifdef CRAY
	ANID(xyzp->coo,xyzp->ianz);
#else
	anid_(xyzp->coo,xyzp->ianz);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void actami(inum,ikleur,iopt,idosrf)
#else
#ifdef CRAY
void ACTAMI(inum,ikleur,iopt,idosrf)
#else
void actami_(inum,ikleur,iopt,idosrf)
#endif
#endif
int *inum;
int *ikleur;
int *iopt;
int *idosrf;
{

#if defined(VMS) || defined(UNDERSC)
	actamd(inum,ikleur,iopt,idosrf,
#else
#ifdef CRAY
	ACTAMD(inum,ikleur,iopt,idosrf,
#else
	actamd_(inum,ikleur,iopt,idosrf,
#endif
#endif
	xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->isurf,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,
	calfptr->ihet,calfptr->iclhet,calfptr->reson,calfptr->iams,
	calfptr->isal,&calfptr->ishoh,&calfptr->ision);

}

#if defined(VMS) || defined(UNDERSC)
void actexp(que,lque,ikleur,idosrf)
#else
#ifdef CRAY
void ACTEXP(que,lque,ikleur,idosrf)
#else
void actexp_(que,lque,ikleur,idosrf)
#endif
#endif
int *que;
int *lque;
int *ikleur;
int *idosrf;
{

#if defined(VMS) || defined(UNDERSC)
	actexd(que,lque,ikleur,idosrf,
#else
#ifdef CRAY
	ACTEXD(que,lque,ikleur,idosrf,
#else
	actexd_(que,lque,ikleur,idosrf,
#endif
#endif
	&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void caldip()
#else
#ifdef CRAY
void CALDIP()
#else
void caldip_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
	caldid(
#else
#ifdef CRAY
	CALDID(
#else
	caldid_(
#endif
#endif
	xyzp->qat,xyzp->coo);
}

#if defined(VMS) || defined(UNDERSC)
void aacom(vrad,ires,str,nstr,istsrf)
#else
#ifdef CRAY
void AACOM(vrad,ires,str,nstr,istsrf)
#else
void aacom_(vrad,ires,str,nstr,istsrf)
#endif
#endif
double *vrad;
int *ires;
int *nstr;
int *istsrf;
char *str;
{

#if defined(VMS) || defined(UNDERSC)
	aacod(vrad,ires,str,nstr,istsrf,
#else
#ifdef CRAY
	AACOD(vrad,ires,str,nstr,istsrf,
#else
	aacod_(vrad,ires,str,nstr,istsrf,
#endif
#endif
	xyzp->iresid,xyzp->isurf,
        &calfptr->ncalf,calfptr->ianf,calfptr->islu,
        &calfptr->nchain,calfptr->iamino,calfptr->ihet,calfptr->reson,
	calfptr->isal,calfptr->irsnr,calfptr->achain);

}

#if defined(VMS) || defined(UNDERSC)
void actcal(iopt)
#else
#ifdef CRAY
void ACTCAL(iopt)
#else
void actcal_(iopt)
#endif
#endif
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	actcad(iopt,
#else
#ifdef CRAY
	ACTCAD(iopt,
#else
	actcad_(iopt,
#endif
#endif
	xyzp->iaton,xyzp->iatclr,xyzp->iresid,
	calfptr->icalf,calfptr->ianf,calfptr->islu,&calfptr->nchain,
	calfptr->iamino,calfptr->ibck);

}

#if defined(VMS) || defined(UNDERSC)
void acthel(iopt,iscnd,jcolsp,inclbb)
#else
#ifdef CRAY
void ACTHEL(iopt,iscnd,jcolsp,inclbb)
#else
void acthel_(iopt,iscnd,jcolsp,inclbb)
#endif
#endif
int *iopt;
int *iscnd;
int *jcolsp;
int *inclbb;
{

#if defined(VMS) || defined(UNDERSC)
	acthed(iopt,iscnd,jcolsp,inclbb,
#else
#ifdef CRAY
	ACTHED(iopt,iscnd,jcolsp,inclbb,
#else
	acthed_(iopt,iscnd,jcolsp,inclbb,
#endif
#endif
	xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	calfptr->icalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->ihet,calfptr->reson,
	calfptr->isal,calfptr->ibck);

}

#if defined(VMS) || defined(UNDERSC)
void actss(iopt)
#else
#ifdef CRAY
void ACTSS(iopt)
#else
void actss_(iopt)
#endif
#endif
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	actsd(iopt,
#else
#ifdef CRAY
	ACTSD(iopt,
#else
	actsd_(iopt,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void pmfass(iopt,dochg)
#else
#ifdef CRAY
void PMFASS(iopt,dochg)
#else
void pmfass_(iopt,dochg)
#endif
#endif
int *iopt;
int *dochg;
{

#if defined(VMS) || defined(UNDERSC)
	pmfasd(iopt,dochg,
#else
#ifdef CRAY
	PMFASD(iopt,dochg,
#else
	pmfasd_(iopt,dochg,
#endif
#endif
	xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->ityp,
	&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void dfiass()
#else
#ifdef CRAY
void DFIASS()
#else
void dfiass_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	dfiasd(
#else
#ifdef CRAY
	DFIASD(
#else
	dfiasd_(
#endif
#endif
	xyzp->ityp,
	&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void updres()
#else
#ifdef CRAY
void UPDRES()
#else
void updres_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	updred(
#else
#ifdef CRAY
	UPDRED(
#else
	updred_(
#endif
#endif
	xyzp->coo,
	&calfptr->ncalf,calfptr->icalf);

}

#if defined(VMS) || defined(UNDERSC)
void dfires()
#else
#ifdef CRAY
void DFIRES()
#else
void dfires_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	dfired(
#else
#ifdef CRAY
	DFIRED(
#else
	dfired_(
#endif
#endif
	xyzp->coo,
	calfptr->icalf,&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void twodfi(tdfi,ires1,ires2)
#else
#ifdef CRAY
void TWODFI(tdfi,ires1,ires2)
#else
void twodfi_(tdfi,ires1,ires2)
#endif
#endif
double *tdfi;
int *ires1;
int *ires2;
{

#if defined(VMS) || defined(UNDERSC)
	twodfd(tdfi,ires1,ires2,
#else
#ifdef CRAY
	TWODFD(tdfi,ires1,ires2,
#else
	twodfd_(tdfi,ires1,ires2,
#endif
#endif
	xyzp->coo,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void twodfib(tdfi,ires1,ires2)
#else
#ifdef CRAY
void TWODFIB(tdfi,ires1,ires2)
#else
void twodfib_(tdfi,ires1,ires2)
#endif
#endif
double *tdfi;
int *ires1;
int *ires2;
{

#if defined(VMS) || defined(UNDERSC)
	twodfid(tdfi,ires1,ires2,
#else
#ifdef CRAY
	TWODFID(tdfi,ires1,ires2,
#else
	twodfid_(tdfi,ires1,ires2,
#endif
#endif
	xyzp->coo,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void onedfi(tdfi,ires1)
#else
#ifdef CRAY
void ONEDFI(tdfi,ires1)
#else
void onedfi_(tdfi,ires1)
#endif
#endif
double *tdfi;
int *ires1;
{

#if defined(VMS) || defined(UNDERSC)
	onedfd(tdfi,ires1,
#else
#ifdef CRAY
	ONEDFD(tdfi,ires1,
#else
	onedfd_(tdfi,ires1,
#endif
#endif
	xyzp->coo,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void totpmf(totpmf)
#else
#ifdef CRAY
void TOTPMF(totpmf)
#else
void totpmf_(totpmf)
#endif
#endif
double *totpmf;
{

#if defined(VMS) || defined(UNDERSC)
	totpmd(totpmf,
#else
#ifdef CRAY
	TOTPMD(totpmf,
#else
	totpmd_(totpmf,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void pmfinf(iatm)
#else
#ifdef CRAY
void PMFINF(iatm)
#else
void pmfinf_(iatm)
#endif
#endif
int *iatm;
{

#if defined(VMS) || defined(UNDERSC)
	pmfind(iatm,
#else
#ifdef CRAY
	PMFIND(iatm,
#else
	pmfind_(iatm,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void ipmtyp(iptm,iat,ian,idochg)
#else
#ifdef CRAY
void IPMTYP(iptm,iat,ian,idochg)
#else
void ipmtyp_(iptm,iat,ian,idochg)
#endif
#endif
int *iptm;
int *iat;
int *ian;
int *idochg;
{

#if defined(VMS) || defined(UNDERSC)
	ipmtyd(iptm,iat,ian,idochg,
#else
#ifdef CRAY
	IPMTYD(iptm,iat,ian,idochg,
#else
	ipmtyd_(iptm,iat,ian,idochg,
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void clmon(car,pot)
#else
#ifdef CRAY
void CLMON(car,pot)
#else
void clmon_(car,pot)
#endif
#endif
double *car;
double *pot;
{

#if defined(VMS) || defined(UNDERSC)
	clmod(car,pot,
#else
#ifdef CRAY
	CLMOD(car,pot,
#else
	clmod_(car,pot,
#endif
#endif
	xyzp->coo,xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void clmons(car,pot,idoloc)
#else
#ifdef CRAY
void CLMONS(car,pot,idoloc)
#else
void clmons_(car,pot,idoloc)
#endif
#endif
double *car;
double *pot;
int *idoloc;
{

#if defined(VMS) || defined(UNDERSC)
	clmond(car,pot,idoloc,
#else
#ifdef CRAY
	CLMOND(car,pot,idoloc,
#else
	clmond_(car,pot,idoloc,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->icont,xyzp->ncont);
}

#if defined(VMS) || defined(UNDERSC)
void calfa(istat,istpdb,iaddh,ioatms,nstrt,ioadd)
#else
#ifdef CRAY
void CALFA(istat,istpdb,iaddh,ioatms,nstrt,ioadd)
#else
void calfa_(istat,istpdb,iaddh,ioatms,nstrt,ioadd)
#endif
#endif
int *istat;
int *istpdb;
int *iaddh;
int *ioatms;
int *nstrt;
int *ioadd;
{

#if defined(VMS) || defined(UNDERSC)
	calfd(istat,istpdb,iaddh,ioatms,nstrt,ioadd,
#else
#ifdef CRAY
	CALFD(istat,istpdb,iaddh,ioatms,nstrt,ioadd,
#else
	calfd_(istat,istpdb,iaddh,ioatms,nstrt,ioadd,
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->ityp,
        calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,
	calfptr->isal,calfptr->irsnr,&calfptr->ihashb,
	calfptr->rphi,calfptr->rpsi);

}

#if defined(VMS) || defined(UNDERSC)
void docct()
#else
#ifdef CRAY
void DOCCT()
#else
void docct_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	doccd(
#else
#ifdef CRAY
	DOCCD(
#else
	doccd_(
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void docent()
#else
#ifdef CRAY
void DOCENT()
#else
void docent_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	docend(
#else
#ifdef CRAY
	DOCEND(
#else
	docend_(
#endif
#endif
	rotptr->t,xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void valdis(var,ipntr,numat,iop,iasel,istat)
#else
#ifdef CRAY
void VALDIS(var,ipntr,numat,iop,iasel,istat)
#else
void valdis_(var,ipntr,numat,iop,iasel,istat)
#endif
#endif
double *var;
int *ipntr;
int *numat;
int *iop;
int *iasel;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	valdid(var,ipntr,numat,iop,iasel,istat,
#else
#ifdef CRAY
	VALDID(var,ipntr,numat,iop,iasel,istat,
#else
	valdid_(var,ipntr,numat,iop,iasel,istat,
#endif
#endif
	xyzp->ianz,xyzp->iresid,xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void eemcalc(var,ipntr,numat)
#else
#ifdef CRAY
void EEMCALC(var,ipntr,numat)
#else
void eemcalc_(var,ipntr,numat)
#endif
#endif
double *var;
int *numat;
int *ipntr;
{

#if defined(VMS) || defined(UNDERSC)
	eemcald(var,ipntr,numat,
#else
#ifdef CRAY
	EEMCALD(var,ipntr,numat,
#else
	eemcald_(var,ipntr,numat,
#endif
#endif
	xyzp->ianz,xyzp->coo,xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void distchk()
#else
#ifdef CRAY
void DISTCHK()
#else
void distchk_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	distchd(
#else
#ifdef CRAY
	DISTCHD(
#else
	distchd_(
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void calgas(iasel,iprnt,istat)
#else
#ifdef CRAY
void CALGAS(iasel,iprnt,istat)
#else
void calgas_(iasel,iprnt,istat)
#endif
#endif
int *iasel;
int *iprnt;
int *istat;
{
   int memstat,i,ff;
   short int j;
   short int *ityp;

   memstat = 1;

   ff = *fftyp;

   if ((ityp = (short int *) malloc((sizeof j)*(*xyzp->iatoms))) == NULL) {
	memstat = 0;
   } else {
	for (i = 0; i < *xyzp->iatoms; i++) ityp[i] = xyzp->ityp[i];
   }

#if defined(VMS) || defined(UNDERSC)
	calgad(iasel,iprnt,istat,
#else
#ifdef CRAY
	CALGAD(iasel,iprnt,istat,
#else
	calgad_(iasel,iprnt,istat,
#endif
#endif
	xyzp->qat,xyzp->ianz,xyzp->iconn,xyzp->iresid,xyzp->ityp);

   if (memstat) {
	for (i = 0; i < *xyzp->iatoms; i++) xyzp->ityp[i] = ityp[i];
	free(ityp);
	*fftyp = ff;
   }
}

#if defined(VMS) || defined(UNDERSC)
void mkscon(c,rad,grdw,iptr,npts)
#else
#ifdef CRAY
void MKSCON(c,rad,grdw,iptr,npts)
#else
void mkscon_(c,rad,grdw,iptr,npts)
#endif
#endif
double *c;
double *rad;
double *grdw;
int *iptr;
int *npts;
{

#if defined(VMS) || defined(UNDERSC)
	mkscod(c,rad,grdw,iptr,npts,
#else
#ifdef CRAY
	MKSCOD(c,rad,grdw,iptr,npts,
#else
	mkscod_(c,rad,grdw,iptr,npts,
#endif
#endif
	xyzp->coo,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void connlp(dens,idomap,isp)
#else
#ifdef CRAY
void CONNLP(dens,idomap,isp)
#else
void connlp_(dens,idomap,isp)
#endif
#endif
int *dens;
int *idomap;
int *isp;
{

#if defined(VMS) || defined(UNDERSC)
	connld(dens,idomap,isp,
#else
#ifdef CRAY
	CONNLD(dens,idomap,isp,
#else
	connld_(dens,idomap,isp,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,xyzp->isurf);

}


#if defined(VMS) || defined(UNDERSC)
void allsrf(docol,idomap,idocal,isp)
#else
#ifdef CRAY
void ALLSRF(docol,idomap,idocal,isp)
#else
void allsrf_(docol,idomap,idocal,isp)
#endif
#endif
int *docol;
int *idomap;
int *idocal;
int *isp;
{

#if defined(VMS) || defined(UNDERSC)
	allsrd(docol,idomap,idocal,isp,
#else
#ifdef CRAY
	ALLSRD(docol,idomap,idocal,isp,
#else
	allsrd_(docol,idomap,idocal,isp,
#endif
#endif
	xyzp->isurf,xyzp->iaton,xyzp->ianz,xyzp->iatclr);

}

#if defined(VMS) || defined(UNDERSC)
void alasrf()
#else
#ifdef CRAY
void ALASRF()
#else
void alasrf_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	alasrd(
#else
#ifdef CRAY
	ALASRD(
#else
	alasrd_(
#endif
#endif
	xyzp->iresid,xyzp->isurf,calfptr->iams,calfptr->ihets);

}

#if defined(VMS) || defined(UNDERSC)
void clrsrf()
#else
#ifdef CRAY
void CLRSRF()
#else
void clrsrf_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	clrsrd(
#else
#ifdef CRAY
	CLRSRD(
#else
	clrsrd_(
#endif
#endif
	xyzp->isurf);

}

#if defined(VMS) || defined(UNDERSC)
void propnt(qx,qy,qz,ipen)
#else
#ifdef CRAY
void PROPNT(qx,qy,qz,ipen)
#else
void propnt_(qx,qy,qz,ipen)
#endif
#endif
double *qx;
double *qy;
double *qz;
int *ipen;
{


#if defined(VMS) || defined(UNDERSC)
	propnd(qx,qy,qz,ipen,
#else
#ifdef CRAY
	PROPND(qx,qy,qz,ipen,
#else
	propnd_(qx,qy,qz,ipen,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void getfr(istat)
#else
#ifdef CRAY
void GETFR(istat)
#else
void getfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getfd(istat,
#else
#ifdef CRAY
	GETFD(istat,
#else
	getfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void ggetfr(istat)
#else
#ifdef CRAY
void GGETFR(istat)
#else
void ggetfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	ggetfd(istat,
#else
#ifdef CRAY
	GGETFD(istat,
#else
	ggetfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void getfrm(istat)
#else
#ifdef CRAY
void GETFRM(istat)
#else
void getfrm_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getfrd(istat,
#else
#ifdef CRAY
	GETFRD(istat,
#else
	getfrd_(istat,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void getfra(istat)
#else
#ifdef CRAY
void GETFRA(istat)
#else
void getfra_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getfrad(istat,
#else
#ifdef CRAY
	GETFRAD(istat,
#else
	getfrad_(istat,
#endif
#endif
	xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void nxtpnt(iopt,fancy,atcol,dolabs,backb,wpnt)
#else
#ifdef CRAY
void NXTPNT(iopt,fancy,atcol,dolabs,backb,wpnt)
#else
void nxtpnt_(iopt,fancy,atcol,dolabs,backb,wpnt)
#endif
#endif
int *iopt;
int *fancy;
int *atcol;
int *dolabs;
int *backb;
int *wpnt;
{

#if defined(VMS) || defined(UNDERSC)
	nxtpnd(iopt,fancy,atcol,dolabs,backb,wpnt,
#else
#ifdef CRAY
	NXTPND(iopt,fancy,atcol,dolabs,backb,wpnt,
#else
	nxtpnd_(iopt,fancy,atcol,dolabs,backb,wpnt,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void scalfr(iopt,fancy,atcol,dolabs,backb,wpnt)
#else
#ifdef CRAY
void SCALFR(iopt,fancy,atcol,dolabs,backb,wpnt)
#else
void scalfr_(iopt,fancy,atcol,dolabs,backb,wpnt)
#endif
#endif
int *iopt;
int *fancy;
int *atcol;
int *dolabs;
int *backb;
int *wpnt;
{

#if defined(VMS) || defined(UNDERSC)
	scalfd(iopt,fancy,atcol,dolabs,backb,wpnt,
#else
#ifdef CRAY
	SCALFD(iopt,fancy,atcol,dolabs,backb,wpnt,
#else
	scalfd_(iopt,fancy,atcol,dolabs,backb,wpnt,
#endif
#endif
	rotptr->t,xyzp->coo,
	&scalptr->scal,&scalptr->scali,&scalptr->smag);

}

#if defined(VMS) || defined(UNDERSC)
void resfr()
#else
#ifdef CRAY
void RESFR()
#else
void resfr_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	resfd(
#else
#ifdef CRAY
	RESFD(
#else
	resfd_(
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void tofcoo()
#else
#ifdef CRAY
void TOFCOO()
#else
void tofcoo_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	tofcod(
#else
#ifdef CRAY
	TOFCOD(
#else
	tofcod_(
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void iatnox(iatnx)
#else
#ifdef CRAY
void IATNOX(iatnx)
#else
void iatnox_(iatnx)
#endif
#endif
int *iatnx;
{

#if defined(VMS) || defined(UNDERSC)
	iatnod(iatnx,
#else
#ifdef CRAY
	IATNOD(iatnx,
#else
	iatnod_(iatnx,
#endif
#endif
	xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void gampoi(ipoint,istat,ioxyz)
#else
#ifdef CRAY
void GAMPOI(ipoint,istat,ioxyz)
#else
void gampoi_(ipoint,istat,ioxyz)
#endif
#endif
int *ipoint;
int *istat;
int *ioxyz;
{

#if defined(VMS) || defined(UNDERSC)
	gampod(ipoint,istat,ioxyz,
#else
#ifdef CRAY
	GAMPOD(ipoint,istat,ioxyz,
#else
	gampod_(ipoint,istat,ioxyz,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void gaupoi(istat)
#else
#ifdef CRAY
void GAUPOI(istat)
#else
void gaupoi_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	gaupod(istat,
#else
#ifdef CRAY
	GAUPOD(istat,
#else
	gaupod_(istat,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void getpoi(icomm,ifd,iff,doscl,ioatms,ioadd)
#else
#ifdef CRAY
void GETPOI(icomm,ifd,iff,doscl,ioatms,ioadd)
#else
void getpoi_(icomm,ifd,iff,doscl,ioatms,ioadd)
#endif
#endif
int *icomm;
int *ifd;
int *iff;
int *doscl;
int *ioatms;
int *ioadd;
{

#if defined(VMS) || defined(UNDERSC)
	getpod(icomm,ifd,iff,doscl,ioatms,ioadd,
#else
#ifdef CRAY
	GETPOD(icomm,ifd,iff,doscl,ioatms,ioadd,
#else
	getpod_(icomm,ifd,iff,doscl,ioatms,ioadd,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iconn,
	&scalptr->scal,&scalptr->scali,&scalptr->smag,
	&cell->natc,&cell->ichx,&cell->icrtp);

}

#if defined(VMS) || defined(UNDERSC)
void doconn()
#else
#ifdef CRAY
void DOCONN()
#else
void doconn_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	docond(
#else
#ifdef CRAY
	DOCOND(
#else
	docond_(
#endif
#endif
	xyzp->coo,xyzp->iconn,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void dohcon(ihflag)
#else
#ifdef CRAY
void DOHCON(ihflag)
#else
void dohcon_(ihflag)
#endif
#endif
int *ihflag;
{

#if defined(VMS) || defined(UNDERSC)
	dohcod(ihflag,
#else
#ifdef CRAY
	DOHCOD(ihflag,
#else
	dohcod_(ihflag,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn,xyzp->isurf);

}

#if defined(VMS) || defined(UNDERSC)
void nohcon()
#else
#ifdef CRAY
void NOHCON()
#else
void nohcon_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	nohcod(
#else
#ifdef CRAY
	NOHCOD(
#else
	nohcod_(
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void doscal()
#else
#ifdef CRAY
void DOSCAL()
#else
void doscal_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	doscad(
#else
#ifdef CRAY
	DOSCAD(
#else
	doscad_(
#endif
#endif
	rotptr->t,xyzp->coo,&posptr->zv,&posptr->pincr,
	&scalptr->scal,&scalptr->scali,&scalptr->smag,&scalptr->iscupd);

}

#if defined(VMS) || defined(UNDERSC)
void redcon()
#else
#ifdef CRAY
void REDCON()
#else
void redcon_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	redcod(
#else
#ifdef CRAY
	REDCOD(
#else
	redcod_(
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void domcon(ipt,idoall)
#else
#ifdef CRAY
void DOMCON(ipt,idoall)
#else
void domcon_(ipt,idoall)
#endif
#endif
int *ipt;
int *idoall;
{

#if defined(VMS) || defined(UNDERSC)
	domcod(ipt,idoall,&monmode,
#else
#ifdef CRAY
	DOMCOD(ipt,idoall,&monmode,
#else
	domcod_(ipt,idoall,&monmode,
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void getxyz(igetxy,heat,iaddprv)
#else
#ifdef CRAY
void GETXYZ(igetxy,heat,iaddprv)
#else
void getxyz_(igetxy,heat,iaddprv)
#endif
#endif
int *igetxy;
double *heat;
int *iaddprv;
{

#if defined(VMS) || defined(UNDERSC)
	getxyd(igetxy,heat,iaddprv,
#else
#ifdef CRAY
	GETXYD(igetxy,heat,iaddprv,
#else
	getxyd_(igetxy,heat,iaddprv,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iconn,xyzp->qat,
	&cell->natc,&cell->norg,&cell->icent,&cell->nspg,
	&cell->ichx,&cell->nopr,cell->ir,cell->it,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);


	if (*igetxy == -1) {

#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   getxyd(igetxy,heat,iaddprv,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   GETXYD(igetxy,heat,iaddprv,
#else
	   allcoo_(&addat,&ZERO);
	   getxyd_(igetxy,heat,iaddprv,
#endif
#endif
	   xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iconn,xyzp->qat,
	   &cell->natc,&cell->norg,&cell->icent,&cell->nspg,
	   &cell->ichx,&cell->nopr,cell->ir,cell->it,
	   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

        }
}

#if defined(VMS) || defined(UNDERSC)
void aln2ml(iopt,istat)
#else
#ifdef CRAY
void ALN2ML(iopt,istat)
#else
void aln2ml_(iopt,istat)
#endif
#endif
int *iopt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	aln2md(iopt,istat,
#else
#ifdef CRAY
	ALN2MD(iopt,istat,
#else
	aln2md_(iopt,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid);

}

#if defined(VMS) || defined(UNDERSC)
void alnrot(vec,irot)
#else
#ifdef CRAY
void ALNROT(vec,irot)
#else
void alnrot_(vec,irot)
#endif
#endif
double *vec;
int *irot;
{

#if defined(VMS) || defined(UNDERSC)
	alnrod(vec,irot,
#else
#ifdef CRAY
	ALNROD(vec,irot,
#else
	alnrod_(vec,irot,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void pckrot(istat,iatsel)
#else
#ifdef CRAY
void PCKROT(istat,iatsel)
#else
void pckrot_(istat,iatsel)
#endif
#endif
int *iatsel;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	pckrod(istat,iatsel,
#else
#ifdef CRAY
	PCKROD(istat,iatsel,
#else
	pckrod_(istat,iatsel,
#endif
#endif
	xyzp->iresid,xyzp->iconn,
	calfptr->ianf,calfptr->islu,
	&calfptr->nchain);

}

#if defined(VMS) || defined(UNDERSC)
void alnwrt()
#else
#ifdef CRAY
void ALNWRT()
#else
void alnwrt_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	alnwrd(
#else
#ifdef CRAY
	ALNWRD(
#else
	alnwrd_(
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void alnsel(isel)
#else
#ifdef CRAY
void ALNSEL(isel)
#else
void alnsel_(isel)
#endif
#endif
int *isel;
{

#if defined(VMS) || defined(UNDERSC)
	alnsed(isel,
#else
#ifdef CRAY
	ALNSED(isel,
#else
	alnsed_(isel,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void getchr(igetca)
#else
#ifdef CRAY
void GETCHR(igetca)
#else
void getchr_(igetca)
#endif
#endif
int *igetca;
{

#if defined(VMS) || defined(UNDERSC)
	getchd(igetca,
#else
#ifdef CRAY
	GETCHD(igetca,
#else
	getchd_(igetca,
#endif
#endif
	xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void mopxyz(iun)
#else
#ifdef CRAY
void MOPXYZ(iun)
#else
void mopxyz_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	mopxyd(iun,
#else
#ifdef CRAY
	MOPXYD(iun,
#else
	mopxyd_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void getmol(igetmo,iadd)
#else
#ifdef CRAY
void GETMOl(igetmo,iadd)
#else
void getmol_(igetmo,iadd)
#endif
#endif
int *igetmo;
int *iadd;
{

#if defined(VMS) || defined(UNDERSC)
	getmod(igetmo,iadd,
#else
#ifdef CRAY
	GETMOD(igetmo,iadd,
#else
	getmod_(igetmo,iadd,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->iresid);

}

#if defined(VMS) || defined(UNDERSC)
void outmol(iun)
#else
#ifdef CRAY
void OUTMOl(iun)
#else
void outmol_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	outmod(iun,
#else
#ifdef CRAY
	OUTMOD(iun,
#else
	outmod_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void mopaco(istats,mopopt,irtype)
#else
#ifdef CRAY
void MOPACO(istats,mopopt,irtype)
#else
void mopaco_(istats,mopopt,irtype)
#endif
#endif
int *istats;
int *mopopt;
int *irtype;
{

#if defined(VMS) || defined(UNDERSC)
	mopacd(istats,mopopt,irtype,
#else
#ifdef CRAY
	MOPACD(istats,mopopt,irtype,
#else
	mopacd_(istats,mopopt,irtype,
#endif
#endif
	xyzp->ianz,xyzp->iatclr,xyzp->iconn,xyzp->coo,xyzp->qat,
	&cell->natc,&cell->icent,&cell->nspg,
	&cell->ichx,&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void parfc()
#else
#ifdef CRAY
void PARFC()
#else
void parfc_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	parfd(
#else
#ifdef CRAY
	PARFD(
#else
	parfd_(
#endif
#endif
	xyzp->coo,&scalptr->fscal);

}

#if defined(VMS) || defined(UNDERSC)
void plmol()
#else
#ifdef CRAY
void PLMOL()
#else
void plmol_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	plmod(
#else
#ifdef CRAY
	PLMOD(
#else
	plmod_(
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->iconn,
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->inat,
	calfptr->lab,clfstrptr->labhet,
	&posptr->xv,&posptr->yv,calfptr->icalf,&calfptr->ncalf,
	calfptr->icxp,calfptr->icyp,&scalptr->scal,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void plmolp()
#else
#ifdef CRAY
void PLMOLP()
#else
void plmolp_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	plmold(
#else
#ifdef CRAY
	PLMOLD(
#else
	plmold_(
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->iconn,xyzp->ianz,
	xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->inat,
	calfptr->lab,clfstrptr->labhet,
	&posptr->xv,&posptr->yv,&posptr->zv,&posptr->c0,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->reson,
	calfptr->icxp,calfptr->icyp,calfptr->irsnr,calfptr->achain,
	&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void plfc(shade,ixx,k,ihigh,colsc,icltan,zvect)
#else
#ifdef CRAY
void PLFC(shade,ixx,k,ihigh,colsc,icltan,zvect)
#else
void plfc_(shade,ixx,k,ihigh,colsc,icltan,zvect)
#endif
#endif
int *shade;
int *ixx;
int *k;
int *ihigh;
double *colsc;
int *icltan;
double *zvect;
{

#if defined(VMS) || defined(UNDERSC)
	plfd(shade,ixx,k,ihigh,colsc,icltan,zvect,
#else
#ifdef CRAY
	PLFD(shade,ixx,k,ihigh,colsc,icltan,zvect,
#else
	plfd_(shade,ixx,k,ihigh,colsc,icltan,zvect,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,
	&posptr->xv,&posptr->yv,&scalptr->scal,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void plfcp(shade,ixx,k,ihigh,colsc,icltan,zvect,scalp)
#else
#ifdef CRAY
void PLFCP(shade,ixx,k,ihigh,colsc,icltan,zvect,scalp)
#else
void plfcp_(shade,ixx,k,ihigh,colsc,icltan,zvect,scalp)
#endif
#endif
int *shade;
int *ixx;
int *k;
int *ihigh;
double *colsc;
int *icltan;
double *zvect;
double *scalp;
{

#if defined(VMS) || defined(UNDERSC)
	plfcd(shade,ixx,k,ihigh,colsc,icltan,zvect,scalp,
#else
#ifdef CRAY
	PLFCD(shade,ixx,k,ihigh,colsc,icltan,zvect,scalp,
#else
	plfcd_(shade,ixx,k,ihigh,colsc,icltan,zvect,scalp,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,
	&posptr->xv,&posptr->yv,&posptr->zv,&posptr->c0,
	&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void mstick(zvect,colsc,icltan,m,k,shade,idash)
#else
#ifdef CRAY
void MSTICK(zvect,colsc,icltan,m,k,shade,idash)
#else
void mstick_(zvect,colsc,icltan,m,k,shade,idash)
#endif
#endif
double *zvect;
double *colsc;
int *icltan;
int *m;
int *k;
int *shade;
int *idash;
{

#if defined(VMS) || defined(UNDERSC)
	msticd(zvect,colsc,icltan,m,k,shade,idash,
#else
#ifdef CRAY
	MSTICD(zvect,colsc,icltan,m,k,shade,idash,
#else
	msticd_(zvect,colsc,icltan,m,k,shade,idash,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->iatclr,
	&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void mstck(zvect,colsc,icltan,m,k,shade,idash)
#else
#ifdef CRAY
void MSTCK(zvect,colsc,icltan,m,k,shade,idash)
#else
void mstck_(zvect,colsc,icltan,m,k,shade,idash)
#endif
#endif
double *zvect;
double *colsc;
int *icltan;
int *m;
int *k;
int *shade;
int *idash;
{

#if defined(VMS) || defined(UNDERSC)
	mstcd(zvect,colsc,icltan,m,k,shade,idash,
#else
#ifdef CRAY
	MSTCD(zvect,colsc,icltan,m,k,shade,idash,
#else
	mstcd_(zvect,colsc,icltan,m,k,shade,idash,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->iatclr,
	&posptr->zv,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void sstick()
#else
#ifdef CRAY
void SSTICK()
#else
void sstick_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	ssticd(
#else
#ifdef CRAY
	SSTICD(
#else
	ssticd_(
#endif
#endif
	xyzp->coo,xyzp->ixp,xyzp->iyp,xyzp->iaton,xyzp->iconn,
	&posptr->xv,&posptr->yv,&scalptr->scal);

}

#if defined(VMS) || defined(UNDERSC)
void astick(zvect,colsc,icltan,m,k,ihigh,shade,idash,imon)
#else
#ifdef CRAY
void ASTICK(zvect,colsc,icltan,m,k,ihigh,shade,idash,imon)
#else
void astick_(zvect,colsc,icltan,m,k,ihigh,shade,idash,imon)
#endif
#endif
double *zvect;
double *colsc;
int *icltan;
int *m;
int *k;
int *ihigh;
int *shade;
int *idash;
int *imon;
{

#if defined(VMS) || defined(UNDERSC)
	asticd(zvect,colsc,icltan,m,k,ihigh,shade,idash,imon,
#else
#ifdef CRAY
	ASTICD(zvect,colsc,icltan,m,k,ihigh,shade,idash,imon,
#else
	asticd_(zvect,colsc,icltan,m,k,ihigh,shade,idash,imon,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->ianz,xyzp->iatclr,
	&posptr->xv,&posptr->yv,&scalptr->scal,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void astck(zvect,colsc,scalp,icltan,m,k,ihigh,shade,idash,imon)
#else
#ifdef CRAY
void ASTCK(zvect,colsc,scalp,icltan,m,k,ihigh,shade,idash,imon)
#else
void astck_(zvect,colsc,scalp,icltan,m,k,ihigh,shade,idash,imon)
#endif
#endif
double *zvect;
double *colsc;
double *scalp;
int *icltan;
int *m;
int *k;
int *ihigh;
int *shade;
int *idash;
int *imon;
{

#if defined(VMS) || defined(UNDERSC)
	astcd(zvect,colsc,scalp,icltan,m,k,ihigh,shade,idash,imon,
#else
#ifdef CRAY
	ASTCD(zvect,colsc,scalp,icltan,m,k,ihigh,shade,idash,imon,
#else
	astcd_(zvect,colsc,scalp,icltan,m,k,ihigh,shade,idash,imon,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->ianz,xyzp->iatclr,
	&posptr->xv,&posptr->yv,&posptr->zv,&posptr->c0,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void snglat(zvect,scalp,colsc,icltan,k,ihigh,shade,atcol,ipersp,ipost,icolps)
#else
#ifdef CRAY
void SNGLAT(zvect,scalp,colsc,icltan,k,ihigh,shade,atcol,ipersp,ipost,icolps)
#else
void snglat_(zvect,scalp,colsc,icltan,k,ihigh,shade,atcol,ipersp,ipost,icolps)
#endif
#endif
double *zvect;
double *scalp;
double *colsc;
int *icltan;
int *k;
int *ihigh;
int *shade;
int *atcol;
int *ipersp;
int *ipost;
int *icolps;
{

#if defined(VMS) || defined(UNDERSC)
	snglad(zvect,scalp,colsc,icltan,k,ihigh,shade,atcol,ipersp,ipost,icolps,
#else
#ifdef CRAY
	SNGLAD(zvect,scalp,colsc,icltan,k,ihigh,shade,atcol,ipersp,ipost,icolps,
#else
	snglad_(zvect,scalp,colsc,icltan,k,ihigh,shade,atcol,ipersp,ipost,icolps,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ixp,xyzp->iyp,xyzp->ianz,xyzp->iatclr,
	&posptr->xv,&posptr->yv,&posptr->zv,&posptr->c0,
	&scalptr->scal,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void fstick(roddef,rfac,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd)
#else
#ifdef CRAY
void FSTICK(roddef,rfac,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd)
#else
void fstick_(roddef,rfac,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd)
#endif
#endif
double *roddef;
double *rfac;
double *zvect;
double *colsc;
int *icltan;
int *m;
int *k;
int *ihigh;
int *shade;
int *atcol;
int *scnd;
{

#if defined(VMS) || defined(UNDERSC)
	fsticd(roddef,rfac,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd,
#else
#ifdef CRAY
	FSTICD(roddef,rfac,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd,
#else
	fsticd_(roddef,rfac,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ianz,xyzp->iatclr,
	&posptr->xv,&posptr->yv,&scalptr->scal,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void fstck(roddef,rfac,scalp,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd)
#else
#ifdef CRAY
void FSTCK(roddef,rfac,scalp,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd)
#else
void fstck_(roddef,rfac,scalp,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd)
#endif
#endif
double *roddef;
double *rfac;
double *scalp;
double *zvect;
double *colsc;
int *icltan;
int *m;
int *k;
int *ihigh;
int *shade;
int *atcol;
int *scnd;
{

#if defined(VMS) || defined(UNDERSC)
	fstcd(roddef,rfac,scalp,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd,
#else
#ifdef CRAY
	FSTCD(roddef,rfac,scalp,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd,
#else
	fstcd_(roddef,rfac,scalp,zvect,colsc,icltan,m,k,ihigh,shade,atcol,scnd,
#endif
#endif
	xyzp->coo,xyzp->rzp,xyzp->ianz,xyzp->iatclr,
	&posptr->xv,&posptr->yv,&posptr->zv,&posptr->c0,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void pldstg()
#else
#ifdef CRAY
void PLDSTG()
#else
void pldstg_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	pldstd(
#else
#ifdef CRAY
	PLDSTD(
#else
	pldstd_(
#endif
#endif
	xyzp->ixp,xyzp->iyp);

}

#if defined(VMS) || defined(UNDERSC)
void plalab(iqon)
#else
#ifdef CRAY
void PLALAB(iqon)
#else
void plalab_(iqon)
#endif
#endif
int *iqon;
{

#if defined(VMS) || defined(UNDERSC)
	plalad(iqon,
#else
#ifdef CRAY
	PLALAD(iqon,
#else
	plalad_(iqon,
#endif
#endif
	xyzp->rzp,xyzp->ixp,xyzp->iyp,
	calfptr->icalf,calfptr->ianf,calfptr->islu,&calfptr->nchain,
	calfptr->iamino,calfptr->reson,calfptr->irsnr,calfptr->achain,
	&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void reslab()
#else
#ifdef CRAY
void RESLAB()
#else
void reslab_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	reslad(
#else
#ifdef CRAY
	RESLAD(
#else
	reslad_(
#endif
#endif
	xyzp->rzp,xyzp->ixp,xyzp->iyp,
	calfptr->icalf,&calfptr->nchain,
	calfptr->iamino,calfptr->reson,calfptr->irsnr,calfptr->lab,
	calfptr->ihet,
	calfptr->achain,&calfptr->ncalf,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void plalb(iami)
#else
#ifdef CRAY
void PLALB(iami)
#else
void plalb_(iami)
#endif
#endif
int *iami;
{

#if defined(VMS) || defined(UNDERSC)
	plald(iami,
#else
#ifdef CRAY
	PLALD(iami,
#else
	plald_(iami,
#endif
#endif
	xyzp->ixp,xyzp->iyp,
	calfptr->icalf,calfptr->iamino,calfptr->irsnr);

}

#if defined(VMS) || defined(UNDERSC)
void pllab(ixp,iyp,ianz,k,qat,inr,iqon,ires,ipost)
#else
#ifdef CRAY
void PLLAB(ixp,iyp,ianz,k,qat,inr,iqon,ires,ipost)
#else
void pllab_(ixp,iyp,ianz,k,qat,inr,iqon,ires,ipost)
#endif
#endif
int *ixp;
int *iyp;
int *ianz;
int *k;
double *qat;
int *inr;
int *iqon;
int *ires;
int *ipost;
{

#if defined(VMS) || defined(UNDERSC)
	pllad(ixp,iyp,ianz,k,qat,inr,iqon,ires,ipost,
#else
#ifdef CRAY
	PLLAD(ixp,iyp,ianz,k,qat,inr,iqon,ires,ipost,
#else
	pllad_(ixp,iyp,ianz,k,qat,inr,iqon,ires,ipost,
#endif
#endif
	xyzp->ityp,xyzp->ipdbt,
	calfptr->iamino,calfptr->reson);

}

#if defined(VMS) || defined(UNDERSC)
void plpost(backb,dolabs,icolps,fancy,atcol,persp,shade,idelx)
#else
#ifdef CRAY
void PLPOST(backb,dolabs,icolps,fancy,atcol,persp,shade,idelx)
#else
void plpost_(backb,dolabs,icolps,fancy,atcol,persp,shade,idelx)
#endif
#endif
int *backb;
int *dolabs;
int *icolps;
int *fancy;
int *atcol;
int *persp;
int *shade;
int *idelx;
{

#if defined(VMS) || defined(UNDERSC)
	plposd(backb,dolabs,icolps,fancy,atcol,persp,shade,idelx,
#else
#ifdef CRAY
	PLPOSD(backb,dolabs,icolps,fancy,atcol,persp,shade,idelx,
#else
	plposd_(backb,dolabs,icolps,fancy,atcol,persp,shade,idelx,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iatclr,xyzp->iconn,
	xyzp->ixp,xyzp->iyp,xyzp->rzp,xyzp->inat,xyzp->qat,
	&posptr->xv,&posptr->yv,&posptr->zv,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->reson,&scalptr->scal);

}

#if defined(VMS) || defined(UNDERSC)
void plvrml(iun,fancy,atcol,dolabs,ihnd,backb,dohead)
#else
#ifdef CRAY
void PLVRML(iun,fancy,atcol,dolabs,ihnd,backb,dohead)
#else
void plvrml_(iun,fancy,atcol,dolabs,ihnd,backb,dohead)
#endif
#endif
int *iun;
int *fancy;
int *atcol;
int *dolabs;
int *ihnd;
int *backb;
int *dohead;
{

#if defined(VMS) || defined(UNDERSC)
	plvrmd(iun,fancy,atcol,dolabs,ihnd,backb,dohead,
#else
#ifdef CRAY
	PLVRMD(iun,fancy,atcol,dolabs,ihnd,backb,dohead,
#else
	plvrmd_(iun,fancy,atcol,dolabs,ihnd,backb,dohead,
#endif
#endif
	rotptr->rz,rotptr->t,
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	calfptr->icalf,calfptr->ianf,calfptr->islu,&calfptr->nchain,
	calfptr->iamino,calfptr->reson,&scalptr->scal,&scalptr->scali);

}

#if defined(VMS) || defined(UNDERSC)
void plvst(iun,jcol,k,atcol,hndexl)
#else
#ifdef CRAY
void PLVST(iun,jcol,k,atcol,hndexl)
#else
void plvst_(iun,jcol,k,atcol,hndexl)
#endif
#endif
int *iun;
int *jcol;
int *k;
int *atcol;
int *hndexl;
{

#if defined(VMS) || defined(UNDERSC)
	plvsd(iun,jcol,k,atcol,hndexl,
#else
#ifdef CRAY
	PLVSD(iun,jcol,k,atcol,hndexl,
#else
	plvsd_(iun,jcol,k,atcol,hndexl,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void hcoord(ioatms,nstrt,iaddh)
#else
#ifdef CRAY
void HCOORD(ioatms,nstrt,iaddh)
#else
void hcoord_(ioatms,nstrt,iaddh)
#endif
#endif
int *ioatms;
int *nstrt;
int *iaddh;
{
  int istat;

#if defined(VMS) || defined(UNDERSC)
	hcoodd(&istat,ioatms,nstrt,iaddh,
#else
#ifdef CRAY
	HCOODD(&istat,ioatms,nstrt,iaddh,
#else
	hcoodd_(&istat,ioatms,nstrt,iaddh,
#endif
#endif
	xyzp->ipdbt,xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino);


	if (!istat) {
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   hcoodd(&istat,ioatms,nstrt,iaddh,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   HCOODD(&istat,ioatms,nstrt,iaddh,
#else
	   allcoo_(&addat,&ZERO);
	   hcoodd_(&istat,ioatms,nstrt,iaddh,
#endif
#endif
	   xyzp->ipdbt,xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iresid,
	   xyzp->iconn,
	   calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	   &calfptr->nchain,calfptr->iamino);
        }
}

#if defined(VMS) || defined(UNDERSC)
void hang(idx1,idx2,hang)
#else
#ifdef CRAY
void HANG(idx1,idx2,hang)
#else
void hang_(idx1,idx2,hang)
#endif
#endif
int *idx1;
int *idx2;
double *hang;
{

#if defined(VMS) || defined(UNDERSC)
	hand(idx1,idx2,hang,
#else
#ifdef CRAY
	HAND(idx1,idx2,hang,
#else
	hand_(idx1,idx2,hang,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn,
	calfptr->icalf);

}

#if defined(VMS) || defined(UNDERSC)
void hbond(ioatms,nstrt)
#else
#ifdef CRAY
void HBOND(ioatms,nstrt)
#else
void hbond_(ioatms,nstrt)
#endif
#endif
int *ioatms;
int *nstrt;
{

#if defined(VMS) || defined(UNDERSC)
	hbodd(ioatms,nstrt,
#else
#ifdef CRAY
	HBODD(ioatms,nstrt,
#else
	hbodd_(ioatms,nstrt,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn,
	calfptr->icalf,&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void acthb(iopt,hbfilt)
#else
#ifdef CRAY
void ACTHB(iopt,hbfilt)
#else
void acthb_(iopt,hbfilt)
#endif
#endif
int *iopt;
double *hbfilt;
{

#if defined(VMS) || defined(UNDERSC)
	acthd(iopt,hbfilt,
#else
#ifdef CRAY
	ACTHD(iopt,hbfilt,
#else
	acthd_(iopt,hbfilt,
#endif
#endif
	xyzp->coo,xyzp->iconn,xyzp->ianz,
	calfptr->icalf,&calfptr->ncalf);

}

#if defined(VMS) || defined(UNDERSC)
void disabh(iopt)
#else
#ifdef CRAY
void DISABH(iopt)
#else
void disabh_(iopt)
#endif
#endif
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	disabd(iopt,
#else
#ifdef CRAY
	DISABD(iopt,
#else
	disabd_(iopt,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void hbconn(iopt,iat1,iat2)
#else
#ifdef CRAY
void HBCONN(iopt,iat1,iat2)
#else
void hbconn_(iopt,iat1,iat2)
#endif
#endif
int *iopt;
int *iat1;
int *iat2;
{

#if defined(VMS) || defined(UNDERSC)
	hbcond(iopt,iat1,iat2,
#else
#ifdef CRAY
	HBCOND(iopt,iat1,iat2,
#else
	hbcond_(iopt,iat1,iat2,
#endif
#endif
	xyzp->ianz,xyzp->iatclr,xyzp->iaton,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void getchn(ires,ichain)
#else
#ifdef CRAY
void GETCHN(ires,ichain)
#else
void getchn_(ires,ichain)
#endif
#endif
int *ires;
int *ichain;
{
#if defined(VMS) || defined(UNDERSC)
	getcdh(ires,ichain,
#else
#ifdef CRAY
	GETCDH(ires,ichain,
#else
	getcdh_(ires,ichain,
#endif
#endif
	calfptr->ianf,calfptr->islu,&calfptr->nchain);
}

#if defined(VMS) || defined(UNDERSC)
void ribbs()
#else
#ifdef CRAY
void RIBBS()
#else
void ribbs_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
	ribbd(
#else
#ifdef CRAY
	RIBBD(
#else
	ribbd_(
#endif
#endif
	&calfptr->issdon);
}

#if defined(VMS) || defined(UNDERSC)
void ribbon(iscnd,dogl,nr,iungl,ipart,ist,ichain)
#else
#ifdef CRAY
void RIBBON(iscnd,dogl,nr,iungl,ipart,ist,ichain)
#else
void ribbon_(iscnd,dogl,nr,iungl,ipart,ist,ichain)
#endif
#endif
int *iscnd;
int *dogl;
int *nr;
int *iungl;
int *ipart;
int *ist;
int *ichain;
{
 int istat;

#if defined(VMS) || defined(UNDERSC)
	ribbod(&istat,iscnd,dogl,nr,iungl,ipart,ist,ichain,rotptr->t,
#else
#ifdef CRAY
	RIBBOD(&istat,iscnd,dogl,nr,iungl,ipart,ist,ichain,rotptr->t,
#else
	ribbod_(&istat,iscnd,dogl,nr,iungl,ipart,ist,ichain,rotptr->t,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,
	xyzp->iconn,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->isal,&calfptr->ihashb);

	if (!istat) {
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   ribbod(&istat,iscnd,dogl,nr,iungl,ipart,ist,ichain,rotptr->t,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   RIBBOD(&istat,iscnd,dogl,nr,iungl,ipart,ist,ichain,rotptr->t,
#else
	   allcoo_(&addat,&ZERO);
	   ribbod_(&istat,iscnd,dogl,nr,iungl,ipart,ist,ichain,rotptr->t,
#endif
#endif
	   xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,
	   xyzp->iconn,
	   calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	   &calfptr->nchain,calfptr->iamino,calfptr->isal,&calfptr->ihashb);
        }
}

#if defined(VMS) || defined(UNDERSC)
void prnts()
#else
#ifdef CRAY
void PRNTS()
#else
void prnts_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	prntd(
#else
#ifdef CRAY
	PRNTD(
#else
	prntd_(
#endif
#endif
	xyzp->iaton);

}
#if defined(VMS) || defined(UNDERSC)
void proxim(itarg,thresh,ikleur,idosrf)
#else
#ifdef CRAY
void PROXIM(itarg,thresh,ikleur,idosrf)
#else
void proxim_(itarg,thresh,ikleur,idosrf)
#endif
#endif
int *itarg;
double *thresh;
int *ikleur;
int *idosrf;
{

#if defined(VMS) || defined(UNDERSC)
	proxid(itarg,thresh,ikleur,idosrf,
#else
#ifdef CRAY
	PROXID(itarg,thresh,ikleur,idosrf,
#else
	proxid_(itarg,thresh,ikleur,idosrf,
#endif
#endif
	xyzp->coo,xyzp->iresid,&calfptr->ishoh);

}

#if defined(VMS) || defined(UNDERSC)
void proxic(itarg,backb,adds,idocom,thresh)
#else
#ifdef CRAY
void PROXIC(itarg,backb,adds,idocom,thresh)
#else
void proxic_(itarg,backb,adds,idocom,thresh)
#endif
#endif
int *itarg;
int *backb;
int *adds;
int *idocom;
double *thresh;
{

#if defined(VMS) || defined(UNDERSC)
	proxd(itarg,backb,adds,idocom,thresh,
#else
#ifdef CRAY
	PROXD(itarg,backb,adds,idocom,thresh,
#else
	proxd_(itarg,backb,adds,idocom,thresh,
#endif
#endif
	xyzp->coo,xyzp->iresid,xyzp->iaton,xyzp->iconn,
	calfptr->iams,&calfptr->ishoh);

}

#if defined(VMS) || defined(UNDERSC)
void setchn(iopt)
#else
#ifdef CRAY
void SETCHN(iopt)
#else
void setchn_(iopt)
#endif
#endif
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	setcdd(iopt,
#else
#ifdef CRAY
	SETCDD(iopt,
#else
	setcdd_(iopt,
#endif
#endif
	&calfptr->nchain,calfptr->ianf,calfptr->islu,calfptr->irsnr,
	calfptr->achain);

}

#if defined(VMS) || defined(UNDERSC)
void rdchx(idebug,iop,istdbd,useab,moddma,istat,icssr)
#else
#ifdef CRAY
void RDCHX(idebug,iop,istdbd,useab,moddma,istat,icssr)
#else
void rdchx_(idebug,iop,istdbd,useab,moddma,istat,icssr)
#endif
#endif
int *idebug;
int *iop;
int *istdbd;
int *useab;
int *moddma;
int *istat;
int *icssr;
{

#if defined(VMS) || defined(UNDERSC)
	rdchd(idebug,iop,istdbd,useab,moddma,istat,icssr,
#else
#ifdef CRAY
	RDCHD(idebug,iop,istdbd,useab,moddma,istat,icssr,
#else
	rdchd_(idebug,iop,istdbd,useab,moddma,istat,icssr,
#endif
#endif
	xyzp->coo,xyzp->iconn,xyzp->ianz,xyzp->iatclr,xyzp->ityp,xyzp->qat,
	&cell->natc,&cell->icent,&cell->inorm,&cell->ncon,&cell->nspg,
	&cell->kz,&cell->ichx,&cell->icrtp,&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rfbio(idebug,ifrst,istat)
#else
#ifdef CRAY
void RFBIO(idebug,ifrst,istat)
#else
void rfbio_(idebug,ifrst,istat)
#endif
#endif
int *idebug;
int *ifrst;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rfbid(idebug,ifrst,istat,
#else
#ifdef CRAY
	RFBID(idebug,ifrst,istat,
#else
	rfbid_(idebug,ifrst,istat,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	&cell->natc,&cell->norg,&cell->icent,&cell->inorm,&cell->ncon,
	&cell->nspg,&cell->kz,&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void getxdt(ipnt,nat,istat)
#else
#ifdef CRAY
void GETXDT(ipnt,nat,istat)
#else
void getxdt_(ipnt,nat,istat)
#endif
#endif
int *ipnt;
int *nat;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getxdd(ipnt,nat,istat,
#else
#ifdef CRAY
	GETXDD(ipnt,nat,istat,
#else
	getxdd_(ipnt,nat,istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rfdat(idebug,istat,refcod)
#else
#ifdef CRAY
void RFDAT(idebug,istat,refcod)
#else
void rfdat_(idebug,istat,refcod)
#endif
#endif
int *idebug;
int *istat;
int *refcod;
{

#if defined(VMS) || defined(UNDERSC)
	rfdad(idebug,istat,refcod,
#else
#ifdef CRAY
	RFDAD(idebug,istat,refcod,
#else
	rfdad_(idebug,istat,refcod,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	&cell->natc,&cell->norg,&cell->icent,&cell->inorm,
	&cell->ncon,&cell->nspg,&cell->kz,
	&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void fdat(iop,ifrst,istdbd,useab,moddma,idebug)
#else
#ifdef CRAY
void FDAT(iop,ifrst,istdbd,useab,moddma,idebug)
#else
void fdat_(iop,ifrst,istdbd,useab,moddma,idebug)
#endif
#endif
int *iop;
int *ifrst;
int *istdbd;
int *useab;
int *moddma;
int *idebug;
{

#if defined(VMS) || defined(UNDERSC)
	fdad(iop,ifrst,istdbd,useab,moddma,idebug,
#else
#ifdef CRAY
	FDAD(iop,ifrst,istdbd,useab,moddma,idebug,
#else
	fdad_(iop,ifrst,istdbd,useab,moddma,idebug,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,
	xyzp->iconn,xyzp->lwrit,xyzp->lring,xyzp->ityp,
	&scalptr->scal,&scalptr->scali,&scalptr->smag,
	&cell->natc,&cell->norg,&cell->icent,&cell->inorm,
	&cell->ncon,&cell->nspg,
	&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2]);

}

#if defined(VMS) || defined(UNDERSC)
void delat(iat,iacn,iorg,mxdma)
#else
#ifdef CRAY
void DELAT(iat,iacn,iorg,mxdma)
#else
void delat_(iat,iacn,iorg,mxdma)
#endif
#endif
int *iat;
int *iacn;
int *iorg;
int *mxdma;
{

#if defined(VMS) || defined(UNDERSC)
	delad(iat,iacn,iorg,mxdma,
#else
#ifdef CRAY
	DELAD(iat,iacn,iorg,mxdma,
#else
	delad_(iat,iacn,iorg,mxdma,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->qat,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void polh(nat,ipolh,iatom)
#else
#ifdef CRAY
void POLH(nat,ipolh,iatom)
#else
void polh_(nat,ipolh,iatom)
#endif
#endif
int *ipolh;
int *iatom;
int *nat;
{

#if defined(VMS) || defined(UNDERSC)
	pold(nat,ipolh,iatom,
#else
#ifdef CRAY
	POLD(nat,ipolh,iatom,
#else
	pold_(nat,ipolh,iatom,
#endif
#endif
	xyzp->ianz,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void ifnn(ifnn,noff,ia1,ia2)
#else
#ifdef CRAY
void IFNN(ifnn,noff,ia1,ia2)
#else
void ifnn_(ifnn,noff,ia1,ia2)
#endif
#endif
int *ifnn;
int *noff;
int *ia1;
int *ia2;
{

#if defined(VMS) || defined(UNDERSC)
	ifnd(ifnn,noff,ia1,ia2,
#else
#ifdef CRAY
	IFND(ifnn,noff,ia1,ia2,
#else
	ifnd_(ifnn,noff,ia1,ia2,
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void rdgro(idebug,istat)
#else
#ifdef CRAY
void RDGRO(idebug,istat)
#else
void rdgro_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdgrod(idebug,istat,
#else
#ifdef CRAY
	RDGROD(idebug,istat,
#else
	rdgrod_(idebug,istat,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	xyzp->ityp,xyzp->ipdbt,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->reson,
	calfptr->isal,calfptr->irsnr,&calfptr->ishoh);

	if (*istat == -1) {
           hetptr.NHetAtm = 0;
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   rdgrod(idebug,istat,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   RDGROD(idebug,istat,
#else
	   allcoo_(&addat,&ZERO);
	   rdgrod_(idebug,istat,
#endif
#endif
	   xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	   xyzp->ityp,xyzp->ipdbt,
	   calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	   &calfptr->nchain,calfptr->iamino,calfptr->reson,
	   calfptr->isal,calfptr->irsnr,&calfptr->ishoh);
        }
}

#if defined(VMS) || defined(UNDERSC)
void addbox(v1,v2,v3)
#else
#ifdef CRAY
void ADDBOX(v1,v2,v3)
#else
void addbox_(v1,v2,v3)
#endif
#endif
double *v1;
double *v2;
double *v3;
{

#if defined(VMS) || defined(UNDERSC)
	addbod(v1,v2,v3,
#else
#ifdef CRAY
	ADDBOD(v1,v2,v3,
#else
	addbod_(v1,v2,v3,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void addtbx(v1,v2,v3)
#else
#ifdef CRAY
void ADDTBX(v1,v2,v3)
#else
void addtbx_(v1,v2,v3)
#endif
#endif
double *v1;
double *v2;
double *v3;
{

#if defined(VMS) || defined(UNDERSC)
	addtbd(v1,v2,v3,
#else
#ifdef CRAY
	ADDTBD(v1,v2,v3,
#else
	addtbd_(v1,v2,v3,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,xyzp->iaton,xyzp->iresid);

}

#if defined(VMS) || defined(UNDERSC)
void gropt(ipnt)
#else
#ifdef CRAY
void GROPT(ipnt)
#else
void gropt_(ipnt)
#endif
#endif
int *ipnt;
{

#if defined(VMS) || defined(UNDERSC)
	gropd(ipnt,
#else
#ifdef CRAY
	GROPD(ipnt,
#else
	gropd_(ipnt,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rdmol(idebug,ipdbon,ioadd,istat)
#else
#ifdef CRAY
void RDMOL(idebug,ipdbon,ioadd,istat)
#else
void rdmol_(idebug,ipdbon,ioadd,istat)
#endif
#endif
int *idebug;
int *ipdbon;
int *ioadd;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdmod(idebug,ipdbon,ioadd,istat,
#else
#ifdef CRAY
	RDMOD(idebug,ipdbon,ioadd,istat,
#else
	rdmod_(idebug,ipdbon,ioadd,istat,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	xyzp->ityp,xyzp->ipdbt,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->reson,
	calfptr->isal,&calfptr->ishoh,&calfptr->ihashb,
	&cell->natc,&cell->norg,&cell->icent,&cell->ncon,&cell->nspg,
	&cell->kz,&cell->ichx,&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

	if (*istat == -1) {
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   rdmod(idebug,ipdbon,ioadd,istat,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   RDMOD(idebug,ipdbon,ioadd,istat,
#else
	   allcoo_(&addat,&ZERO);
	   rdmod_(idebug,ipdbon,ioadd,istat,
#endif
#endif
	   xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
   	   xyzp->ityp,xyzp->ipdbt,
	   calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
   	   &calfptr->nchain,calfptr->iamino,calfptr->reson,
	   calfptr->isal,&calfptr->ishoh,&calfptr->ihashb,
	   &cell->natc,&cell->norg,&cell->icent,&cell->ncon,&cell->nspg,
	   &cell->kz,&cell->ichx,&cell->nopr,cell->ir,cell->it,
	   &cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	   &cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);
        }
}

#if defined(VMS) || defined(UNDERSC)
void wrmol(iun)
#else
#ifdef CRAY
void WRMOL(iun)
#else
void wrmol_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrmod(iun,
#else
#ifdef CRAY
	WRMOD(iun,
#else
	wrmod_(iun,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iconn,
	xyzp->iresid,xyzp->lring,xyzp->inat,xyzp->ityp,xyzp->ipdbt,
	calfptr->icalf,&calfptr->ncalf,calfptr->iamino,&calfptr->ishoh,
	&cell->natc,&cell->nspg,&cell->ichx,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void ispn(ispn,iat,irng,idochg,ifive)
#else
#ifdef CRAY
void ISPN(ispn,iat,irng,idochg,ifive)
#else
void ispn_(ispn,iat,irng,idochg,ifive)
#endif
#endif
int *ispn;
int *iat;
int *irng;
int *idochg;
int *ifive;
{

#if defined(VMS) || defined(UNDERSC)
	ispnd(ispn,iat,irng,idochg,ifive,
#else
#ifdef CRAY
	ISPND(ispn,iat,irng,idochg,ifive,
#else
	ispnd_(ispn,iat,irng,idochg,ifive,
#endif
#endif
	xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->lwrit,xyzp->lring);

}

#if defined(VMS) || defined(UNDERSC)
void wrcrys(iun)
#else
#ifdef CRAY
void WRCRYS(iun)
#else
void wrcrys_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrcryd(iun,
#else
#ifdef CRAY
	WRCRYD(iun,
#else
	wrcryd_(iun,
#endif
#endif
	xyzp->ianz,xyzp->coo,
	&cell->natc,&cell->nspg,&cell->ichx,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdshlx(idebug,istat)
#else
#ifdef CRAY
void RDSHLX(idebug,istat)
#else
void rdshlx_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdshld(idebug,istat,
#else
#ifdef CRAY
	RDSHLD(idebug,istat,
#else
	rdshld_(idebug,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn,xyzp->iatclr,
	&cell->natc,&cell->icent,&cell->ncon,&cell->nspg,
	&cell->kz,&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdcif(idebug,istat)
#else
#ifdef CRAY
void RDCIF(idebug,istat)
#else
void rdcif_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdcifd(idebug,istat,
#else
#ifdef CRAY
	RDCIFD(idebug,istat,
#else
	rdcifd_(idebug,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn,xyzp->iatclr,
	&cell->natc,&cell->icent,&cell->ncon,&cell->nspg,
	&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrshlx(iun,idospf)
#else
#ifdef CRAY
void WRSHLX(iun,idospf)
#else
void wrshlx_(iun,idospf)
#endif
#endif
int *iun;
int *idospf;
{

#if defined(VMS) || defined(UNDERSC)
	wrshld(iun,idospf,
#else
#ifdef CRAY
	WRSHLD(iun,idospf,
#else
	wrshld_(iun,idospf,
#endif
#endif
	xyzp->coo,xyzp->ianz,
	&cell->natc,&cell->icent,&cell->nspg,
	&cell->kz,&cell->ichx,&cell->nopr,cell->ir,cell->it,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrcif(iun)
#else
#ifdef CRAY
void WRCIF(iun)
#else
void wrcif_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrcifd(iun,
#else
#ifdef CRAY
	WRCIFD(iun,
#else
	wrcifd_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,
	&cell->natc,&cell->nspg,&cell->ichx,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void cllrot(vec,irot,ifd)
#else
#ifdef CRAY
void CLLROT(vec,irot,ifd)
#else
void cllrot_(vec,irot,ifd)
#endif
#endif
double *vec;
int *irot;
int *ifd;
{

#if defined(VMS) || defined(UNDERSC)
	cllrod(vec,irot,ifd,
#else
#ifdef CRAY
	CLLROD(vec,irot,ifd,
#else
	cllrod_(vec,irot,ifd,
#endif
#endif
	xyzp->coo,xyzp->ianz,
	&cell->natc,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void zm2fr(cm,ctmp,imkeep)
#else
#ifdef CRAY
void ZM2FR(cm,ctmp,imkeep)
#else
void zm2fr_(cm,ctmp,imkeep)
#endif
#endif
double *cm;
double *ctmp;
int *imkeep;
{

#if defined(VMS) || defined(UNDERSC)
	zm2fd(cm,ctmp,imkeep,
#else
#ifdef CRAY
	ZM2FD(cm,ctmp,imkeep,
#else
	zm2fd_(cm,ctmp,imkeep,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	&cell->natc,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrchx(iun)
#else
#ifdef CRAY
void WRCHX(iun)
#else
void wrchx_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrchd(iun,
#else
#ifdef CRAY
	WRCHD(iun,
#else
	wrchd_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,xyzp->qat,xyzp->ityp,
	&cell->natc,&cell->inorm,&cell->nspg,&cell->ichx,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdmsi(idebug,istat)
#else
#ifdef CRAY
void RDMSI(idebug,istat)
#else
void rdmsi_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdmsd(idebug,istat,
#else
#ifdef CRAY
	RDMSD(idebug,istat,
#else
	rdmsd_(idebug,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,xyzp->qat,
	&cell->natc,&cell->icent,&cell->ncon,&cell->nspg,
	&cell->ichx,&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrmsi(iun)
#else
#ifdef CRAY
void WRMSI(iun)
#else
void wrmsi_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrmsd(iun,
#else
#ifdef CRAY
	WRMSD(iun,
#else
	wrmsd_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iconn,xyzp->qat,
	&cell->natc,&cell->nspg,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdcpmolu(istats)
#else
#ifdef CRAY
void RDCPMOLU(istats)
#else
void rdcpmolu_(istats)
#endif
#endif
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdcpmold(istats,
#else
#ifdef CRAY
	RDCPMOLD(istats,
#else
	rdcpmold_(istats,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void cpmdpt(ipnt,istat)
#else
#ifdef CRAY
void CPMDPT(ipnt,istat)
#else
void cpmdpt_(ipnt,istat)
#endif
#endif
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	cpmdpd(ipnt,istat,
#else
#ifdef CRAY
	CPMDPD(ipnt,istat,
#else
	cpmdpd_(ipnt,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void cpmdgetfr(istat)
#else
#ifdef CRAY
void CPMDGETFR(istat)
#else
void cpmdgetfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	cpmdgetfd(istat,
#else
#ifdef CRAY
	CPMDGETFD(istat,
#else
	cpmdgetfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void cpmdptdyn(ipnt,istat)
#else
#ifdef CRAY
void CPMDPTDYN(ipnt,istat)
#else
void cpmdptdyn_(ipnt,istat)
#endif
#endif
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	cpmdptdyd(ipnt,istat,
#else
#ifdef CRAY
	CPMDPTDYD(ipnt,istat,
#else
	cpmdptdyd_(ipnt,istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void wrcpmd(iun)
#else
#ifdef CRAY
void WRCPMD(iun)
#else
void wrcpmd_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrcpdd(iun,
#else
#ifdef CRAY
	WRCPDD(iun,
#else
	wrcpdd_(iun,
#endif
#endif
	xyzp->ianz,xyzp->coo,&cell->natc,&cell->ichx,
        &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
        &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void cpmdcell()
#else
#ifdef CRAY
void CPMDCELL()
#else
void cpmdcell_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	cpmdceld(
#else
#ifdef CRAY
	CPMDCELD(
#else
	cpmdceld_(
#endif
#endif
	&cell->nspg,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdmolu(sline,iemlin,idocoo,idobohr,istats)
#else
#ifdef CRAY
void RDMOLU(sline,iemlin,idocoo,idobohr,istats)
#else
void rdmolu_(sline,iemlin,idocoo,idobohr,istats)
#endif
#endif
int *sline;
int *iemlin;
int *idocoo;
int *idobohr;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdmodu(sline,iemlin,idocoo,idobohr,istats,
#else
#ifdef CRAY
	RDMODU(sline,iemlin,idocoo,idobohr,istats,
#else
	rdmodu_(sline,iemlin,idocoo,idobohr,istats,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void gamupt(ipnt,istat)
#else
#ifdef CRAY
void GAMUPT(ipnt,istat)
#else
void gamupt_(ipnt,istat)
#endif
#endif
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	gamupd(ipnt,istat,
#else
#ifdef CRAY
	GAMUPD(ipnt,istat,
#else
	gamupd_(ipnt,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void ugetfr(istat)
#else
#ifdef CRAY
void UGETFR(istat)
#else
void ugetfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	ugetfd(istat,
#else
#ifdef CRAY
	ugetfd(istat,
#else
	ugetfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void wrvasp(iun)
#else
#ifdef CRAY
void WRVASP(iun)
#else
void wrvasp_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrvasd(iun,
#else
#ifdef CRAY
	WRVASD(iun,
#else
	wrvasd_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrmopa(iun)
#else
#ifdef CRAY
void WRMOPA(iun)
#else
void wrmopa_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrmopd(iun,
#else
#ifdef CRAY
	WRMOPD(iun,
#else
	wrmopd_(iun,
#endif
#endif
	xyzp->coo,xyzp->ianz,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrfc(iun3)
#else
#ifdef CRAY
void WRFC(iun3)
#else
void wrfc_(iun3)
#endif
#endif
int *iun3;
{

#if defined(VMS) || defined(UNDERSC)
	wrfd(iun3,
#else
#ifdef CRAY
	WRFD(iun3,
#else
	wrfd_(iun3,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rdfc(ipnt,istats)
#else
#ifdef CRAY
void RDFC(ipnt,istats)
#else
void rdfc_(ipnt,istats)
#endif
#endif
int *ipnt;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdfd(ipnt,istats,
#else
#ifdef CRAY
	RDFD(ipnt,istats,
#else
	rdfd_(ipnt,istats,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rdmsf(idebug,istat)
#else
#ifdef CRAY
void RDMSF(idebug,istat)
#else
void rdmsf_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdmdf(idebug,istat,
#else
#ifdef CRAY
	RDMDF(idebug,istat,
#else
	rdmdf_(idebug,istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,xyzp->qat,xyzp->ityp,
	&cell->natc,&cell->norg,&cell->icent,&cell->inorm,
	&cell->ncon,&cell->nspg,&cell->kz,&cell->ichx,
	&cell->nopr,cell->ir,cell->it,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void rdpdb(istat)
#else
#ifdef CRAY
void RDPDB(istat)
#else
void rdpdb_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	rdpdd(istat,
#else
#ifdef CRAY
	RDPDD(istat,
#else
	rdpdd_(istat,
#endif
#endif
	xyzp->coo,xyzp->ianz,&calfptr->ihashb);

}

#if defined(VMS) || defined(UNDERSC)
void quwat(nwat)
#else
#ifdef CRAY
void QUWAT(nwat)
#else
void quwat_(nwat)
#endif
#endif
int *nwat;
{

#if defined(VMS) || defined(UNDERSC)
	quwad(nwat,
#else
#ifdef CRAY
	QUWAD(nwat,
#else
	quwad_(nwat,
#endif
#endif
	xyzp->iresid,xyzp->iconn,xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void evwat()
#else
#ifdef CRAY
void EVWAT()
#else
void evwat_()
#endif
#endif
{
	int nwat;

#if defined(VMS) || defined(UNDERSC)
	quwat(&nwat);
	nwat = nwat*3;
	if (nwat + *xyzp->iatoms > *xyzp->mxnat) allcoo(&nwat,&ZERO);
	evwad(
#else
#ifdef CRAY
	QUWAT(&nwat);
	nwat = nwat*3;
	if (nwat + *xyzp->iatoms > *xyzp->mxnat) ALLCOO(&nwat,&ZERO);
	EVWAD(
#else
	quwat_(&nwat);
	nwat = nwat*3;
	if (nwat + *xyzp->iatoms > *xyzp->mxnat) allcoo_(&nwat,&ZERO);
	evwad_(
#endif
#endif

	xyzp->coo,xyzp->qat,xyzp->iresid,calfptr->irsnr,xyzp->iatclr,
	xyzp->iaton,xyzp->iconn,xyzp->ianz,&calfptr->ncalf,calfptr->icalf,
	xyzp->ityp,xyzp->ipdbt,&calfptr->ishoh);

}

#if defined(VMS) || defined(UNDERSC)
void fndoh(itar,ang,ires,copt,istat)
#else
#ifdef CRAY
void FNDOH(itar,ang,ires,copt,istat)
#else
void fndoh_(itar,ang,ires,copt,istat)
#endif
#endif
int *itar;
double *ang;
int *ires;
double *copt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	fndod(itar,ang,ires,copt,istat,
#else
#ifdef CRAY
	FNDOD(itar,ang,ires,copt,istat,
#else
	fndod_(itar,ang,ires,copt,istat,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->iconn,xyzp->ityp,xyzp->iresid,
	calfptr->irsnr,&calfptr->ncalf,calfptr->icalf);

}

void FreeWat(sel)
int sel;
{
   if (watres[sel] != NULL) free(watres[sel]);
   if (watanz[sel] != NULL) free(watanz[sel]);
   if (watcoo[sel] != NULL) free(watcoo[sel]);
   if (watcon[sel] != NULL) free(watcon[sel]);
   if (watmap[sel] != NULL) free(watmap[sel]);
   if (watqat[sel] != NULL) free(watqat[sel]);
   if (wattyp[sel] != NULL) free(wattyp[sel]);

   watres[sel] = NULL;
   watanz[sel] = NULL;
   watcoo[sel] = NULL;
   watcon[sel] = NULL;
   watmap[sel] = NULL;
   watqat[sel] = NULL;
   wattyp[sel] = NULL;
}

void RestComplete()
{
  int i,j,k,ires,irsnrt,nw,ido;

#if defined(VMS) || defined(UNDERSC)
  curs(&ONE);
#else
#ifdef CRAY
  CURS(&ONE);
#else
  curs_(&ONE);
#endif
#endif

  if (!incompl->nincmp) return;

  for (j=0;j<3;j++) {
     for (i = 0; i < incompl->nincmp; i++) {
	ires = ABS(incompl->incomp[i]);

	ido = 1;
	for (k = 0; k < 3; k++) {
	    if (!calfptr->icalf[ires-1][k]) ido = 0;
	}

	if (!calfptr->icalf[ires][0]) ido = 0;

	if (ido) {
	   if (j == 2) {
		onerot(ires,1);
	   } else {
		onerot(ires,0);
	   }

	} else {
	   if (j == 2) {
		fprintf(stderr,"%s %d: incomplete residue skipped: missing backbone atoms !!\n",AminoAcids[calfptr->iamino[ires-1]-1],calfptr->irsnr[ires-1]);
	   }
	}
     }
  }


#ifdef DOGL
  update_model = 0;
#else
  update_model = 1;
#endif

#if defined(VMS) || defined(UNDERSC)
  qupd();
  curs(&ZERO);
#else
#ifdef CRAY
  QUPD();
  CURS(&ZERO);
#else
  qupd_();
  curs_(&ZERO);
#endif
#endif

}

#if defined(VMS) || defined(UNDERSC)
void opthyd()
#else
#ifdef CRAY
void OPTHYD()
#else
void opthyd_()
#endif
#endif
{
	int i;

	if (HLIG) LigandHydroQ(1,1,1,0);

	if (HINC) RestComplete();

        update_model=0;
	if (*fftyp != 7) typit(7,1);

#if defined(VMS) || defined(UNDERSC)
	opthdd(&HFLP,&HHIS,&HRES,&HWAT,
#else
#ifdef CRAY
	OPTHDD(&HFLP,&HHIS,&HRES,&HWAT,
#else
	opthdd_(&HFLP,&HHIS,&HRES,&HWAT,
#endif
#endif
	iupres,&nupres,calfptr->irsnr,&calfptr->ncalf, calfptr->icalf,xyzp->coo,
	xyzp->qat,xyzp->iconn,xyzp->ianz,xyzp->iresid,calfptr->iamino,
	xyzp->ityp,xyzp->ipdbt);

#ifdef DOGL
	for (i=0; i < nupres; i++ ) {
	   ogres(iupres[i],0,0);
	}
	if (*fancy) {
	   oghet(0);
	} else {
	   oglines();
	}
	update_model = 0;
#endif
	update_struct();

}

#if defined(VMS) || defined(UNDERSC)
void appchg()
#else
#ifdef CRAY
void APPCHG()
#else
void appchg_()
#endif
#endif
{
  if (! *icommf) return;
  if (calfptr->ncalf > 0) {
     if (!qdpptr->ihasq) {
	HINC = HRES = HLIG = HFLP = HHIS = HWAT = 1;
#if defined(VMS) || defined(UNDERSC)
	opthyd();
#else
#ifdef CRAY
	OPTHYD();
#else
	opthyd_();
#endif
#endif
     }
  } else { 
     if (!qdpptr->ihasq) {
#if defined(VMS) || defined(UNDERSC)
	addchg();
#else
#ifdef CRAY
	ADDCHG();
#else
	addchg_();
#endif
#endif
     }
  }
}

#if defined(VMS) || defined(UNDERSC)
void nmrcpl(idebug)
#else
#ifdef CRAY
void NMRCPL(idebug)
#else
void nmrcpl_(idebug)
#endif
#endif
int *idebug;
{
   double d;
   int size;

   size = NAT->natoms;

   if ((jcoupl = (double *) malloc((sizeof d)*size*size)) != NULL) {
#if defined(VMS) || defined(UNDERSC)
	nmrcpd(idebug,
#else
#ifdef CRAY
	NMRCPD(idebug,
#else
	nmrcpd_(idebug,
#endif
#endif
	jcoupl);
   } else {
	fprintf(stderr,"Failed to allocate memory for J-coupling !\n");
	nmrptr->ihsnmr = 1;
   }
}

#if defined(VMS) || defined(UNDERSC)
void nmcshl()
#else
#ifdef CRAY
void NMCSHL()
#else
void nmcshl_()
#endif
#endif
{
   double d;
   int size;

   size = NAT->natoms;

   if ((jcoupl = (double *) malloc((sizeof d)*size*size)) != NULL) {
#if defined(VMS) || defined(UNDERSC)
	nmcshd(
#else
#ifdef CRAY
	NMCSHD(
#else
	nmcshd_(
#endif
#endif
	jcoupl);
   } else {
	fprintf(stderr,"Failed to allocate memory for J-coupling !\n");
	nmrptr->ihsnmr = 1;
   }
}

#if defined(VMS) || defined(UNDERSC)
void pdbstd(istat,doscnd,ioadd)
#else
#ifdef CRAY
void PDBSTD(istat,doscnd,ioadd)
#else
void pdbstd_(istat,doscnd,ioadd)
#endif
#endif
int *istat;
int *doscnd;
int *ioadd;
{
  int iszhnt;

#if defined(VMS) || defined(UNDERSC)
	pdbsiz(&iszhnt);
	if (*ioadd) {
	   if (iszhnt + *xyzp->iatoms > *xyzp->mxnat) allcoo(&iszhnt,&ZERO);
	} else {
	   if (iszhnt > *xyzp->mxnat) allcoo(&iszhnt,&ZERO);
           setid(&FOUR,&ZERO,xyzp->isurf,xyzp->iresid,xyzp->ipdbt);
	}
	pdbsdd(istat,doscnd,ioadd,
#else
#ifdef CRAY
	PDBSIZ(&iszhnt);
	if (*ioadd) {
	   if (iszhnt + *xyzp->iatoms > *xyzp->mxnat) ALLCOO(&iszhnt,&ZERO);
	} else {
	   if (iszhnt > *xyzp->mxnat) ALLCOO(&iszhnt,&ZERO);
           SETID(&FOUR,&ZERO,xyzp->isurf,xyzp->iresid,xyzp->ipdbt);
	}
	PDBSDD(istat,doscnd,ioadd,
#else
	pdbsiz_(&iszhnt);
	if (*ioadd) {
	   if (iszhnt + *xyzp->iatoms > *xyzp->mxnat) allcoo_(&iszhnt,&ZERO);
	} else {
	   if (iszhnt > *xyzp->mxnat) allcoo_(&iszhnt,&ZERO);
           setid_(&FOUR,&ZERO,xyzp->isurf,xyzp->iresid,xyzp->ipdbt);
	}
	pdbsdd_(istat,doscnd,ioadd,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,xyzp->ityp,
        &calfptr->ncalf,calfptr->ianf,calfptr->islu,
        &calfptr->nchain,calfptr->iamino,calfptr->ihet,
        calfptr->isal,calfptr->irsnr,calfptr->achain,
	&calfptr->ihashb,&calfptr->ishoh);


	if (*istat == -1) {
	   hetptr.NHetAtm = 0;
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   pdbsdd(istat,doscnd,ioadd,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   PDBSDD(istat,doscnd,ioadd,
#else
	   allcoo_(&addat,&ZERO);
	   pdbsdd_(istat,doscnd,ioadd,
#endif
#endif
	   xyzp->coo,xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,
	   xyzp->ityp,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
           &calfptr->nchain,calfptr->iamino,calfptr->ihet,
           calfptr->isal,calfptr->irsnr,calfptr->achain,
	   &calfptr->ihashb,&calfptr->ishoh);
        }
}

#if defined(VMS) || defined(UNDERSC)
void conpdb()
#else
#ifdef CRAY
void CONPDB()
#else
void conpdb_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	conpdd(
#else
#ifdef CRAY
	CONPDD(
#else
	conpdd_(
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->iresid,
	&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void convpdb()
#else
#ifdef CRAY
void CONVPDB()
#else
void convpdb_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	convpdd(
#else
#ifdef CRAY
	CONVPDD(
#else
	convpdd_(
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->iresid,
	&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void conslv()
#else
#ifdef CRAY
void CONSLV()
#else
void conslv_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	consld(
#else
#ifdef CRAY
	CONSLD(
#else
	consld_(
#endif
#endif
	xyzp->iconn,xyzp->iresid);

}

#if defined(VMS) || defined(UNDERSC)
void connij(idcon,i,j,idoconv)
#else
#ifdef CRAY
void CONNIJ(idcon,i,j,idoconv)
#else
void connij_(idcon,i,j,idoconv)
#endif
#endif
int *idcon;
int *i;
int *j;
int *idoconv;
{

#if defined(VMS) || defined(UNDERSC)
	connid(idcon,i,j,idoconv,
#else
#ifdef CRAY
	CONNID(idcon,i,j,idoconv,
#else
	connid_(idcon,i,j,idoconv,
#endif
#endif
	xyzp->iconn,xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void setchg(iat,iopt)
#else
#ifdef CRAY
void SETCHG(iat,iopt)
#else
void setchg_(iat,iopt)
#endif
#endif
int *iat;
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
	setchd(iat,iopt,
#else
#ifdef CRAY
	SETCHD(iat,iopt,
#else
	setchd_(iat,iopt,
#endif
#endif
	xyzp->qat,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void flagh(ihpdb,iat)
#else
#ifdef CRAY
void FLAGH(ihpdb,iat)
#else
void flagh_(ihpdb,iat)
#endif
#endif
int *ihpdb;
int *iat;
{

#if defined(VMS) || defined(UNDERSC)
	flagd(ihpdb,iat,
#else
#ifdef CRAY
	FLAGD(ihpdb,iat,
#else
	flagd_(ihpdb,iat,
#endif
#endif
	xyzp->isurf);

}

#if defined(VMS) || defined(UNDERSC)
void conat(ipdb,iat1,iat2,iop)
#else
#ifdef CRAY
void CONAT(ipdb,iat1,iat2,iop)
#else
void conat_(ipdb,iat1,iat2,iop)
#endif
#endif
int *ipdb;
int *iat1;
int *iat2;
int *iop;
{

#if defined(VMS) || defined(UNDERSC)
	conad(ipdb,iat1,iat2,iop,
#else
#ifdef CRAY
	CONAD(ipdb,iat1,iat2,iop,
#else
	conad_(ipdb,iat1,iat2,iop,
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void conath(ipdb,ihpdb,iat1,iat2)
#else
#ifdef CRAY
void CONATH(ipdb,ihpdb,iat1,iat2)
#else
void conath_(ipdb,ihpdb,iat1,iat2)
#endif
#endif
int *ipdb;
int *ihpdb;
int *iat1;
int *iat2;
{

#if defined(VMS) || defined(UNDERSC)
	conatd(ipdb,ihpdb,iat1,iat2,
#else
#ifdef CRAY
	CONATD(ipdb,ihpdb,iat1,iat2,
#else
	conatd_(ipdb,ihpdb,iat1,iat2,
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void pdbtyp(ipdb,ihpdb,jres,ihashy)
#else
#ifdef CRAY
void PDBTYP(ipdb,ihpdb,jres,ihashy)
#else
void pdbtyp_(ipdb,ihpdb,jres,ihashy)
#endif
#endif
int *ipdb;
int *ihpdb;
int *jres;
int *ihashy;
{

#if defined(VMS) || defined(UNDERSC)
	pdbtyd(ipdb,ihpdb,jres,ihashy,
#else
#ifdef CRAY
	PDBTYD(ipdb,ihpdb,jres,ihashy,
#else
	pdbtyd_(ipdb,ihpdb,jres,ihashy,
#endif
#endif
	xyzp->ipdbt);

}

#if defined(VMS) || defined(UNDERSC)
void typeit(ipdb,jres,ihpdb,ihashy)
#else
#ifdef CRAY
void TYPEIT(ipdb,jres,ihpdb,ihashy)
#else
void typeit_(ipdb,jres,ihpdb,ihashy)
#endif
#endif
int *ipdb;
int *ihpdb;
int *jres;
int *ihashy;
{

#if defined(VMS) || defined(UNDERSC)
	typeid(ipdb,jres,ihpdb,ihashy,
#else
#ifdef CRAY
	TYPEID(ipdb,jres,ihpdb,ihashy,
#else
	typeid_(ipdb,jres,ihpdb,ihashy,
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void typamb(ipdb,jres,ihpdb,ihashy)
#else
#ifdef CRAY
void TYPAMB(ipdb,jres,ihpdb,ihashy)
#else
void typamb_(ipdb,jres,ihpdb,ihashy)
#endif
#endif
int *ipdb;
int *ihpdb;
int *jres;
int *ihashy;
{

#if defined(VMS) || defined(UNDERSC)
	typamd(ipdb,jres,ihpdb,ihashy,
#else
#ifdef CRAY
	TYPAMD(ipdb,jres,ihpdb,ihashy,
#else
	typamd_(ipdb,jres,ihpdb,ihashy,
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void typamo(ipdb,jres,ihpdb,ihashy)
#else
#ifdef CRAY
void TYPAMO(ipdb,jres,ihpdb,ihashy)
#else
void typamo_(ipdb,jres,ihpdb,ihashy)
#endif
#endif
int *ipdb;
int *ihpdb;
int *jres;
int *ihashy;
{

#if defined(VMS) || defined(UNDERSC)
	typado(ipdb,jres,ihpdb,ihashy,
#else
#ifdef CRAY
	TYPADO(ipdb,jres,ihpdb,ihashy,
#else
	typado_(ipdb,jres,ihpdb,ihashy,
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->ityp);

}


#if defined(VMS) || defined(UNDERSC)
void mkback(ipdb,ihpdb,jres,icres,ihashy,idoconv)
#else
#ifdef CRAY
void MKBACK(ipdb,ihpdb,jres,icres,ihashy,idoconv)
#else
void mkback_(ipdb,ihpdb,jres,icres,ihashy,idoconv)
#endif
#endif
int *ipdb;
int *ihpdb;
int *jres;
int *icres;
int *ihashy;
int *idoconv;
{

/*
 The variable NW_MKBACK switches betwwen the old (NW_MKBACK=0)
 and the new (NW_MKBACK=0) form of mkback. The old version depended
 on the next call (residue nr. one higher) to complete the connections of
 Coo. Hence if called on its own the Coo connections would not be complete.
 However since the icalf variables of the next residue have NOT been set
 at the time when it is first called, we still need this one !!!

 The new form of mkback can be called on its own and have all connections
 complete. Depend on icalf variables already been set for all residues.
*/

    if (NW_MKBACK) {
#if defined(VMS) || defined(UNDERSC)
	mkbadd(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#else
#ifdef CRAY
	MKBADD(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#else
	mkbadd_(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#endif
#endif
	xyzp->iconn,xyzp->coo,
        calfptr->icalf,calfptr->ianf,calfptr->islu,
        &calfptr->nchain,calfptr->iamino);
    } else {
#if defined(VMS) || defined(UNDERSC)
	mkbacd(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#else
#ifdef CRAY
	MKBACD(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#else
	mkbacd_(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#endif
#endif
	xyzp->iconn,xyzp->coo,
        calfptr->icalf,calfptr->ianf,calfptr->islu,
        &calfptr->nchain,calfptr->iamino);
    }

}

#if defined(VMS) || defined(UNDERSC)
void mknbck(ipdb,ihpdb,jres,icres,ihashy,idoconv)
#else
#ifdef CRAY
void MKNBCK(ipdb,ihpdb,jres,icres,ihashy,idoconv)
#else
void mknbck_(ipdb,ihpdb,jres,icres,ihashy,idoconv)
#endif
#endif
int *ipdb;
int *ihpdb;
int *jres;
int *icres;
int *ihashy;
int *idoconv;
{

#if defined(VMS) || defined(UNDERSC)
	mknbcd(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#else
#ifdef CRAY
	MKNBCD(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#else
	mknbcd_(ipdb,ihpdb,jres,icres,ihashy,idoconv,
#endif
#endif
	xyzp->iconn,xyzp->coo,
        calfptr->icalf,calfptr->ianf,calfptr->islu,
        &calfptr->nchain,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void tautom()
#else
#ifdef CRAY
void TAUTOM()
#else
void tautom_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	tautd(
#else
#ifdef CRAY
	TAUTD(
#else
	tautd_(
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	xyzp->ipdbt,xyzp->ityp,&calfptr->ncalf,calfptr->icalf,
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void addhs(ires,jres,ipdb,ihpdb,nterm)
#else
#ifdef CRAY
void ADDHS(ires,jres,ipdb,ihpdb,nterm)
#else
void addhs_(ires,jres,ipdb,ihpdb,nterm)
#endif
#endif
int *ires;
int *jres;
int *ipdb;
int *ihpdb;
int *nterm;
{

#if defined(VMS) || defined(UNDERSC)
	addhd(ires,jres,ipdb,ihpdb,nterm,
#else
#ifdef CRAY
	ADDHD(ires,jres,ipdb,ihpdb,nterm,
#else
	addhd_(ires,jres,ipdb,ihpdb,nterm,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	xyzp->isurf,xyzp->ipdbt,xyzp->ityp,&calfptr->ncalf,calfptr->icalf,
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void numhet(num)
#else
#ifdef CRAY
void NUMHET(num)
#else
void numhet_(num)
#endif
#endif
int *num;
{

#if defined(VMS) || defined(UNDERSC)
	numhed(num,
#else
#ifdef CRAY
	NUMHED(num,
#else
	numhed_(num,
#endif
#endif
	xyzp->iresid);

}

#if defined(VMS) || defined(UNDERSC)
void qcxyz(idebug,nuclear,ipnt,istat)
#else
#ifdef CRAY
void QCXYZ(idebug,nuclear,ipnt,istat)
#else
void qcxyz_(idebug,nuclear,ipnt,istat)
#endif
#endif
int *idebug;
int *nuclear;
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	qcxyd(idebug,nuclear,ipnt,istat,
#else
#ifdef CRAY
	QCXYD(idebug,nuclear,ipnt,istat,
#else
	qcxyd_(idebug,nuclear,ipnt,istat,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void orcxyz(idebug,ipnt,istat)
#else
#ifdef CRAY
void ORCXYZ(idebug,ipnt,istat)
#else
void orcxyz_(idebug,ipnt,istat)
#endif
#endif
int *idebug;
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	orcxyd(idebug,ipnt,istat,
#else
#ifdef CRAY
	ORCXYD(idebug,ipnt,istat,
#else
	orcxyd_(idebug,ipnt,istat,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void entag(idebug,istat)
#else
#ifdef CRAY
void ENTAG(idebug,istat)
#else
void entag_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	entad(idebug,istat,
#else
#ifdef CRAY
	ENTAD(idebug,istat,
#else
	entad_(idebug,istat,
#endif
#endif
	xyzp->ianz);

}

#if defined(VMS) || defined(UNDERSC)
void enmull(idebug,istat)
#else
#ifdef CRAY
void ENMULL(idebug,istat)
#else
void enmull_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	enmuld(idebug,istat,
#else
#ifdef CRAY
	ENMULD(idebug,istat,
#else
	enmuld_(idebug,istat,
#endif
#endif
	xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void nwxyz(idebug,ipnt,istat)
#else
#ifdef CRAY
void NWXYZ(idebug,ipnt,istat)
#else
void nwxyz_(idebug,ipnt,istat)
#endif
#endif
int *idebug;
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	nwxyd(idebug,ipnt,istat,
#else
#ifdef CRAY
	NWXYD(idebug,ipnt,istat,
#else
	nwxyd_(idebug,ipnt,istat,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void enwxyz(idebug,ipnt,istat)
#else
#ifdef CRAY
void ENWXYZ(idebug,ipnt,istat)
#else
void enwxyz_(idebug,ipnt,istat)
#endif
#endif
int *idebug;
int *ipnt;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	enwxyd(idebug,ipnt,istat,
#else
#ifdef CRAY
	ENWXYD(idebug,ipnt,istat,
#else
	enwxyd_(idebug,ipnt,istat,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void fnwxyz(idebug,istat)
#else
#ifdef CRAY
void FNWXYZ(idebug,istat)
#else
void fnwxyz_(idebug,istat)
#endif
#endif
int *idebug;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	fnwxyd(idebug,istat,
#else
#ifdef CRAY
	FNWXYD(idebug,istat,
#else
	fnwxyd_(idebug,istat,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void getqfr(istat)
#else
#ifdef CRAY
void GETQFR(istat)
#else
void getqfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getqfd(istat,
#else
#ifdef CRAY
	GETQFD(istat,
#else
	getqfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void getofr(istat)
#else
#ifdef CRAY
void GETOFR(istat)
#else
void getofr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getofd(istat,
#else
#ifdef CRAY
	GETOFD(istat,
#else
	getofd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void getnfr(istat)
#else
#ifdef CRAY
void GETNFR(istat)
#else
void getnfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	getnfd(istat,
#else
#ifdef CRAY
	GETNFD(istat,
#else
	getnfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void egtnfr(istat)
#else
#ifdef CRAY
void EGTNFR(istat)
#else
void egtnfr_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	egtnfd(istat,
#else
#ifdef CRAY
	EGTNFD(istat,
#else
	egtnfd_(istat,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rotcor(b)
#else
#ifdef CRAY
void ROTCOR(b)
#else
void rotcor_(b)
#endif
#endif
double *b;
{

#if defined(VMS) || defined(UNDERSC)
	rotcod(b,
#else
#ifdef CRAY
	ROTCOD(b,
#else
	rotcod_(b,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rotmom(ipoint,ifav)
#else
#ifdef CRAY
void ROTMOM(ipoint,ifav)
#else
void rotmom_(ipoint,ifav)
#endif
#endif
int *ipoint;
int *ifav;
{

#if defined(VMS) || defined(UNDERSC)
	rotmod(ipoint,ifav,
#else
#ifdef CRAY
	ROTMOD(ipoint,ifav,
#else
	rotmod_(ipoint,ifav,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rotfir(ioxyz)
#else
#ifdef CRAY
void ROTFIR(ioxyz)
#else
void rotfir_(ioxyz)
#endif
#endif
int *ioxyz;
{

#if defined(VMS) || defined(UNDERSC)
	rotfid(ioxyz,
#else
#ifdef CRAY
	ROTFID(ioxyz,
#else
	rotfid_(ioxyz,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void setorg(iatom)
#else
#ifdef CRAY
void SETORG(iatom)
#else
void setorg_(iatom)
#endif
#endif
int *iatom;
{

#if defined(VMS) || defined(UNDERSC)
	setord(iatom,
#else
#ifdef CRAY
	SETORD(iatom,
#else
	setord_(iatom,
#endif
#endif
	rotptr->t,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void samino(istat)
#else
#ifdef CRAY
void SAMINO(istat)
#else
void samino_(istat)
#endif
#endif
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	samind(istat,
#else
#ifdef CRAY
	SAMIND(istat,
#else
	samind_(istat,
#endif
#endif
	xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->ipdbt,
	calfptr->icalf,&calfptr->ncalf,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void getpdb(ires,ipdb,ihpdb)
#else
#ifdef CRAY
void GETPDB(ires,ipdb,ihpdb)
#else
void getpdb_(ires,ipdb,ihpdb)
#endif
#endif
int *ires;
int *ipdb;
int *ihpdb;
{

#if defined(VMS) || defined(UNDERSC)
	getpdd(ires,ipdb,ihpdb,
#else
#ifdef CRAY
	GETPDD(ires,ipdb,ihpdb,
#else
	getpdd_(ires,ipdb,ihpdb,
#endif
#endif
	xyzp->ianz,xyzp->iresid,xyzp->ipdbt);

}

#if defined(VMS) || defined(UNDERSC)
void bckok(ibckok,ires,iop)
#else
#ifdef CRAY
void BCKOK(ibckok,ires,iop)
#else
void bckok_(ibckok,ires,iop)
#endif
#endif
int *ibckok;
int *ires;
int *iop;
{

#if defined(VMS) || defined(UNDERSC)
	bckod(ibckok,ires,iop,
#else
#ifdef CRAY
	BCKOD(ibckok,ires,iop,
#else
	bckod_(ibckok,ires,iop,
#endif
#endif
	xyzp->ianz,xyzp->iresid,xyzp->ipdbt,
	calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void wrsrf(iun,nesp,iesp)
#else
#ifdef CRAY
void WRSRF(iun,nesp,iesp)
#else
void wrsrf_(iun,nesp,iesp)
#endif
#endif
int *iun;
int *nesp;
int *iesp;
{

#if defined(VMS) || defined(UNDERSC)
	wrsrd(iun,nesp,iesp,
#else
#ifdef CRAY
	WRSRD(iun,nesp,iesp,
#else
	wrsrd_(iun,nesp,iesp,
#endif
#endif
	xyzp->ianz,xyzp->iatclr,xyzp->iconn,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void rdsrf(iun,istats,iesp,iaddprv,idebug)
#else
#ifdef CRAY
void RDSRF(iun,istats,iesp,iaddprv,idebug)
#else
void rdsrf_(iun,istats,iesp,iaddprv,idebug)
#endif
#endif
int *iun;
int *istats;
int *iesp;
int *iaddprv;
int *idebug;
{

#if defined(VMS) || defined(UNDERSC)
	rdsrd(iun,istats,iesp,iaddprv,idebug,
#else
#ifdef CRAY
	RDSRD(iun,istats,iesp,iaddprv,idebug,
#else
	rdsrd_(iun,istats,iesp,iaddprv,idebug,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void srfden(x,y,z,f)
#else
#ifdef CRAY
void SRFDEN(x,y,z,f)
#else
void srfden_(x,y,z,f)
#endif
#endif
double *x;
double *y;
double *z;
double *f;
{

#if defined(VMS) || defined(UNDERSC)
	srfded(x,y,z,f,
#else
#ifdef CRAY
	SRFDED(x,y,z,f,
#else
	srfded_(x,y,z,f,
#endif
#endif
	xyzp->ianz,xyzp->isurf,xyzp->coo,xyzp->icont,xyzp->ncont);

}

#if defined(VMS) || defined(UNDERSC)
void defsrf()
#else
#ifdef CRAY
void DEFSRF()
#else
void defsrf_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	defsrd(
#else
#ifdef CRAY
	DEFSRD(
#else
	defsrd_(
#endif
#endif
	xyzp->isurf,xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void clrmon()
#else
#ifdef CRAY
void CLRMON()
#else
void clrmon_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	clrmod(
#else
#ifdef CRAY
	CLRMOD(
#else
	clrmod_(
#endif
#endif
	xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void intcor(intc,rout,isel,inum)
#else
#ifdef CRAY
void INTCOR(intc,rout,isel,inum)
#else
void intcor_(intc,rout,isel,inum)
#endif
#endif
int *intc;
short int *rout;
int *isel;
int *inum;
{

#if defined(VMS) || defined(UNDERSC)
	intcod(intc,rout,isel,inum,
#else
#ifdef CRAY
	INTCOD(intc,rout,isel,inum,
#else
	intcod_(intc,rout,isel,inum,
#endif
#endif
	xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void xyzcoo(idocopy,idoconv,ioadd)
#else
#ifdef CRAY
void XYZCOO(idocopy,idoconv,ioadd)
#else
void xyzcoo_(idocopy,idoconv,ioadd)
#endif
#endif
int *idocopy;
int *idoconv;
int *ioadd;
{

#if defined(VMS) || defined(UNDERSC)
	xyzcod(idocopy,idoconv,ioadd,
#else
#ifdef CRAY
	XYZCOD(idocopy,idoconv,ioadd,
#else
	xyzcod_(idocopy,idoconv,ioadd,
#endif
#endif
	xyzp->ianz,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void wrmsf(iun)
#else
#ifdef CRAY
void WRMSF(iun)
#else
void wrmsf_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrmsfd(iun,
#else
#ifdef CRAY
	WRMSFD(iun,
#else
	wrmsfd_(iun,
#endif
#endif
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,
	xyzp->iconn,xyzp->lring,xyzp->ityp,&cell->natc,&cell->nspg,&cell->ichx,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);


}

#if defined(VMS) || defined(UNDERSC)
void wrtnk(iun)
#else
#ifdef CRAY
void WRTNK(iun)
#else
void wrtnk_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrtnd(iun,
#else
#ifdef CRAY
	WRTND(iun,
#else
	wrtnd_(iun,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->lring,xyzp->ityp,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void wrgff(iun)
#else
#ifdef CRAY
void WRGFF(iun)
#else
void wrgff_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrgfd(iun,
#else
#ifdef CRAY
	WRGFD(iun,
#else
	wrgfd_(iun,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->isurf,xyzp->lring,
	xyzp->lwrit,&calfptr->ncalf,&calfptr->ishoh,
	xyzp->iresid,xyzp->ityp,xyzp->coo,xyzp->qat,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void wrogl(iun)
#else
#ifdef CRAY
void WROGL(iun)
#else
void wrogl_(iun)
#endif
#endif
int *iun;
{

#if defined(VMS) || defined(UNDERSC)
	wrogd(iun,
#else
#ifdef CRAY
	WROGD(iun,
#else
	wrogd_(iun,
#endif
#endif
	rotptr->rx,rotptr->ry,rotptr->rz,
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,
	xyzp->lring,xyzp->coo,xyzp->rzp,calfptr->reson,
	calfptr->ianf,&calfptr->nchain,&calfptr->ncalf);

}

#if defined(VMS) || defined(UNDERSC)
void getnat(natoms)
#else
#ifdef CRAY
void GETNAT(natoms)
#else
void getnat_(natoms)
#endif
#endif
int *natoms;
{
   int i;

/*
   *natoms = 0;
   for (i=0; i < *xyzp->iatoms; i++ ) 
	if (xyzp->ianz[i] < 100 && xyzp->ianz[i] > 0) (*natoms)++;
*/

   *natoms = *xyzp->iatoms;
   for (i=*xyzp->iatoms-1; i >= 0; i-- ) 
	if (xyzp->ianz[i] < 100 && xyzp->ianz[i] > 0) {
	    *natoms = i;
            (*natoms)++;
	    break;
	}
}

#if defined(VMS) || defined(UNDERSC)
void allon(ntota,nwat,nion,nsign,newat,nresi)
#else
#ifdef CRAY
void ALLON(ntota,nwat,nion,nsign,newat,nresi)
#else
void allon_(ntota,nwat,nion,nsign,newat,nresi)
#endif
#endif
int *ntota;
int *nwat;
int *nion;
int *nsign;
int *newat;
int *nresi;
{
   int i,j,iwat,nwater,iall,nions,ires;

   if ( *nion == -1) {
	nions = 0;
	nwater = (*newat - *nwat);
   } else {
	nions = (*newat - *nion + 1);
	nwater = (*nion - *nwat);
   }
   iall = nwater + nions + 8;
   nwater = nwater/3;

   if (*newat > *xyzp->mxnat)  {
#if defined(VMS) || defined(UNDERSC)
	allcoo(&iall,&ZERO);
#else
#ifdef CRAY
	ALLCOO(&iall,&ZERO);
#else
	allcoo_(&iall,&ZERO);
#endif
#endif
   }


   *xyzp->iatoms = *newat;

   if (hetptr.NHetAtm == 0) {
	hetptr.Allocated[0] = 1;
	hetptr.HetAtm[0] = (char *) malloc(6);
	strcpy(hetptr.HetAtm[0],"Helix");
	hetptr.Allocated[1] = 1;
	hetptr.HetAtm[1] = (char *) malloc(5);
	strcpy(hetptr.HetAtm[1],"Beta");
	hetptr.Allocated[2] = 1;
	hetptr.HetAtm[2] = (char *) malloc(8);
	strcpy(hetptr.HetAtm[2],"RNA/DNA");
	hetptr.Allocated[3] = 1;
	hetptr.HetAtm[3] = (char *) malloc(5);
	strcpy(hetptr.HetAtm[3],"coil");
	hetptr.NHetAtm = 4;
   }
/*   if (hetptr.NHetAtm < 4) hetptr.NHetAtm = 4;*/

   cellpnt->iclon = 1;

   ires = *nresi -1;
   if (ires > 0) ires = -4;

   hetptr.Allocated[hetptr.NHetAtm] = 1;
   hetptr.HetAtm[hetptr.NHetAtm] = (char *) malloc(4);
   strcpy(hetptr.HetAtm[hetptr.NHetAtm],"HOH");
   hetptr.NHetAtm++;

   if (calfptr->ishoh == 0) calfptr->ishoh = abs(ires);

   for (i=0; i < nwater; i++ ) {
        iwat = *ntota + 3*i;

	xyzp->ianz[iwat] = 8;
	xyzp->ityp[iwat] = 649;
	xyzp->qat[iwat] = -0.834;
	xyzp->iaton[iwat] = 1;
	xyzp->iatclr[iwat] = 1;
	xyzp->iresid[iwat] = ires;
	xyzp->iconn[iwat*(MXCON+1)] = 2;
	xyzp->iconn[iwat*(MXCON+1)+1] = (iwat+1)+1;
	xyzp->iconn[iwat*(MXCON+1)+2] = (iwat+2)+1;

	xyzp->ianz[iwat+1] = 1;
	xyzp->ityp[iwat+1] = 650;
	xyzp->qat[iwat+1] = 0.471;
	xyzp->iaton[iwat+1] = 1;
	xyzp->iatclr[iwat+1] = 1;
	xyzp->iresid[iwat+1] = ires;
	xyzp->iconn[(iwat+1)*(MXCON+1)] = 1;
	xyzp->iconn[(iwat+1)*(MXCON+1)+1] = (iwat)+1;

	xyzp->ianz[iwat+2] = 1;
	xyzp->ityp[iwat+2] = 650;
	xyzp->qat[iwat+2] = 0.471;
	xyzp->iaton[iwat+2] = 1;
	xyzp->iatclr[iwat+2] = 1;
	xyzp->iresid[iwat+2] = ires;
	xyzp->iconn[(iwat+2)*(MXCON+1)] = 1;
	xyzp->iconn[(iwat+2)*(MXCON+1)+1] = (iwat)+1;

	ires--;

   }

   if (nions > 0) {
	calfptr->ision = ires;
	hetptr.Allocated[hetptr.NHetAtm] = 1;
	hetptr.HetAtm[hetptr.NHetAtm] = (char *) malloc(5);
	strcpy(hetptr.HetAtm[hetptr.NHetAtm],"ions");
	hetptr.NHetAtm++;
   } else calfptr->ision = 10000;

   for (i=0; i < nions; i++ ) {
        iwat = *ntota + nwater*3 + i;

	if (*nsign) {
	   xyzp->ianz[iwat] = 17;
	   xyzp->ityp[iwat] = 659;
	   xyzp->qat[iwat] =  -1.0;
	} else {
	   xyzp->ianz[iwat] = 11;
	   xyzp->ityp[iwat] = 652;
	   xyzp->qat[iwat] =  1.0;
	}
	xyzp->iaton[iwat] = 1;
	xyzp->iatclr[iwat] = 1;
	xyzp->iresid[iwat] = ires;
	xyzp->iconn[iwat*(MXCON+1)] = 0;

	ires--;

   }

 /*  hetptr.NHetAtm++;*/

   *xyzp->iatoms = *ntota + iall;
   for (i=0; i < 8; i++ ) {
        iwat = *ntota + nwater*3 + nions + i;
	xyzp->iaton[iwat] = 1;
	xyzp->ianz[iwat] = 100;
	xyzp->iresid[iwat] = 0;
	xyzp->lwrit[iwat] = 1;

   }


}

#if defined(VMS) || defined(UNDERSC)
void upajob()
#else
#ifdef CRAY
void UPAJOB()
#else
void upajob_()
#endif
#endif
{
   if (ATMup) RedrawATM();
   if (TNKup) RedrawTNK();
   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
}

#if defined(VMS) || defined(UNDERSC)
void rdbin(iun,heat)
#else
#ifdef CRAY
void RDBIN(iun,heat)
#else
void rdbin_(iun,heat)
#endif
#endif
int *iun;
double *heat;
{
#if defined(VMS) || defined(UNDERSC)
	rdbid(iun,heat,
#else
#ifdef CRAY
	RDBID(iun,heat,
#else
	rdbid_(iun,heat,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	xyzp->lring, &cell->natc,&cell->norg,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);
}

#if defined(VMS) || defined(UNDERSC)
void gettyp(ires,iat1,iat2)
#else
#ifdef CRAY
void GETTYP(ires,iat1,iat2)
#else
void gettyp_(ires,iat1,iat2)
#endif
#endif
int *ires;
int *iat1;
int *iat2;
{
#if defined(VMS) || defined(UNDERSC)
	gettyd(ires,iat1,iat2,
#else
#ifdef CRAY
	GETTYD(ires,iat1,iat2,
#else
	gettyd_(ires,iat1,iat2,
#endif
#endif
	xyzp->ityp,xyzp->ipdbt,xyzp->ianz,xyzp->iresid,
	calfptr->iamino,calfptr->icalf,&calfptr->ncalf);
}

#if defined(VMS) || defined(UNDERSC)
void chkbrk()
#else
#ifdef CRAY
void CHKBRK()
#else
void chkbrk_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
	chkbrd(
#else
#ifdef CRAY
	CHKBRD(
#else
	chkbrd_(
#endif
#endif
	xyzp->iconn,calfptr->icalf,calfptr->ianf,calfptr->islu,
	calfptr->iamino,calfptr->isal,calfptr->reson,
	&calfptr->ncalf,&calfptr->nchain);
}

#if defined(VMS) || defined(UNDERSC)
void gettnk(igttnk,idebug,ipdbon,iffset,iheat,heat)
#else
#ifdef CRAY
void GETTNK(igttnk,idebug,ipdbon,iffset,iheat,heat)
#else
void gettnk_(igttnk,idebug,ipdbon,iffset,iheat,heat)
#endif
#endif
int *igttnk;
int *idebug;
int *ipdbon;
int *iffset;
int *iheat;
double *heat;
{

	int i;

#if defined(VMS) || defined(UNDERSC)
	gettnd(igttnk,idebug,ipdbon,iffset,iheat,heat,
#else
#ifdef CRAY
	GETTND(igttnk,idebug,ipdbon,iffset,iheat,heat,
#else
	gettnd_(igttnk,idebug,ipdbon,iffset,iheat,heat,
#endif
#endif
	xyzp->ianz,xyzp->iconn,xyzp->iatclr,xyzp->ityp,xyzp->coo,xyzp->qat,
	xyzp->isurf,&calfptr->issdon,&cellpnt->iclon,&cell->ichx,
	&calfptr->ishoh,&calfptr->ision,&cell->nspg,&cell->natc,&cell->norg,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

	if (*igttnk == -1) {
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   gettnd(igttnk,idebug,ipdbon,iffset,iheat,heat,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   GETTND(igttnk,idebug,ipdbon,iffset,iheat,heat,
#else
	   allcoo_(&addat,&ZERO);
	   gettnd_(igttnk,idebug,ipdbon,iffset,iheat,heat,
#endif
#endif
	   xyzp->ianz,xyzp->iconn,xyzp->iatclr,xyzp->ityp,xyzp->coo,xyzp->qat,
	   xyzp->isurf,&calfptr->issdon,&cellpnt->iclon,&cell->ichx,
	   &calfptr->ishoh,&calfptr->ision,&cell->nspg,&cell->natc,&cell->norg,
	   &cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	   &cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);
        }
	COO[istruct]->icst = *icst;
	for (i=0; i<*xyzp->iatoms; i++) {
	   if (xyzp->isurf[i] != 1) *icst = 1;
	}
}

#if defined(VMS) || defined(UNDERSC)
void tnkfst(igttnk,idebug,ialloc)
#else
#ifdef CRAY
void TNKFST(igttnk,idebug,ialloc)
#else
void tnkfst_(igttnk,idebug,ialloc)
#endif
#endif
int *igttnk;
int *idebug;
int *ialloc;
{


#if defined(VMS) || defined(UNDERSC)
	tnkfsd(igttnk,idebug,ialloc,
#else
#ifdef CRAY
	TNKFSD(igttnk,idebug,ialloc,
#else
	tnkfsd_(igttnk,idebug,ialloc,
#endif
#endif
	xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	xyzp->lring,&cell->ichx,
	&cell->natc,&cell->norg,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	&cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

	if (*igttnk == -1) {
#if defined(VMS) || defined(UNDERSC)
	   allcoo(&addat,&ZERO);
	   tnkfsd(igttnk,idebug,ialloc,
#else
#ifdef CRAY
	   ALLCOO(&addat,&ZERO);
	   TNKFSD(igttnk,idebug,ialloc,
#else
	   allcoo_(&addat,&ZERO);
	   tnkfsd_(igttnk,idebug,ialloc,
#endif
#endif
	   xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
	   xyzp->lring,&cell->ichx,
	   &cell->natc,&cell->norg,
	   &cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	   &cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);
        }
}

#if defined(VMS) || defined(UNDERSC)
void dotyp(icel)
#else
#ifdef CRAY
void DOTYP(icel)
#else
void dotyp_(icel)
#endif
#endif
int *icel;
{

#if defined(VMS) || defined(UNDERSC)
	dotyd(icel,
#else
#ifdef CRAY
	DOTYD(icel,
#else
	dotyd_(icel,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iconn,xyzp->iresid,
	xyzp->lwrit,xyzp->lring,xyzp->ityp,xyzp->coo,xyzp->qat,xyzp->icont,
	calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,&calfptr->ishoh,
	&cell->natc,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

}

#if defined(VMS) || defined(UNDERSC)
void chkcoo(kcoo,kcooh)
#else
#ifdef CRAY
void CHKCOO(kcoo,kcooh)
#else
void chkcoo_(kcoo,kcooh)
#endif
#endif
int *kcoo;
int *kcooh;
{

#if defined(VMS) || defined(UNDERSC)
	chkcod(kcoo,kcooh,
#else
#ifdef CRAY
	CHKCOD(kcoo,kcooh,
#else
	chkcod_(kcoo,kcooh,
#endif
#endif
	xyzp->ianz,xyzp->iconn);
}

#if defined(VMS) || defined(UNDERSC)
void espfit(idip,nesp,esp,connl,dx,dy,dz,iz,dmachg,ichadd)
#else
#ifdef CRAY
void ESPFIT(idip,nesp,esp,connl,dx,dy,dz,iz,dmachg,ichadd)
#else
void espfit_(idip,nesp,esp,connl,dx,dy,dz,iz,dmachg,ichadd)
#endif
#endif
int *idip;
int *nesp;
double *esp;
double *connl;
double *dx;
double *dy;
double *dz;
int *iz;
int *dmachg;
int *ichadd;
{

#if defined(VMS) || defined(UNDERSC)
	espfid(idip,nesp,esp,connl,dx,dy,dz,iz,dmachg,ichadd,
#else
#ifdef CRAY
	ESPFID(idip,nesp,esp,connl,dx,dy,dz,iz,dmachg,ichadd,
#else
	espfid_(idip,nesp,esp,connl,dx,dy,dz,iz,dmachg,ichadd,
#endif
#endif
	xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void allzmt(ipdbon)
#else
#ifdef CRAY
void ALLZMT(ipdbon)
#else
void allzmt_(ipdbon)
#endif
#endif
int *ipdbon;
{

#if defined(VMS) || defined(UNDERSC)
	allzmd(ipdbon,
#else
#ifdef CRAY
	ALLZMD(ipdbon,
#else
	allzmd_(ipdbon,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void ligzmt()
#else
#ifdef CRAY
void LIGZMT()
#else
void ligzmt_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	ligzmd(
#else
#ifdef CRAY
	LIGZMD(
#else
	ligzmd_(
#endif
#endif
	xyzp->ianz,xyzp->iaton);

}

#if defined(VMS) || defined(UNDERSC)
void pdbzmt()
#else
#ifdef CRAY
void PDBZMT()
#else
void pdbzmt_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
	pdbzmd(
#else
#ifdef CRAY
	PDBZMD(
#else
	pdbzmd_(
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,
	&calfptr->ishoh);
	clfstrptr->ihashz = 0;

}

#if defined(VMS) || defined(UNDERSC)
void haswat(ino)
#else
#ifdef CRAY
void HASWAT(ino)
#else
void haswat_(ino)
#endif
#endif
int *ino;
{

#if defined(VMS) || defined(UNDERSC)
	haswad(ino,
#else
#ifdef CRAY
	HASWAD(ino,
#else
	haswad_(ino,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn);

}

#if defined(VMS) || defined(UNDERSC)
void intzmt(ispdb)
#else
#ifdef CRAY
void INTZMT(ispdb)
#else
void intzmt_(ispdb)
#endif
#endif
int *ispdb;
{

#if defined(VMS) || defined(UNDERSC)
	intzmd(ispdb,
#else
#ifdef CRAY
	INTZMD(ispdb,
#else
	intzmd_(ispdb,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,
	xyzp->lwrit,xyzp->lring,
	calfptr->icalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino);

}

#if defined(VMS) || defined(UNDERSC)
void icrcon(icrcon,isel,idisc,ndisc,nanz,ispdb)
#else
#ifdef CRAY
void ICRCON(icrcon,isel,idisc,ndisc,nanz,ispdb)
#else
void icrcon_(icrcon,isel,idisc,ndisc,nanz,ispdb)
#endif
#endif
int *icrcon;
int *isel;
int *idisc;
int *ndisc;
int *nanz;
int *ispdb;
{

#if defined(VMS) || defined(UNDERSC)
	icrcod(icrcon,isel,idisc,ndisc,nanz,ispdb,
#else
#ifdef CRAY
	ICRCOD(icrcon,isel,idisc,ndisc,nanz,ispdb,
#else
	icrcod_(icrcon,isel,idisc,ndisc,nanz,ispdb,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->lwrit,xyzp->coo,
	calfptr->icalf,&calfptr->ncalf);

}

#if defined(VMS) || defined(UNDERSC)
void calcx(ical,isel,nx)
#else
#ifdef CRAY
void CALCX(ical,isel,nx)
#else
void calcx_(ical,isel,nx)
#endif
#endif
int *ical;
int *isel;
int *nx;
{

#if defined(VMS) || defined(UNDERSC)
	calcd(ical,isel,nx,
#else
#ifdef CRAY
	CALCD(ical,isel,nx,
#else
	calcd_(ical,isel,nx,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->coo);

}

#if defined(VMS) || defined(UNDERSC)
void prelea(iprel,ilead,isel,ispdb,ithree)
#else
#ifdef CRAY
void PRELEA(iprel,ilead,isel,ispdb,ithree)
#else
void prelea_(iprel,ilead,isel,ispdb,ithree)
#endif
#endif
int *iprel;
int *ilead;
int *isel;
int *ispdb;
int *ithree;
{

#if defined(VMS) || defined(UNDERSC)
	prelead(iprel,ilead,isel,ispdb,ithree,
#else
#ifdef CRAY
	PRELEAD(iprel,ilead,isel,ispdb,ithree,
#else
	prelead_(iprel,ilead,isel,ispdb,ithree,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,xyzp->lwrit);

}

#if defined(VMS) || defined(UNDERSC)
void preleh(iprel,ilead,isel,ispdb,ithree)
#else
#ifdef CRAY
void PRELEH(iprel,ilead,isel,ispdb,ithree)
#else
void preleh_(iprel,ilead,isel,ispdb,ithree)
#endif
#endif
int *iprel;
int *ilead;
int *isel;
int *ispdb;
int *ithree;
{

#if defined(VMS) || defined(UNDERSC)
	prelehd(iprel,ilead,isel,ispdb,ithree,
#else
#ifdef CRAY
	PRELEHD(iprel,ilead,isel,ispdb,ithree,
#else
	prelehd_(iprel,ilead,isel,ispdb,ithree,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iresid,xyzp->iconn,xyzp->lwrit);

}

#if defined(VMS) || defined(UNDERSC)
void rdbas(idebug,dfree,istats)
#else
#ifdef CRAY
void RDBAS(idebug,dfree,istats)
#else
void rdbas_(idebug,dfree,istats)
#endif
#endif
int *idebug;
int *dfree;
int *istats;
{

#if defined(VMS) || defined(UNDERSC)
	rdbad(idebug,dfree,istats,
#else
#ifdef CRAY
	RDBAD(idebug,dfree,istats,
#else
	rdbad_(idebug,dfree,istats,
#endif
#endif
	xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void setis(nset,istart)
#else
#ifdef CRAY
void SETIS(nset,istart)
#else
void setis_(nset,istart)
#endif
#endif
int *nset;
int *istart;
{

#if defined(VMS) || defined(UNDERSC)
	setid(nset,istart,
#else
#ifdef CRAY
	SETID(nset,istart,
#else
	setid_(nset,istart,
#endif
#endif
	xyzp->isurf,xyzp->iresid,xyzp->ipdbt);

}

#if defined(VMS) || defined(UNDERSC)
void clkbck(istsurf,incp,ifogl)
#else
#ifdef CRAY
void CLKBCK(istsurf,incp,ifogl)
#else
void clkbck_(istsurf,incp,ifogl)
#endif
#endif
int *istsurf;
int *incp;
int *ifogl;
{

#if defined(VMS) || defined(UNDERSC)
	clkbcd(istsurf,incp,ifogl,
#else
#ifdef CRAY
	CLKBCD(istsurf,incp,ifogl,
#else
	clkbcd_(istsurf,incp,ifogl,
#endif
#endif
	xyzp->iresid,xyzp->coo,
	calfptr->icalf,&calfptr->ncalf,calfptr->reson);

}

#if defined(VMS) || defined(UNDERSC)
void newfil(idebug,istat,inc,ioadd,ioatms,nstrt,namols,nxtmf,ipdbon,namls,iof)
#else
#ifdef CRAY
void NEWFIL(idebug,istat,inc,ioadd,ioatms,nstrt,namols,nxtmf,ipdbon,namls,iof)
#else
void newfil_(idebug,istat,inc,ioadd,ioatms,nstrt,namols,nxtmf,ipdbon,namls,iof)
#endif
#endif
int *idebug;
int *istat;
int *inc;
int *ioadd;
int *ioatms;
int *nstrt;
int *namols;
int *nxtmf;
int *ipdbon;
int *namls;
int *iof;
{

#if defined(VMS) || defined(UNDERSC)
	newfid(idebug,istat,inc,ioadd,ioatms,nstrt,namols,nxtmf,ipdbon,namls,iof,
#else
#ifdef CRAY
	NEWFID(idebug,istat,inc,ioadd,ioatms,nstrt,namols,nxtmf,ipdbon,namls,iof,
#else
	newfid_(idebug,istat,inc,ioadd,ioatms,nstrt,namols,nxtmf,ipdbon,namls,iof,
#endif
#endif
	xyzp->iaton,xyzp->iatclr,xyzp->iresid,
	&calfptr->ncalf);

}

#if defined(VMS) || defined(UNDERSC)
void acthlp(iop1,iop2,iop3)
#else
#ifdef CRAY
void ACTHLP(iop1,iop2,iop3)
#else
void acthlp_(iop1,iop2,iop3)
#endif
#endif
int *iop1;
int *iop2;
int *iop3;
{

#if defined(VMS) || defined(UNDERSC)
	acthld(iop1,iop2,iop3,
#else
#ifdef CRAY
	ACTHLD(iop1,iop2,iop3,
#else
	acthld_(iop1,iop2,iop3,
#endif
#endif
	calfptr->ihet);

}

#if defined(VMS) || defined(UNDERSC)
void acttog(iop1,iop2,iop3)
#else
#ifdef CRAY
void ACTTOG(iop1,iop2,iop3)
#else
void acttog_(iop1,iop2,iop3)
#endif
#endif
int *iop1;
int *iop2;
int *iop3;
{

#if defined(VMS) || defined(UNDERSC)
	acttod(iop1,iop2,iop3,
#else
#ifdef CRAY
	ACTTOD(iop1,iop2,iop3,
#else
	acttod_(iop1,iop2,iop3,
#endif
#endif
	calfptr->ihet);

}

#if defined(VMS) || defined(UNDERSC)
void acttag(iop1,iop2,iop3)
#else
#ifdef CRAY
void ACTTAG(iop1,iop2,iop3)
#else
void acttag_(iop1,iop2,iop3)
#endif
#endif
int *iop1;
int *iop2;
int *iop3;
{

#if defined(VMS) || defined(UNDERSC)
	acttad(iop1,iop2,iop3,
#else
#ifdef CRAY
	ACTTAD(iop1,iop2,iop3,
#else
	acttad_(iop1,iop2,iop3,
#endif
#endif
	calfptr->ihet,&calfptr->ision);

}

#if defined(VMS) || defined(UNDERSC)
void setarr(iop,iopval,ioatms)
#else
#ifdef CRAY
void SETARR(iop,iopval,ioatms)
#else
void setarr_(iop,iopval,ioatms)
#endif
#endif
int *iop;
int *iopval;
int *ioatms;
{

#if defined(VMS) || defined(UNDERSC)
	setard(iop,iopval,ioatms,
#else
#ifdef CRAY
	SETARD(iop,iopval,ioatms,
#else
	setard_(iop,iopval,ioatms,
#endif
#endif
	xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iresid,xyzp->iconn,xyzp->qat,
	calfptr->ihet,calfptr->iclhet,calfptr->reson,calfptr->lab,
	clfstrptr->labhet,&clfstrptr->ilcset,clfstrptr->ligcat,calfptr->iams,
	calfptr->ihets,calfptr->irsnr,&calfptr->ncalf,&calfptr->issdon,
	&scalptr->scal,&scalptr->scali,&scalptr->fscal,&scalptr->smag,
	&posptr->xv,&posptr->yv,&posptr->zv,&posptr->pincr,
	&cell->natc,&cell->ichx,&cell->icrtp,
	&pnt->ipoints,&geo1ptr->ngeoms);

}

#if defined(VMS) || defined(UNDERSC)
void epvrml(vdwr,moddma,natoms,norbs,idops)
#else
#ifdef CRAY
void EPVRML(vdwr,moddma,natoms,norbs,idops)
#else
void epvrml_(vdwr,moddma,natoms,norbs,idops)
#endif
#endif
double *vdwr;
int *moddma;
int *natoms;
int *norbs;
int *idops;
{

#if defined(VMS) || defined(UNDERSC)
	epvrmd(vdwr,moddma,natoms,norbs,idops,
#else
#ifdef CRAY
	EPVRMD(vdwr,moddma,natoms,norbs,idops,
#else
	epvrmd_(vdwr,moddma,natoms,norbs,idops,
#endif
#endif
	xyzp->iaton);

}

#if defined(VMS) || defined(UNDERSC)
void clrcod(natorg,natoms,idebug)
#else
#ifdef CRAY
void CLRCOD(natorg,natoms,idebug)
#else
void clrcod_(natorg,natoms,idebug)
#endif
#endif
int *natorg;
int *natoms;
int *idebug;
{

#if defined(VMS) || defined(UNDERSC)
	clrcdd(natorg,natoms,idebug,
#else
#ifdef CRAY
	CLRCDD(natorg,natoms,idebug,
#else
	clrcdd_(natorg,natoms,idebug,
#endif
#endif
	xyzp->iatclr);

}

#if defined(VMS) || defined(UNDERSC)
void wrxyz(jmod)
#else
#ifdef CRAY
void WRXYZ(jmod)
#else
void wrxyz_(jmod)
#endif
#endif
int *jmod;
{

#if defined(VMS) || defined(UNDERSC)
	wrxyd(jmod,
#else
#ifdef CRAY
	WRXYD(jmod,
#else
	wrxyd_(jmod,
#endif
#endif
	xyzp->qat);

}

#if defined(VMS) || defined(UNDERSC)
void progeo(ipoints,iff,istat)
#else
#ifdef CRAY
void PROGEO(ipoints,iff,istat)
#else
void progeo_(ipoints,iff,istat)
#endif
#endif
int *ipoints;
int *iff;
int *istat;
{

#if defined(VMS) || defined(UNDERSC)
	proged(ipoints,iff,istat,
#else
#ifdef CRAY
	PROGED(ipoints,iff,istat,
#else
	proged_(ipoints,iff,istat,
#endif
#endif
	geop->formax,geop->forrms,geop->dismax,geop->disrms,
	geop->epoints,geop->isav,xyzp->coo,xyzp->ianz,
	&cell->icrtp);

}

#if defined(VMS) || defined(UNDERSC)
void wrcart(iun,dopdb,idogau,ipdbwh)
#else
#ifdef CRAY
void WRCART(iun,dopdb,idogau,ipdbwh)
#else
void wrcart_(iun,dopdb,idogau,ipdbwh)
#endif
#endif
int *iun;
int *dopdb;
int *idogau;
int *ipdbwh;
{

#if defined(VMS) || defined(UNDERSC)
	wrcard(iun,dopdb,idogau,ipdbwh,
#else
#ifdef CRAY
	WRCARD(iun,dopdb,idogau,ipdbwh,
#else
	wrcard_(iun,dopdb,idogau,ipdbwh,
#endif
#endif
	geop->epoints,
	xyzp->coo,xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iresid,
	xyzp->iconn,xyzp->ityp,
	&calfptr->ncalf,calfptr->ianf,calfptr->islu,&calfptr->nchain,
	calfptr->iamino,calfptr->reson,calfptr->irsnr,calfptr->achain,
	&calfptr->ishoh);

}

#if defined(VMS) || defined(UNDERSC)
void dyncpmd(ipoints)
#else
#ifdef CRAY
void DYNCPMD(ipoints)
#else
void dyncpmd_(ipoints)
#endif
#endif
int *ipoints;
{

#if defined(VMS) || defined(UNDERSC)
	dyncpdd(ipoints,
#else
#ifdef CRAY
	DYNCPDD(ipoints,
#else
	dyncpdd_(ipoints,
#endif
#endif
	geop->isav,geop->epoints);

}

#if defined(VMS) || defined(UNDERSC)
void plvend(iun,loop)
#else
#ifdef CRAY
void PLVEND(iun,loop)
#else
void plvend_(iun,loop)
#endif
#endif
int *iun;
int *loop;
{

#if defined(VMS) || defined(UNDERSC)
	plvedd(iun,loop,
#else
#ifdef CRAY
	PLVEDD(iun,loop,
#else
	plvedd_(iun,loop,
#endif
#endif
	geop->epoints,&scalptr->scal);

}

/* END shadow C routines for Fortran routines to pass coordinate pointers */

/* shadow C routines for Fortran routines to rotation pointers */

#if defined(VMS) || defined(UNDERSC)
void xyzrot(inct,theang)
#else
#ifdef CRAY
void XYZROT(inct,theang)
#else
void xyzrot_(inct,theang)
#endif
#endif
int *inct;
double *theang;
{
#if defined(VMS) || defined(UNDERSC)
	xyzrod(inct,theang,
#else
#ifdef CRAY
	XYZROD(inct,theang,
#else
	xyzrod_(inct,theang,
#endif
#endif
	rotptr->rx,rotptr->ry,rotptr->rz);
}

#if defined(VMS) || defined(UNDERSC)
void rotts(x,y,z,xc,yc,zc,itran)
#else
#ifdef CRAY
void ROTTS(x,y,z,xc,yc,zc,itran)
#else
void rotts_(x,y,z,xc,yc,zc,itran)
#endif
#endif
float *x;
float *y;
float *z;
double *xc;
double *yc;
double *zc;
int *itran;
{
#if defined(VMS) || defined(UNDERSC)
	rottd(x,y,z,xc,yc,zc,itran,
#else
#ifdef CRAY
	ROTTD(x,y,z,xc,yc,zc,itran,
#else
	rottd_(x,y,z,xc,yc,zc,itran,
#endif
#endif
	rotptr->rx,rotptr->ry,rotptr->rz,rotptr->t);
}

#if defined(VMS) || defined(UNDERSC)
void rott(x,y,z,xc,yc,zc,itran)
#else
#ifdef CRAY
void ROTT(x,y,z,xc,yc,zc,itran)
#else
void rott_(x,y,z,xc,yc,zc,itran)
#endif
#endif
double *x;
double *y;
double *z;
double *xc;
double *yc;
double *zc;
int *itran;
{
#if defined(VMS) || defined(UNDERSC)
	rotd(x,y,z,xc,yc,zc,itran,
#else
#ifdef CRAY
	ROTD(x,y,z,xc,yc,zc,itran,
#else
	rotd_(x,y,z,xc,yc,zc,itran,
#endif
#endif
	rotptr->rx,rotptr->ry,rotptr->rz,rotptr->t);
}

#if defined(VMS) || defined(UNDERSC)
void inirot()
#else
#ifdef CRAY
void INIROT()
#else
void inirot_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
	inirod(
#else
#ifdef CRAY
	INIROD(
#else
	inirod_(
#endif
#endif
	rotptr->rx,rotptr->ry,rotptr->rz,rotptr->t);
}

#if defined(VMS) || defined(UNDERSC)
void mtinv3()
#else
#ifdef CRAY
void MTINV3()
#else
void mtinv3_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
	mtind3(
#else
#ifdef CRAY
	MTIND3(
#else
	mtind3_(
#endif
#endif
	rotptr->rx,rotptr->ry,rotptr->rz);
}

#if defined(VMS) || defined(UNDERSC)
void mktrn(inct,incp)
#else
#ifdef CRAY
void MKTRN(inct,incp)
#else
void mktrn_(inct,incp)
#endif
#endif
int *inct;
int *incp;
{
#if defined(VMS) || defined(UNDERSC)
	mktrd(inct,incp,
#else
#ifdef CRAY
	MKTRD(inct,incp,
#else
	mktrd_(inct,incp,
#endif
#endif
	&posptr->xv,&posptr->yv,&posptr->zv,
	&posptr->pincr,&scalptr->scal,&scalptr->scali,&scalptr->smag);
}

#if defined(VMS) || defined(UNDERSC)
void setxyv()
#else
#ifdef CRAY
void SETXYV()
#else
void setxyv_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
	setxyd(
#else
#ifdef CRAY
	SETXYD(
#else
	setxyd_(
#endif
#endif
	&posptr->xv,&posptr->yv);
}

#if defined(VMS) || defined(UNDERSC)
void chkbck(upogl)
#else
#ifdef CRAY
void CHKBCK(upogl)
#else
void chkbck_(upogl)
#endif
#endif
int *upogl;
{
	if (*upogl) SSdone[istruct] = 0;
#if defined(VMS) || defined(UNDERSC)
	chkbcd(
#else
#ifdef CRAY
	CHKBCD(
#else
	chkbcd_(
#endif
#endif
	&calfptr->ncalf,calfptr->ihet,calfptr->reson,xyzp->iaton,xyzp->iatclr,&calfptr->ision);
}

/* END shadow C routines for Fortran routines to rotation pointers */

#if defined(VMS) || defined(UNDERSC)
void qupd()
{
    int oglon;

    rsold = RESUND;
    oglon = (*fancy || *fullgl);
    if (denmode) oglon = *ifdogl;
#ifdef DOGL
    if (oglon && has_opengl) {
	if (update_res > 0) {
	   ogres(update_res,1,1);
        } else {
           if (update_model || *irtcel) ogind();
	   else dispsf();
	}
        if (dogif) {
           picnum++;
           if (picnum < *picmax) {
		glXWaitGL();
		switch (*igffrm) {
		case 1:
			sprintf(stemp, "%s%03d.gif",GifFile,picnum);
			WOGLGIF(stemp);
			break;
		case 2:
			sprintf(stemp, "%s%03d.rgb",GifFile,picnum);
			save_rgb(stemp);
			break;
		case 3:
			sprintf(stemp, "%s%03d.bmp",GifFile,picnum);
			save_bmp(stemp);
			break;
		}
		glXSwapBuffers(display, win);
	   }
	}
    } else {
#endif
      if (!denmode) {
	doclr();
	if (*persp) {
	   plmolp();
	} else {
	   plmol();
	}
      } else {
	RedrawWin();
      }
      if (*logo) dlogo();
      doexp();
#ifdef DOGL
    }
#endif

}
#else
#ifdef CRAY
void QUPD()
{
    int oglon;

    oglon = (*fancy || *fullgl);
    if (denmode) oglon = *ifdogl;
#ifdef DOGL
    if (oglon && has_opengl) {
	if (update_res > 0) {
	   ogres(update_res,1,1);
        } else {
           if (update_model || *irtcel) ogind();
	   else dispsf();
	}
        if (dogif) {
           picnum++;
           if (picnum < *picmax) {
		glXWaitGL();
		switch (*igffrm) {
		case 1:
			sprintf(stemp, "%s%03d.gif",GifFile,picnum);
			WOGLGIF(stemp);
			break;
		case 2:
			sprintf(stemp, "%s%03d.rgb",GifFile,picnum);
			save_rgb(stemp);
			break;
		case 3:
			sprintf(stemp, "%s%03d.bmp",GifFile,picnum);
			save_bmp(stemp);
			break;
		}
		glXSwapBuffers(display, win);
	   }
	}
    } else {
#endif
      if (!denmode) {
	doclr();
	if (*persp) {
	   PLMOLP();
	} else {
	   PLMOL();
	}
      } else {
	RedrawWin();
      }
      if (*logo) DLOGO();
      DOEXP();
#ifdef DOGL
    }
#endif
}

#else
void qupd_()
{
    int oglon;
    oglon = (*fancy || *fullgl);
    if (denmode) oglon = *ifdogl;
#ifdef DOGL
    if (oglon && has_opengl) {
	if (update_res > 0) {
	   ogres(update_res,1,1);
        } else {
           if (update_model || *irtcel) ogind(); 
	   else dispsf();
	}
        if (dogif) {
           picnum++;
           if (picnum < *picmax) {
		glXWaitGL();
		switch (*igffrm) {
		case 1:
			sprintf(stemp, "%s%03d.gif",GifFile,picnum);
			WOGLGIF(stemp);
			break;
		case 2:
			sprintf(stemp, "%s%03d.rgb",GifFile,picnum);
			save_rgb(stemp);
			break;
		case 3:
			sprintf(stemp, "%s%03d.bmp",GifFile,picnum);
			save_bmp(stemp);
			break;
		}
		glXSwapBuffers(display, win);
	   }
	}
    } else {
#endif
      if (!denmode) {
	doclr();
	if (*persp) {
	   plmolp_();
	} else {
	   plmol_();
	}
      } else {
	RedrawWin();
      }
      if (!*fullgl) {
	if (*logo) dlogo_();
	doexp_();
      }
#ifdef DOGL
    }
#endif
}
#endif
#endif

void update_struct()
{
#if defined(VMS) || defined(UNDERSC)
   qupd();
#else
#ifdef CRAY
   QUPD();
#else
   qupd_();
#endif
#endif
}

void SetSurfColor(is,j)
int is;
int j;
{
   int i;

   if (is >= MAXSURF || j >= MAX_COLORS) return;

#ifdef DOGL
   diffuseColor[istruct][is][0] = ((GLfloat) colorr[j]) / 65535.0 ;
   diffuseColor[istruct][is][1] = ((GLfloat) colorg[j]) / 65535.0 ;
   diffuseColor[istruct][is][2] = ((GLfloat) colorb[j]) / 65535.0 ;
   diffuseColor[istruct][is][3] = 1.0;
   for (i=0; i<3; i++) {
	specularColor[is][i] = specColor[i];
   }
#endif
}

void CopySurfColor(is1,is2)
int is1;
int is2;
{
   int i;

   if (is2 >= MAXSURF) return;

   fprintf(stderr,"copysurfcolor is1 %d is2 %d\n",is1,is2);
#ifdef DOGL
   diffuseColor[istruct][is2][0] = diffuseColor[istruct][is1][0];
   diffuseColor[istruct][is2][1] = diffuseColor[istruct][is1][1];
   diffuseColor[istruct][is2][2] = diffuseColor[istruct][is1][2];
   for (i=0; i<3; i++) {
	specularColor[is2][i] = specularColor[is1][i];
   }
#endif
}

void sizz(i,j,iset)
int i;
int j;
int iset;
{

 *(zmptrp->iz + (i*4) + j) = iset;

}


static int *Snstr;
#ifdef VMS
static struct dsc$descriptor_s *Sstr;
#else
#ifdef CRAY
static _fcd Sstr;
#else
static char *Sstr;
#endif
#endif


void ColorByStruct()
{
    int i,k,ilow;

    for (k=0; k < alnptr->nalign; k++) {
	if (k == 0) {
	   ilow = 0;
        } else {
	   ilow = alnptr->istch[k-1];
	}
	for (i=ilow; i < alnptr->istch[k]; i++)
	   chncol(i,alnptr->istcol[k],0);
    }
}


#if defined(VMS) || defined(UNDERSC)
void setion()
#else
#ifdef CRAY
void SETION()
#else
void setion_()
#endif
#endif
{
    calfptr->ision = 100000;
}

void presetp()
{
        int iop,i,j;

	if (hetptr.NHetAtm) {

	    if (!calfptr->issdon) {
#if defined(VMS) || defined(UNDERSC)
		ribbs();
#else
#ifdef CRAY
		RIBBS();
#else
		ribbs_();
#endif
#endif
	    }

            for (iop=0;iop<4;iop++) {
		if (calfptr->ihet[iop]) {
#if defined(VMS) || defined(UNDERSC)
                acthel(&ONE,&iop,&clfhptr->isndcl[iop],&ZERO);
#else
#ifdef CRAY
                ACTHEL(&ONE,&iop,&clfhptr->isndcl[iop],&ZERO);
#else
                acthel_(&ONE,&iop,&clfhptr->isndcl[iop],&ZERO);
#endif
#endif
		}
	    }
            for (i=0;i < calfptr->ncalf;i++) {
		if (calfptr->reson[i] > 0) {
		   if (calfptr->iamino[i] > 23) {
            	   	for (j=0;j<6;j++) 
			   xyzp->iaton[calfptr->icalf[i][j] - 1] = 1;
		   } else {
            		for (j=0;j<4;j++) 
			   if (calfptr->icalf[i][j] >= 1 && 
				calfptr->icalf[i][j] < 50000) {
				xyzp->iaton[calfptr->icalf[i][j] - 1] = 1;
			   }
		   }
		}
	    }
	}
}

void sndon(iop,set,color)
int iop;
int set;
int color;
{
   int i;

   if (iop > 3) return;

   if (*ipdbon && SSdone[istruct] == -1) {
       if (!OMAPup) NSurf[istruct] = 0;
#if defined(VMS) || defined(UNDERSC)
       ribgl(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
#else
#ifdef CRAY
       RIBGL(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
#else
       ribgl_(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
#endif
#endif
       SSdone[istruct] = 1;
   }

   for (i=RIBindex[istruct].start[iop]; 
	i <= RIBindex[istruct].end[iop]; i++) {
	if (i == -1) break;
	SSon[istruct][i] = 1;
	if (set) {
	   SetSurfColor(i,color);
	} else {
	   SetSurfColor(i,clfhptr->isndcl[iop]);
	}
   }

   RedrawSTRC();
}

void sndoff(iop)
int iop;
{
   int i;

   if (iop > 3) return;

   for (i=RIBindex[istruct].start[iop]; 
	i <= RIBindex[istruct].end[iop]; i++) {
	if (i == -1) break;
	SSon[istruct][i] = 0;
   }

   RedrawSTRC();
}

void preset(int iset)
{
    int i,iop;
    int cell_up, cell_low;

 
    cell_low = cell_up = 0;
    if (cellpnt->iclon) {
	cell_low = cellpnt->iclpnt[0]-1;
	cell_up = cell_low + 7;
    }

    if (hetptr.NHetAtm) {

	    if (!calfptr->issdon) {
#if defined(VMS) || defined(UNDERSC)
		ribbs();
#else
#ifdef CRAY
		RIBBS();
#else
		ribbs_();
#endif
#endif
         	for (i=0;i<4;i++) calfptr->ihet[i] = 0;
	    }

/* red 1, orange 2, green 3 (helix), ... purple 9 (beta), grey 8 (coil) */				 
	    if (iset) {
#if defined(VMS) || defined(UNDERSC)
	        actcal(&ZERO);
#else
#ifdef CRAY
	        ACTCAL(&ZERO);
#else
	        actcal_(&ZERO);
#endif
#endif
		for (i=0; i < calfptr->ncalf; i++) calfptr->reson[i] = 0;
		for (i=0; i < *xyzp->iatoms; i++ ) {
		   if (! (i >= cell_low && i <= cell_up) ) xyzp->iaton[i] = 0;
		}
		update_sel = 1;

		for (i=0; i < MXHETA; i++) calfptr->ihet[i] = 0;
	    }

            for (iop=0;iop<4;iop++) {
		calfptr->ihet[iop] = 1;
#if defined(VMS) || defined(UNDERSC)
                acthel(&ONE,&iop,&clfhptr->isndcl[iop],&ZERO);
#else
#ifdef CRAY
                ACTHEL(&ONE,&iop,&clfhptr->isndcl[iop],&ZERO);
#else
                acthel_(&ONE,&iop,&clfhptr->isndcl[iop],&ZERO);
#endif
#endif
		sndon(iop,0,0);
	    }
	    if (alnptr->nalign) ColorByStruct();
    }
}

void str2qbox(qp,str,len)
QBOXSTRU	*qp;
char *str;
int len;
{
   if (len == -1) {
	strcpy(qp->str,str);
   } else {
	strncpy(qp->str,str,MINI(len,qp->strmax));
   }
   qp->wnd_start = 0;
   qp->curpos = strlen(qp->str);
}

void str2qboxa(qp,str,dir,len)
QBOXSTRU	*qp;
char *str;
char *dir;
int len;
{
   if (len == -1) {
	strcpy(qp->str,dir);
	strcat(qp->str,str);
   } else {
	strcpy(qp->str,dir);
	strncpy(qp->str,str,MINI(len,qp->strmax));
   }
   qp->wnd_start = 0;
   qp->curpos = strlen(qp->str);
}

void DebugStructure()
{
   int i;

   for (i=0; i<nstruct; i++) {
	   fprintf(stderr,"str %d file %s\n",i,COO[i]->fname);
	   fprintf(stderr," iatoms %d\n",COO[i]->iatoms);
	   fprintf(stderr," natoms %d\n",COO[i]->NAT.natoms);
	   fprintf(stderr," ipoints %d\n",COO[i]->ipoints);
	   fprintf(stderr," iftyp %d\n",COO[i]->iftyp);
	   fprintf(stderr," iconv %d\n",COO[i]->poi.iconv);
	   fprintf(stderr," mxzorg %d\n",COO[i]->zmt.mxzorg);
   }
}

void SaveFirstStruct()
{
    int j;
    char* p;

    COO[0]->coo   = *xyzp;
    COO[0]->geop  = *geop;
    COO[0]->zmt   = *zmptrp;
    COO[0]->stoc  = *stocp;
    COO[0]->dorb  = *dorbp;
    COO[0]->orb   = *orbp;

    COO[0]->fname = (char *) malloc(strlen(firstfile) + 3);
    strcpy(COO[0]->fname, firstfile);

    if ((p = strrchr(firstfile, '/'))) p++; 
    if (p == NULL) p = firstfile;
    strfiles[0] = (char *) malloc(strlen(p) + 3);
    strcpy(strfiles[0], p);

    for (j=0; j<hetptr.NHetAtm; j++) {
       COO[0]->hetatm.Allocated[j] = hetptr.Allocated[j];
       COO[0]->hetatm.HetAtm[j] = hetptr.HetAtm[j];
    }
    COO[0]->hetatm.NHetAtm = hetptr.NHetAtm;

    if (pdbcode == NULL) {
	if (COO[0]->pdbcode != NULL) free(COO[0]->pdbcode);
	COO[0]->pdbcode = NULL;
    } else {
	COO[0]->pdbcode = (char *) malloc(5);
	strncpy(COO[0]->pdbcode, pdbcode,4);
	COO[0]->pdbcode[4] = '\0';
    }

}

void SaveActiveStruct()
{
    int j;
    char* p;

/* 
   These are the data with general pointers that are copied to the
   COO structures when a new structure becomes active

   For Data structures that use dynamic memory allocation, we only
   keep a pointer in the COO structure. The pointer is assigned in
   the memory allocation rotines (allcoo, allgeo) when a new file 
   is read.
*/

    COO[istruct]->geop  = *geop;
    COO[istruct]->zmt   = *zmptrp;
    COO[istruct]->stoc  = *stocp;
    COO[istruct]->dorb  = *dorbp;
    COO[istruct]->orb   = *orbp;

    COO[istruct]->IANZbox = IANZbox;
    COO[istruct]->BLbox   = BLbox;
    COO[istruct]->ALPHbox = ALPHbox;
    COO[istruct]->BETbox  = BETbox;
    COO[istruct]->IZbox   = IZbox;

    COO[istruct]->iatoms = *xyzp->iatoms;
    COO[istruct]->mxnat = *xyzp->mxnat;
    COO[istruct]->natorg = *natorg;
    COO[istruct]->pdb = *ipdbon;
    COO[istruct]->backb = *backb;
    COO[istruct]->iftyp = *iftyp;
    COO[istruct]->rot = *rotptr;
    COO[istruct]->pos = *posptr;
    COO[istruct]->scal = *scalptr;
    COO[istruct]->cell = *cell;
    COO[istruct]->cellpnt = *cellpnt;
    COO[istruct]->geo = *geo1ptr;
    COO[istruct]->cnv = *cnvptr;
    COO[istruct]->poi = poi;
    COO[istruct]->ipoints = pnt->ipoints;
    COO[istruct]->calf = *calfptr;
    COO[istruct]->strx = strx;
    COO[istruct]->XYZ = *XYZ;
    COO[istruct]->NAT = *NAT;
    COO[istruct]->bas = *BAS;
    COO[istruct]->gau = *slagau;
    COO[istruct]->mop = *MOP;
    COO[istruct]->frq = *FRQ;
    COO[istruct]->pseud = *PSEUD;
    COO[istruct]->plane = *plane;
    COO[istruct]->eul = *eul;
    COO[istruct]->proj = *proj;
    COO[istruct]->mfdata = *mfdata;
    COO[istruct]->FLDS   = FLDS;
    COO[istruct]->potcom = *potcom;
    COO[istruct]->zmpart = *zmpart;
    COO[istruct]->jobcom = *jobcom;
    COO[istruct]->qdpptr = *qdpptr;
    COO[istruct]->hlpsrf = *hlpsrf;
    COO[istruct]->hetlab = hetlab;
    COO[istruct]->nmr = *nmrptr;
    COO[istruct]->jcoupl = jcoupl;
    COO[istruct]->nz = *zmptrp->nz;
    COO[istruct]->ihaszm = *zmptrp->ihaszm;
    COO[istruct]->mxzat = *zmptrp->mxzat;
    COO[istruct]->ncols = *dorbp->ncols;
    COO[istruct]->ncolb = *dorbp->ncolb;
    COO[istruct]->nocc = *dorbp->nocc;
    COO[istruct]->nocb = *dorbp->nocb;
    COO[istruct]->naorbs = *dorbp->naorbs;
    COO[istruct]->mxorb = *dorbp->mxorb;
    COO[istruct]->uhf = *iuhf;
    COO[istruct]->spd = *ispd;
    COO[istruct]->ipsi = *ipsi;
    COO[istruct]->inact = inactMC;
    COO[istruct]->inaf = inafMC;
    COO[istruct]->uscl = *uscl;
    COO[istruct]->adjus = *adjuss;
    COO[istruct]->atcol = *atcol;
    COO[istruct]->ZMEAA = ZMEAA;
    COO[istruct]->doesp = *doesp;
    COO[istruct]->fftyp = *fftyp;
    COO[istruct]->irtcel = *irtcel;
    COO[istruct]->normc = *normc;
    COO[istruct]->icst = *icst;
    COO[istruct]->ibox = *ibox;
    COO[istruct]->igfmap = *igfmap;
    COO[istruct]->iresrd = *iresrd;
    COO[istruct]->clfstr = *clfstrptr;
    COO[istruct]->fancy = *fancy;
    COO[istruct]->alnstr = *alnptr;
    COO[istruct]->ihasex = *ihasex;
    COO[istruct]->bcksvg = bcksvg;

    wrsvgs(COO[bcksvg.istruct]->fname);

    for (j=0; j<FRQ->nfreq; j++) 
       COO[istruct]->frsym[j] = frsym[j];

    for (j=0; j<hetptr.NHetAtm; j++) {
       COO[istruct]->hetatm.Allocated[j] = hetptr.Allocated[j];
       COO[istruct]->hetatm.HetAtm[j] = hetptr.HetAtm[j];
    }
    COO[istruct]->hetatm.NHetAtm = hetptr.NHetAtm;

    for (j=0; j<MXHETA; j++) hetptr.Allocated[j] = 0;
    hetptr.NHetAtm = 0;

    COO[istruct]->mlftit = mlftit;
    COO[istruct]->ntits = ntits;
    COO[istruct]->mxtits = mxtits;

    if (pdbcode == NULL) {
	if (COO[istruct]->pdbcode != NULL) free(COO[istruct]->pdbcode);
	COO[istruct]->pdbcode = NULL;
    } else {
	if (COO[istruct]->pdbcode == NULL) {
	   COO[istruct]->pdbcode = (char *) malloc(5);
	   strncpy(COO[istruct]->pdbcode, pdbcode,4);
	   COO[istruct]->pdbcode[4] = '\0';
	}
    }
}

void AllocateStructure(newstr)
STRUSTRU **newstr;
{
  *newstr = (STRUSTRU *) malloc((sizeof **newstr)*1); 
  (*newstr)->memfil.str = NULL;
}

void AllocateSubStructures(file,naat)
char *file;
int naat;
{
	int *allc,*frst;

	hetptr.NHetAtm = 0;
	COO[nstruct]->pdbcode = NULL;
	Ngrostr = 0;
	omapr = 0;

	xyzp   = &COO[nstruct]->coo;
	geop   = &COO[nstruct]->geop;
	zmptrp = &COO[nstruct]->zmt;
	stocp  = &COO[nstruct]->stoc;
	dorbp  = &COO[nstruct]->dorb;
	orbp   = &COO[nstruct]->orb;

	strfiles[nstruct] = (char *) malloc(strlen(file) + 3);
	COO[nstruct]->fname = (char *) malloc(strlen(strname) + 3);
	strcpy(strfiles[nstruct], file);
	strcpy(COO[nstruct]->fname, strname);
	mfdata->mollin = (int *) malloc(sizeof(int)*MXMFMOL);
	mfdata->mollin[0] = 0;
	mfdata->maxmol = MXMFMOL;
	mlftit = (char **) malloc(sizeof(char *)*MXMFMOL);
	mxtits = MXMFMOL;
	COO[nstruct]->svgs = NULL;
	COO[nstruct]->svgdone = 0;

	fileop.str = NULL;
	fileop.line_index = NULL;
	fileop.size = 0;
	fileop.nlines = 0;
	fileop.nfiles = 0;
	fileop.currl = 0;

	bcksvg.UpSVG = 0;
	bcksvg.CurSVG = 0;
	bcksvg.ReadSVG = 0;
	bcksvg.istruct = nstruct;

	if (strx.fpos != NULL) strx.fpos = NULL;
	if (strx.fptr) strx.fptr = NULL;

	nstruct++; 
	istruct = nstruct - 1;

	allc = &addat; frst = &ONE;
	if (naat > 0) { 
	   allc = &naat;
	   frst = &MONE;
	}

#if defined(VMS) || defined(UNDERSC)
	allcoo(allc,frst);
	allgeo(&addat,&ONE);
	allorb(&addat,&ONE);
#else
#ifdef CRAY
	ALLCOO(allc,frst);
	ALLGEO(&addat,&ONE);
	ALLORB(&addat,&ONE);
#else
	allcoo_(allc,frst);
	allgeo_(&addat,&ONE);
	allorb_(&addat,&ONE);
#endif
#endif

	*xyzp->iatoms = 0;

	AllocZMat(*xyzp->mxnat,ONE);


	strlist.select = istruct;
	if (!STRup) inistr();
	else RedrawSTR();
}

void NewActiveStruct()
{
    int i,j,j1,nstr, HasZMtmp;
#ifdef VMS
    struct dsc$descriptor_s ztr;
#else
#ifdef CRAY
    _fcd ztr;
#else
    char ztr[4];
#endif
#endif

    xyzp   = &COO[istruct]->coo;
    geop   = &COO[istruct]->geop;
    zmptrp = &COO[istruct]->zmt;
    stocp  = &COO[istruct]->stoc;
    dorbp  = &COO[istruct]->dorb;
    orbp   = &COO[istruct]->orb;

    IANZbox = COO[istruct]->IANZbox;
    BLbox   = COO[istruct]->BLbox;
    ALPHbox = COO[istruct]->ALPHbox;
    BETbox  = COO[istruct]->BETbox;
    IZbox   = COO[istruct]->IZbox;

    *xyzp->iatoms   = COO[istruct]->iatoms;
    *xyzp->mxnat    = COO[istruct]->mxnat;
    *natorg         = COO[istruct]->natorg;
    *ipdbon         = COO[istruct]->pdb;
    *iftyp          = COO[istruct]->iftyp;
    *rotptr         = COO[istruct]->rot;
    *posptr         = COO[istruct]->pos;
    *scalptr        = COO[istruct]->scal;
    *cell           = COO[istruct]->cell;
    *cellpnt        = COO[istruct]->cellpnt;
    *geo1ptr        = COO[istruct]->geo;
    *cnvptr         = COO[istruct]->cnv;
    bckpoi(istruct);
    pnt->ipoints    = COO[istruct]->ipoints;
    *calfptr        = COO[istruct]->calf;
    strx            = COO[istruct]->strx;
    *XYZ            = COO[istruct]->XYZ;
    *NAT            = COO[istruct]->NAT;
    *BAS            = COO[istruct]->bas;
    *slagau         = COO[istruct]->gau;
    *MOP            = COO[istruct]->mop;
    *FRQ            = COO[istruct]->frq;
    *PSEUD          = COO[istruct]->pseud;
    *plane          = COO[istruct]->plane;
    *eul            = COO[istruct]->eul;
    *proj           = COO[istruct]->proj;
    *mfdata         = COO[istruct]->mfdata;
    FLDS            = COO[istruct]->FLDS;
    *potcom         = COO[istruct]->potcom;
    *zmpart         = COO[istruct]->zmpart;
    *jobcom         = COO[istruct]->jobcom;
    *qdpptr         = COO[istruct]->qdpptr;
    *hlpsrf         = COO[istruct]->hlpsrf;
    hetlab          = COO[istruct]->hetlab;
    *nmrptr         = COO[istruct]->nmr;
    jcoupl          = COO[istruct]->jcoupl;
    *zmptrp->nz     = COO[istruct]->nz;
    *zmptrp->ihaszm = COO[istruct]->ihaszm;
    *zmptrp->mxzat  = COO[istruct]->mxzat;
    *dorbp->ncols   = COO[istruct]->ncols;
    *dorbp->ncolb   = COO[istruct]->ncolb;
    *dorbp->nocc    = COO[istruct]->nocc;
    *dorbp->nocb    = COO[istruct]->nocb;
    *dorbp->naorbs  = COO[istruct]->naorbs;
    *dorbp->mxorb   = COO[istruct]->mxorb;
    *iuhf           = COO[istruct]->uhf;
    *ispd           = COO[istruct]->spd;
    *ipsi           = COO[istruct]->ipsi;
    *uscl           = COO[istruct]->uscl;
    *adjuss         = COO[istruct]->adjus;
    *atcol          = COO[istruct]->atcol;
    *doesp          = COO[istruct]->doesp;
    *fftyp          = COO[istruct]->fftyp;
    *irtcel         = COO[istruct]->irtcel;
    *normc          = COO[istruct]->normc;
    *icst           = COO[istruct]->icst;
    *ibox           = COO[istruct]->ibox;
    *igfmap         = COO[istruct]->igfmap;
    *iresrd         = COO[istruct]->iresrd;
    *clfstrptr      = COO[istruct]->clfstr;
    *fancy          = COO[istruct]->fancy;
    *alnptr         = COO[istruct]->alnstr;
    *ihasex         = COO[istruct]->ihasex;
    bcksvg	    = COO[istruct]->bcksvg;

    if (pdbcode != NULL) {
	if (pdbcode == pdbcbck) {
	   free(pdbcode); pdbcode = NULL;
	}
    }
    
    pdbcode	    = COO[istruct]->pdbcode;

    hetptr.NHetAtm         = COO[istruct]->hetatm.NHetAtm;
    for (j=0; j<hetptr.NHetAtm; j++) {
	hetptr.Allocated[j] = COO[istruct]->hetatm.Allocated[j];
	hetptr.HetAtm[j] = COO[istruct]->hetatm.HetAtm[j];
    }

    for (j=0; j<hetptr.NHetAtm; j++) {
	j1 = j + 1;
#if defined(VMS) || defined(UNDERSC)
/*
	for (i=0; i<strlen(hetptr.HetAtm[j]); i++)
	    ztr.dsc$a_pointer[i] = hetptr.HetAtm[j][i];
	parhet(&j1,&ztr);
*/
	clfstrptr->ihashz = 0;
#else
#ifdef CRAY
/*
	strncpy(_fcdtocp(ztr),hetptr.HetAtm[j],strlen(hetptr.HetAtm[j]));
	PARHET(&j1,ztr);
*/
	clfstrptr->ihashz = 0;
#else
	if (hetptr.HetAtm[j] != NULL) {
	   strncpy(ztr,hetptr.HetAtm[j],3);
	   parhet_(&j1,ztr);
	}
#endif
#endif
    }

    ntits         = COO[istruct]->ntits;
    mxtits        = COO[istruct]->mxtits;
    mlftit        = COO[istruct]->mlftit;
/*    svgarr        = COO[istruct]->svgs;*/

    for (j=0; j<FRQ->nfreq; j++) 
        frsym[j]  = COO[istruct]->frsym[j];

    pnt->ipnt = 1;

    HasZMtmp = *zmptrp->ihaszm;

    actde(COO[istruct]->inact,COO[istruct]->inaf,0);

    *backb           = COO[istruct]->backb;
    if (*backb) {
	TogDown(&cbut[BBACKB]);
	ActBut(&cbut[BFORC],1);
	ActBut(&cbut[BINCRF],1);
	ActBut(&cbut[BHBOND],1);
	ActBut(&cbut[BDECRF],1);
	ActBut(&cbut[BUNSC],1);
    } else {
	TogUp(&cbut[BBACKB]);
    }

    if (*fancy) {
	TogDown(&cbut[BSOLID]);
    } else {
	TogUp(&cbut[BSOLID]);
    }

    if (*atcol) {
	TogDown(&cbut[BATCOL]);
    } else {
	TogUp(&cbut[BATCOL]);
    }

    if (HasZMtmp) {
	ZMEAA           = COO[istruct]->ZMEAA;
	if (ZMEAA) EXPbox[0].fake = 0;
	else EXPbox[0].fake = 1;
    }

/* Now update open windows */

    if (ZMEup) {
	
	if (pdb && !*zmptrp->ihaszm) { 
	   if (DoPDB(1)) i = 1;
	} else {
#if defined(VMS) || defined(UNDERSC)
	   upzme();
#else
#ifdef CRAY
	   UPZME();
#else
	   upzme_();
#endif
#endif
	}
	RedrawZME();
    }

    if (cnvup) {
	drwcnv();
    }

    if (specup) {
	createspec(0);
	drwspec();
    }

    if (FRup) {
	createfr(0);
	RedrawList(&frlist);
    }

    if (OMAPup) EndOMAP();

    if (geoup) {
	XClearWindow(display,wingeo);

#if defined(VMS) || defined(UNDERSC)
	drwgeo();
#else
#ifdef CRAY
	DRWGEO();
#else
	drwgeo_();
#endif
#endif
    }

/* close old iun2 unit and open file associated with new active structure */

    nstr = strlen(COO[istruct]->fname);

#ifdef VMS
    for (i=0; i<strlen(COO[istruct]->fname); i++)
	{Sstr->dsc$a_pointer[i] = COO[istruct]->fname[i];}
    nwfil(Sstr,&nstr);
#else
#ifdef CRAY
    strncpy(_fcdtocp(Sstr),COO[istruct]->fname,
	strlen(COO[istruct]->fname));
    NWFIL(Sstr,&nstr);
#else
    strcpy(Sstr,COO[istruct]->fname);
#if defined(UNDERSC)
    nwfil(Sstr,&nstr);
#else
    nwfil_(Sstr,&nstr);
#endif
#endif
#endif

    WinName(win,COO[istruct]->fname);
    omapr = 0;

}

void GetFirstFile()
{
char* p;
char* q;

	nfilesstart = fsel.nfiles;
	firstreadf = 0;
	if (nfilesstart) {
	   strcpy(firstfile,fsel.files[0]);
	   if (firstfile[0] != '/') {
		if (getcwd(firstfile,MAXFILELEN) == NULL) 
		   strcpy(firstfile,"./");
		if (firstfile[strlen(firstfile)-1] == '/') 
		   firstfile[strlen(firstfile)-1] = '\0';

		p = fsel.files[0];
		while (p[0] == '.' && p[1] == '.') {
		   q = firstfile;
		   if ((q = strrchr(firstfile, '/'))) q[0] = '\0';
		   p++; p++; p++;
		}
		if (p[0] == '.') p++;
		if (p[0] == '/') p++;
		if (firstfile[strlen(firstfile)-1] != '/') 
		   strcat(firstfile,"/");
		strcat(firstfile,p);
	   }
	}
}

void NewDir(fs)
FSELSTRU *fs;
{
char* p;
char  tmpdir[MAXDIRLEN];

	seldir = fs->dirlist.select;
	if (seldir > fs->ndirs - 1) seldir = fs->ndirs - 1;

	if (strcmp(fs->dirs[seldir],"..") == 0) {
	    strcpy(tmpdir,fs->lastdir);
	    if (fs->lastdir[0] != '/') {

		if (getcwd(fs->lastdir,MAXDIRLEN) == NULL) 
		   strcpy(fs->lastdir,"./");
		if (fs->lastdir[strlen(fs->lastdir)-1] != '/') 
		   strcat(fs->lastdir,"/");

		p = tmpdir;
		if (p[0] == '.') p++;
		if (p[0] == '/') p++;
		strcat(fs->lastdir,p);
	    }

	    if (fs->lastdir[strlen(fs->lastdir)-1] == '/') 
		fs->lastdir[strlen(fs->lastdir)-1] = '\0';

	    if ((p = strrchr(fs->lastdir, '/'))) {
		p++; *p = '\0';
	    }

	} else {
	    if (strcmp(fs->dirs[seldir],".") != 0) {
		strcat(fs->lastdir,fs->dirs[seldir]);
		strcat(fs->lastdir,"/");
	    }
	}
}

#if defined(VMS) || defined(UNDERSC)
void parsfn(char *str, int *nstr, int *iopt);
#else
#ifdef CRAY
void PARSFN(char *str, int *nstr, int *iopt);
#else
void parsfn_(char *str, int *nstr, int *iopt);
#endif
#endif

int palette()
{
    int iii, clopt, ich, doret;
    LSSTRU List;

#ifdef DOGL
    GLint loc;
    List.list = palopt; List.nents = 9;
#ifdef GL_COLOR_ATTACHMENT0_EXT
    if (has_shader && has_fbo) List.nents = 12;
#endif
#else
    List.list = palopt; List.nents = 7;
#endif

    doret = 1;

    if (DoPopUp(winMC, cbut[BPAL].x+1,cbut[BPAL].y+BUTTH,
	&List,&clopt,0) == -1) {
   	update_model = 0;
	return(0);
    }

    RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);

    switch (clopt) {
	case 0:
		List.list = bgopt; List.nents = 2;
		if (DoPopUp(winMC,cbut[BPAL].x+1,cbut[BPAL].y+BUTTH,
			    &List,&BGmode,0) == -1) return(0);
#if defined(VMS) || defined(UNDERSC)
		wrtres();
#else
#ifdef CRAY
		WRTRES();
#else
		wrtres_();
#endif
#endif
		break;

	case 1:
	case 2:
		if (!monoscr) {
		    int colt;

		    update_model = 0;

		    if (clopt == 1) {
			if (DoPopUp(winMC,cbut[BPAL].x-8,cbut[BPAL].y+BUTTH,
				    NULL,&iii,0) == -1) return(0);
			colt = iii;
		    } else {
			if (has_opengl && (*fancy || *fullgl)) {
				colt = 13; BGmode = 1;
			} else colt = 0;
		    }

		    if (has_opengl && (*fancy || *fullgl) ) {
			OBGcolor = colt;
		    } else {
			IBGcolor = colt;
		    }

		    XSetBackground(display, gc, colors[IBGcolor]);

#ifdef DOGL
		    if (has_opengl) setobg();
#endif
#if defined(VMS) || defined(UNDERSC)
		    wrtres();
#else
#ifdef CRAY
		    WRTRES();
#else
		    wrtres_();
#endif
#endif
		}
		break;

	case 3:
		doret = 0;
		update_model = 0;
		if (!COLup) InitCOL();
		else XMapRaised(display,COLwin);
		break;

	case 4:
		doret = 0;
		if (!monoscr) {
			if (DoPopUp(winMC,cbut[BPAL].x-8,cbut[BPAL].y+BUTTH,
				    NULL,&iii,0) == -1) return(0);
			if (iii) {
			   activecolor = iii;
			   update_model = 0;
			   if (!ECOLup) EditCOL();
			   else XMapRaised(display,ECOLwin);
			}
		}
		break;

	case 5:
		ResetColors();
		break;

	case 6:
		doret = 0;
		update_model = 0;
		if (!DPTup) InitDPT();
		else XMapRaised(display,DPTwin);
		break;

	case 7:
		doret = 0;
		update_model = 0;
		if (!STRCup) inistrc();
		break;

	case 8:
		List.list = Chains; 
		List.nents = calfptr->nchain;

		doret = 0;

		if (DoPopUp(winMC,cbut[BPAL].x-8,cbut[BPAL].y+8*BUTTH,
			     &List,&ich,0) == -1) return(0);

		RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);

		if (DoPopUp(winMC,cbut[BPAL].x-8,cbut[BPAL].y+8*BUTTH,
			     NULL,&iii,0) == -1) return(0);

		RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
		chncol(ich,iii-1,1);
		break;
	case 9:
		DoSSAO = 0;
		DoShad = 0;
		DoShadow = 0;
		if (DoBlur) {
		   DoBlur = 0;
		} else {
		   DoBlur = 1;
		}
		break;
	case 10:
		List.list = occlopt; List.nents = 2;

		DoBlur = 0;
		DoShad = 0;
		DoShadow = 0;
		if (DoSSAO) {
		   DoSSAO = 0;
		} else {
		   if (DoPopUp(winMC,cbut[BPAL].x+1,cbut[BPAL].y+10*BUTTH,
			    &List,&SSAO_type,0) == -1) return(0);
		   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
		   DoSSAO = 1;
		}
#ifdef DOGL
#ifdef GL_ARB_shader_objects
		glUseProgramObjectARB(program[1]);
		loc    = glGetUniformLocationARB(program[1], "ssaotyp");
		glUniform1iARB(loc, SSAO_type);
#endif
#endif
		break;
	case 11:
		if (DoShad) DoShad = 0;
		else {
		   DoShad = 1;
		   DoShadow = 1;
		   DoSSAO = 0;
		   DoBlur = 0;
		}
		break;
       }

       return(doret);
}

void parname(FSELSTRU *fs,char *strname,int selfil);
void RedrawFwinH(FSELSTRU *fs);

int ScrollP(lp,sc,ks,opt)
SCRSTRU *sc;
LISTSTRU *lp;
int ks;
int opt;
{
  int i,dofile,ret;
  FSELSTRU *fs;

  ret = 1;
  fs = NULL;

  if (lp != NULL) {
	if (lp == &fsel.flist || lp == &fsel.dirlist) {
	   fs = &fsel;
	} else if (lp == &dsel.flist || lp == &dsel.dirlist) {
	   fs = &dsel;
	} else if (lp == &gsel.flist || lp == &gsel.dirlist) {
	   fs = &gsel;
	} else if (lp->win == MLTwin) {
	   ret = 0;
	} else if (lp->win == ZMEwin) {
	   ret = 0;
	} else {
	   for (i=0; i<MXSHFILS; i++) {
		if (lp == &shfiles[i].FILElist) ret = 0;
	   }
	   if (ret) return(0);
	}
  }
  dofile = 0;

  switch (opt) {
  case 0:
	*sc->wpos = 0;
	sc->fpos = 0;
	break;
  case 1:
	*sc->wpos = *sc->wpos + sc->wh;
	sc->fpos = 0;
	break;
  case 2:
	*sc->wpos = *sc->wpos - sc->wh;
	sc->fpos = 0;
	break;
  case 3:
	*sc->wpos = *sc->wn - sc->wh;
	sc->fpos = 0;
	break;
  case 4:
	{
	int wh;
	wh = sc->wh;
	if (*sc->wn < wh) wh = *sc->wn;
	*sc->wpos = ks;
	sc->fpos = 0;
	if (*sc->wpos > (*sc->wn) - 1 - wh) {
	   *sc->wpos = (*sc->wn - wh);
	   sc->fpos = ks - *sc->wpos;
	}
	selfil = *sc->wpos + sc->fpos;
	}
	break;
  case 5:
	{
	int wh;
	wh = sc->wh;
	if (*sc->wn < wh) wh = *sc->wn;
	if (*sc->wpos > (*sc->wn) - 1 - wh) {
	   sc->fpos = sc->fpos - 1;
	   if (sc->fpos < 0) {
		sc->fpos = 0;
		*sc->wpos = *sc->wpos - 1;
	   }
	} else {
	   *sc->wpos = *sc->wpos - 1;
	}
	selfil = *sc->wpos + sc->fpos;
	}
	break;
  case 6:
	{
	int wh;
	wh = sc->wh;
	if (*sc->wn < wh) wh = *sc->wn;
	if (*sc->wpos > (*sc->wn) - 1 - wh) {
	   *sc->wpos = (*sc->wn - wh);
	   sc->fpos = sc->fpos + 1;
	   if (sc->fpos > wh - 1)  sc->fpos = wh - 1;
	} else {
	   *sc->wpos = *sc->wpos + 1;
	}
	selfil = *sc->wpos + sc->fpos;
	}
	break;
  case 7:
	if (fs == &fsel) dofile = 1;
	break;
  default:
	break;
  }

  if (opt == 4 || opt == 5 || opt == 6 || opt == 7) {
     *sc->wpos = *sc->wpos + sc->fpos;
     if (*sc->wpos > (*sc->wn) - 1 ) *sc->wpos = (*sc->wn) - 1;
  } else {
     if (*sc->wpos > (*sc->wn) - 1 - sc->wh) {
	if ((*sc->wn) - 1 - sc->wh >= 0) {
	   *sc->wpos = (*sc->wn) - sc->wh;
	}
	else *sc->wpos = 0;
     }
  }
  if (*sc->wpos < 0) *sc->wpos = 0;
  lp->select = *sc->wpos;

  if (fs != NULL) parname(fs,strname,lp->select);

  if (dofile) {
     if (lp == &fsel.flist) {
	if (ParseFile(strname,fs->files[lp->select])) return(1);
     } else {
	NewDir(fs);
	getfiles(fs,fs->lastdir);
	RedrawFwin(fs);
	update_model = 0;
     }
  } else if (opt == 7 && fs != NULL) {
    str2qbox(&qboxes[QREADF],fs->files[selfil],-1);
    PromptBox(&qboxes[QREADF]);
    if (fs->subopt == 1) {
	str2qbox(&qboxes[QMFILE],fs->files[selfil],-1);
        PromptBox(&qboxes[QMFILE]);
    } else if (fs->subopt == 2) {
	str2qboxa(&qboxes[QQSAR],fs->files[selfil],fs->lastdir,-1);
        PromptBox(&qboxes[QQSAR]);
    } else if (fs->subopt == 3) {
	str2qboxa(&qboxes[QQSARB],fs->files[selfil],fs->lastdir,-1);
        PromptBox(&qboxes[QQSARB]);
    }
    XUnmapWindow(display,fs->win);
    return(0);
  }
  
  if (lp != NULL) {
	if (lp->win == ZMEwin) {
		UpdateZME();
		RedrawScroll(sc);
	} else {
	   RedrawList(lp);
	}
	if (fs != NULL) RedrawFwinH(fs);
  } else if (sc != NULL) {
	RedrawScroll(sc);
  }
  XSync(display,True);

  return(0);

}

void ScrollWheel(inct,incp,iop)
int *inct;
int *incp;
int iop;
{
        update_model = 0;
	*inct = 417; 

	*incp = 5;
	if (iop) *incp = -5;

#if defined(VMS) || defined(UNDERSC)
	mktrn(inct,incp);
	qupd();
#else
#ifdef CRAY
 	MKTRN(inct,incp);
	QUPD();
#else
       	mktrn_(inct,incp);
	qupd_();
#endif
#endif

}

void setgif(iopt)
int iopt;
{

  if (dogif) {
	dogif = 0;
	if (iopt) {
	   TogBut(&cbut[BGIF]);
	} else {
	   TogBut(&dbut[BGIF2]);
	}
  } else {
	if (DisplayCells(display, screen) > 256) {;
	   strcpy(molwstr,"GIF file only for 8-bits screen");
	   StatusStr(0,1);
	} else {
	   dogif = 1;
	   if (iopt) {
#ifdef DOGL
	     if (has_opengl && (*fancy || *fullgl)) {
		strcpy(molwstr,"a Gif file per screen update");
		StatusStr(0,1);
		if (dogif) {
		    picnum++;
		    if (picnum < *picmax) {
		  	glXWaitGL();
			sprintf(stemp, "%s%03d.gif",GifFile,picnum);
			WOGLGIF(stemp);
			glXSwapBuffers(display, win);
		    }
		}
	     } else {
#endif
	 	strcpy(molwstr,"a GIF file per screen update");
		StatusStr(0,1);
#if defined(VMS) || defined(UNDERSC)
		doexp();
#else
#ifdef CRAY
		DOEXP();
#else
		doexp_();
#endif
#endif
#ifdef DOGL
	     }
#endif
	     TogBut(&cbut[BGIF]);
	   } else {
	     TogBut(&dbut[BGIF2]);
	   }
	}
  }
  update_model = 0;
}

void RedrawFwinH(fs)
FSELSTRU *fs;
{
  int i;

  if (fs->parse) {

	butje(fs->win,320,40,80,70,1,0,0,1,None,0,0,0,0);

	for (i=0; i<NBUTTR; i++) DrwBut(&fs->rbut[i]);
	PromptBox(&qboxes[QPDB]); 
	PromptBox(&qboxes[QSUBSTR]); 

	LineString(fs->win, "Filter:", 322, 150);
	LineString(fs->win, "Replace", 350, 75);
	LineString(fs->win, "Add", 350, 105);
	LineString(fs->win, "Show", 350, 130);
  } else {
	for (i=0; i<2; i++) DrwBut(&fs->rbut[i]);
  }

}

void RedrawFwin(fs)
FSELSTRU *fs;
{
  int i;

  XSetForeground(display, gc, infobg);
  if (fs->parse) {
	str2qbox(&qboxes[QREADF],fs->lastdir,MAXPATHLEN);
  } else {
	str2qbox(&qboxes[QREADF],fs->pntr,MAXPATHLEN);
  }
  PromptBox(&qboxes[QREADF]); 

  RedrawList(&fs->flist);
  RedrawList(&fs->dirlist);

  if (fs->parse) {
	butje(fs->win,320,40,80,70,1,0,0,1,None,0,0,0,0);
	for (i=0; i<NBUTTR; i++) DrwBut(&fs->rbut[i]);
	PromptBox(&qboxes[QPDB]); 
	PromptBox(&qboxes[QSUBSTR]); 
  } else {
	for (i=0; i<2; i++) DrwBut(&fs->rbut[i]);
  }

  ULineString(fs->win, "Files", 325, 55);
  ULineString(fs->win, "Directories", 325, 265);
  if (fs->parse) {
	LineString(fs->win, "Filter:", 322, 150);
	LineString(fs->win, "Replace", 350, 75);
	LineString(fs->win, "Add", 350, 105);
	LineString(fs->win, "Show", 350, 130);
  }

}

void EndOMAP()
{
  int j;

  if (!OMAPup) return;

  XSync(display, False);
  XDestroyWindow(display,OMAPwin);
  XSync(display, False);
  omapfol = 0;
  omapCa = -1;
  OMAPtype = 0;
  if (omaplck) {
 	for (j=0; j<3; j++) rotptr->t[j] = omapt[j];
	omaplck = 0;
  }
  OMAPup = 0;
#ifdef DOGL
  for (j=0; j<NSurf[istruct]; j++) {
	if (SSon[istruct][j]) clp[istruct][j] = 0;
  }

  DeleteSurface(omapsrf);

  deletebox();
#endif
  update_struct();
}

void ClickOMAP(int i)
{
   int j,i2;

   if (i>=0) {

     switch (i) {
	case 0:
	   if (OMAPup) EndOMAP();
	   break;

	case 1: 
	   TogBut(&butomap[1]);
	   if (omapfol) {
		omapfol = 0;
   		for (j=0; j<3; j++) {
			rotptr->t[j] = omapt[j];
			omaprat[j] = 1.0;
		}
   		for (j=0; j<6; j++) {
			omaprat[j] = 1.0;
			RedrawSlide(&omapscr[j]);
		}
		UpdateOMAP1();
		UpdateSLAB1();
		UpdateOMAP2();
		UpdateSLAB2();
		UpdateOMAP3();
		UpdateSLAB3();
		disp_map(NULL);
		update_struct();
	   } else {
		if (!omaphlp) {
	           if (DoCan(event.xbutton.x_root,
			event.xbutton.y_root,
			"Use space bar to lock/unlock\nDensity volume",0)) {}
		   omaphlp = 1;
		   RedrawOMAP();
		}
		omapfol = 1;
	   	for (j=0; j<3; j++) {
			int i2;
			omapt[j] = rotptr->t[j];
			i2 = 1 + 2*j;
			omaprat[i2] = 25.0/(float) comsrfptr->r[j];
			omapwpos[i2] = 
				(int) ((float) omapwn[i2]*omaprat[i2]);
			RedrawSlide(&omapscr[i2]);
		}
	   }
	   UpdateSLAB1();
	   UpdateSLAB2();
	   UpdateSLAB3();
	   update_struct();
	   break;

	case 2: 
	   omapcnt1 = atof(qboxes[QCNT].str);
	   if (omapPandN) omapcnt2 = atof(qboxes[QCNT2].str);
	   disp_map(NULL);
	   break;

	case 3: 
	   if (!TogBut(&butomap[3])) {
		DoLines = 1;
		for (j=0; j<NSurf[istruct]; j++) {
		   if (SSon[istruct][j]) {
			trns[istruct][j] = 0;
		   }
		}
	   } else {
		DoLines = 0;
		for (j=0; j<NSurf[istruct]; j++) {
		   if (SSon[istruct][j] && Schain[istruct][i] == -1) {
			trns[istruct][j] = 1;
		   }
		}
	   }
	   disp_map(NULL);
	   break;

     }

   } else {

	if (ClickBox(&qboxes[QCNT],1, event.xbutton.x,event.xbutton.y) >= 0) {
		qboxes[QCNT].active = 1;
		qboxes[QCNT2].active = 0;
		RedrawOMAP();
	}
	if (ClickBox(&qboxes[QCNT2],1, event.xbutton.x,event.xbutton.y) >= 0) {
		qboxes[QCNT2].active = 1;
		qboxes[QCNT].active = 0;
		RedrawOMAP();
	}
   }

   for (j=0; j<6; j++) {
	if (SlideScroll(&omapscr[j],event.xbutton.x,event.xbutton.y)) { }
   }

}

void parname(FSELSTRU *fs,char *strname,int selfil)
{
	    if (fs->files[selfil][0] != '/') {
		strcpy(strname,fs->lastdir);
#ifndef VMS
		if (strname[strlen(strname)-1] != '/') strcat(strname,"/");
#endif
		strcat(strname,fs->files[selfil]);
	    } else strcpy(strname,fs->files[selfil]);
}

int FileSelectBP(fs)
FSELSTRU *fs;
{
    int i;

#ifndef VMS

    if (PressList(&fs->dirlist,event.xbutton.x, event.xbutton.y)) {
	 if (fs->ndirs > 0) {
	     NewDir(fs);
	     getfiles(fs,fs->lastdir);
	     RedrawFwin(fs);
	     update_model = 0;
	 }
    }

#endif

    if (PressList(&fs->flist,event.xbutton.x, event.xbutton.y)) {

	 selfil = fs->flist.select;
	 if (selfil > fs->nfiles - 1) selfil = fs->nfiles - 1;
	 lpnt = fs->flist.lpnt;
         XFlush(display);
         XSync(display, True);
         RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
         XSync(display, True);
   
	 if (fs->parse) {

	    parname(fs,strname,selfil);

	    if (strstr(strname,".ogl")) {
		if (!has_opengl) {
		   lViewer(strname);
		   return(1);
		}
	    }

	    XFlush(display);
	    if (!fs->rbut[BSHOW].toggle) {
		nshfile++;
		if (nshfile > MXSHFILS-1) nshfile = MXSHFILS-1;
		else ShowFile(strname,NULL,&shfiles[nshfile]);
		RedrawFwin(fs);
	    } else {
	 	if (ParseFile(strname,fs->files[selfil])) return(1);
	    }

	 } else {
	    str2qbox(&qboxes[QREADF],fs->files[selfil],-1);
	    PromptBox(&qboxes[QREADF]);
	    if (fs->subopt == 1) {
		str2qbox(&qboxes[QMFILE],fs->files[selfil],-1);
	        PromptBox(&qboxes[QMFILE]);
	    } else if (fs->subopt == 2) {
		str2qboxa(&qboxes[QQSAR],fs->files[selfil],fs->lastdir,-1);
	        PromptBox(&qboxes[QQSAR]);
	    } else if (fs->subopt == 3) {
		str2qboxa(&qboxes[QQSARB],fs->files[selfil],fs->lastdir,-1);
	        PromptBox(&qboxes[QQSARB]);
	    }
	 }
    } else {

	update_model = 0;

	i = ClickBox(&qboxes[QREADF],1,event.xbutton.x,event.xbutton.y);
	if (i>=0) {
	    qboxes[QREADF].active = 1;
	    qboxes[QPDB].active = 0;
	    qboxes[QSUBSTR].active = 0;
	}
	PromptBox(&qboxes[QREADF]);


	if (fs->parse) {
	   i = ClickBox(&qboxes[QSUBSTR],1,event.xbutton.x,event.xbutton.y);
	   if (i>=0) {
	       qboxes[QSUBSTR].active = 1;
	       qboxes[QREADF].active = 0;
	       qboxes[QPDB].active = 0;
	   }
	   i = ClickBox(&qboxes[QPDB],1,event.xbutton.x,event.xbutton.y);
	   if (i>=0) {
	       qboxes[QPDB].active = 1;
	       qboxes[QSUBSTR].active = 0;
	       qboxes[QREADF].active = 0;
	   }
	   PromptBox(&qboxes[QREADF]);
	   PromptBox(&qboxes[QSUBSTR]);
	   PromptBox(&qboxes[QPDB]);
	   i=Clickwin(fs->rbut,NBUTTR,event.xbutton.x, event.xbutton.y,1);
	} else {
	   i=Clickwin(fs->rbut,2,event.xbutton.x, event.xbutton.y,1);
	}

	if (i>=0) {
        	switch (i) {
                    case BDIR : if (fs->parse) {
				   getfiles(fs,qboxes[QREADF].str);
				} else {
				   getfiles(fs,fs->lastdir);
				}
				RedrawFwin(fs);
				break;
                    case BCAN : XUnmapWindow(display,fs->win);
				TogUp(&cbut[BREADF]);
                                fs->qbrfile = 0;
				if (!fs->parse && !fs->subopt) {
				   cpstr(qboxes[QREADF].str,gfile,SUBLEN1);
	    			   *Sinct = fs->inct;
	    			   return(1);
				}
                                break;
                    case BREP : TogBut(&fs->rbut[Fwinopt]);
				ActBut(&fs->rbut[Fwinopt],1);
				Fwinopt = BREP;
				TogBut(&fs->rbut[Fwinopt]);
				ActBut(&fs->rbut[Fwinopt],-1);
				addfile = 0;
				break;
                    case BADD : TogBut(&fs->rbut[Fwinopt]);
				ActBut(&fs->rbut[Fwinopt],1);
				Fwinopt = BADD;
				TogBut(&fs->rbut[Fwinopt]);
				ActBut(&fs->rbut[Fwinopt],-1);
				addfile = 1;
				if (DoCan(event.xbutton.x_root, 
					event.xbutton.y_root,
				"The ADD file is only functional for file types:\n  - Mol2, PDB, sdf and XYZ files",0)) {}
				break;
                    case BPDB : 
				if (!CheckWGET()) {
				    strcpy(strname,"");
				    GetPDBWWW(qboxes[QPDB].str,strname);
				    if (ParseFile(strname,qboxes[QPDB].str)) return(1);
				}
				break;
                    case BSPDB : 
				InitSRCH(event.xbutton.x_root, 
					event.xbutton.y_root);
				break;

                    case BSHOW :
				TogBut(&fs->rbut[BSHOW]);
				ActBut(&fs->rbut[BSHOW],1);
				break;
		}
	}

    }
}

void FileSelect(fs)
FSELSTRU *fs;
{

    fs->win = CreateWindow("Molden File Select","-80-80",QBOXWIDE,QBOXRFD,
                            infobg,infofg,(Window)0);
    XSelectInput(display, fs->win, ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask | EnterWindowMask);

    DefBut(&fs->rbut[BDIR],  fs->win, 325, 275            , 110, BUTTH, 
        	   "Update Directory", infobg, CNTCOL);

    if (fs->parse) {
	DefBut(&fs->rbut[BCAN],  fs->win, 325, 275+BUTTN      , 50, BUTTH, 
        	   "Close", infobg, CNTCOL);

	DefBut(&fs->rbut[BREP],  fs->win, 325, 65            , 15, 15, 
        	   " ", infobg, CNTCOL);
	DefBut(&fs->rbut[BADD],  fs->win, 325, 90            ,15, 15, 
        	   " ", infobg, CNTCOL);
	DefBut(&fs->rbut[BPDB],  fs->win, 380, 216           ,65, BUTTH, 
        	   "<-Get PDB", infobg, CNTCOL);
	DefBut(&fs->rbut[BSPDB],  fs->win, 325, 190          ,70, BUTTH, 
        	   "Search PDB", infobg, CNTCOL);
	DefBut(&fs->rbut[BSHOW],  fs->win, 325, 115          ,15, 15, 
        	   " ", infobg, CNTCOL);
	ActBut(&fs->rbut[Fwinopt],-1);
	TogDown(&fs->rbut[Fwinopt]);
    } else {
	DefBut(&fs->rbut[BCAN],  fs->win, 325, 275+BUTTN      , 50, BUTTH, 
        	   "OK", infobg, CNTCOL);
    }


    if (fs->nfiles == 0) {
	  getfiles(fs,fs->lastdir);
    } else {
	if (fs->parse) {
	  if (firstreadf) GetFirstFile();
	}
    }

    WinObj[9].win = &fs->win;
    WinObj[9].subwin = NULL;
    WinObj[9].butarr = fs->rbut;
    WinObj[9].numbut = 5;
    WinObj[9].winup = NULL;
    WinObj[9].init = FileSelect;
    WinObj[9].redraw = NULL;
}

void FileSelectList(fs)
FSELSTRU *fs;
{
   DefList(&fs->flist,fs->win,DIRX,DIRY,DIRW,DIRH,NULL,
		NFLS,fs->files,NULL,NULL,NULL,&fs->nfiles,NULL);
   fs->flist.select = selfil;
   fs->flist.lpnt = lpnt;
   DefList(&fs->dirlist,fs->win,DDIRX,DDIRY,DDIRW,
		DDIRH,NULL,NDRS,fs->dirs,NULL,NULL,NULL,&fs->ndirs,NULL);
   fs->dirlist.select = seldir;
   fs->dirlist.lpnt = 0;
   XMapWindow(display,fs->win);

   if (fs->parse) {
   	qboxstr(&qboxes[QREADF],&fs->win,1,0,-1,DEFQX,
		DEFQY,QBOXWIDE,QBOXHIGH,0,
		"Directory: ",fs->lastdir,0,
		0,fs->inct,1,fwincall);

   	qboxstr(&qboxes[QSUBSTR],&fs->win,0,0,190,322,
		160,60,35,0,
		"","",0,0,fs->inct,-1,substrcall);

	qboxstr(&qboxes[QPDB],&fs->win,0,0,190,322,
		215,60,35,0,
		"","",4,0,fs->inct,-1,getpdbcall);
   } else {
   	qboxstr(&qboxes[QREADF],&fs->win,1,0,-1,DEFQX,
		DEFQY,QBOXWIDE,QBOXHIGH,0,
		fs->label,fs->pntr,0,
		0,fs->inct,-1,filecall);

   }
}

void UpdPHRM()
{
    FeatSel = pharm.index[PHRMlist.select];
    if (FeatSel > -1 && FeatSel < pharm.NSelFeat) {
	PHRMbut[6].str = FeatStr[pharm.array[FeatSel].type];
	sprintf(qboxes[QPHRMR].str,"%f",pharm.array[FeatSel].rad*0.52917706);
    }

    if (PHRMup) {
	ogfeatures();
	dispsf();
	XMapRaised(display,PHRMwin);
	RedrawPHRM();
    }
}

void PHRMrad(char *str)
{
	pharm.array[pharm.index[PHRMlist.select]].rad  =
		atof(qboxes[QPHRMR].str) / 0.52917706;
	UpdPHRM();
}

void Prt_CooD(double coo[3],int ianz)
{

    fprintf(stderr,"%d %#9.3f,%#9.3f,%#9.3f\n",ianz,
		coo[0]*toangs, coo[1]*toangs, coo[2]*toangs);
}

void Prt_Coo(float coo[3],int ianz)
{

    fprintf(stderr,"%d %#9.3f,%#9.3f,%#9.3f\n",ianz,
		coo[0]*toangs, coo[1]*toangs, coo[2]*toangs);
}

void PrtCoo(COOSTRU *coop, double *coo,int ATMsel)
{
    int k;

    fprintf(stderr,"Coordinates (Ang) %#9.3f,%#9.3f,%#9.3f\n",
		coo[0]*toangs, coo[1]*toangs, coo[2]*toangs);
    fprintf(stderr,"ianz %d\n",coop->ianz[ATMsel]);
    fprintf(stderr,"num conn %d\n",coop->iconn[(ATMsel)*(MXCON+1)]);

    for (k=0; k < coop->iconn[(ATMsel)*(MXCON+1)]; k++)

    fprintf(stderr,"%d ",coop->iconn[(ATMsel)*(MXCON+1)+1+k]);
    fprintf(stderr,"\n");
    fprintf(stderr,"iresid %d\n",coop->iresid[ATMsel]);
}

#define BARR1	0
#define BARR2	1
#define BARRW	23
#define BARRH	23


void RedrawQEDIT(SHFILSTRU *sh);

void RedrawFILE(SHFILSTRU *sh)
{
   int i;

   if (!sh->FILEup) return;

   butje(sh->FILEwin,0,0,FILEWINW,FILEWINH,4,0,0,1,None,0,0,0,0);

   RedrawList(&sh->FILElist);

   if (sh->FILElist.sub != NULL) LineString(sh->FILEwin,"Go To ->",130,FILEWINH - 27);

   for (i=0; i < FILEBUT; i++) {
	DrwBut(&sh->FILEbut[i]);
   }

   if (sh->FILElist.sub == NULL) PromptBox(sh->qbox);

   XFlush(display);
}

int GetCharPosition(FSELSTRU *fs,int ks)
{
   int i,n,pos;
   char c[2];

   n = -1;

   for (i=0; i< fs->nfiles; i++) {
	if (fs->substr != NULL) {
	   if (myStrcasestr(fs->files[i],fs->substr)) {
		n++;
	   }
	}
   }

   *fs->flist.list.nents = n+1;

   pos = -1;

   n = -1;

   for (i=0; i< fs->nfiles; i++) {
	if (fs->substr != NULL) {
	   if (myStrcasestr(fs->files[i],fs->substr)) {
		n++;
		c[0] = fs->files[i][0];
		c[1] = '\0';
		if (strchr(c,ks)) {
		   pos = n;
	   	   break;
		}
	   }
	}
   }

   selfil = pos;
   return(pos);
}

int GetCharDPosition(int ks)
{
   int i,n,pos;
   char c[2];

   pos = -1;

   for (i=0; i< fsel.ndirs; i++) {
	c[0] = fsel.dirs[i][0];
	c[1] = '\0';
	if (strchr(c,ks)) {
	   pos = i;
	   break;
	}
   }

   return(pos);
}

void GetSearchPositions(SHFILSTRU *sh, char *str)
{
   int i,n;

   n = 0;

   for (i=0; i< sh->fileop.nlines ; i++) {
	if (myStrcasestr(sh->fileop.lines[i],str)) {
	   n++;
	}
   }

   sh->commds = (int *) malloc(sizeof(int)*n);

   n = 0;

   for (i=0; i< sh->fileop.nlines ; i++) {
	if (myStrcasestr(sh->fileop.lines[i],str)) {
	   sh->commds[n] = i;
	   n++;
	}
   }

   sh->ncomm = n;
}

void updsrch(SHFILSTRU *sh, char *str)
{
   GetSearchPositions(sh,str);
   (sh->icomm)++;
   if (sh->icomm > sh->ncomm-1) sh->icomm = sh->ncomm-1;
   *(sh->FILElist.scrbar.wpos) = sh->commds[sh->icomm];
   sh->FILElist.sub = str;
   RedrawLBox(&sh->FILElist); 
   RedrawScroll(&sh->FILElist.scrbar);
}

void updsrchstr(SHFILSTRU *sh,char *str)
{
	updsrch(sh,str);
}

int ButtonsFILE(int i,SHFILSTRU *sh)
{
   int j,k;

   switch (i) {
   case 0:
	if (sh->FILEup) {
	    XDestroyWindow(display,sh->FILEwin);
	    if (sh->fileop.lines != NULL) free(sh->fileop.lines);
	    dispsf();
	    sh->FILEup = 0;
	}
	break;
   case 1: {
	   int icomm,l,yes;
	   LSSTRU List;

	   yes = 0;
	   if (sh->FILElist.sub != NULL) {
		if (strstr(sh->FILElist.sub,"BGN COMMAND")) yes = 1;
	   }

	   if (yes) {
	      List.list = sh->commstr; List.nents = sh->ncomm;
	      l = sh->ncomm*LINEHIGH;
	      if (DoPopUp(sh->FILEwin,sh->FILEbut[1].x+20,sh->FILEbut[1].y-l,
			&List,&icomm,0) == -1) break;
		sh->FILEbut[1].str = sh->commstr[icomm];
		DrwBut(&sh->FILEbut[1]);
		sh->icomm = icomm;
		*(sh->FILElist.scrbar.wpos) = sh->commds[icomm];
		RedrawLBox(&sh->FILElist); 
		RedrawScroll(&sh->FILElist.scrbar);
	   } else {
		updsrch(sh,sh->qbox->str);
	   }
	   }
	break;
   default:
	break;
   }
}

static int DeletingFile = 0;

void filmem(int iopt,int list,char *strn, FILEOP *fileop);
void DelMemFile(int *idel,FILEOP *fileop);
void wrtfilmem(char *strn,FILEOP *fileop);

void GetCommandPositions(SHFILSTRU *sh)
{
   int i,n,l;
   char *ptr1;
   char *ptr2;

   n = 0;

   for (i=0; i< sh->fileop.nlines ; i++) {
	if (strstr(sh->fileop.lines[i],"BGN COMMAND")) {
	   n++;
	}
   }

   sh->commds = (int *) malloc(sizeof(int)*n);
   sh->commstr = (char **) malloc(sizeof(char *)*n);

   n = 0;

   for (i=0; i< sh->fileop.nlines ; i++) {
	if (strstr(sh->fileop.lines[i],"BGN COMMAND")) {
	   sh->commds[n] = i;
	   ptr1 = strstr(sh->fileop.lines[i]," - ") + 3;
	   l = strstr(ptr1," tool") - ptr1;
	   ptr2 = (char *) malloc(sizeof(char)*(l+1));
	   strncpy(ptr2,ptr1,l);
	   ptr2[l] = '\0';
	   sh->commstr[n] = ptr2;
	   n++;
	}
   }

   sh->ncomm = n;
}

void ShowFile(char *fname,char *sub,SHFILSTRU *sh)
{

  int i,len;

  if (nshfile > MXSHFILS-1)  {
	sprintf(cmdstr,"A maximum of %d files can be concurrently open\n",MXSHFILS);
	if (DoCan(event.xbutton.x_root,event.xbutton.y_root,cmdstr,0)) {}
	return;
  }

  strcpy(cmdstr,fname);

  sh->FILEup = 1;

  sh->FILEwin = CreateWindow(cmdstr,"-0+0",FILEWINW,FILEWINH,
	 		 infobg,infofg,(Window)0);
  sh->subFILE = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],sh->FILEwin);

  XSelectInput(display, sh->FILEwin, KeyPressMask | ExposureMask 
	| ButtonPressMask | ButtonReleaseMask | ButtonMotionMask 
	| LeaveWindowMask | SubstructureNotifyMask | PointerMotionMask 
	| EnterWindowMask);

  XMapWindow(display,sh->FILEwin);

  WinObj[47+nshfile-1].win = &sh->FILEwin;
  WinObj[47+nshfile-1].subwin = &sh->subFILE;
  WinObj[47+nshfile-1].butarr = sh->FILEbut;
  WinObj[47+nshfile-1].numbut = FILEBUT;
  WinObj[47+nshfile-1].winup  = &sh->FILEup;
  WinObj[47+nshfile-1].redraw = RedrawFILE;
  WinObj[47+nshfile-1].sh = sh;

  filmem(0,1,fname,&sh->fileop);
  free(sh->fileop.str);

  DefList(&sh->FILElist,sh->FILEwin,DIRX,DIRY,FILEWINW-75,FILEWINH-100, " ",
		30,sh->fileop.lines,NULL,NULL,
		NULL,&sh->fileop.nlines,NULL);

  sh->FILElist.fgc = infobg;
  sh->FILElist.bgc = infofg;
  if (sub != NULL) {
	sh->FILElist.hlc = colors[1];
  } else {
	sh->FILElist.hlc = colors[6];
  }
  sh->FILElist.sub = sub;
  sh->FILElist.dosel = 0;

  DefBut(&sh->FILEbut[0], sh->FILEwin, 15, FILEWINH-45, 50, 23, "Close", 
	infobg, -15);
  sh->FILEbut[0].explstr = "Close Window";

  if (sub != NULL) {
	GetCommandPositions(sh);
	DefBut(&sh->FILEbut[1], sh->FILEwin, 200, FILEWINH-45, 250, 23, 
		"Empty", infobg, -15);
	sh->FILEbut[1].explstr = "Goto output of Open3DQSAR command";
	sh->FILEbut[1].style = 1;

  } else {
	DefBut(&sh->FILEbut[1], sh->FILEwin, 200, FILEWINH-45, 250, 23, 
		"Search/Next", infobg, -15);
	sh->FILEbut[1].explstr = "Search file for keyword";

	sh->qbox = (QBOXSTRU *) malloc(sizeof(QBOXSTRU));
	qboxstr(sh->qbox,&sh->FILEwin,0,0,190,500,FILEWINH-45,200,40,2,
		"","",MAXSTRLEN,0,*Sinct,-1,updsrchstr);
	sh->qbox->active = 1;
	sh->icomm = -1;
	for (i=0; i<MXSHFILS; i++) 
	   if (&shfiles[i] == sh) sh->qbox->shfilint = i;
  }
}

int FselKey(Window win, int ks, int x, int y)
{
   FSELSTRU *sel;
   SCRSTRU *sc;
   LISTSTRU *lp, zmelist;

   sel = NULL;

   if (win == fsel.win || win == gsel.win || win == dsel.win ||
	win == MLTwin || win == ZMEwin) {

	if (win == fsel.win) {
	   sel = &fsel;
	   lp  = &fsel.flist;
	} else if (win == gsel.win) {
	   sel = &gsel;
	   lp  = &gsel.flist;
	} else if (win == dsel.win) {
	   sel = &dsel;
	   lp  = &dsel.flist;
	} else if (win == MLTwin) {
	   lp  = &mltlist;
	} else if (win == ZMEwin) {
	   zmelist.win = ZMEwin;
	   zmelist.scrbar = zscroll;
	   zmelist.x = ZMEZOffx+1;
	   zmelist.y = ZMEZOffy;
	   zmelist.w = ZMEZWIDE-1;
	   zmelist.h = ZME_window_high*ZMEQHIGH+ZMEBord+1;
	   zmelist.scrbar.wpos = &ZME_window_pos;
	   lp  = &zmelist;
	} else {
	   return(0);
	}

	if (VIERKANT(x, y,lp->x,lp->y, lp->w,lp->h)) {
		   int iret = 1;
		   if (ks == XK_Home) {
			ScrollP(lp,&lp->scrbar,-1,0);
		   } else if (ks == XK_End) {
			ScrollP(lp,&lp->scrbar,-1,3);
		   } else if (ks == XK_Page_Up) {
			ScrollP(lp,&lp->scrbar,-1,2);
		   } else if (ks == XK_Page_Down) {
			ScrollP(lp,&lp->scrbar,-1,1);
                   } else if (ks == XK_Up || ks == XK_KP_8) {
			ScrollP(lp,&lp->scrbar,-1,5);
                   } else if (ks == XK_Down || ks == XK_KP_2) {
			ScrollP(lp,&lp->scrbar,-1,6);
                   } else if (ks == XK_Return) {
			ScrollP(lp,&lp->scrbar,-1,7);
			if (win != fsel.win) iret  = 0;
                   } else if (ks == XK_Delete) {
			if (lp == &mltlist) {
			   if (!DeletingFile) {
				DelMemFile(&lp->select,&COO[istruct]->memfil);
				RedrawLBox(lp); 
				RedrawScroll(&lp->scrbar);
				iret = 1;
				DeletingFile = 0;
			   }
			}
		   } else if (ks < 127 && ks >= 32) {
			if (sel != NULL) {
			   ScrollP(lp,&lp->scrbar,GetCharPosition(sel,ks),4);
			} else {
			   iret = 0;
			}
		   } else {
			iret = 0;
		   }
		   return(iret);
	} else {
	}

	if (sel == NULL) return(0);

	if (win == fsel.win) lp  = &fsel.dirlist;

	if (PressList(&sel->dirlist, x, y)) {
		   if (ks == XK_Home) {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,0);
		   } else if (ks == XK_End) {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,3);
		   } else if (ks == XK_Page_Up) {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,2);
		   } else if (ks == XK_Page_Down) {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,1);
                   } else if (ks == XK_Up || ks == XK_KP_8) {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,5);
                   } else if (ks == XK_Down || ks == XK_KP_2) {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,6);
                   } else if (ks == XK_Return) {
			ScrollP(lp,&lp->scrbar,-1,7);
		   } else {
			ScrollP(&sel->dirlist,&sel->dirlist.scrbar,
				GetCharDPosition(ks),4);
		   }
		   return(1);
	} else {
	   return(0);
	}
   } else {
	return(0);
   }

}

int Scr_Wheel(Window win, int but, int x, int y)
{
  FSELSTRU *sel;
  LISTSTRU *lp,zmelist;
  int But,zmen;

  But = but+1;
  sel = NULL;
  lp  = NULL;

  if ((win == fsel.win || win == gsel.win || win == MLTwin ||
	win == dsel.win || win == ZMEwin) && (but == 5 || but == 4)) {

	if (win == fsel.win) {
	   sel = &fsel;
	   lp  = &fsel.flist;
	} else if (win == gsel.win) {
	   sel = &gsel;
	   lp  = &gsel.flist;
	} else if (win == dsel.win) {
	   sel = &dsel;
	   lp  = &dsel.flist;
	} else if (win == MLTwin) {
	   lp  = &mltlist;
	} else if (win == ZMEwin) {
	   zmelist.win = ZMEwin;
	   zmelist.scrbar = zscroll;
	   zmelist.x = ZMEZOffx+1;
	   zmelist.y = ZMEZOffy;
	   zmelist.w = ZMEZWIDE-1;
	   zmelist.h = ZME_window_high*ZMEQHIGH+ZMEBord+1;
	   zmelist.scrbar.wpos = &ZME_window_pos;
	   lp  = &zmelist;
	}

	if (lp == NULL) return(0);

	if (VIERKANT(x, y,lp->x,lp->y, lp->w,lp->h)) {
		   ScrollP(lp,&lp->scrbar,-1,But);
		   return(1);
	}

	if (sel == NULL) return(0);

	if (PressList(&sel->dirlist, x, y)) {
		   ScrollP(&sel->dirlist,&sel->dirlist.scrbar,-1,But);
		   return(1);
	}
  }

  return(0);
}

void Delete_Field(int idel,FILEOP *fileop)
{
    int i,j;

    for (j=0; j < FLDS.nfields; j++) {
	free(FLDS.Fields[j][idel]);
    }

    for (j=0; j < FLDS.nfields; j++) {
	for (i=idel; i < fileop->nfiles - 1; i++) {
		FLDS.Fields[j][i] = FLDS.Fields[j][i+1];
	}
    }

    FLDS.editted = 1;
}

void Activate_Structure(int *select)
{
	if (*select > ntits - 1 ) *select = ntits - 1;
	mfdata->imol = *select + 1;
	if (mfdata->imol > ntits) mfdata->imol = ntits;
	WinName(win,mlftit[*select]);

	DowinC = 1; DoactC = 1; DoactMC = 1;

#if defined(VMS) || defined(UNDERSC)
	curs(&ONE);
#else
#ifdef CRAY
	CURS(&ONE);
#else
	curs_(&ONE);
#endif
#endif
	*Sinct = 481;
	*Sincp = addfile;

	if (addfile && *ipdbon) {
	    int nl;
			
	    nl = strlen(mlftit[*select]);
#if defined(VMS) || defined(UNDERSC)
	    parsfn(mlftit[*select], &nl, &ONE);
#else
#ifdef CRAY
	    PARSFN(mlftit[*select], &nl, &ONE);
#else
	    parsfn_(mlftit[*select], &nl, &ONE);
#endif
#endif
	}
}

#if defined(VMS) || defined(UNDERSC)
void xwin(x, y, icomm, str, nstr, inct, incp)
#else
#ifdef CRAY
void XWIN(x, y, icomm, str, nstr, inct, incp)
#else
void xwin_(x, y, icomm, str, nstr, inct, incp)
#endif
#endif

float *x;
float *y;
int *icomm;
#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
int *inct;
int *incp;


{

  int done;
  int i,j;

  float Arg1;
  float Arg2;
  int Command;

  if (COO[0] == NULL) {
	AllocateStructure(&COO[0]);
	COO[0]->svgdone = 0;
	COO[0]->fname = NULL;
  }

  if (*icomm == 15 || *icomm == 0) update_model = 1;

  Arg1 = *x;
  Arg2 = *y;
  Command = *icomm;
  if (Command == DenWindow || Command == MolWindow || Command == OpenWindow) {
     Sstr = str; Snstr = nstr; Sinct = inct; Sincp = incp;
  }


  switch(Command) {
  case DenWindow : 
  {



    while(XCheckTypedWindowEvent(display,win,Expose,&report));

    if ( DowinC ) {
       DirBox(winC,1);    
       DowinC = 0;
       ZoomEnable = True;
       ZoomSelection = False;
       xoff = 0.0;
       yoff = 0.0;
       scale = 1.0;
       XFlush(display);
    }
    if ( DoactC ) {actde(*inct,*incp,1);DoactC = 0;}

    done = 0;
    *inct = 0;
    *incp = 0;
    if (hold) {
       XSync(display, False);
       if (XPending(display)>0){
          if (XCheckMaskEvent(display,ButtonReleaseMask,&event))
                        { hold = 0; goto XXLOOP;}
       }
       if (!*ifdogl) {
	   gl2DEnd();
	   *inct = holdt;
	   *incp = holdp;
	   clrsave();
	   gl2DInit();
	   return;
       } else {
#if defined(VMS) || defined(UNDERSC)
           mktrn(&holdt,&holdp);
#else
#ifdef CRAY
           MKTRN(&holdt,&holdp);
#else
           mktrn_(&holdt,&holdp);
#endif
#endif
	   if (update_model) ogind();
	   else dispsf();
       }
    }
XXLOOP:

    gl2DEnd();

    while (!done) {
  

	XNextEvent(display, &event);

        switch (event.type) {

           case KeyPress:    {
              XKeyEvent *key_event = (XKeyEvent *) &event;
              char buf[1];  XComposeStatus status;  int stlen;

              stlen = XLookupString(key_event,buf,1,&ks,&status);
	      /*if (!stlen) break;*/

/* the following statement is only there to stop the compiler
   from optimising away ks */

	      sprintf(stemp,"%d",(int) ks);

              for (i=0; i<NQBOX; i++) 
		if (key_event->window == qboxes[i].win && qboxes[i].active) 
		   if (KeyChk(&qboxes[i],buf[0],ks)) {
		       if (key_event->window != fsel.win) {
				if (*Sinct != 150) clrsave();
				return;
			}
		   }

              /* do non-character processing (arrow-keys, that is) */
              if (key_event->window == win || key_event->window == winMC) {
                 if      (ks==XK_Left  || ks==XK_KP_4)
                   { *inct = 1; }
                 else if (ks==XK_Right || ks==XK_KP_6)
                   { *inct = -1; }
                 else if (ks==XK_Up    || ks==XK_KP_8)
                   { *incp = -1; }
                 else if (ks==XK_Down  || ks==XK_KP_2)
                   { *incp = 1; }
                 else if (buf[0]=='i')
                   { *inct = 30;
                     *incp = 1; }
                 else if (buf[0]=='d')
                   { *inct = 30;
                     *incp = -1; }
                 else if (buf[0]=='m')
                   { *inct = 45; }
                 else if (buf[0]=='c')
                   { *inct = 80; }
                 else if (buf[0]=='e')
                   { *inct = 85; }
/*
                 else if (buf[0]=='3')
                   { *inct = 90; }
                 else if (buf[0]=='t') {
                   { sprintf(stemp,"Orbital number (1-%d)? ",NAT->norbs);
		     qboxstr(&qboxes[QORB],NULL,1,0,-1,DEFQX,DEFQY,
		     QBOXWIDE,QBOXHIGH, 0,stemp,NULL,0,1,160,dummyproc);
		    }
		 }
*/
                 else if (buf[0]=='n')
                   { *inct = 170; }
                 else if (buf[0]=='b')
                   { *inct = 180; }
                 else if (buf[0]=='a')
                   { *inct = 190; }
                 else if (buf[0]=='o')
                   { *inct = 200; }
                 else if (buf[0]=='r')
                   { *inct = 210; }
                 else if (buf[0]=='u')
		   { OnTop(); }
                 if ((*ifdogl && has_opengl) && key_event->window == win) 				{Key(buf[0]);}
                 cnt = 0;
		 clrsave();
                 if (!(*ifdogl && has_opengl)) return;
              }
           }
           break;

           case ButtonPress: {

              if(DEBUG)fprintf(stderr,"ButtonPress\n");

              if(event.xbutton.window == win && event.xbutton.button == 2
                 && ZoomEnable && !do3dx && !*ifdogl) {
        
                 ZoomEnable = False;
                 ZoomSelection = True;
                 MotionCount = 0; 
         
                 XDefineCursor(display, win, ZoomCursor);
                 XSetFunction(display, gc, GXxor);
                 XSetForeground(display, gc, colors[11]);
                 ZoomX1 = event.xbutton.x;
                 ZoomY1 = event.xbutton.y;
                 ZoomW = 1;
                 ZoomH = 1;
                 XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
         
              } else if(event.xbutton.window == win && event.xbutton.button == 2
                      && !ZoomEnable && !ZoomSelection && !*ifdogl) {

                 ZoomEnable = True;
                 scale = 1.0;
                 xoff = 0.0;
                 yoff = 0.0;

                 RedrawWin();
              } else if(event.xbutton.window == win && 
                      event.xbutton.button == 3) {

                 DirBox(winC,1);
                 if (qbcomm) DirBox(COMMwin,1);
                 if (DoEig) DirBox(EBox,1);
                 for (i=0; i<NQBOX; i++) 
   		   if (qboxes[i].pop && qboxes[i].active) 
			XMapRaised(display,qboxes[i].win);

              }

              if (event.xbutton.window == EBox) {
	       if (PressList(&elist,event.xbutton.x, event.xbutton.y)) {
		 update_model = 1;
		 *ivtwo = -1;
		 clrsave();
                 *inct = 160; 
		 if (*iuhf && ibeta) {
			*incp = -1*(elist.select+1);
		 } else {
			*incp = elist.select+1;
		 }
		 gl2DInit();
                 return;
	       }
	      } else if(event.xbutton.window == win &&
                      event.xbutton.button == 1 ) {
              
                 int curtx = event.xbutton.x;
                 int curty = event.xbutton.y;
                 float dangy,tsqx,tsqy;

                 if (!ZoomEnable && *dospa  && !*ifdogl) {
                    ZoomEnable = True;
                    scale = 1.0;
                    xoff = 0.0;
                    yoff = 0.0;
                    return;
                 }

		 if (*ifdogl) {
		    moving = 1;
		    startx = event.xbutton.x;
		    starty = event.xbutton.y;
		    btype = 0;
		    if (event.xbutton.state & ShiftMask) btype = 1;
		    if (event.xbutton.state & ControlMask) btype = 2;
		    if ((event.xbutton.state & ControlMask) 
			  && (event.xbutton.state & ShiftMask)) btype = 3;
		    if (has_opengl) 
			  moused(event.xbutton.button,event.xbutton.state, 
					  event.xbutton.x, event.xbutton.y);
		    break;

                 } else {
		   hold = 1;
		   holdt = 0;
		   holdp = 0;
                   tsqx = (int) (width / 2 - curtx);
                   tsqy = (int) (height / 2 - curty);
                   cnt = 0;
		   clrsave();
		   gl2DInit();
                   if (tsqx == 0 && tsqy == 0) return;
                   if (tsqx == 0 && tsqy > 0) { *incp = -1; holdp = *incp; return;}
                   if (tsqx == 0 && tsqy < 0) { *incp =  1; holdp = *incp; return;}
                   if (tsqy == 0 && tsqx > 0) { *inct = -1; holdt = *inct; return;}
                   if (tsqy == 0 && tsqx < 0) { *inct =  1; holdt = *inct; return;}
                   dangy = tsqy / tsqx;
                   if (tsqx > 0) {
                    if (dangy <= 1 && dangy >= -1) {
                        *inct = 1; holdt = *inct; return;}
                    else if (dangy > 1) {
                        *incp = 1; holdp = *incp; return;}
                    else { *incp = -1; holdp = *incp; return;}
                   }
                   if (tsqx < 0) {
                    if (dangy <= 1 && dangy >= -1) {
                        *inct = -1; holdt = *inct; return;}
                    else if (dangy > 1) {
                        *incp = -1; holdp = *incp; return;}
                    else { *incp = 1; holdp = *incp; return;}
                   }
                 }
              }

              if (event.xbutton.window == win && event.xbutton.button == 4) 
			ScrollWheel(inct,incp,1);
	      

              if (event.xbutton.window == win && event.xbutton.button == 5) 
		 	ScrollWheel(inct,incp,0);

              if (event.xbutton.window == QBox && qboxup)  {
		for (j=0; j<NQBOX; j++) 
		    if (qboxes[j].win == QBox && qboxes[j].active) break;
		i = Clickwin(qboxclose,2,event.xbutton.x,event.xbutton.y,1);
		if (i == 0) {
		   if (KeyChk(&qboxes[j],'\012',(KeySym) 0)) return;
		} else if (i == 1) {
		   XDestroyWindow(display,QBox);
		   XSync(display, False);
		   qboxup = 0;
		}
	      }

	      if (event.xbutton.button  == 3) 
			QBoxPaste(event.xbutton.window,qboxes,NQBOX);

              if (event.xbutton.window == MAPwin) {
		 i = Clickwin(mapbut,NBUTSM,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsMAP(i)) return;
		 } else {
			i = ClickBox(&qboxes[QVFILE],10,
				event.xbutton.x,event.xbutton.y);
			if (i>=0) {
				for (j=0; j<10; j++) qboxes[QVFILE+j].active = 0;
				qboxes[QVFILE+i].active = 1;
				RedrawMAP();
			}
		 }
	      }

	      if (event.xbutton.window == OMAPwin && OMAPup) {
		    update_model = 0;
		    i = Clickwin(butomap,3,event.xbutton.x, event.xbutton.y,1); 
		    ClickOMAP(i);
	      }

              if (event.xbutton.window == VIRwin) {
		 i = Clickwin(virbut,2,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsVIR(i)) return;
		 } else {
			i = ClickBox(&qboxes[QSVFILE],2,
				event.xbutton.x,event.xbutton.y);
			if (i>=0) {
				for (j=0; j<2; j++) 
					qboxes[QSVFILE+j].active = 0;
				qboxes[QSVFILE+i].active = 1;
				RedrawVIR();
			}
		 }
	      }

              if (event.xbutton.window == STRCwin) {
	         update_model = 0;
		 i = Clickwin(strcbut,STRCBN,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSTRC(i)) return;
		 } else {
			if (PressList(&strclist,
				event.xbutton.x, event.xbutton.y)) {

				dispsf();
			}
		 }
	      }

              if (event.xbutton.window == gsel.win ) {

		if (FileSelectBP(&gsel) == 1) return;

              }

              if (event.xbutton.window == dsel.win ) {

		if (FileSelectBP(&dsel) == 1) return;

              }
              if (event.xbutton.window == winC) {
		 int doret = 1;
		 *ivtwo = -1;
                 i=Clickwin(dbut,NBUTTS,event.xbutton.x, event.xbutton.y,1);

		 update_model = 1;
		 gl2DInit();

                 if (i>=0) {
                 switch (i) {
                 case BPSI: 
			update_model = 0;
			doret = 0;
			if (TogBut(&dbut[BPSI])) {
			   XDestroyWindow(display,EBox);
			   *inct = 160; *incp = 0;
			   DoEig = 0;
			}
			else {
			   LSSTRU List;
			   List.list = alphbet; List.nents = 2;
			   if (*iuhf) {
				if (DoPopUp(winC,dbut[BPSI].x+1,
					dbut[BPSI].y+BUTTH,&List,&ibeta,0) == -1) break;
			   }
			   EBox = CreateWindow("Molden Orbital Select",
				"-80-80",QBOXWIDE,QBOXRF,infobg,infofg,
				(Window)0);

			   XSelectInput(display, EBox, ExposureMask | 
				KeyPressMask | ButtonPressMask | 
				ButtonReleaseMask | ButtonMotionMask | 
				LeaveWindowMask | EnterWindowMask);

			   WinObj[18].win = &EBox;
			   WinObj[18].subwin = NULL;
			   WinObj[18].butarr = NULL;
			   WinObj[18].numbut = -1;
			   WinObj[18].winup = &DoEig;
			   WinObj[18].init = NULL;
			   WinObj[18].redraw = NULL;

			   if ((*iuhf && !ibeta) || !*iuhf) 
      				DefList(&elist,EBox,DIRX,DIRY,DIRW,DIRH,
				" Nr.        Eigenvalue   Occupation",
				NFLS,NULL,dorbp->eiga,dorbp->focc,
				NULL,dorbp->ncols,NULL);

			   if (*iuhf && ibeta) 
      				DefList(&elist,EBox,DIRX,DIRY,DIRW,DIRH,
				" Nr.        Eigenvalue   Occupation",
				NFLS,NULL,dorbp->eigb,dorbp->focb,NULL,
				dorbp->ncolb,NULL);

			   XMapWindow(display,EBox);
			   DoEig = 1;
			}
			break;
                 case BHOMO: *inct = 230; break;
                 case BLUMO: *inct = 240; break;
                 case BNDEN: if (*iuhf)
				{LSSTRU List;
				 List.list = spdopt; List.nents = 2;
				 if (DoPopUp(winC,dbut[BNDEN].x+1,
					dbut[BNDEN].y+BUTTH,&List,ispd,0) == -1) break;
				}
			     *inct = 170;
			     break;
                 case BLAPL: *inct = 171; break;
                 case BELF:  *inct = 172; *valcnt = 0.8; break;
                 case BBONDS: *inct = 180; break;
                 case BATOM: *inct = 190; break;
                 case BOVRLP: *inct = 200; break;
                 case BELPOT: {
				int itmp;
				LSSTRU List;
				List.list = pots2; List.nents = 3;
				if (DoPopUp(winC,dbut[BELPOT].x+1,
					dbut[BELPOT].y+BUTTH,&List,&itmp,0) == -1) break;
				*inct = 350+itmp;
				break;}
                 case BMAXMIN: *inct = 360; break;
                 case BPOST:   {
				LSSTRU List;
				if (do3dx) {
			           if (DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
				"Postscript is not supported for this drawing mode",0)) {}
				   break;
				}
				List.list = postopt; List.nents = 2;
				if (DoPopUp(winC,dbut[BPOST].x+1,
					dbut[BPOST].y+BUTTH,&List,icolps,0) == -1) break;
				qboxstr(&qboxes[QPOST],NULL,1,0,-1,DEFQX,DEFQY,
					QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
					0,0,150,0,dummyproc);
				}
				break;
                 case BMOLMOD: *inct = 75; DirBox(winC,0);
                                DowinMC =1;DoactMC = 1;
				denmode = 0;
		 		empty_model(istruct,1);
				update_model = 1;
				ZoomEnable = True;
				ZoomSelection = False;
				xoff = 0.0;
				yoff = 0.0;
				scale = 1.0;
				if (qbcomm) {
			   	   TogUp(&dbut[BCOMM]);
			   	   qbcomm = 0;
			   	   XUnmapWindow(display,COMMwin);
				}
		 		if (DoEig) {
				    TogUp(&dbut[BPSI]);
				    XDestroyWindow(display,EBox);
				    DoEig = 0;
				}
		 		if (STRCup) {
				    XDestroyWindow(display,STRCwin);
				    STRCup = 0;
				}
                                break;
                 case BEUCL: *inct = 85; do3dx = 0; *do3d = 0;*dospa = 0;
                             ActBut(&dbut[BCONT],1);
                             ActBut(&dbut[BINCRS],1);
                             ActBut(&dbut[BDECRS],1);
                             ActBut(&dbut[BSTEP],1);
                             ActBut(&dbut[BCUT],1);
                             ActBut(&dbut[BFILL],0);
                             DrwBut(&dbut[BCONT]);
                             DrwBut(&dbut[BFILL]);
                             DrwBut(&dbut[BSTEP]);
                             DrwBut(&dbut[BCUT]);
                             DrwBut(&dbut[BINCRS]);
                             DrwBut(&dbut[BDECRS]);
#ifdef DOGL
			     if (*ifdogl) {
				*ifdogl = 0;
				TogUp(&dbut[BOGL]);
			     }
#endif
                             break;
                 case B3D:   
			     *inct = 90; do3dx = 0; *do3d = 1; *dospa = 0;
                             ActBut(&dbut[BCONT],1);
                             ActBut(&dbut[BINCRS],1);
                             ActBut(&dbut[BDECRS],1);
                             ActBut(&dbut[BSTEP],1);
                             ActBut(&dbut[BCUT],1);
                             ActBut(&dbut[BFILL],0);
                             DrwBut(&dbut[BCONT]);
                             DrwBut(&dbut[BFILL]);
                             DrwBut(&dbut[BSTEP]);
                             DrwBut(&dbut[BCUT]);
                             DrwBut(&dbut[BINCRS]);
                             DrwBut(&dbut[BDECRS]);
#if defined(VMS) || defined(UNDERSC)
			     bldlst();
#else
#ifdef CRAY
			     BLDLST();
#else
			     bldlst_();
#endif
#endif
			     if (*ifdogl) doret = 0;
                             break;
                 case B3DX:  
			     *inct = 91; do3dx = 1; *do3d = 0; *dospa = 0;
                             ActBut(&dbut[BINCRS],1);
                             ActBut(&dbut[BDECRS],1);
                             ActBut(&dbut[BCONT],0);
                             ActBut(&dbut[BFILL],0);
                             ActBut(&dbut[BSTEP],0);
                             ActBut(&dbut[BCUT],0);
                             DrwBut(&dbut[BCONT]);
                             DrwBut(&dbut[BFILL]);
                             DrwBut(&dbut[BSTEP]);
                             DrwBut(&dbut[BCUT]);
                             DrwBut(&dbut[BINCRS]);
                             DrwBut(&dbut[BDECRS]);
#if defined(VMS) || defined(UNDERSC)
			     bldlst();
#else
#ifdef CRAY
			     BLDLST();
#else
			     bldlst_();
#endif
#endif
			     if (*ifdogl) doret = 0;
                             break;
                 case BSRF2: 
			     if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
				"Go to Mol. Mode to view this\nUse the Surface icon to save the surface",0)) {
				}
			     linmax = 2;
                 case BVRML2:
			     if ((do3dx || *do3d) && i == BVRML2 && ! *dospa) {
				int optie;
				LSSTRU List;
				List.list = vrml2dopt; List.nents = 2;

				if (DoPopUp(winC,dbut[BVRML2].x+1,
					dbut[BVRML2].y+BUTTH,&List,&optie,0) == -1) break;
				if (optie) {
				   *inct = 651;
				} else {
				   qboxstr(&qboxes[QVRML],NULL,1,0,-1,
				   DEFQX,DEFQY, QBOXWIDE,QBOXHIGH,0,
				   "VRML Filename ? ",NULL,0,0,
				   650,0,dummyproc);
				}
				break;
			     }
                 case BSPACE: 
			     *ivtwo = -1;
/* check */
			     if (i == BVRML2) {
				LSSTRU List; LSSTRU MList;
				if (!*ipsi) {
				   MList.list = denopt; MList.nents = 2;
				   if (DoPopUp(winC,dbut[BVRML2].x-25,
					dbut[BVRML2].y+BUTTH,&MList,mapit,0) == -1) break;
				}
				if (! *mapit) {
				   List.list = vrmlopt; List.nents = 4;
				   if (DoPopUp(winC,dbut[BVRML2].x+1,
					dbut[BVRML2].y+BUTTH,&List,ivtwo,0) == -1) break;
				}
			      }
			     do3dx = 0; *do3d = 0;
                             ActBut(&dbut[BCONT],0);
                             ActBut(&dbut[BINCRS],0);
                             ActBut(&dbut[BDECRS],0);
                             ActBut(&dbut[BSTEP],0);
                             ActBut(&dbut[BCUT],0);
                             ActBut(&dbut[BFILL],1);
                             DrwBut(&dbut[BCONT]);
                             DrwBut(&dbut[BFILL]);
                             DrwBut(&dbut[BSTEP]);
                             DrwBut(&dbut[BCUT]);
                             DrwBut(&dbut[BINCRS]);
                             DrwBut(&dbut[BDECRS]);
			     if (*mapit) {
				doret = 0;
				InitMAP();
			     } else {
				if (i == BVRML2) 
				   InitVIR();
				else if (i == BSPACE && 
				(NAT->natoms || (*cubetyp == 2 || *cubetyp == 3))) {
				   qboxes[QSPAC].dflt = valcnt;
	   			   sprintf(stemp,"%5.2f",*valcnt);
		    		   qboxstr(&qboxes[QSPAC],NULL,1,0,-1,DEFQX,DEFQY,
				   QBOXWIDE,QBOXHIGH, 0,"Contour Value ? ",stemp,
				   0,3,92,-1,dummyproc);
				   doret = 0;
				}
				else if (i == BSPACE) *inct = 92;
				else if (i == BSRF2) *inct = 94;
			     }
                             break;
                 case BFILL : *inct = 93;TogBut(&dbut[BFILL]);break;
                 case BINCRS: *inct = 30;*incp = 1;break;
                 case BDECRS: *inct = 30;*incp = -1;break;
                 case BCONT:  *inct = 80;TogBut(&dbut[BCONT]); break;
                 case BMOL:   *inct = 45;TogBut(&dbut[BMOL]); break;
                 case BCOMM: 
			*ivtwo = -1;
			if (qbcomm) {
			   TogUp(&dbut[BCOMM]);
			   qbcomm = 0;
			   XUnmapWindow(display,COMMwin);
			}
			else {
			   TogDown(&dbut[BCOMM]);
			   XMapWindow(display,COMMwin); qbcomm = 1;
			   qboxstr(&qboxes[QCOMM],&COMMwin,1,0,-1,DEFQX,DEFQY,
				QBOXWIDE,QBOXHIGH,0,"Command Line ? ",NULL,
				0,0,220,-1,dummyproc);
			}
			if (*ifdogl) doret = 0;
			break;
                 case BQUIT: {
			if (!DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
					" Are you sure to quit?  ",1)) {
		          FreeAll(1);
                          XFreeGC(display, gc);
                          XCloseDisplay(display);
                          *inct = 15; 
			} }
			break;
                 case BCUBE: 
			{int irwopt; LSSTRU List;
			 List.list = rwopt; List.nents = 2;
			 if (DoPopUp(winC,dbut[BCUBE].x+1,
				dbut[BCUBE].y+BUTTH-30,&List,&irwopt,0) == -1) break;
			 if (irwopt) {
			    qboxstr(&qboxes[QCUBE],NULL,1,0,-1,DEFQX,DEFQY,
				QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
				0,0,282,0,dummyproc);
			 } else {
			    List.list = cubeopt; List.nents = 3;
			    if (DoPopUp(winC,dbut[BCUBE].x+1,
				dbut[BCUBE].y+BUTTH-30,&List,cubetyp,0) == -1) break;
			    *do3d = 0; do3dx = 0;
			    qboxstr(&qboxes[QCUBE],NULL,1,0,-1,DEFQX,DEFQY,
				QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
				0,0,281,0,dummyproc);
			 }
        		 XSync(display, False);
			}
			break;
                 case BGIF2: 
			setgif(0);
			doret = 0;
			break;
                 case BLOCAL: 
#if defined(VMS) || defined(UNDERSC)
			dipole();
#else
#ifdef CRAY
			DIPOLE();
#else
			dipole_();
#endif
#endif
			doret = 0;
			break;
                 case BOGL: 
#ifdef DOGL
			if (*ifdogl) {
			   *ifdogl = 0;
			   TogUp(&dbut[BOGL]);
			   gl2DInit();
			} else {
			   if (has_opengl) {
			      *ifdogl = 1;
			      TogDown(&dbut[BOGL]);
			      if (!do3dx && !*do3d && !*dospa) *do3d = 1;
			      dispsf();
			      inistrc();
			   }
			}
			doret = 1;
#endif
			break;
                 case BORI: *inct = 210; TogBut(&dbut[BORI]); break;
                 case BSTEP: {
		      qboxstr(&qboxes[QSTEP],NULL,1,0,-1,DEFQX,DEFQY,
			QBOXWIDE,QBOXHIGH,0,"Step ? ",NULL,0,3,250,-1,
				dummyproc);
		      break;}
                 case BCUT: {
		      qboxstr(&qboxes[QCUT],NULL,1,0,-1,DEFQX,DEFQY,
			QBOXWIDE,QBOXHIGH,0,"Cut (0.0 > cut <= 1.0) ? ",NULL,
			0,3,260,-1,dummyproc);
		      break;}
                 case BWRBAS: *inct = 270; break;
                 case BRDBAS:  
				{
				 LSSTRU List;
				 List.list = readgrd; List.nents = 2;
				 if (DoPopUp(winC,dbut[BRDBAS].x+1,
					dbut[BRDBAS].y+BUTTH,&List,incp,0) == -1) break;
				gsel.qbrfile = 1;
				gsel.subopt = 0;
				FileSelectList(&gsel);
				doret = 0;
				*inct = 280;
				}
				break;
                 }
                 cnt = 0;
		 clrsave();
                 if (doret) return;
                 }
              }
 
           }
           break;


           case MotionNotify: {


              if(DEBUG)fprintf(stderr,"MotionNotify\n");

	      if (!bcksvg.UpSVG) SetExplButton(event.xmotion.window,
				event.xmotion.x,event.xmotion.y);

              if(event.xmotion.window == win && ZoomSelection) {
                 int NewX, NewY;
   
   
                 while(XCheckTypedWindowEvent(display, win, MotionNotify,
                                        &event));
   
                 MotionCount++;

#ifdef DOGL
		 rubber(0);
#else
                 XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
#endif
   
                 /* get the location of the pointer */
   
                 NewX = event.xmotion.x;
                 NewY = event.xmotion.y;
                                                                                   
                 ZoomX2 = MAXI(ZoomX1, NewX);
                 ZoomY2 = MAXI(ZoomY1, NewY);
                 ZoomW = MAXI(ABS(ZoomX2 - ZoomX1),1);
                 ZoomH = MAXI(ABS(ZoomY2 - ZoomY1),1);

#ifdef DOGL
		 rubber(0);
#else
                 XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
#endif

              } /* end ZoomSelection */
              if (event.xmotion.window == win && *ifdogl && (moving || gmoving)) {
	        /*update_model = 0;*/
		if (XCheckMaskEvent(display,ButtonReleaseMask,&event)) {
		   if (has_opengl) motion(event.xmotion.x, event.xmotion.y, 1);
		   moving = 0;
		} else {
		   while (XCheckMaskEvent(display,ButtonMotionMask,&event));
		   *incp = (event.xmotion.x - startx);
		   if (btype == 0) { 
			*inct = 421;
		   } else if (btype == 1) {
			*inct = 415;
		   } else if (btype == 2) {
			*inct = 417;
		   } else if (btype == 3) {
			*inct = 422;
		   }
#if defined(VMS) || defined(UNDERSC)
		   mktrn(inct,incp);
#else
#ifdef CRAY
        	   MKTRN(inct,incp);
#else
        	   mktrn_(inct,incp);
#endif
#endif
		   *incp = (event.xmotion.y - starty);
		   if (btype == 0) { 
			*inct = -421;
		   } else if (btype == 1) {
			*inct = 416;
		   }

#if defined(VMS) || defined(UNDERSC)
		   mktrn(inct,incp);
                   if (*ifdogl) motion(event.xmotion.x, event.xmotion.y, 0);
		   else qupd();
#else
#ifdef CRAY
        	   MKTRN(inct,incp);
                   if (*ifdogl) motion(event.xmotion.x, event.xmotion.y, 0);
		   else QUPD();
#else
        	   mktrn_(inct,incp);
                   if (*ifdogl) motion(event.xmotion.x, event.xmotion.y, 0);
		   else qupd_();
#endif
#endif
		   startx = event.xmotion.x;
		   starty = event.xmotion.y;
		   *inct = 0;
		   XFlush(display);
		   XSync(display, False);
                }
	      } 
           } /* end MotionNotify */
           break;


           case ButtonRelease: {


              if(DEBUG)fprintf(stderr,"ButtonRelease\n");

              if (!*ifdogl && event.xbutton.window == win) {
		 moving = 0;
		 gmoving = 0;
	      }

              if (event.xbutton.window == win && 
		  (event.xbutton.button == 1 || event.xbutton.button == 2) &&
                  !ZoomSelection ) moving = 0;

              if(event.xbutton.window == win && event.xbutton.button == 2 
                 && ZoomSelection ) {

                 ZoomSelection = False;
                 XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
                 XSetFunction(display, gc, GXcopy);
                 XUndefineCursor(display, win);


                 ZoomX2 = event.xbutton.x;
                 ZoomY2 = event.xbutton.y;
                
                 if (MotionCount >=3 ) {

                    scale   = height*1.0 /MAXI(ABS(ZoomY2 - ZoomY1),1);
                    xoff = ZoomX1*1.0 / height;
		    yoff = ZoomY1*1.0 / height;
		    if (*fullgl && !*ifdogl) {
			yoff = 1.0 - yoff - 1.0/scale;
		    }

                    RedrawWin();
                 }
                 else
                 {ZoomEnable = True;}



              } /* end zoom */

              if (*ifdogl && event.xbutton.window == win) {
		 mouseu(event.xbutton.button,event.xbutton.state, 
			event.xbutton.x, event.xbutton.y);
                 dispsf();
		 break;
	      }

           } /* end ButtonRelease */
           break;
                                                                                
  	
	   case ClientMessage: {
		Atom proto, delwin;
		XClientMessageEvent *client_event = 
			(XClientMessageEvent *) &event;

		proto = XInternAtom(display, "WM_PROTOCOLS", False);
		delwin = XInternAtom(display, "WM_DELETE_WINDOW", False);

		if (client_event->message_type == proto &&
		    client_event->data.l[0] == delwin) {
		    if (client_event->window == COMMwin) {
			if (qbcomm) {
			   TogUp(&dbut[BCOMM]);
			   qbcomm = 0;
			   XUnmapWindow(display,COMMwin);
			}
		    } else if (client_event->window == EBox) {
			if (DoEig) {
			   TogUp(&dbut[BPSI]);
			   DoEig = 0;
			   XUnmapWindow(display,EBox);
			}
		    } else if (client_event->window == QBox) {
			XDestroyWindow(display,QBox);
			XSync(display, False);
		        qboxup = 0;
		    }
		}
	   }
	   break;

           case Expose: {


              if(DEBUG)fprintf(stderr,"Expose\n");

        /* if the window doesn't do intelligent redraw, drop all-1 exposes */

	      if (event.xexpose.count>0 && event.xexpose.window != win) break;

	      while(XCheckTypedWindowEvent(display,win,Expose,&report)) {
	           if (event.xexpose.count == 0) break;
	      }

              if (event.xexpose.window == win && !ZoomSelection && !*ifdogl) {
                   if (!CheckForConfig()) {
                       if (!*fullgl && molback == molcur) {
                          XCopyArea(display,molcur,win,gc,0,0,width,height,0,0);
                       }
                       else {
                          RedrawWin();
                       }
                   }
              } else {
                   if (event.xexpose.window == winC) {
			while(XCheckTypedWindowEvent(display,win,
				Expose,&report)) {
			}
                   	RedrawwinC(0,0,WINCWIDE,WINCHIGH);
		   }
              }

              if (*ifdogl && event.xexpose.window == win) {
                 dispsf();
              }

              for (i=0; i<NQBOX; i++) 
		if (event.xexpose.window == qboxes[i].win)
			PromptBox(&qboxes[i]);

              for (i=0; i<NOBJS; i++) { 
	         if (WinObj[i].win != NULL && WinObj[i].winup != NULL) {
	            if (event.xexpose.window == *WinObj[i].win 
			&& WinObj[i].redraw != NULL && *(WinObj[i].winup))  {
			if (WinObj[i].sh == NULL) WinObj[i].redraw();
			else WinObj[i].redraw(WinObj[i].sh);
			}
		 }
	      }
	      if (event.xexpose.window == EBox) RedrawList(&elist);
	      if (event.xexpose.window == gsel.win) RedrawFwin(&gsel);
	      if (event.xexpose.window == dsel.win) RedrawFwin(&dsel);
           }
           break;

	   case MapNotify: {
	      if (event.xmap.window == expldat.win && 
		event.xmap.send_event == True) DoExpl();
           }
           break;

	   case EnterNotify: {
		if (!bcksvg.UpSVG) {
		   expldat.win = -1;
		   signal(SIGALRM,SIG_IGN);
		}
           }
           break;

	   case LeaveNotify: {
		if (!bcksvg.UpSVG) {
		   expldat.win = -1;
		   signal(SIGALRM,SIG_IGN);
		}
           }
           break;

           case ConfigureNotify: {

              if(DEBUG)fprintf(stderr,"ConfigureNotify\n");

              /* you want to increase or decrease the size of the window*/
              /* get the new width and height*/

              if (event.xconfigure.window == win) {

		   while(XCheckTypedWindowEvent(display, win, 
			ConfigureNotify,&event)) {
		   }

                   if (event.xconfigure.width == width &&
                       event.xconfigure.height == height) {
			if (has_opengl && *ifdogl) {
#ifdef DOGL
			    glXSwapBuffers(display, win);
#endif
			} else {
			    if ( !*fullgl && molback == molcur) {
				XCopyArea(display,molcur,win,gc,
					0,0,width,height,0,0);
			    } else {
				RedrawWin();
			    }
                        }
			break;
		   }

                   width  = event.xconfigure.width;
                   height = event.xconfigure.height;

                   /* now resize the Graphics window, this will generate an 
                      expose event*/

                   if (!CheckForConfig()) {
                      XEvent xev;
                      xwa.width = width;
                      xwa.height = height;
                      XResizeWindow(display, 
                                    win,
                                    width,
                                    height);

                   while (XCheckTypedWindowEvent(display, win, Expose, &xev)) {
                      XExposeEvent *exp = (XExposeEvent *) &xev;}

		   Aspect = (float) width / (float) height;
		   if (has_opengl && *ifdogl) Reshape(1);
		   else {
                      if (do3dx || *dospa) return;
                      else RedrawWin();
		   }

                   }
              }
           }
           break;

           case UnmapNotify:         break;

           default: break;		/* ignore unexpected events */

        }  /* end switch event type*/

    }/* end while */

    XFreeGC(display, gc);
    XCloseDisplay(display);
    *inct = 15;
    return;

  } /* end DenWindow */
  break;

  case MolWindow : 
  {


    if ( DowinMC ) {
       DirBox(winMC,1);    
       DowinMC = 0;
       ZoomEnable = False;
       ZoomSelection = False;
    }

    if (DoactMC) {
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
	actde(*inct,*incp,0); 
	DoactMC = 0;
	if (ntits > 1)  {
	   if (!MLTup)  initMLT();
	   else RedrawMLT();
 	}
	
    }

    done = 0;
    *inct = 0;
    *incp = 0;


    if (hold) {
       update_model = 0;
       while (1){
        XSync(display, False);
        if (XCheckMaskEvent(display,ButtonReleaseMask,&event))
          		{ hold = 0; goto XLOOP;}
	doclr();
#if defined(VMS) || defined(UNDERSC)
        mktrn(&holdt,&holdp);
	qupd();
#else
#ifdef CRAY
        MKTRN(&holdt,&holdp);
	QUPD();
#else
        mktrn_(&holdt,&holdp);
	qupd_();
#endif
#endif
       }
    } 
XLOOP:

    if (animptr.on) {
       int donext=0;

       while (1){
	int i;
	double vartmp;

        XSync(display, False);
	if (update_res == -1) update_model = 1;
	doclr();
/*        if (XCheckTypedWindowEvent(display,ANIMwin,Expose,&event)) {*/
	   if (ANIMup) RedrawANIM();
/*	}*/
        if (XCheckMaskEvent(display,ButtonPressMask,&event)) {
	   if (event.xbutton.window == win) {
		hold = 0; 
		XSendEvent(display, win, False, NoEventMask, &event);
		goto ALOOP;
	   } else if (event.xbutton.window == ANIMwin) {
		if (ANIMup) {
		   RedrawANIM();
		   i = Clickwin(butANIM,ANIMBN,
			event.xbutton.x, event.xbutton.y,1);
		   if (i>=0) {
			if (ButtonsANIM(i)) {
			   SwitchOffAnim(); 
			   goto ALOOP;
			} else {
			   donext = 1;
			}
		   }
		}
	   }
        }
	if (donext) {
	   i = 0;
	   animptr.frame = animptr.frame + animptr.vdirection;
	   if (animptr.frame >= animptr.nframe || 
	    animptr.frame <= -animptr.nframe) {
		animptr.vdirection = -1*animptr.vdirection;
		i = 1;
	   }
	   vartmp = animptr.varinit + 
		animptr.frame * animptr.varincr[animptr.vartype];
	   if (animptr.vartype == 0 && vartmp <= 0.0) {
		vartmp = *animptr.variable; 
		animptr.vdirection = -1*animptr.vdirection;
   	   }
	   if (animptr.vartype == 1 && (vartmp <= 0.0 || vartmp >= 180.0)) {
		vartmp = *animptr.variable;
		if (!i) animptr.vdirection = -1*animptr.vdirection;
	   }
	   *animptr.variable = vartmp;
	   AnimLinks(vartmp);
	   if (animptr.part) zmpart->ipart = animptr.part;
	   if (!animptr.ssdone) SSdone[istruct] = 0;
	   anim();
	}
	if (!ANIMNXT) donext = 0;
       }
     }
ALOOP:

    while (!done) {
  
	XFlush(display);
	if (XPending(display) == 0  && DoFreq ) {
		XSync(display,False); return;
	}
	if (aflag && !cflag && !dflag) {
	   if (! ((*fancy || *fullgl) && has_opengl) ) {
              XSetForeground(display, gc, colors[2]);
              for (i = 0; i <acnt-1; i++) {
		   XDrawLine(display,win,gc,
			xyzp->iyp[asel[i]-1],xyzp->ixp[asel[i]-1],
			xyzp->iyp[asel[i+1]-1],xyzp->ixp[asel[i+1]-1]);
              }
           }
        }

	if (DoSVGExpose) SvgExpose();
	DoSvgfile();
        XNextEvent(display, &event);
        switch (event.type) {

           case KeyPress:    {
              XKeyEvent *key_event = (XKeyEvent *) &event;
              char buf[10];  XComposeStatus status;  int stlen,istat;

              if(DEBUG)fprintf(stderr,"KeyPress\n");

              stlen = XLookupString(key_event,buf,1,&ks,&status);
	      /*if (!stlen) break;*/

/* the following statement is only there to stop the compiler
   from optimising away ks */

	      sprintf(stemp,"%d",(int) ks);

	      if (FselKey(key_event->window, ks, 
		event.xbutton.x, event.xbutton.y)) {
		return;
	      }

              for (i=0; i<NQBOX; i++) {
		if (key_event->window == qboxes[i].win && qboxes[i].active) {
		   if (KeyChk(&qboxes[i],buf[0],ks)) {
		       if (key_event->window == ATMwin && i == QATOM) {
				if (ATMselp <= *xyzp->iatoms || 
				    ChkLig(ATMselp) || ChkProt(ATMselp) ) {
	    			    update_sel = 1;
	    			    update_model = 0;
				    if (xyzp->iaton[ATMsel] == 2) 
					xyzp->iaton[ATMsel] = 1;
				    ATMsel = ATMselp - 1;
				    xyzp->iaton[ATMsel] = 2;
				    UpdateATM();
				    RedrawATM();
				    if (DCKLIGPROC) ogLigSurf();
				    else if (DCKPROTPROC == 1) ogIntSurf();
				    update_struct();
				} else {
				    if (DoCan(width/2, height/2,
					"Number greater than total number of atoms",0)) {
				    }
				}
			}
			if (!(key_event->window == fsel.win &&
				(i == QREADF || i == QSUBSTR))) {
				return;
			}

		   }
		}
	      }

              if (key_event->window == ZMEwin) {
		int isl;

		istat = 0; isl = 0;
		for (i=0; i<*zmptrp->nz; i++) {
			if (IANZbox[i].active) {
			   istat = KeyChk(&IANZbox[i],buf[0],ks);
			   isl = i;
			}
			if (BLbox[i].active) {
			   istat = KeyChk(&BLbox[i],buf[0],ks); 
			   isl = i;
			}
			if (ALPHbox[i].active) {
			   istat = KeyChk(&ALPHbox[i],buf[0],ks); 
			   isl = i;
			}
			if (BETbox[i].active) {
			   istat = KeyChk(&BETbox[i],buf[0],ks); 
			   isl = i;
			}
			for (j=0; j<4; j++) {
				if (IZbox[i*4+j].active) {
				   istat = KeyChk(&IZbox[i*4+j],buf[0],ks); 
			   	   isl = i;
				}
			}
		}
          	if (istat && !Selecting && !ZMEsel) {
		    Zmat2Copy();
		    if (!mapchk()) map_prop();
		    DeActZME(); GetQZME(); UpdateZME();
		    if (IsPhiPsi(isl)) {
			FindZRangeFromBox(isl);
	   		if (zmpart->ipart) {
			   zmpart->imx = *zmptrp->nz;
			   update_res = -1;
			   SSdone[istruct] = 0;
	   		}
		    } else FindZRangeFromBox(isl);
		    update_model = 1;
		    *Sinct = 530; return; 
		}
		if (EXPbox[0].active)
			if (KeyChk(&EXPbox[0],buf[0],ks)) 
				aaexp(EXPbox[0].str,strlen(EXPbox[0].str));
	      }

	      for (i=0; i<MXSHFILS; i++) {

                 if (key_event->window == shfiles[i].FILEwin) {
		    if (shfiles[i].FILEup) {
			if (ks == XK_Home) {
				ScrollP(&shfiles[i].FILElist,
					&shfiles[i].FILElist.scrbar,-1,0);
			} else if (ks == XK_End) {
				ScrollP(&shfiles[i].FILElist,
					&shfiles[i].FILElist.scrbar,-1,3);
			} else if (ks == XK_Page_Up) {
				ScrollP(&shfiles[i].FILElist,
					&shfiles[i].FILElist.scrbar,-1,2);
			} else if (ks == XK_Page_Down) {
				ScrollP(&shfiles[i].FILElist,
					&shfiles[i].FILElist.scrbar,-1,1);
			} else {
				ScrollP(&shfiles[i].FILElist,
					&shfiles[i].FILElist.scrbar,-1,4);
			}
		    }
	         }

		 if (key_event->window == shfiles[i].FILEwin) {
		   if (KeyChk(shfiles[i].qbox,buf[0],ks)) {
			if (shfiles[i].FILElist.sub == NULL) {
				PromptBox(shfiles[i].qbox);
			}
		   }
		 }
	      }

              if (key_event->window == win || key_event->window == winMC) {
		 update_model = 0;
                 if      (ks==XK_Left)
                   { *inct = -3; *incp = 1; }
                 else if (ks==XK_Right)
                   { *inct = -3; *incp = -1; }
                 else if (ks==XK_Up)
                   { *inct = -2; *incp = 1;}
                 else if (ks==XK_Down)
                   { *inct = -2; *incp = -1;}
                 else if (ks==XK_KP_7)
                   { *inct = -1; *incp = 1;}
                 else if (ks==XK_KP_9)
                   { *inct = -1; *incp = -1;}
                 else if (ks==XK_KP_1)
                   { *inct = 290; *incp = -1;}
                 else if (ks==XK_KP_3)
                   { *inct = 290; *incp = 1;}
                 else if (ks==XK_KP_4)
                   { *inct = 420; }
                 else if (ks==XK_KP_6)
                   { *inct = 430; }
                 else if (ks==XK_KP_8)
                   { *inct = 440;}
                 else if (ks==XK_KP_2)
                   { *inct = 450;}
                 else if (ks==XK_space)
                   { if (omaplck) omaplck = 0;
		     else {
			omaplck = 1;
			for (i=0; i<3; i++) 
			   rotptr->t[i] = xyzp->coo[omapCa*3+i];
			update_struct();
		     }
		   }
                 else if (buf[0]=='a' || buf[0]=='A')
		   {
			if (!gijsup) {
			   createauthor();gijsup = 1;
			} else {
			   XFreePixmap(display,gijs);
			   XDestroyWindow(display,winau);gijsup = 0;
			}
		   }
                 else if (buf[0]=='s')
                   { *inct = 75; DowinC = 1;DoactC = 1; }
                 else if (buf[0]=='f')
                   { update_model = 1; *inct = 100; }
                 else if (buf[0]=='n')
                   { update_model = 1; *inct = 110; }
                 else if (buf[0]=='l')
                   { *inct = 120; }
                 else if (buf[0]=='k')
                   { *inct = 130; }
                 else if (buf[0]=='b')
                   { *ball = 1; hold = 0;}
                 else if (buf[0]=='x')
                   { *inct = 610; }
                 else if (buf[0]=='m')
                   {update_model = 1;  
		     qboxstr(&qboxes[QMXYZ],NULL,1,0,-1,DEFQX,DEFQY,QBOXWIDE,
			QBOXHIGH, 0,"XYZ file ? ",NULL,0,0,151,0,dummyproc);
		   }
                 else if (buf[0]=='h')
                   {update_model = 1;  
		     qboxstr(&qboxes[QMXYZ],NULL,1,0,-1,DEFQX,DEFQY,QBOXWIDE,
			QBOXHIGH, 0,"XYZ file ? ",NULL,0,0,152,0,dummyproc);
		   }
                 else if (buf[0]=='u')
		   { OnTop(); }
                 else if (buf[0]=='c')
		   { *igtfil = 1;update_model = 1;  
		     DeActZME(); GetQZME(); UpdateZME(); 
		     *Sinct = 530; return; 
		   }
                 else if (buf[0]==' ')
                   { 
			*inct = 155;
		   }
                 else if (ks==XK_Escape) { 
		   if (DoDockCenter) {
			DoDockCenter = 0;
			DCKPROTPROC = 0;
			if (!DCKBYPASS) {
			   createDock();dockup=1;
			} else {
			   ogIntSurf();
			}
		   } else if (ZMEsel || ZMEmode) {
			if (ZMEup) {
			   ZMEsel = 0; ZMEmode = 0;
			   ZME_window_pos = *zmptrp->nz-ZME_window_high;
			   if (ZME_window_pos < 0) ZME_window_pos = 0;
			   sprintf(stemp,"Atom slection aborted !");
		   	   strcpy(ZMEerr,stemp);
			   RedrawStatus();
			   RedrawZME();
                 	   XUndefineCursor(display, win);
			   update_sel = 1;
			}
		   } else {
			if (ZMEup) {
#ifdef DOGL
			  if ((*fancy || *fullgl) && has_opengl) {
			      ogunsel();
			      dispsf();
			  }
#endif
			}
		   }
                   if (dflag) {
			dflag = 0;aflag = 0;
			Selecting = 0; ZMEsel = 0;
/*
			for ( i = 0; i < *xyzp->iatoms; i++ ) {
				if (xyzp->iaton[i] >= 2) xyzp->iaton[i] = 1;
			}
	    		update_sel = 1;
			XUndefineCursor(display,win);
			RedrawZME();
*/
			XUndefineCursor(display,win);
			if (*ialtyp == 1) {
                           for (i=0; i<*iscst; i++) xyzp->iaton[i] = 1;
                           for (i=*iscst; i<(*iscst)+(*nscnd); i++) 
				xyzp->iaton[i] = 2;
			} else {
                           for (i=0; i<*xyzp->iatoms; i++) xyzp->iaton[i] = 2;
			}
	    		update_sel = 1;
                        *isimpl = 4;
                        ApplSel(0);
		        update_model = 1;
                        return;
		     } else {
			if (update_casel)  exit_casel();
			if (*irtcel) {
		           update_model = 1;
			   i = *irtcel; *irtcel = 0;
			   ogmoll(0);
			   *irtcel = i;
			}
			DoFreq = 0;
		        update_model = 0;
			*inct = 153;
                        return;
		     }
		   }
                 else if (ks==XK_Tab) 
		   { if (!Selecting && !cflag && !dflag) {
			acnt = 0;
			if (doalign) {
			   cflag = 1;aflag = 6;anum = 6;
			} else {
			   cflag = 2;
			   aflag = 2;anum = 2;
			   if (event.xbutton.state & ShiftMask) 
				aflag = 4;anum = 4;
			}
		        XDefineCursor(display,win,AtomCursor);
		     }
		   }
                   if (((*fancy || *fullgl) && has_opengl) 
			&& key_event->window == win)
			{Key(buf[0]);}
                 return;
              }
              if (key_event->window == ZMEwin) {
		 update_model = 0;
                 if (ks==XK_Escape)
		   if (ZMEsel || ZMEmode) {
			if (ZMEup) {
			   ZMEsel = 0; ZMEmode = 0;
			   ZME_window_pos = *zmptrp->nz-ZME_window_high;
			   if (ZME_window_pos < 0) ZME_window_pos = 0;
			   sprintf(stemp,"Atom slection aborted !");
		   	   strcpy(ZMEerr,stemp);
			   RedrawStatus();
			   RedrawZME();
                 	   XUndefineCursor(display, win);
			   update_sel = 1;
#ifdef DOGL
			   dispsf();
#endif
			}
		   } else {
			if (ZMEup) {
#ifdef DOGL
			  if ((*fancy || *fullgl) && has_opengl) {
			      ogunsel();
			      dispsf();
			  }
#endif
			}
		   }
	      }
           }
           break;

           case ButtonPress: {
	      int doret = 1;

              if(DEBUG)fprintf(stderr,"ButtonPress\n");

	      if (!bcksvg.UpSVG) {
	         expldat.win = -1;
	         signal(SIGALRM,SIG_IGN);
	      }

	      update_model = 1;

              if(event.xbutton.window == win && !ZoomEnable && 
                (event.xbutton.button == 1 || event.xbutton.button == 2)) {
                 int curx = event.xbutton.x;
                 int cury = event.xbutton.y;

/* blag set: single atom selection */

                 if (bflag) {
                    XUndefineCursor(display,win);
                    bflag = 0;
                    *inct = bretval;
		    if (bretval == 320) {
			if (ScreenPDB(curx,cury)) {
			   int ires=-1;
			   ires = CurAmino + 1;
#if defined(VMS) || defined(UNDERSC)
			   actami(&ires,&ZERO,&ONE,&ZERO);
#else
#ifdef CRAY
			   ACTAMI(&ires,&ZERO,&ONE,&ZERO);
#else
			   actami_(&ires,&ZERO,&ONE,&ZERO);
#endif
#endif
			   *inct = 0;
			   rsold = RESUND;
#ifdef DOGL
			   ogres(ires,ONE,1);
#else
			   return;
#endif
			}
		    }
		    *incp = 1 + FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
					*xyzp->iatoms,curx,cury,MINDIFF);

		    if (bretval == 321) {
			*inct = 530;
			idum1 = DelAmino(xyzp->iresid[*incp-1]);
		    }

		    if (bretval == 563) {
		        j = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
			    *xyzp->iatoms,curx,cury,MINDIFF);
			if (j != -1) {
                           for (i=0; i<3; i++) {
				CNTDCK[i] = (float) xyzp->coo[j*3+i];
			   }
			}
			DoDockCenter = 1;
		    }

		    if (bretval == 322) {
			*inct = 530;
			InsertAmino = xyzp->iresid[*incp-1];
			if (SEQup) {
			   XMapRaised(display,SEQwin);
			   RedrawSEQ();
			} else {
			   InitSEQ(event.xbutton.x_root,
				event.xbutton.y_root);
			}
		    }

		    if (bretval == 561) {
			for ( i = 0; i < *xyzp->iatoms; i++ ) xyzp->iaton[i] = 1;
			xyzp->iaton[*incp-1] = 2;
	    		update_sel = 1;
		    }
		    if (bretval == 565) {
			int ir;

			ir = xyzp->iresid[*incp-1];
			for (i=0; i < *xyzp->iatoms; i++ ) {
			   if (xyzp->iresid[i] == ir) xyzp->iaton[i] = 2;
			}
	    		update_sel = 1;
		    }

		    if (bretval == 566) {

#if defined(VMS) || defined(UNDERSC)
			proxic(incp,backb,&ONE,&ZERO,&THRESH);
#else
#ifdef CRAY
			PROXIC(incp,backb,&ONE,&ZERO,&THRESH);
#else
			proxic_(incp,backb,&ONE,&ZERO,&THRESH);
#endif
#endif
			ressel();
	    		update_sel = 1;
		    }
		    return;
                 }

/* aflag set: select multiple atoms */

                 if (aflag && ! bflag && !(event.xbutton.state & ControlMask)) {
                    int ia,ib,floke,low,up;

		    up = *xyzp->iatoms;
		    low = 0;

		    if (cflag) {
			if (acnt == 0 || acnt == 2 || acnt == 4) {
			   low = 0; up = *iscst;
			} else {
			   low = *iscst; up = *xyzp->iatoms;
			}
		    }


		    ib = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,low,up,
				curx,cury,MINDIFF);

		    if (ib < 0) ib = -2;
                    floke = 1;

                    for (ia = 0; ia <acnt; ia++) {
			if (dflag) {
			   if (ia < *xyzp->mxnat) 
				if (jring[ia] == ib+1 ) floke = 0;
			} else {
                           if (asel[ia] == ib+1 ) floke = 0;
			}
		    }

/*
		    if (cflag) {
			if (acnt == 0 || acnt == 2 || acnt == 4) {
			   if (ib >= *iscst) floke = 0;
			} else {
			   if (ib < *iscst) floke = 0;
			}
		    }
*/

                    if (floke && ib >= 0) {

		       if (dflag) {
			  if (acnt < *xyzp->mxnat) jring[acnt] = ib+1;
		       } else {
			  asel[acnt] = ib+1;
		       }
			
		       if (aflag && (*fancy || *fullgl) && has_opengl) {
			  xyzp->iaton[ib] = 3;
		          update_model = 0;
	    		  update_sel = 1;
#ifdef DOGL
			  dispsf();
#endif
		       }

                       aflag--;
                       acnt++;

                       if (*ibell) XBell(display,0);

		       if (cflag) {
			xyzp->iaton[ib] = 3 + (acnt-1)/2;
	    		update_sel = 1;
#ifdef DOGL
			ogsel();
#endif
			if (aflag) return;
		       }

		       if (dflag) {
			xyzp->iaton[ib] = 3;
			sprintf(stemp,"%d Atoms to go",aflag);
			strcpy(ZMEerr,stemp);
			RedrawStatus();
	    		update_sel = 1;
			if (aflag) {
		           update_model = 0;
			   return;
			}
		       }
                    }

		    if (!cflag && !dflag) {
			if (! ((*fancy || *fullgl) && has_opengl) ) {
			   XSetForeground(display, gc, colors[2]);
			   for (i = 0; i <acnt-1; i++) {
				XDrawLine(display,win,gc,
				xyzp->iyp[asel[i]-1]  ,xyzp->ixp[asel[i]-1], 
				xyzp->iyp[asel[i+1]-1],xyzp->ixp[asel[i+1]-1]);
			   }
			}
		    }

                    if (!aflag) {

/* done multiple atom selecting, now parse selection */

	               update_model = 1;
                       XUndefineCursor(display,win);

		       if (cflag) {
			  for (i=0; i<*xyzp->iatoms; i++) xyzp->iaton[i] = 1;
	    		  update_sel = 1;
			  if (cflag == 1) {

/* align two molecules, 3 atoms of each molecule selected */

#if defined(VMS) || defined(UNDERSC)
				alnsel(asel);
#else
#ifdef CRAY
				ALNSEL(asel);
#else
				alnsel_(asel);
#endif
#endif
			  } else {
#if defined(VMS) || defined(UNDERSC)
				cllvec(asel,&anum,xyzp->coo);
#else
#ifdef CRAY
				CLLVEC(asel,&anum,xyzp->coo);
#else
				cllvec_(asel,&anum,xyzp->coo);
#endif
#endif
			  }
			  cflag = 0;
			  return;

		       } else if (dflag) {
/* reorder zmatrix */
			  dflag = 0; Selecting = 0; ZMEsel = 0;
			  for (i=0; i<*xyzp->iatoms; i++) xyzp->iaton[i] = 2;
	    		  update_sel = 1;
			  *isimpl = 4;
			  ApplSel(0);
			  return;

		       } else if (SelZME(asel)) {

/* add zmat line, parse new structure */

			  return;

		       } else {

/* calculate distance, angle, or dihedral */

#ifdef DOGL
			  if ((*fancy || *fullgl) && has_opengl) {
			      ogunsel();
			  }
#endif

			  if (eflag) {
			     if (asel[1] > asel[0]) {
				eflag = asel[0];
				asel[0] = asel[1];
				asel[1] = eflag;
			     }
			     eflag = 0;
			     aret = jcoupl[(asel[0]-1)*NAT->natoms + asel[1]-1];
			     anum = 6;
			  } else {
#if defined(VMS) || defined(UNDERSC)
			     tomold(&aret,asel,&anum);
#else
#ifdef CRAY
			     TOMOLD(&aret,asel,&anum);
#else
			     tomold_(&aret,asel,&anum);
#endif
#endif
			  }
			  MkDistWin(asel,anum,aret);
	                  update_model = 0;
		       }
                    }
                 }
		 else {
                 
		 int k;

		 if (!Selecting && !animptr.on) {
		    if (ScreenZME(event.xbutton.x,event.xbutton.y) 
			&& ZMEup && *zmptrp->ihaszm) {
			if (event.xbutton.button == 2) {
			     int iret; 

			     if (ZMEAA) {
				if (AmiCom(1,event.xbutton.x,event.xbutton.y)) 
					return;
			     } else {
	 			iret = GetFrag(1,event.xbutton.x,event.xbutton.y);
				if (iret != -1) return;
			     }
			}
	                update_model = 0;
			return;
		    }

		    if (ScreenPDB(event.xbutton.x,event.xbutton.y) && 
			!((event.xbutton.state & ShiftMask) || 
			  (event.xbutton.state & ControlMask)) && 
			event.xbutton.button == 2) {
			moving = 0; gmoving = 0;
			if (AmiCom(1,event.xbutton.x,event.xbutton.y)) {
				    while(XCheckTypedWindowEvent(display, win, 
					ButtonRelease,&event));
				    return;
			}
			while(XCheckTypedWindowEvent(display, win, 
				ButtonRelease,&event)) {
			}
	                update_model = 0;
			break;
			/*return;*/
		    }
		 }

		 if (!Selecting && !animptr.on) {
		    if (hlpsrf->itsrf) {
			if (has_opengl && (*fancy || *fullgl)) {
			   if (ChangeLevel(event.xbutton.button,
				event.xbutton.x,event.xbutton.y)) return;
			}
		    } else {
			if (FindEsp(event.xbutton.button,
				event.xbutton.x,event.xbutton.y)) return;
		    }
		 }

		if (event.xbutton.button == 1 && PHRMup && !ZMEup &&
			!((event.xbutton.state & ShiftMask) || 
			  (event.xbutton.state & ControlMask)) ) {
		    k = FindSel(NULL,pharm.iyp,pharm.ixp,0,pharm.nfeat,
			event.xbutton.x,event.xbutton.y,MINDIFF);
		    if (k != -1) {
			FeatSel = k;
			if (PHRMup) {
			   XMapRaised(display,PHRMwin);
			   RedrawPHRM();
			}
		    }
 		}

		if (event.xbutton.button == 1 && ATMup && !ZMEup &&
			!((event.xbutton.state & ShiftMask) || 
			  (event.xbutton.state & ControlMask)) ) {

		    k = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
			*xyzp->iatoms,curx,cury,MINDIFF);

		    if (k != -1) {
			if (xyzp->iaton[ATMsel] == 2) xyzp->iaton[ATMsel] = 1;
	    		update_sel = 1;
			ATMsel = k;
			ATMselp = ATMsel + 1;
			xyzp->iaton[ATMsel] = 2;
			PrtCoo(xyzp,&xyzp->coo[ATMsel*3],ATMsel);
			if (ATMup) {
			   UpdateATM();
			   XMapRaised(display,ATMwin);
			   RedrawATM();
			} else {
			   InitATM(event.xbutton.x_root,event.xbutton.y_root);
			   qdpptr->iqon = 2;
			   if (cbut[BLABEL].toggle) {
			      TogDown(&cbut[BLABEL]);
			      *Sinct = 180;
			   }
			}
	                update_model = 0;
			return;
		    }
		 }

		 if (*ball && !dflag) {
		    moving = 1;
		    startx = event.xbutton.x;
		    starty = event.xbutton.y;
		    btype = 0;
		    if (event.xbutton.state & ShiftMask) btype = 1;
		    if (event.xbutton.state & ControlMask) btype = 2;
		    if ((event.xbutton.state & ControlMask) 
			  && (event.xbutton.state & ShiftMask)) btype = 3;
		    if ((*fancy || *fullgl) && has_opengl) 
			  moused(event.xbutton.button,event.xbutton.state, 
					  event.xbutton.x, event.xbutton.y);
		    break;
		 } else {
		    rotat(event.xbutton.x,event.xbutton.y);
		    *inct = holdt; *incp = holdp; 
		    return;
		 }

                 }
              }
              else if(event.xbutton.window == win && (event.xbutton.button == 1
                  || event.xbutton.button == 2) && ZoomEnable ) {
        
		 moving = 0;
                 ZoomEnable = False;
                 ZoomSelection = True;
                 MotionCount = 0; 
         
                 XDefineCursor(display, win, ZoomCursor);
		 if (! (has_opengl && (*fancy || *fullgl)) ) {
                    XSetFunction(display, gc, GXxor);
                    XSetForeground(display, gc, colors[11]);
		 }

                 ZoomX1 = event.xbutton.x;
                 ZoomY1 = event.xbutton.y;
                 ZoomW = 1;
                 ZoomH = 1;

		 if (has_opengl && (*fancy || *fullgl)) {
#ifdef DOGL
		    rubber(1);
#endif
		 } else {
                    XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
		 }
         
              }

              if (event.xbutton.window == win && event.xbutton.button == 3)  {
	        update_model = 0;
		OnTop();
	      }

	    for (i=0; i<MXSHFILS; i++) {

              if (event.xbutton.window == shfiles[i].FILEwin && 
			event.xbutton.button == 5)  {
		int ihlp;

		*(shfiles[i].FILElist.scrbar.wpos) = 
			*(shfiles[i].FILElist.scrbar.wpos) + 1;

		ihlp = *(shfiles[i].FILElist.scrbar.wn) - 
			shfiles[i].FILElist.scrbar.wh;

		if (*(shfiles[i].FILElist.scrbar.wpos) > ihlp - 1) {
		   if (ihlp - 1 >= 0) 
			*(shfiles[i].FILElist.scrbar.wpos) = ihlp;
		}

		RedrawLBox(&shfiles[i].FILElist); 
		RedrawScroll(&shfiles[i].FILElist.scrbar);
	      }

              if (event.xbutton.window == shfiles[i].FILEwin && 
			event.xbutton.button == 4)  {

		*(shfiles[i].FILElist.scrbar.wpos) = 
			*(shfiles[i].FILElist.scrbar.wpos) - 1;
		if (*(shfiles[i].FILElist.scrbar.wpos) < 0) 
			*(shfiles[i].FILElist.scrbar.wpos) = 0;
		RedrawLBox(&shfiles[i].FILElist); 
		RedrawScroll(&shfiles[i].FILElist.scrbar);
	      }

	    }

              if (event.xbutton.window == win && event.xbutton.button == 4)  {
		if (event.xbutton.state & ShiftMask) {
			change_iso(1);
		} else {
			update_model = 0;
			if (DoDockCenter) {
			   DCKRadius = DCKRadius + 1.0;
			   if (DCKRadius < 1.) DCKRadius = 1.0;
			   if (DCKRadius*toangs > 8.0) DCKRadius = 8.0/toangs;
			   dispsf();
			} else {
			   *inct = 417; *incp = -5;
#if defined(VMS) || defined(UNDERSC)
			   mktrn(inct,incp);
			   qupd();
#else
#ifdef CRAY
 			   MKTRN(inct,incp);
			   QUPD();
#else
       			   mktrn_(inct,incp);
			   qupd_();
#endif
#endif
			}
		}
	      }

              if (event.xbutton.window == win && event.xbutton.button == 5)  {
		if (event.xbutton.state & ShiftMask) {
			change_iso(0);
		} else {
			update_model = 0;
			if (DoDockCenter) {
			   DCKRadius = DCKRadius - 1.0;
			   if (DCKRadius < 1.) DCKRadius = 1.0;
			   dispsf();
			} else {
			   *inct = 417; *incp = 5;
#if defined(VMS) || defined(UNDERSC)
			   mktrn(inct,incp);
		   	   qupd();
#else
#ifdef CRAY
 		   	   MKTRN(inct,incp);
		   	   QUPD();
#else
       		   	   mktrn_(inct,incp);
		   	   qupd_();
#endif
#endif
			}
		}
	      }

	      if (Scr_Wheel(event.xbutton.window, event.xbutton.button, 
		event.xbutton.x, event.xbutton.y)) {
		return;
	      }

              if (event.xbutton.window == QBox)  {
		for (j=0; j<NQBOX; j++) 
		    if (qboxes[j].win == QBox && qboxes[j].active) break;
		i = Clickwin(qboxclose,2,event.xbutton.x,event.xbutton.y,1);
		if (i == 0) {
		   if (KeyChk(&qboxes[j],'\012',(KeySym) 0)) return;
		} else if (i == 1) {
		   XDestroyWindow(display,QBox);
		   XSync(display, False);
		   qboxup = 0;
		}
	      }

	      if (event.xbutton.button  == 3) {
	         update_model = 0;
		 QBoxPaste(event.xbutton.window,qboxes,NQBOX);
	      }

              if (event.xbutton.window == winau) {
	         update_model = 0;
                 XFreePixmap(display,gijs);
                 XDestroyWindow(display,winau);gijsup = 0;}

              if (event.xbutton.window == wincnv) {
	         update_model = 0;
                 XDestroyWindow(display,wincnv);cnvup = 0;}

              if (event.xbutton.window == winsco) {
	         update_model = 0;
		 i = Clickwin(scbut,NSCBUTTS,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSCO(i)) return;
		 }
	      }

              if (event.xbutton.window == winpmf) {
	         update_model = 0;
		 i = Clickwin(pbut,NPBUTTS,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsPMF(i)) return;
		 }
	      }


              if (event.xbutton.window == winspec && specup) {
		 if (event.xbutton.button == 1 || event.xbutton.button == 2) {
			*inct = 510; *incp = 0;
			if (spect.current != -1) {
				*incp = 1 + spect.index[spect.current];
				frlist.select = spect.index[spect.current];
				if (DoFreq && FRQ->ihasi) RedrawList(&frlist);
			}
			if (*incp) {
			   if (FRQ->ihasi) {
				drwspec();
				return;
			   } else if (nmrptr->ihsnmr) {
				click_nmr_spec(spect.current);
			   }
			} else {
			   /* dummy inct */
			   *inct = 1000;
			}
		 }
	      }

              if (event.xbutton.window == wingeo && geoup) {
		 if (event.xbutton.button == 1 || event.xbutton.button == 2) {
			*inct = 117; *incp = 0;
			if (geo1ptr->ifmxav && geoFmax.current != -1) {
				*incp = 1 + geoFmax.index[geoFmax.current];
			}
			if (geo1ptr->ifrmav && geoFrms.current != -1) {
				*incp = 1 + geoFrms.index[geoFrms.current];
			}
			if (geo1ptr->idmxav && geoSmax.current != -1) {
				*incp = 1 + geoSmax.index[geoSmax.current];
			}
			if (geo1ptr->idrmav && geoSrms.current != -1) {
				*incp = 1 + geoSrms.index[geoSrms.current];
			}
			if (geo1ptr->ieav && geoE.current != -1) {
				*incp = 1 + geoE.index[geoE.current];
			}
			if (*incp) {
			   pnt->ipnt = *incp;
#if defined(VMS) || defined(UNDERSC)
			   drwgeo();
#else
#ifdef CRAY
			   DRWGEO();
#else
			   drwgeo_();
#endif
#endif
			   return;
			}
		 }
		 else if(event.xbutton.button == 3) {
	                update_model = 0;
			XDestroyWindow(display,wingeo);geoup = 0;
			TogUp(&cbut[BGEOM]);
		 }
	      }

              if (event.xbutton.window == winrama && ramaup) {
		 if (event.xbutton.button == 1 || event.xbutton.button == 2) {
		    int i,j,itmp,ftmp,rtmp;
		    i = FindSel(NULL,RamaStru.x,RamaStru.y,0,RamaStru.npts,
			event.xbutton.x,event.xbutton.y,GLTOL);
		    if (i >= 0 && i < calfptr->ncalf) {
			j = (calfptr->iamino[i])-1;
			if (j >= 0 && j < MXRES) {
			   sprintf(pchgtmp,"%s %d",
				AminoAcids[j],calfptr->irsnr[i]);
			   XSetBackground(display, gc, colors[15]);
			   XSetForeground(display, gc, colors[0]);
			   XDrawImageString(display, winrama, gc, 
				rwi-100, rhi-10, pchgtmp, strlen(pchgtmp));

			   itmp = *ivdwpl;
			   ftmp = *fancy;
			   *ivdwpl = 1;
			   *fancy = 1;
			   calfptr->reson[i] = 1;
			   rtmp = i+1;
			   if (*backb) actami_(&rtmp,&ZERO,&ONE,&ZERO);
#ifdef DOGL
			   ogres(i+1,1,0);
#endif
			   *ivdwpl = itmp;
			   *fancy = ftmp;
			   if (RamaStru.current != -1) {
				j = RamaStru.current;
				rtmp = j+1;
				if (*backb) {
					calfptr->reson[j] = 0;
					actami_(&rtmp,&ZERO,&ZERO,&ZERO);
				}
#ifdef DOGL
				ogres(j+1,1,0);
#endif
				if (calfptr->iamino[j] == 1) {
				   DrawTriangle(0.0,0.0,
				   RamaStru.x[j],RamaStru.y[j],
				   6,3,1,0);
				} else if (calfptr->iamino[j] == 15) {
				   DrawTriangle(0.0,0.0,
				   RamaStru.x[j],RamaStru.y[j],
				   6,4,1,0);
				} else {
				   DrawBox(0.0,0.0,
				   RamaStru.x[j],RamaStru.y[j],
				   6,3,1,0);
				}
			   }
			   dispsf();
			   if (calfptr->iamino[i] == 1) {
				DrawTriangle(0.0,0.0,
				RamaStru.x[i],RamaStru.y[i],
				6,0,0,0);
			   } else if (calfptr->iamino[i] == 15) {
				DrawTriangle(0.0,0.0,
				RamaStru.x[i],RamaStru.y[i],
				6,0,0,0);
			   } else {
				DrawBox(0.0,0.0,
				RamaStru.x[i],RamaStru.y[i],
				6,0,0,0);
			   }
			   RamaStru.current = i;
			}
#ifndef DOGL
			return;
#endif
		    }
		 }
	      }

              if (event.xbutton.window == FrBox) {
	       if (PressList(&frlist,event.xbutton.x, event.xbutton.y)) {
                 *inct = 510; *incp = frlist.select+1;
                 return;
	       }
	      }

              if (event.xbutton.window == FLXwin) {
	       if (PressList(&flxlist,event.xbutton.x, event.xbutton.y)) {
		   showresrot(flxlist.select);
	       }
	      }

              if (event.xbutton.window == QEDITwin) {
	       if (PressList(&shfiles[0].COMMlist,
			event.xbutton.x, event.xbutton.y)) {
		   qboxes[QEDIT].str = shfiles[0].COMMlist.list.list[
			shfiles[0].COMMlist.select];
		   PromptBox(&qboxes[QEDIT]);
	       }
	      }

              if (event.xbutton.window == ZMEwin) {
		if (PressZME(event.xbutton.button, 
			event.xbutton.x, event.xbutton.y)) return;
	      }

              if (event.xbutton.window == ATMwin ) {
		if (PressList(&fftlist,event.xbutton.x, event.xbutton.y)) {
		 if (fftlist.list.ilst == NULL) {
		    if (ffatnr[*fftyp] ==  NULL) {
			xyzp->ityp[ATMsel] = ffsgn[*fftyp]*(fftlist.select + 1);
		    } else {
			if (xyzp->ianz[ATMsel] == 
				ffatnr[*fftyp][fftlist.select]) {
			   xyzp->ityp[ATMsel] = ffsgn[*fftyp]*(fftlist.select + 1);
			} else {
		  	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
				"Wrong type for this atom",0)) fftlist.select = -1;
				fftlist.select = -1;
				RedrawList(&fftlist);
			   
			}
		    }
		 } else {
			if (xyzp->ianz[ATMsel] == 
				ffatnr[*fftyp][fftlist.select]) {
			   xyzp->ityp[ATMsel] =  ffsgn[*fftyp]*
				(fftlist.list.ilst[fftlist.select] + 1);
			} else {
		  	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
				"Wrong type for this atom",0)) fftlist.select = -1;
				fftlist.select = -1;
				RedrawList(&fftlist);
			   
			}
		 }
		 return;
		}
	      }

              if (event.xbutton.window == winpmf) {
	       if (PressList(&pmflistmn,event.xbutton.x, event.xbutton.y)) {
		 int pmfat1;

		 pmfat1 = ipmfmn[pmflistmn.select]-1;
                 if (xyzp->iaton[pmfat1] == 1) xyzp->iaton[pmfat1] = 3;
		 else xyzp->iaton[pmfat1] = 1;
	    	 update_sel = 1;
                 return;
	       }
	       if (PressList(&pmflistmx,event.xbutton.x, event.xbutton.y)) {
		 int pmfat2;

		 pmfat2 = ipmfmx[pmflistmx.select]-1;
                 if (xyzp->iaton[pmfat2] == 1) xyzp->iaton[pmfat2] = 4;
		 else xyzp->iaton[pmfat2] = 1;
	    	 update_sel = 1;
                 return;
	       }
	      }

              if (event.xbutton.window == MLTwin ) {

	       if (PressList(&mltlist,event.xbutton.x, event.xbutton.y)) {
		 Activate_Structure(&mltlist.select);
                 return;

	       }

	      }

              if (event.xbutton.window == SRCHwin) {
	       if (PressList(&srchlist,event.xbutton.x, event.xbutton.y)) {
		   PDBentry(pdbres[srchlist.select]);
	       }
	      }

              if (event.xbutton.window == fsel.win ) {

		if (FileSelectBP(&fsel) == 1) return;

              }

              if (event.xbutton.window == gsel.win ) {

		if (FileSelectBP(&gsel) == 1) {
		   if (gsel.Callwin == PHRMwin) {
			sprintf(qboxes[QPHRMT].str,"%s%s",gsel.lastdir,gfile);
			GetJsonU(qboxes[QPHRMT].str);
			if (PHRMup) {
			   ogfeatures();
			   dispsf();
			   XMapRaised(display,PHRMwin);
			   RedrawPHRM();
			}
		   }
		   if (gsel.Callwin == PSRCHwin) {
			if (PSRCHup) {
			   sprintf(qboxes[QSCSDF].str,"%s%s",gsel.lastdir,gfile);
			   XMapRaised(display,PSRCHwin);
			   RedrawPSRCH();
			}
		   }
		}

              }

              if (event.xbutton.window == dsel.win ) {

	        update_model = 0; doret = 0;
		if (FileSelectBP(&dsel) == 1) {
		   if (dsel.Callwin == windock) {
			if (dockup) {
			   sprintf(qboxes[QDCKFI].str,"%s%s",dsel.lastdir,gfile);
			   XMapRaised(display,windock);
			   strcpy(dcklig,qboxes[QDCKFI].str);
			   if (access(dcklig,F_OK) != 0) {
				DoCan(event.xbutton.x_root, 
					event.xbutton.y_root,
					"Non existent ambfor .xyz file !\n",0);
				break;
			   }
			   if (!IntSurfDone) {
				if (*ipdbon) {
				    ogIntSurf();
	   			}
			   }
			   Write_Mol("/tmp/tmpje.mol",ndocka,DCKxyz,0);
			   Cvt2SVG();
			   drwdock();
			   break;
			}
		   }
		}

              }

	      if (event.xbutton.window == DISTwin) {
	         update_model = 0;
		 i = Clickwin(clbut,NCLBUT,event.xbutton.x, event.xbutton.y,1);

		 if (i>=0) {
		     if (ButtonsDIST(i)) return;
		 }
	      }

	    for (i=0; i<MXSHFILS; i++) {
              if (event.xbutton.window == shfiles[i].FILEwin) {
	       if (PressList(&shfiles[i].FILElist,
			event.xbutton.x, event.xbutton.y)) {
	       }
	      }
	    }


	      if (event.xbutton.window == COLwin) {
		 i = Clickwin(colbut,NBUTSC,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			RButtonsCOL(i);
		 } else {
			i = Clickwin(AtmBut,TABBUTN,
				event.xbutton.x,event.xbutton.y,1);
			if (i>=0) {
			    ButtonsCOL(i);
			    return;
			}
		 }
	      }


	      if (event.xbutton.window == SEQwin) {
		 i = Clickwin(butSEQ,NBUTSEQ,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsSEQ(i)) return;
		 } else {
			i = ClickBox(&qboxes[QPHI],2,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QPHI].active = 0;
				qboxes[QPSI].active = 0;
				qboxes[QPHI+i].active = 1;
				RedrawSEQ();
			}
		 }
	      }

	      if (event.xbutton.window == TNKwin) {
	         update_model = 0;
		 i = Clickwin(butTNK,ntnkb,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsTNK(i)) return;
		 } else {
			i = ClickBox(&qboxes[QGRD],4,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QGRD].active = 0;
				qboxes[QARCH].active = 0;
				qboxes[QTNKJN].active = 0;
				qboxes[QMAXIT].active = 0;
				qboxes[QGRD+i].active = 1;
				RedrawTNK();
			}
		 }
	      }

	      if (event.xbutton.window == CPwin) {
		  if (ButtonsCP(event.xbutton.x, event.xbutton.y)) {
			*Sinct = 154; return;
		  }
	      }

	      if (event.xbutton.window == CTwin) {
		  int CTtmp;
		  CTtmp = ButtonsCT(event.xbutton.x, event.xbutton.y);
		  if (CTtmp) {
			*Sinct = 550; 
			if (CTtmp == 2) *Sincp = 17; 
			else *Sincp = 2;
			return;
		  }
	      }

	      if (event.xbutton.window == ISOwin) {
		 i = Clickwin(isobut,NBUTISO,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsISO(i)) {
				return;
			}
		 } else {
			i = ClickBox(&qboxes[QEDGE],5,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QEDGE].active = 0;
				qboxes[QVALC1].active = 0;
				qboxes[QVALC2].active = 0;
				qboxes[QVALC3].active = 0;
				qboxes[QNPTS].active = 0;
				qboxes[QEDGE+i].active = 1;
				RedrawISO();
			}
		 }
	      }

	      if (event.xbutton.window == ATMwin) {
		 i = Clickwin(butATM,NBUTATM,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsATM(i)) {
				return;
			}
                 } else {
                        i = ClickBox(&qboxes[QCHARG],3,
                                event.xbutton.x,event.xbutton.y);
                        if (i>=0) {
			    if ( i == 1 && (event.xbutton.state & ShiftMask) ) {
			        if (DoCan(event.xbutton.x_root,
					event.xbutton.y_root,selstr,0)) {
				}
				Selecting = 1; ZoomEnable = True;Select = True;
				SelRes = *qboxes[QRSD].iflt;
			    } else {
                                qboxes[QCHARG].active = 0;
                                qboxes[QRSD].active = 0;
                                qboxes[QATOM].active = 0;
                                qboxes[QCHARG+i].active = 1;
                                RedrawATM();
			    }
                        }
		 }
	      }

	      if (event.xbutton.window == winspec) {
		 i = Clickwin(spbut,nsbutts,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsSPC(i)) {
				*Sinct = 1000; return;
		 	}
                 } else {
                        i = ClickBox(&qboxes[QHW],nspqbox,
                                event.xbutton.x,event.xbutton.y);
                        if (i>=0) {
			    int j;
			    for (j=0; j<nspqbox; j++) qboxes[QHW+j].active = 0;
			    qboxes[QHW+i].active = 1;
			    drwspec();
                        }
		 }
	      }

	      if (event.xbutton.window == ONIwin) {
		 i = Clickwin(onbut,NBUTSO,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsONI(i)) {
				*Sinct = 1000; return;
			}
		 }
	      }

	      if (event.xbutton.window == windock && dockup) {
		 i = Clickwin(dockbut,NBUTDCK,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsDCK(i)) return;
		 } else {
			i = ClickBox(&qboxes[QDCKFI],3,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QDCKFI].active = 0;
				qboxes[QDCKSL].active = 0;
				qboxes[QDCKOUT].active = 0;
				qboxes[QDCKFI+i].active = 1;
				drwdock();
			}
		 }
	      }

	      if (event.xbutton.window == FLRwin) {
		 i = Clickwin(flrbut,NBUTSF,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsFLR(i)) {
				*Sinct = 1000; return;
			}
		 }
	      }

	      if (event.xbutton.window == SUBwin) {
	         update_model = 0;
		 i = Clickwin(sbut,NBUTSS,event.xbutton.x, event.xbutton.y,1);
                 if (i>=0) {
			if (ButtonsSUB(i)) {
				*Sinct = 151; *iixyz = 7+jmode; 
				if (jmode == 3) *iixyz = 12;
				return;
			}
		 } else {
			i = ClickBox(&qboxes[QGLIN1],7,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QGLIN1].active = 0;
				qboxes[QGLIN2].active = 0;
				qboxes[QGTITL].active = 0;
				qboxes[QJNAME].active = 0;
#ifndef DOQUEUE
				qboxes[QQNAME].active = 0;
				qboxes[QTIME].active = 0;
#endif
				qboxes[QENAME].active = 0;
				qboxes[QGLIN1+i].active = 1;
				RedrawSUB();
			}

		 }
	      }

	      if (event.xbutton.window == DPTwin) {
		    update_model = 0;
		    i = Clickwin(butdpt,2,event.xbutton.x, event.xbutton.y,1); 
		    if (i>=0) {
                        switch (i) {
			case 0:
			   XSync(display, False);
			   XDestroyWindow(display,DPTwin);
			   XSync(display, False);
			   DPTup = 0;
			   break;
			case 1: { LSSTRU List; 
			   List.list = ChainLength; List.nents = 10;
			   if (DoPopUp(DPTwin,butdpt[1].x+1,
				   butdpt[1].y,&List,&linmax,0) == -1) break;
			   linmax++;
			   }
			   break;
			}
		    }
		    if (ScrollPage(NULL,&dptscr[0],event.xbutton.x,
			event.xbutton.y)) {
		    }
	      }

	      if (event.xbutton.window == OMAPwin) {
		    update_model = 0;
		    i = Clickwin(butomap,4,event.xbutton.x, event.xbutton.y,1); 
		    ClickOMAP(i);
	      }

	      if (event.xbutton.window == ECOLwin) {
		    if (Clickwin(butecol,1,event.xbutton.x, event.xbutton.y,1) != -1) {
			SetPalCol(1);
			XSync(display, False);
			XDestroyWindow(display,ECOLwin);
			XSync(display, False);
			ECOLup = 0;
			return;
		    }
		    if (ScrollPage(NULL,&ecolscr[0],event.xbutton.x,event.xbutton.y)) {
			SetPalCol(0);
		    }
		    if (ScrollPage(NULL,&ecolscr[1],event.xbutton.x,event.xbutton.y)) {
			SetPalCol(0);
		    }
		    if (ScrollPage(NULL,&ecolscr[2],event.xbutton.x,event.xbutton.y)) {
			SetPalCol(0);
		    }
	      }

              if (event.xbutton.window == DELAYwin) {
	         update_model = 0;
		 i = Clickwin(delbut,3,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsDEL(i)) idum1 = 0;
		 }
	      }

              if (event.xbutton.window == MOVwin) {
		 i = Clickwin(movbut,5,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsMOV(i)) idum1 = 0;
		 } else {
			j = ClickBox(&qboxes[QMOV],1, 
				event.xbutton.x, event.xbutton.y);
			if (j>=0) {
			   qboxes[QMOV].active = 1;
			   RedrawMOV();
			}
		 }
	      }

              if (event.xbutton.window == SRFwin) {
	         update_model = 0;
		 i = Clickwin(srfbut,6,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSRF(i)) idum1 = 0;
		 }
	      }

              if (event.xbutton.window == MLTwin) {
	         update_model = 0;
		 i = Clickwin(mltbut,Nmltb,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsMLT(i)) idum1 = 0;
		 } else {
			i = ClickBox(&qboxes[QRESF],4,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QRESF].active = 0;
				qboxes[QQUERY].active = 0;
				qboxes[QNRES].active = 0;
				qboxes[QSDFO].active = 0;
				qboxes[QRESF+i].active = 1;
				RedrawMLT();
			}
		 }
	      }

              if (event.xbutton.window == PHRMwin) {
	         update_model = 0;
		 i = Clickwin(PHRMbut,PHRMBUT,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsPHRM(i)) idum1 = 0;
		 } else {
			if (PressList(&PHRMlist,
				event.xbutton.x, event.xbutton.y)) {

			   UpdPHRM();

			} else {
			   i = ClickBox(&qboxes[QPHRMT],2,
				event.xbutton.x,event.xbutton.y);
                 	   if (i>=0) {
				qboxes[QPHRMT].active = 0;
				qboxes[QPHRMR].active = 0;
				qboxes[QPHRMT+i].active = 1;
				RedrawPHRM();
			   }
			}
		 }
	      }

              if (event.xbutton.window == PSRCHwin) {
	         update_model = 0;
		 i = Clickwin(PSRCHbut,PSRCHBUT,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsPSRCH(i)) idum1 = 0;
		 } else {
			i = ClickBox(&qboxes[QSCSDF],2,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QSCSDF].active = 0;
				qboxes[QCRIND].active = 0;
				qboxes[QSCSDF+i].active = 1;
				RedrawPSRCH();
			}
		 }
	      }

              if (event.xbutton.window == QSARwin) {
	         update_model = 0;
		 i = Clickwin(QSARbut,QSARBUT,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsQSAR(i)) idum1 = 0;
		 } else {
			   i = ClickBox(&qboxes[QQSAR],8,
				event.xbutton.x,event.xbutton.y);
                 	   if (i>=0) {
				qboxes[QQSAR].active = 0;
				qboxes[QQSARO].active = 0;
				qboxes[QQSARB].active = 0;
				qboxes[QQSARP].active = 0;
				qboxes[QQSARMN].active = 0;
				qboxes[QQSARMX].active = 0;
				qboxes[QQSARVW].active = 0;
				qboxes[QQSAREL].active = 0;
				if (QSAR.cut || (!QSAR.cut && i <= 3)) {
				   qboxes[QQSAR+i].active = 1;
				}
				RedrawQSAR();
			   }
		 }
	      }

	    for (j=0; j<MXSHFILS; j++) {
              if (event.xbutton.window == shfiles[j].FILEwin) {
	         update_model = 0;
		 i = Clickwin(shfiles[j].FILEbut,FILEBUT,
			event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsFILE(i,&shfiles[j])) idum1 = 0;
		 }
	      }
	   }

              if (event.xbutton.window == QEDITwin) {
	         update_model = 0;
		 i = Clickwin(QEDITbut,QEDITBUT,
			event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsQEDIT(i)) idum1 = 0;
		 } else {
			   i = ClickBox(&qboxes[QEDIT],1,
				event.xbutton.x,event.xbutton.y);
                 	   if (i>=0) {
				qboxes[QEDIT].active = 1;
				RedrawQEDIT(&shfiles[0]);
			   }
		 }
	      }

              if (event.xbutton.window == FLXwin) {
	         update_model = 0;
		 i = Clickwin(flxbut,9,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsFLX(i)) idum1 = 0;
		 }
	      }

              if (event.xbutton.window == CHGwin) {
	         update_model = 0;
		 i = Clickwin(chgbut,3,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsCHG(i)) return;
		 } else {
                        ClickBox(&qboxes[QCHRG2],1,
                                event.xbutton.x,event.xbutton.y);
		 }
	      }

              if (event.xbutton.window == STRwin) {
	         update_model = 0;
		 i = Clickwin(strbut,5,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSTR(i)) return;
		 } else {
			if (PressList(&strlist,
				event.xbutton.x, event.xbutton.y)) {

			    if (istruct > -1) SaveActiveStruct();

			    uping = 0; 
/*
			    bcksvg.UpSVG = 0; bcksvg.ReadSVG = 0;
			    bcksvg.CurSVG = 0;
*/

			    if (strlist.select < nstruct) {
				istruct = strlist.select;
				NewActiveStruct();

				/*DebugStructure();*/

  				update_sel = 1;
				doclr();
				if (NMols[istruct] == -1) update_model = 1;
				update_struct();
				if (ntits > 1) {
				   initMLT();
				} else {
				   if (MLTup) {
		    			XDestroyWindow(display,MLTwin);
					MLTup = 0;
				   }
				}
			    }
			}
			if (PressList(&str2list,
				event.xbutton.x, event.xbutton.y)) {

			    if (str2list.select < nstruct) {
				sstruct = str2list.select;
			    }
			}
		 }
	      }

              if (event.xbutton.window == STRCwin) {
	         update_model = 0;
		 i = Clickwin(strcbut,STRCBN,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSTRC(i)) return;
		 } else {
			if (PressList(&strclist,
				event.xbutton.x, event.xbutton.y)) {

				dispsf();
			}
		 }
	      }

              if (event.xbutton.window == SELHwin) {
	         update_model = 0;
		 i = Clickwin(selhbut,SELHBN,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSELH(i)) return;
		 }
	      }

              if (event.xbutton.window == SRCHwin) {
	         update_model = 0;
		 i = Clickwin(butSRCH,SRCHBN,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsSRCH(i)) return;
		 }
	      }

              if (event.xbutton.window == PARwin) {
	         update_model = 0;
		 i = Clickwin(parbut,3,event.xbutton.x, event.xbutton.y,1);
		 if (i>=0) {
			if (ButtonsPAR(i)) return;
		 } else {
			i = ClickBox(&qboxes[QHBMIN],4,
				event.xbutton.x,event.xbutton.y);
                 	if (i>=0) {
				qboxes[QHBMIN].active = 0;
				qboxes[QHBMAX].active = 0;
				qboxes[QHAMIN].active = 0;
				qboxes[QHAMAX].active = 0;
				qboxes[QHBMIN+i].active = 1;
				RedrawPAR();
			}
		 }
	      }

              if (event.xbutton.window == winMC &&  !ZoomEnable && 
		  !ZoomSelection && !animptr.on) {

                 i=Clickwin(cbut,NBUTTS2,event.xbutton.x, event.xbutton.y,1);

                 if (i>=0) {
                 switch (i) {

                 case BFIRST: *inct = 100; break;
                 case BPREV:  *inct = 109; break;
                 case BNEXT:  *inct = 110; break;
                 case BMOVIE: *inct = 115; DoFreq = 1; break;
                 case BHOUR:  update_model = 0; InitDelay(); break;
                 case BMOLF:  
				if (ntits > 1)  {
				   if (!MLTup)  initMLT();
				   else RedrawMLT();
 				}
				break;
                 case BSOLID: 
			      update_sel = 1;
			      if (!TogBut(&cbut[BSOLID])){
				LSSTRU List;
				List.list = vdwstr ; 
				if (has_opengl) {
				   List.nents = 3;
				} else {
				   List.nents = 2;
				}
				if (DoPopUp(winMC,
				    cbut[BSOLID].x+1,cbut[BSOLID].y+BUTTH,
					&List,ivdwpl,0) == -1) {
				   TogBut(&cbut[BSOLID]);
				   break;
				} else {
#ifdef DOGL
				   ogsel();
				   dispsf();
#endif
				}
				*incp = 0;
				if (has_opengl) {
				   int ndmtmp;
				   *ifogl = 1;
				   *fancy = 1;
				   ndmtmp = monptr->ndm;
				   if (*fancy || *fullgl) {
#if defined(VMS) || defined(UNDERSC)
					ogmon();
#else
#ifdef CRAY
					OGMON();
#else
					ogmon_();
#endif
#endif
#ifdef DOGL
					ogbox();
#endif
				   }
/*
 clrmon clears created connections, and sets ndm zero
 it DOES NOT clear the monitor array
*/

#if defined(VMS) || defined(UNDERSC)
					clrmon();
#else
#ifdef CRAY
					CLRMON();
#else
					clrmon_();
#endif
#endif
				   monptr->ndm = ndmtmp;
				   ResetRes();
				}
			      } else {
				*incp = 1;
				*ivdwpl = 0;
				if (has_opengl) {
				   if (*fullgl) {
					*ifogl = 1;
				   } else {
					*ifogl = 0;
				   }
				} else {
				   *ifogl = 0;
				}
				*fancy = 0;
				if (has_opengl) {
				   if (*fullgl) {
#if defined(VMS) || defined(UNDERSC)
				      ogmon();
#else
#ifdef CRAY
				      OGMON();
#else
				      ogmon_();
#endif
#endif
#ifdef DOGL
				      ogbox();
#endif
				   } else {
/*
 domcon creates connections for ifogl!=1 and calls ogmon
*/

#if defined(VMS) || defined(UNDERSC)
				      domcon(&ONE,&ONE);
#else
#ifdef CRAY
				      DOMCON(&ONE,&ONE);
#else
				      domcon_(&ONE,&ONE);
#endif
#endif
				   }
				   ResetRes();
				}
			      }
			      *inct = 140;
                              break;
                 case BZOOMIN:   hold = 1; holdt = 290; holdp = -1;
				 *inct = 290;*incp = -1; break;
                 case BZOOMOUT:  hold = 1; holdt = 290; holdp = 1;
				 *inct = 290;*incp = 1; break;
                 case BPOSTT: {
				int idums;
				LSSTRU List;
				update_model = 0;
				List.list = postopt; List.nents = 2;
				if (DoPopUp(winMC,
					cbut[BPOSTT].x+1,cbut[BPOSTT].y+BUTTH,
					&List,icolps,0) == -1) break;
		/* check for dummies */
				idums = 0;
				for (i=0; i<*xyzp->iatoms; i++) 
				   if (xyzp->ianz[i] == 99)  idums = 1;
				if (idums) {
				   List.list = dumopt; List.nents = 2;
				   if (DoPopUp(winMC,
					cbut[BPOSTT].x+1,cbut[BPOSTT].y+BUTTH,
					&List,idelx,0) == -1) break;
				}
				qboxstr(&qboxes[QPOSTT],NULL,1,0,-1,DEFQX,DEFQY,
					QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
					0,0,150,0,dummyproc);
				break;}

                 case BDENMOD:  *inct = 75; DirBox(winMC,0);
                                DowinC =1; DoactC = 1;
				denmode = 1;
				*shade  = 0;
				*ifdogl = 0;
				*ivdwpl = 0;
#ifdef DOGL
				TogUp(&dbut[BOGL]);
#endif
				cursrfcol[0][0] = 0.0 ;
				cursrfcol[0][1] = 0.0 ;
				cursrfcol[0][2] = 1.0 ;
		                empty_model(istruct,1);
				if (fsel.qbrfile) {
				   TogUp(&cbut[BREADF]);
				   fsel.qbrfile = 0;
				   XUnmapWindow(display,fsel.win);
				}
				if (ZMEup) UnMapZME();
				if (frfor && FRup) {
				   TogUp(&cbut[BFORC]);
				   XDestroyWindow(display,FrBox);
				   DoFreq = 0;
				   FRup = 0;
				   NMRup = 0;
				}
				if (frfor && specup) {
				   XDestroyWindow(display,winspec);
				   specup = 0;
				}
				if (distup) {
				   distup = 0;
				   XUnmapWindow(display,DISTwin);
				}
		 		if (STRCup) {
				    XDestroyWindow(display,STRCwin);
				    STRCup = 0;
				}
		 		if (OMAPup) {
				    XDestroyWindow(display,OMAPwin);
				    OMAPup = 0;
				    omapr = 0;
#ifdef DOGL
				    deletebox();
#endif
				}
				gl2DInit();
				break;

                 case BQUITT: 
				update_model = 0;
				if (!DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
					" Are you sure to quit?  ",1)) {
				   FreeAll(1);
#ifdef DOGL
#ifdef GL_ARB_shader_objects
				   if (has_shader) del_shader();
#endif
#ifdef GL_COLOR_ATTACHMENT0_EXT
				   if (has_fbo) del_fbo(&fbo);
#endif
#endif
				   XFreeGC(display, gc);
				   XCloseDisplay(display);
				   exit(0);
				   *inct = 15;
				}
				break;

                 case BSURF: {
				int itmp;
				LSSTRU List;
				if (ISOup) break;
#ifdef MPFIT
				List.list = pots; List.nents = 21;
#else
				List.list = pots; List.nents = 20;
#endif
				if (DoPopUp(winMC,
				   cbut[BSURF].x+1,cbut[BSURF].y-60,
				   &List,&itmp,0) == -1) break;
				RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
				if (itmp == 7) {
				   if (DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
					"This will take a while",1)) {
					break;
				   }
				}
				if (itmp == 0 || itmp == 1 || itmp == 7 || itmp == 8) {
				   List.list = surftyp; List.nents = 2;
		   		   if (itmp == 1) List.nents = 3;
				   if (DoPopUp(winMC,
					cbut[BSURF].x+1,cbut[BSURF].y+BUTTH,
					&List,&surface->istyp,0) == -1) break;
				   if (surface->istyp == 1) {
                             		if (itmp == 0 || itmp == 1) {
						surface->nvalc = 1;
					}
                             		if (itmp == 7 || itmp == 8) {
						surface->nvalc = 3;
					}
					if (!ISOup) {
					   InitISO(event.xbutton.x_root,
						event.xbutton.y_root);
					   ISOt = 570+itmp;
                             		   if (itmp == 0 || itmp ==1) {
						 ActBut(&isobut[0],0);
					   }
					   break;
					} else {
                             		   if (itmp == 0 || itmp ==1) {
						isobut[0].str = 
						   ChainLength[surface->nvalc];
						ActBut(&isobut[0],0);
						RedrawISO();
					   }
					}
				   }
		   		   if (surface->istyp == 2) {
				   	   int kcoo,kcooh;
#if defined(VMS) || defined(UNDERSC)
					   chkcoo(&kcoo,&kcooh);
#else
#ifdef CRAY
					   CHKCOO(&kcoo,&kcooh);
#else
					   chkcoo_(&kcoo,&kcooh);
#endif
#endif
					   *pol  =  0.085;
					   *pol2 = -0.07;
					   *ipsa = 1;

					   if (kcooh) {
#if defined (_WIN32) || defined(_WIN64)
			   		   if (DoCan(XX,YY,
#else
			   		   if (DoCan(event.xbutton.x_root,
						   	event.xbutton.y_root,
#endif
				"Molecule contains -COOH group !\nThis should be deprotonated",0)) {}
					   }
		   		   }
				   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
				}
				if (itmp == 3) {
				    double tsa,psa;

#if defined(VMS) || defined(UNDERSC)
				    tpsa();
#else
#ifdef CRAY
				    TPSA();
#else
				    tpsa_();
#endif
#endif
				    doret = 0;
				    break;
				}
				if (itmp == 4) {
				   qboxstr(&qboxes[QSRFW],NULL,1,0,-1,
				    DEFQX,DEFQY,QBOXWIDE,QBOXHIGH,0,
				    "Surface Filename ? ",NULL,0,0,
				    574,0,dummyproc);
				    break;
				}
				if (itmp == 5) {
				   qboxstr(&qboxes[QSRFW],NULL,1,0,-1,
				    DEFQX,DEFQY,QBOXWIDE,QBOXHIGH,0,
				    "Surface Filename ? ",NULL,0,0,
				    575,0,dummyproc);
				    break;
				}
				if (itmp == 11) {
				   List.list = eems; List.nents = 4;
				   if (DoPopUp(winMC,
					cbut[BSURF].x+50,
					cbut[BSURF].y+11*LINEHIGH,
					&List,&ieemopt,0) == -1) break;
				   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
				   inichg(1);
				   break;
				}
				if (itmp == 12) {
#if defined(VMS) || defined(UNDERSC)
				   clqgas(&calfptr->ishoh);
#else
#ifdef CRAY
				   CLQGAS(&calfptr->ishoh);
#else
				   clqgas_(&calfptr->ishoh);
#endif
#endif
				   break;
				}
				if (itmp == 14) {
				    List.list = srfopt; List.nents = 2; int iii;
				    if (DoPopUp(winMC,cbut[BSURF].x-8,
					cbut[BSURF].y+14*LINEHIGH,&List,&iii,0) == -1) break;
				    if (iii) {
					molsrf(iii,0,1);
				    } else {
					if (DoPopUp(winMC,
					      cbut[BSURF].x-8,cbut[BSURF].y+BUTTH,
					      NULL,&iii,0) == -1) break;
					molsrf(iii,0,0);
				    }
				    break;
				}
				if (itmp == 15) {
				    if (omap()) break;
				    break;
				}

				if (itmp == 16) {
				    OpenPHRME();
				    break;
				}

				if (itmp == 17) {
				   if (OMAPup) DeleteOMAP();
				   qboxstr(&qboxes[QSRFW],NULL,1,0,-1,
					DEFQX,DEFQY,QBOXWIDE,QBOXHIGH,0,
					"GRID kont Filename ? ",NULL,0,0,
					586,0,dummyproc);
				    break;
				}
				if (itmp == 18) {
			   	   createRama();ramaup=1;
				}
				if (itmp == 19) {
				   MOLxyz.coo = NULL;
				   initQSAR();
				   doret = 0;
				}
#ifdef DOGL
				*incp = 0;
				if (itmp == 6) {
#if defined(VMS) || defined(UNDERSC)
				   srfclr();
#else

#ifdef CRAY
				   SRFCLR();
#else
				   srfclr_();
#endif

#endif
				   dispsf();
				}
#endif
				if (itmp == 13) {
				   if (qdpptr->ihsdp) {
					if (qdpptr->idipon) {
					   qdpptr->idipon = 0;
					} else {
					   qdpptr->idipon = 1;
#if defined(VMS) || defined(UNDERSC)
					   putxyz();
#else

#ifdef CRAY
					   PUTXYZ();
#else
					   putxyz_();
#endif

#endif
					}
				   } else {
#if defined(VMS) || defined(UNDERSC)
					calelt();
#else

#ifdef CRAY
					CALELT();
#else
					calelt_();
#endif

#endif
				   	if (qdpptr->ihsdp) qdpptr->idipon = 1;
				   }
#ifdef DOGL
				   if (qdpptr->idipon) ogdipole();
#endif
				   if (qdpptr->idipon) 
#if defined(VMS) || defined(UNDERSC)
					   prtdip();
#else

#ifdef CRAY
					   PRTDIP();
#else
					   prtdip_();
#endif

#endif
				   update_struct();
				}
#ifdef MPFIT
				if (itmp == 20) {
				    List.nents = 2;
				    if (DoPopUp(winMC,
					cbut[BSURF].x+1,cbut[BSURF].y+BUTTH,
					&List,incp,0) == -1) *incp = 0;
				}
#endif
				*inct = 570+itmp;
			      break;}

                 case BHYD: {
				   if (!cbut[BHYD].toggle) {
					TogUp(&cbut[BHYD]);
					*inct = 620;
				   } else {
					int itmp;
					LSSTRU List;
					List.list = hyds; List.nents = 5;
					if (DoPopUp(winMC,
					     cbut[BHYD].x+1,cbut[BHYD].y+BUTTH,
					     &List,&itmp,0) == -1) break;
					if (itmp != 2 && itmp != 3 && 
					    itmp != 4) TogDown(&cbut[BHYD]);

					if (itmp == 3) InitPar();
					else if (itmp == 4) {
					   if (!SELHup) iniselh();
					   doret = 0;
					}
					else *inct = 621+itmp;
				   }
			      break;}

                 case BVRML: {
				LSSTRU List;
				List.list = vrmlopt; List.nents = 4;
				if (DoPopUp(winMC,
					cbut[BVRML].x+1,cbut[BVRML].y+BUTTH,
					&List,ivtwo,0) == -1) break;
				update_model = 0;
				if (*ivtwo == 3 || 
				   (*ivtwo == 2 && *ipdbon && *backb)) {
				   *inct = 116;
				} else {
				   qboxstr(&qboxes[QVRML],NULL,1,0,-1,DEFQX,
					DEFQY, QBOXWIDE,QBOXHIGH,0,
					"VRML Filename ? ",NULL,0,0,
					589,0,dummyproc);
				}
			      }
			      break;

                 case BMOV: { int iret = -1;
			      strcpy(stemp,"which avconv > /dev/null 2>&1");
			      iret = system(stemp);
			      if (iret == 0) {
			         if (!Movup) InitMovie(event.xbutton.x_root,
						    event.xbutton.y_root);
			      } else {
				if (DoCan(event.xbutton.x_root, 
					event.xbutton.y_root,
				"The movie functionality depends on package avconv\nOn linux to install:\nsudo apt-get install libav-tools",0)) {}
			      }
			      }
			      break;
                 case BALIGN: {
				LSSTRU List; int ial;
				List.list = alnopt; List.nents = 3;
				if (DoPopUp(winMC,
					cbut[BALIGN].x+1,cbut[BALIGN].y+BUTTH,
					&List,&ial,0) == -1) break;
				RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
			if (ial == 0) {
				if (!DoCan(event.xbutton.x_root,
					event.xbutton.y_root,ogXYZStr,1)) {
				 qboxstr(&qboxes[QMXYZ],NULL,1,0,-1,DEFQX,DEFQY,
				   QBOXWIDE,QBOXHIGH, 0,"XYZ file ? ",NULL,0,0,
				   152,0,dummyproc);
				}
			} else if (ial == 1) {
			    LSSTRU List; int ibl;
			    List.list = dckopt; List.nents = 2;
			    if (DoPopUp(winMC,
				cbut[BALIGN].x+1,cbut[BALIGN].y+BUTTH,
				&List,&ibl,0) == -1) break;
			    if (ibl == 0) {
				*iocnt = 0;
				if (!DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
	"To you want to overlay the centers of the two molecules ? \n\
Click Cancel if you want to keep the original coordinates",1)) {
				   *iocnt = 1;
				}
				if (!DoCan(event.xbutton.x_root,
					event.xbutton.y_root,ogOVRLStr,1)) {
				 qboxstr(&qboxes[QMXYZ],NULL,1,0,-1,DEFQX,DEFQY,
				   QBOXWIDE,QBOXHIGH, 0,"PDB file ? ",NULL,0,0,
				   1520,0,dummyproc);
				 }
			    } else {
				if (!DoCan(event.xbutton.x_root,
					event.xbutton.y_root,ogLigStr,1)) {
				   *iocnt = 0;
				   bflag = 1; doret = 1; bretval = 562;
			           XDefineCursor(display,win,AtomCursor);
				 }
			    }
			} else {
				doret = 1;
				if (!DoCan(event.xbutton.x_root, 
					   event.xbutton.y_root,
					   ogDockStr,1)) {
			           XDefineCursor(display,win,AtomCursor);
				   bflag = 1; bretval = 563;
      
				}

			      	break;
			}
				 doalign = 1;
			      }
			      break;

                 case BORIG: {bflag = 1; doret = 0; bretval = 560;
			      strcpy(molwstr,"Click on atom to set Origin !");
			      StatusStr(0,1);
			      XDefineCursor(display,win,AtomCursor);
			      break;}

                 case BCELL: { int icell; int iwcell; LSSTRU List;
				List.list = cellopts; List.nents = ncell;
				if (DoPopUp(winMC,
					cbut[BCELL].x-8,cbut[BCELL].y-BUTTH,
					&List,&icell,0) == -1) break;
				RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
                                if (! cell->ichx) {
#if defined(VMS) || defined(UNDERSC)
					mkcell(xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
#else
#ifdef CRAY
					MKCELL(xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
#else
					mkcell_(xyzp->coo,xyzp->ianz,xyzp->iatclr,xyzp->iconn,
#endif
#endif
				   &cell->natc,&cell->icent,&cell->inorm,&cell->nspg,
				   &cell->nopr,cell->ir,cell->it,
				   &cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
				   &cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
				   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
				   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);
					cell->ichx = 1;
				}
				*incp = icell + 1;
				if (icell == 19) {
				   List.list = cellwopts; List.nents = nwcell;
				   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
				   XFlush(display); XSync(display,False);
				   if (DoPopUp(winMC,
					cbut[BCELL].x-8,cbut[BCELL].y+7*BUTTH,
					&List,&iwcell,0) == -1) break;
				   *incp = 20 + iwcell;
				}
                                *inct = 550;
		 		TogUp(&cbut[BHYD]);
				if (icell == 13) {
				   if (DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
	" - Use the standard rotation, translation and zoom in/out.\n\
 - Use the Esc to switch between rotation of part or the whole structure",1)) {
					*inct = 0;
				   } else {
					doalign = 0;
				   }
				}
				if (icell == 14) {
				   CreateCellPar();
				   doret = 0;
				   *inct = 0;
				}
				if (icell == 18) {
				   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
				   List.list = xtinkopts; List.nents = 2;
				   if (DoPopUp(winMC,
					cbut[BCELL].x-8,cbut[BCELL].y+BUTTH,
					&List,iqopt,0) == -1) break;
				}
				if (icell == 15 || icell == 16) {
				   InitCellDelTrans(0);
				   *incp = 2;
				   if (icell == 15) InitCellDelTrans(1);
				   else InitCellDelTrans(0);
				}
			   }
			   break;

                 case BFORC:  if (pdb) {
				 if (qbres) {
				    TogUp(&cbut[BFORC]);
				    qbres = 0;
				    XUnmapWindow(display,RESwin);
				 } else {
				    XMapWindow(display,RESwin); qbres = 1;
				    TogDown(&cbut[BFORC]);
		                    qboxstr(&qboxes[QRESI],&RESwin,1,0,-1,DEFQX,DEFQY,
				    QBOXWIDE,QBOXHIGH,0,"Display residue(s) ? ",
				    NULL,0,0,460,-1,dummyproc);
				 }
				update_model = 0;
		              } else { 
				update_model = 0;
				if (frfor) {
				   if (FRup) {
                                           XDestroyWindow(display,FrBox);
					   if (specup) {
					      XDestroyWindow(display,winspec);
					      specup = 0;					
					   }
					   *inct = 520;
					   DoFreq = 0;
					   FRup = 0;
				           TogUp(&cbut[BFORC]);
				   } else {
					   if (FRQ->nfreq) createfr(1);
					   createspec(1);
					   DoFreq = 1;
					   if (FRQ->nfreq) FRup = 1;
				           TogDown(&cbut[BFORC]);
				   }
				} else {
				   *incp = TogBut(&cbut[BFORC]);
				   *inct = 130;
				   if (*fancy || *fullgl) ogforces();
				   update_struct();
				}
			      }
                              break;

                 case BINCRF: if (pdb) {
				bflag = 1; doret = 0; bretval = 320;
				strcpy(molwstr,"Click on the backbone to activate !");
				StatusStr(0,1);
				XDefineCursor(display,win,AtomCursor);}
                              else {
				doret = 0;
				scalptr->fscal = scalptr->fscal*1.5;
				scalptr->fscal = MAXI(scalptr->fscal,0.01);
#if defined(VMS) || defined(UNDERSC)
				parfc();
#else
#ifdef CRAY
				PARFC();
#else
				parfc_();
#endif
#endif
				update_model = 0;
				if (*fancy || *fullgl) ogforces();
				update_struct();
			      }
                              break;
                 case BDECRF: if (pdb) {
				int doit;

				if (hetptr.NHetAtm) {
				 LSSTRU List; int iop; 
				 if (!calfptr->issdon) {
#if defined(VMS) || defined(UNDERSC)
					ribbs();
#else
#ifdef CRAY
					RIBBS();
#else
					ribbs_();
#endif
#endif
					calfptr->ihet[0] = 0;
					calfptr->ihet[1] = 0;
					calfptr->ihet[2] = 0;
					calfptr->ihet[3] = 0;
				 }

				 List.list = hetptr.HetAtm; List.nents = hetptr.NHetAtm;
				 if (DoPopUp(winMC,
					cbut[BDECRF].x+1,cbut[BDECRF].y+BUTTH,
					&List,&iop,0) == -1) break;
				 *incp = -1*iop;
				 doit =  calfptr->ihet[iop];

				 if (hetptr.HetAtm[iop] != NULL) {
				    if (strncmp(hetptr.HetAtm[iop],"ion",3) == 0) {
					*incp = calfptr->ision;
					doit = !(*ionoff);
				    }
				 }

                		 if (!monoscr && doit == 0) {

/* switch ON helix/strand/.. or hetatm */

					if (DoPopUp(winMC,
					  cbut[BDECRF].x-8,cbut[BDECRF].y+BUTTH,
					  NULL,Snstr,0) == -1) break;

					sndon(iop,1,*Snstr);

				 } else {

/* switch OFF helix/strand/.. or hetatm */

					*Snstr = 1;
					sndoff(iop);
#ifdef DOGL
					ogbck(iop);
#endif
				 }
				 *inct = 330; 
				}
			      }
                              else {
				doret = 0;
				scalptr->fscal = scalptr->fscal/1.5;
				scalptr->fscal = MAXI(scalptr->fscal,0.01);
#if defined(VMS) || defined(UNDERSC)
				parfc();
#else
#ifdef CRAY
				PARFC();
#else
				parfc_();
#endif
#endif
				update_model = 0;
				if (*fancy || *fullgl) ogforces();
				update_struct();
			      }
			      break; 

                 case BUNSC:  if (pdb) {*inct = 340;
					TogBut(&cbut[BUNSC]);}
                              else {
				doret = 0;
				scalptr->fscal = 1.0;
#if defined(VMS) || defined(UNDERSC)
				parfc();
#else
#ifdef CRAY
				PARFC();
#else
				parfc_();
#endif
#endif
				update_model = 0;
				if (*fancy || *fullgl) ogforces();
				update_struct();
			      }
                              break;

                 case BHBOND: if (pdb) {
                                int ict;

			        TogBut(&cbut[BHBOND]);
				if (!hbon) { 
				   hbon = 1;
				   ict = 490;
				   if (*ipdbon && *zmptrp->ihaszm) ict = 626;
				   qboxstr(&qboxes[QHBOND],NULL,1,0,-1,
					DEFQX, DEFQY, QBOXWIDE,QBOXHIGH, 0,
					"Maximum H-bond distance (Angs.) ? ",
					NULL, 0,2,ict,-1,dummyproc);
				} else {
				   hbon = 0;
				   if (*ipdbon && *zmptrp->ihaszm) {
					*inct = 624;
				   } else {
					*inct = 490;*incp = -1;
				   }
				}
                              }
                              break;

                 case BWRITF: { LSSTRU List; 
			      List.list = wropt; List.nents = 16;
			      if (DoPopUp(winMC,
					cbut[BWRITF].x+1,cbut[BWRITF].y+BUTTH,
					&List,iwropt,0) == -1) break;
			      if (*iwropt == 8) {
				List.list = pdbwh; List.nents = 3;
		   		RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
				if (DoPopUp(winMC,
					cbut[BWRITF].x+1,cbut[BWRITF].y+BUTTH,
					&List,ipdbwh,0) == -1) break;
			      }
			      if (*iwropt == 14 && cell->ichx) {
				   List.list = ambwopts; List.nents = 2;
				   if (DoPopUp(winMC,
					cbut[BWRITF].x+1,cbut[BWRITF].y+BUTTH,
					&List,&pbc->icell,0) == -1) break;
				   if (pbc->icell == 1) {
#if defined(VMS) || defined(UNDERSC)
				fdat(&EIGHTEEN,&ZERO,&ZERO,&ZERO,&ZERO,&ZERO);
#else
#ifdef CRAY
				FDAT(&EIGHTEEN,&ZERO,&ZERO,&ZERO,&ZERO,&ZERO);
#else
				fdat_(&EIGHTEEN,&ZERO,&ZERO,&ZERO,&ZERO,&ZERO);
#endif
#endif
		   		   }
			      }
			      if (*iwropt == 13) {
				   WriteCML();
				   strcpy(molwstr,"Wrote file molecule.cml");
				   StatusStr(0,1);
				   break;
			      }
			      if (*iwropt == 15) {
#if defined(VMS) || defined(UNDERSC)
				   wrtwfn();
#else
#ifdef CRAY
				   WRTWFN();
#else
				   wrtwfn_();
#endif
#endif
				  
				   strcpy(molwstr,"Wrote file molden.wfn");
				   StatusStr(0,1);
				   break;
			      }
			      if (*iwropt >= 3) *ixyz = *iwropt - 3;
			      *iwropt = *iwropt + 1;
			      if (*iwropt > 4) *iwropt = 4;
			      qboxstr(&qboxes[QPOST],NULL,1,0,-1,DEFQX,DEFQY,
					QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
					0,0,470,0,dummyproc);
			      update_model = 0;
			      }
                              break;

                 case BREADF: 
				doret = 0;
				if (fsel.qbrfile) {
				   TogUp(&cbut[BREADF]);
				   fsel.qbrfile = 0;
				   XUnmapWindow(display,fsel.win);
				}
				else {
				   TogDown(&cbut[BREADF]);
				   fsel.qbrfile = 1;
				   FileSelectList(&fsel);

				   TogDown(&dbut[BMOL]);
				   TogDown(&dbut[BCONT]);
				   TogUp(&dbut[BFILL]);
				   TogUp(&dbut[BORI]);
				}
			        update_model = 0;
				break;

                 case BZMAT:    if (ZMEup) {
				   UnMapZME();
				}
				else {
				   if (pdb && !*zmptrp->ihaszm) {
					if (!DoPDB(1)) break;
				   }
#if defined(VMS) || defined(UNDERSC)
				   clrmon();
#else
#ifdef CRAY
				   CLRMON();
#else
				   clrmon_();
#endif
#endif
				   TogDown(&cbut[BZMAT]);
        			   if (denm) ActBut(&cbut[BDENMOD],0);
				   if (pdb) {
				      if (ialtyp == NULL) ZMEAA = 1;
				      else if (*ialtyp == 1) ZMEAA = 0;
				      else ZMEAA = 1;
				   }
				   InitZME(); 
				   if (pdb) {
				      if (ialtyp == NULL) ZMEAA = 1;
				      else if (*ialtyp == 1) ZMEAA = 0;
				      else if (calfptr->ncalf <= 0) ZMEAA = 0;
				      else ZMEAA = 1;
				   }
				}
				*inct = 630;
			        update_model = 0;
				break;

                 case BDIST:  
			        update_model = 0;
                                if (!Selecting && !cflag && !dflag) {
				   *inct = 170;*incp = 1; 
				   aflag = 2;anum = 2;acnt = 0;
				   XDefineCursor(display,win,AtomCursor);
				}
                                break;

                 case BANGLE:  
			        update_model = 0;
                                if (!Selecting && !cflag && !dflag) {
				   *inct = 170;*incp = 2; 
				   aflag = 3;anum = 3;acnt = 0;
				   XDefineCursor(display,win,AtomCursor);
				}
                                break;

                 case BDIHED:  
			        update_model = 0;
                                if (!Selecting && !cflag && !dflag) {
				   *inct = 170;*incp = 3;
				   aflag = 4;anum = 4;acnt = 0;
				   XDefineCursor(display,win,AtomCursor);
				}
				break;

                 case BAUTH:
				if (!ATMup) InitATM(event.xbutton.x_root,
						    event.xbutton.y_root);
			        update_model = 0;
				break;

                 case BPAL:
				doret = palette();
				break;

                 case BGIF:
                              { setgif(1);
				doret = 0;
				break;}
                 case BLABEL:  
				if (cbut[BLABEL].toggle) {
				   LSSTRU List;
				   List.list = labels; 
				   List.nents = 6;
				   if (nmrptr->ihsnmr) {
					List.nents = 7;
					if (DoPopUp(winMC,
					cbut[BLABEL].x+1,cbut[BLABEL].y-20,
					&List,&qdpptr->iqon,0) == -1) break;
				   } else {

					if (DoPopUp(winMC,
					cbut[BLABEL].x+1,cbut[BLABEL].y,
					&List,&qdpptr->iqon,0) == -1) break;
				   }
				   if (qdpptr->iqon == 3 && !qdpptr->ihasq) {
					strcpy(molwstr,
					     "Click on atom to set Origin !");
					StatusStr(0,1);
				   }
				}
				*inct = 180;*incp = 0;
				update_model = 0;
				TogBut(&cbut[BLABEL]);
				break;
                 case BSHADE:  
				if (*shade) {
				   *shade = 0;
				   TogUp(&cbut[BSHADE]);
				   if (DPTup) XUnmapWindow(display,DPTwin);
				} else {
				   if (colcells >= 256) *shade = 1;
				   if (*shade) TogDown(&cbut[BSHADE]);
				   if (!DPTup) InitDPT();
				   else XMapRaised(display,DPTwin);
				}
#ifdef DOGL
			        EnableFog();
#endif
			        update_model = 0;
				break;

                 case BBACKB:  *inct = 310;*incp = 0; 
				DoBackbone();
                               break;
                 case BATCOL:  *inct = 400;*incp = 0; 
				TogBut(&cbut[BATCOL]); break;
                 case BPERSP:  *inct = 410;*incp = 0; 
			       update_model = 0;
				TogBut(&cbut[BPERSP]); break;
                 case BLEFT:    hold = 1; holdt = 420; holdp = 0;
			       update_model = 0;
				*inct = 420;*incp = 0; break;
                 case BRIGHT:   hold = 1; holdt = 430; holdp = 0;
			       update_model = 0;
				*inct = 430;*incp = 0; break;
                 case BUP:      hold = 1; holdt = 440; holdp = 0;
			       update_model = 0;
				*inct = 440;*incp = 0; break;
                 case BDOWN:    hold = 1; holdt = 450; holdp = 0;
			       update_model = 0;
				*inct = 450;*incp = 0; break;
		 case BBALL:    
				if (*ball) {
				   *ball = 0;
				   strcpy(molwstr,"Old Style rotation");
				   StatusStr(0,1);
				} else {
				   *ball = 1;
				   strcpy(molwstr,"Sticky Pointer rotation");
				   StatusStr(0,1);
				}
#if defined(VMS) || defined(UNDERSC)
				wrtres();
#else
#ifdef CRAY
				WRTRES();
#else
				wrtres_();
#endif
#endif
				TogBut(&cbut[BBALL]);
				hold = 0;
			        update_model = 0;
				break;
                 case BPACE:   {
                                *inct = 500;
			       update_model = 0;
                               if (coarse == 2) {
                                  coarse = 0;
                                  cbut[BPACE].pix = slowPix;
                               }
                               else if(coarse == 1) {
                                  coarse = 2;
                                  cbut[BPACE].pix = blastPix;
                               }
                               else {
                                  coarse = 1;
                                  cbut[BPACE].pix = fastPix;
                               }
                               DrwBut(&cbut[BPACE]);
                               *incp = coarse; break;
                               }
                 case BCONV: 
                              {
			       update_model = 0;
                               if (!cnvup)
                                    {createconv();cnvup = 1;}
                               else {
                                    XDestroyWindow(display,wincnv);cnvup = 0;}
                               break;}
                 case BGEOM: 
                              {
			       update_model = 0;
                               if (!geoup) {
                                    if (geo1ptr->gcvav) {
				        TogDown(&cbut[BGEOM]);
					creategeom();
					geoup = 1;
				    }
			       }
                               else {
				    TogUp(&cbut[BGEOM]);
                                    XDestroyWindow(display,wingeo);geoup = 0;}
                               break;}
                 case BJCPL:  
			        update_model = 0;
                                if (!Selecting && !cflag && !dflag) {
				   *inct = 170;*incp = 1; 
				   aflag = 2;anum = 2;acnt = 0; eflag = 1;
				   XDefineCursor(display,win,AtomCursor);
				}
                                break;


                 }/*end switch*/
                 if (doret) return;
                 }
              }/* end if*/
 

           }/*end buttonpress*/
           break;


           case MotionNotify: {


              if(DEBUG)fprintf(stderr,"MotionNotify\n");

	      motion_screen(inct,incp);

	      if (!bcksvg.UpSVG) SetExplButton(event.xmotion.window,
				event.xmotion.x,event.xmotion.y);

              if(event.xmotion.window == wincnv) {
		if (cnvptr->icvav1) 
			parse_motion(&scfEfirst);
		if (cnvptr->icvav2) 
			parse_motion(&scfElast);
	      }

              if (event.xmotion.window == winspec) {
			parse_motion(&spect);
	      }

              if (event.xmotion.window == winsco && scoup) {
			parse_motion(&docksco);
	      }

              if(event.xmotion.window == wingeo) {
		if (geo1ptr->gcvav) {
			if (geo1ptr->ifmxav) parse_motion(&geoFmax);
      			if (geo1ptr->ifrmav) parse_motion(&geoFrms);
			if (geo1ptr->idmxav) parse_motion(&geoSmax);
			if (geo1ptr->idrmav) parse_motion(&geoSrms);
			if (geo1ptr->ieav) parse_motion(&geoE);
		}
	      }

              if(event.xmotion.window == win && ZoomSelection) {


                 while(XCheckTypedWindowEvent(display, win, MotionNotify,
                                        &event));
		 if ( !(has_opengl && (*fancy || *fullgl))) {
                    XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
		 }

                 MotionCount++;

                 /* get the location of the pointer */

                 ZoomX2 = MAXI(ZoomX1, event.xmotion.x);
                 ZoomY2 = MAXI(ZoomY1, event.xmotion.y);
                 ZoomW = MAXI(ABS(ZoomX2 - ZoomX1),1);
                 ZoomH = MAXI(ABS(ZoomY2 - ZoomY1),1);
		 if (has_opengl && (*fancy || *fullgl)) {
#ifdef DOGL
		    rubber(1);
#endif
		 } else {
                    XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
		 }

              } /* end ZoomSelection */

                                                                                
           } /* end MotionNotify */
           break;


           case ButtonRelease: {

              if (!((*fancy || *fullgl) && has_opengl) && event.xbutton.window == win) {
		 moving = 0;
		 gmoving = 0;
	      }

              if (event.xbutton.window == win && 
		  (event.xbutton.button == 1 || event.xbutton.button == 2) &&
                  !ZoomSelection ) moving = 0;

              if (event.xbutton.window == win && (event.xbutton.button == 1 ||
                 event.xbutton.button == 2) && ZoomSelection ) {

                 ZoomSelection = False;

		 if (has_opengl && (*fancy || *fullgl)) {
		    dispsf();
		 } else {
                    XDrawRectangle(display, win, gc,
                                ZoomX1, ZoomY1, ZoomW, ZoomH);
                    XSetFunction(display, gc, GXcopy);
		 }
                 XUndefineCursor(display, win);

                 if (MotionCount >=3 ) {
                    for ( i = 0; i < *xyzp->iatoms; i++ ) {
                      if (xyzp->iaton[i] >= 1 && 
                      VIERKANT(xyzp->iyp[i], xyzp->ixp[i], 
				ZoomX1, ZoomY1, ZoomW, ZoomH)) {
                         if (Select && xyzp->ianz[i] != 100) xyzp->iaton[i] = 2;
                         else xyzp->iaton[i] = 1;
                      }
                    }
		    if (SelRes != -3) {
			for ( i = 0; i < *xyzp->iatoms; i++ ) {
			   if (xyzp->iaton[i] > 1) {
				xyzp->iresid[i] = SelRes;
	   			xyzp->iatclr[i] = xyzp->iatclr[ATMsel];
				xyzp->iaton[i] = 1;
			   }
			}
			SelRes = -3;
		    }
	    	    update_model = 0;
	    	    update_sel = 1;
                    return;
                 }

              } /* end zoom */

              if (( (*fancy || *fullgl) && has_opengl) 
			&& event.xbutton.window == win) {
		 mouseu(event.xbutton.button,event.xbutton.state, 
			event.xbutton.x, event.xbutton.y);
                 dispsf();
		 if (animptr.on) {
		    hold = 0; 
		    return;
		 }
		 break;
	      }

           } /* end ButtonRelease */
           break;
                                                                                
  	
           case Expose: {


	      update_model = 0;
              if (DEBUG) fprintf(stderr,"Expose\n");

	      while (XCheckWindowEvent(display, event.xexpose.window, 
			ExposureMask, &event)) {
	      }

              if ( !((*fancy || *fullgl) && has_opengl) 
			&& event.xexpose.window == win) {
                 if ( molback == molcur ) {
                    XCopyArea(display,molcur,win,gc,0,0,width,height,0,0);
                 }
              }

              if (((*fancy || *fullgl)  && has_opengl) 
			&& event.xexpose.window == win) {
                dispsf();
		break;
              }

              for (i=0; i<NQBOX; i++) { 
		if (event.xexpose.window == qboxes[i].win)
			PromptBox(&qboxes[i]);
	      }	

              for (i=0; i<NOBJS; i++) { 
	         if (WinObj[i].win != NULL && WinObj[i].winup != NULL) {
	            if (event.xexpose.window == *WinObj[i].win 
			&& WinObj[i].redraw != NULL && *(WinObj[i].winup)) {
			if (WinObj[i].sh == NULL) WinObj[i].redraw();
			else WinObj[i].redraw(WinObj[i].sh);
		    }
		 }
	      }
	      if (event.xexpose.window == fsel.win) RedrawFwin(&fsel);

	      if (event.xexpose.window == gsel.win) RedrawFwin(&gsel);

	      if (event.xexpose.window == dsel.win) RedrawFwin(&dsel);

	      if (event.xexpose.window == FrBox) RedrawList(&frlist);
	      if (event.xexpose.window == MLTwin && 
			event.xexpose.send_event == True) DoSvgfile();
	      if (event.xexpose.window == MLTwin) RedrawMLT();
              if (event.xexpose.window == winMC) {
                   RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);}


              if (event.xexpose.window == winau && gijsup) {
                   XSetForeground(display, gc, infobg);
                   XSetBackground(display, gc, infofg);
                   XCopyPlane(display, gijs, winau, gc, 0, 0, gijsface_width,
                   gijsface_height, 0, 0, (unsigned long)1);}

              if (event.xexpose.window == FLXwin && FLXup)
	           RedrawList(&flxlist);

              if (event.xexpose.window == winrama && ramaup) {
		   if ( rwiold != rwi || rhiold != rwi) {
	              if (event.xexpose.count == 0) {
			  XResizeWindow(display, winrama, rwi, rwi);
			  rwiold = rwi; rhiold = rhi;
		      }
		   }
		   DrawRama();
	      }

              if (event.xexpose.window == wingeo && geoup) {

		   while(XCheckTypedWindowEvent(display,wingeo,
				Expose,&report));
		   XClearWindow(display,wingeo);

#if defined(VMS) || defined(UNDERSC)
                   drwgeo();
#else
#ifdef CRAY
                   DRWGEO();
#else
                   drwgeo_();
#endif
#endif
	      }

              if (event.xexpose.window == windock && dockup) {

                   drwdock();
	      }
           }
           break;

	   case MapNotify: {
	      if (event.xmap.window == expldat.win && 
		event.xmap.send_event == True) DoExpl();
           }
           break;

	   case EnterNotify: {
		if (!bcksvg.UpSVG) {
		   expldat.win = -1;
		   signal(SIGALRM,SIG_IGN);
		}
           }
           break;

	   case ClientMessage: {
		Atom proto, delwin;
		XClientMessageEvent *client_event = 
			(XClientMessageEvent *) &event;

		proto = XInternAtom(display, "WM_PROTOCOLS", False);
		delwin = XInternAtom(display, "WM_DELETE_WINDOW", False);

		if (client_event->message_type == proto &&
		    client_event->data.l[0] == delwin) {
		    if (client_event->window == ZMEwin) {
			UnMapZME();
		    } else if (client_event->window == RESwin) {
			if (qbres) {
			    TogUp(&cbut[BFORC]);
			    qbres = 0;
			    XUnmapWindow(display,RESwin);
			}
		    } else if (client_event->window == fsel.win) {
			if (fsel.qbrfile) {
			    TogUp(&cbut[BREADF]);
			    fsel.qbrfile = 0;
			    XUnmapWindow(display,fsel.win);
			}
		    } else if (client_event->window == DISTwin) {
			if (distup) {
			    distup = 0;
			    XUnmapWindow(display,DISTwin);
			}
		    } else if (client_event->window == FrBox) {
			if (frfor && FRup) {
			    TogUp(&cbut[BFORC]);
			    XDestroyWindow(display,FrBox);
			    DoFreq = 0;
			    FRup = 0;
#if defined(VMS) || defined(UNDERSC)
			    resfr();
			    doconn();
#else
#ifdef CRAY
			    RESFR();
			    DOCONN();
#else
			    resfr_();
			    doconn_();
#endif
#endif
       		      	    *normc = 0;
			}
		    } else if (client_event->window == winspec) {
			if (frfor && specup) {
			    XDestroyWindow(display,winspec);
			    specup = 0;
			}
		    } else if (client_event->window == wingeo) {
			if (geoup) {
			    TogUp(&cbut[BGEOM]);
			    XDestroyWindow(display,wingeo);
			    geoup = 0;
			}
		    } else if (client_event->window == wincnv) {
			if (cnvup) {
			    XDestroyWindow(display,wincnv);
			    cnvup = 0;
			}
		    } else if (client_event->window == winsco) {
			if (scoup) {
			    XDestroyWindow(display,winsco);
			    scoup = 0;
			}
		    } else if (client_event->window == winrama) {
			if (ramaup) {
			    XDestroyWindow(display,winrama);
			    ramaup = 0;
			}
		    } else if (client_event->window == winpmf) {
			if (pmfup) {
			    XDestroyWindow(display,winpmf);
			    pmfup = 0;
			}
		    } else if (client_event->window == winspec) {
			if (specup) {
			    XDestroyWindow(display,winspec);
			    specup = 0;
			}
		    } else if (client_event->window == windock) {
			if (dockup) {
			    XDestroyWindow(display,windock);
			    dockup = 0;
			}
		    } else if (client_event->window == CPwin) {
			if (CPup) {
			    XDestroyWindow(display,CPwin);
			    CPup = 0;
			}
		    } else if (client_event->window == ATMwin) {
			if (ATMup) {
#ifdef DOGL
			    if ((*fancy || *fullgl) && has_opengl) ogunsel();
#endif
			    XDestroyWindow(display,ATMwin);
			    ATMup = 0;
			}
		    } else if (client_event->window == COLwin) {
			if (COLup) {
			    XDestroyWindow(display,COLwin);
			    COLup = 0;
			}
		    } else if (client_event->window == ECOLwin) {
			if (ECOLup) {
			    XDestroyWindow(display,ECOLwin);
			    ECOLup = 0;
			}
		    } else if (client_event->window == CHGwin) {
			if (CHGup) {
			    XDestroyWindow(display,CHGwin);
			    CHGup = 0;
			}
		    } else if (client_event->window == CTwin) {
			if (CTup) {
			    XDestroyWindow(display,CTwin);
			    CTup = 0;
			}
		    } else if (client_event->window == DPTwin) {
			if (DPTup) {
			    XDestroyWindow(display,DPTwin);
			    DPTup = 0;
			}
		    } else if (client_event->window == SUBwin) {
			if (SUBup) {
			    XDestroyWindow(display,SUBwin);
			    SUBup = 0;
			}
		    } else if (client_event->window == SEQwin) {
			if (SEQup) {
			    XDestroyWindow(display,SEQwin);
			    SEQup = 0;
			}
		    } else if (client_event->window == TNKwin) {
			if (TNKup) {
			    XDestroyWindow(display,TNKwin);
			    TNKup = 0;
			}
		    } else if (client_event->window == SRFwin) {
			if (SRFup) {
			    XDestroyWindow(display,SRFwin);
			    SRFup = 0;
			}
		    } else if (client_event->window == SELHwin) {
			if (SELHup) {
			    XDestroyWindow(display,SELHwin);
			    SELHup = 0;
			}
		    } else if (client_event->window == SRCHwin) {
			if (SRCHup) {
			    XDestroyWindow(display,SRCHwin);
			    SRCHup = 0;
			}
		    } else if (client_event->window == MLTwin) {
			if (MLTup) {
			    XDestroyWindow(display,MLTwin);
			    MLTup = 0;
			}
		    } else if (client_event->window == winau) {
			if (gijsup) {
			    XFreePixmap(display,gijs);
			    XDestroyWindow(display,winau);
			    gijsup = 0;
			}
		    } else if (client_event->window == MOVwin) {
			if (Movup) {
			    XDestroyWindow(display,MOVwin);
			    Movup = 0;
			}
		    } else if (client_event->window == STRwin) {
			if (DoCan(width/2, height/2,
				"This window is essential",0)) {}
		    } else if (client_event->window == QBox) {
			XDestroyWindow(display,QBox);
			XSync(display, False);
		        qboxup = 0;
		    } else if (client_event->window == winMC ||
				client_event->window == win) {
			if (DoCan(width/2, height/2,
				"Use the Skull Icon to quit Molden",0)) {}
		    }
		}
	   }
	   break;

           case ConfigureNotify: {

              if(DEBUG)fprintf(stderr,"ConfigureNotify\n");

              /* you want to increase or decrease the size of the window*/
              /* get the new width and height*/

	      while(XCheckTypedWindowEvent(display, 
		event.xconfigure.window, ConfigureNotify,&event)) {
	      }

              if (event.xconfigure.window == win) {

		   /* check for real resize */

                   if (event.xconfigure.width == width &&
                       event.xconfigure.height == height) {
			if (has_opengl && (*fancy || *fullgl)) {
#ifdef DOGL
			    /*glXSwapBuffers(display, win);*/
dispsf();
#endif
			    break;
			} else return;
		   }

                   width  = event.xconfigure.width;
                   height = event.xconfigure.height;

                   /* now resize the Graphics window, this will generate an 
                      expose event*/

                   size_hints.flags  = USSize;
                   size_hints.width  =  width;
                   size_hints.height  =  height;
                   XSetNormalHints(display, win, &size_hints);
		   if (has_opengl && (*fancy || *fullgl)) Reshape(1);
                   return;
              }

              if (event.xconfigure.window == winspec) {
		   int i, spold,spoldw;

		   spold = SPECHIGH;
		   spoldw = SPECWIDE;
		   SPECWIDE = event.xconfigure.width;
		   SPECHIGH = event.xconfigure.height - SPBHIGH;
		   if (SPECHIGH < 0) SPECHIGH = 0;

                   /* now resize the Graphics window, this will generate an 
                      expose event*/

                   size_hints.flags  = USSize;
                   size_hints.width  =  SPECWIDE;
		   if (event.xconfigure.height < SPBHIGH) {
			size_hints.height  =  SPBHIGH;
		   } else {
			size_hints.height  =  event.xconfigure.height;
		   }
                   XSetNormalHints(display, winspec, &size_hints);
		   for (i=0; i<nsbutts; i++) {
			spbut[i].y = SPECHIGH + (spbut[i].y - spold);
			if (i >= 2) 
			    spbut[i].x = SPECWIDE + (spbut[i].x - spoldw);
		   }
		   for (i=0; i<nspqbox; i++) 
			qboxes[QHW+i].y = SPECHIGH + (qboxes[QHW+i].y - spold);
		   drwspec();
              }

              if (event.xconfigure.window == wingeo) {

		   nhframes = 1;
		   if (geo1ptr->ifmxav || geo1ptr->ifrmav) nhframes = 2;
		   nwframes = 1;
		   if (geo1ptr->idmxav || geo1ptr->idrmav) nwframes = 2;

		   gwi = event.xconfigure.width;
		   ghi = event.xconfigure.height;

		   if (nwframes == 2) {
			CNVWIDE = gwi / 2;
		   } else {
			CNVWIDE = gwi;
		   }
		   if (nhframes == 2) {
			CNVHIGH = ghi / 2;
		   } else {
			CNVHIGH = ghi;
		   }

                   /* now resize the Graphics window, this will generate an 
                      expose event*/

                   size_hints.flags  = USSize;
                   size_hints.width  =  gwi;
                   size_hints.height  =  ghi;
                   XSetNormalHints(display, wingeo, &size_hints);
		   XClearWindow(display,wingeo);
#if defined(VMS) || defined(UNDERSC)
		   drwgeo();
#else
#ifdef CRAY
		   DRWGEO();
#else
		   drwgeo_();
#endif
#endif
                   return;
              }

              if (event.xconfigure.window == winrama) {

		   rwi = event.xconfigure.width;
		   rhi = event.xconfigure.height;

		   if (rwi < rhi) {
			rhi = rwi;
		   } else {
			rwi = rhi;
		   }

		   if (rwi > DisplayWidth(display,screen) ||
		       rhi > DisplayHeight(display,screen)) {
			if (DisplayWidth(display,screen) > 
			    DisplayHeight(display,screen)) {
				rwi = rhi = DisplayHeight(display,screen);
			} else {
				rwi = rhi = DisplayWidth(display,screen);
			}
		   }

                   size_hints.flags  = PSize;
                   size_hints.width  =  rwi;
                   size_hints.height  =  rwi;
                   XSetNormalHints(display, winrama, &size_hints);
              }
           }
           break;

           case UnmapNotify:         break;

           default: break;		/* ignore unexpected events */

        }  /* end switch event type*/


    }/* end while */

#ifdef DOGL
    if ((has_opengl && (
	(!(*fancy || *fullgl) && !moving ) || 
	( (*fancy || *fullgl) && !gmoving)
	)) 
		|| !has_opengl) {
	    return;
    } else dispsf();
#else
    return;
#endif

  } /* end MolWindow */
  break;

  case OpenWindow :
  {
    int ig;
#ifdef DOGL
    int dummy;
#endif

    SetupTable();

#ifdef __CYGWIN__
/*
    if (getenv("DISPLAY") == NULL) putenv("DISPLAY=localhost:0.0");
*/
    if (getenv("DISPLAY") == NULL) putenv("DISPLAY=127.0.0.1:0.0");
#endif
    if (( display = XOpenDisplay(NULL)) == NULL )
    {
      fprintf( stderr, "Molden: cannot connect to X server %s\n",
               XDisplayName(display_name));
      exit(-1);
    }

    if (strstr(ServerVendor(display),"StarNet")) {
	if (*istaro) {
	   StarNetOld = 1;
	} else {
	   StarNet = 1;
	   fprintf(stderr,"\nWith older versions of StarNet X-Win32\n");
	   fprintf(stderr,"(6.1 and older) use the -Q commandline flag\n\n");
	}
    }

    xison = 1;

    if (DEBUG) XSynchronize(display,1);

    XSetErrorHandler (X_Error_Message_CB);

    width  = 800;	
    height = 800;

    screen         = DefaultScreen(display);
    Mwidth  = DisplayWidth(display, screen);
    Mheight = DisplayHeight(display, screen);

    if (GEOMset) {
	ig = XParseGeometry(GEOMstr,&wx,&wy,&width,&height);
    }

    xswa.background_pixel = BlackPixel(display,screen);
    xswa.border_pixel     = WhitePixel(display,screen);
    xswa.backing_store    = NotUseful;
    xswa.backing_planes   = 0;
    xswa.save_under       = False;
    IBGcolor = 0;

    rootW = RootWindow(display,screen);
    dispDEEP  = DisplayPlanes(display,screen);

#ifdef DOGL
    if (glXQueryExtension(display, &dummy, &dummy)) has_opengl = 1;

    if (has_opengl) {
	if ((vi = glXChooseVisual(display, DefaultScreen(display),attributeList))) {
	    screen = vi->screen;

	    if (vi->class != TrueColor) fprintf(stderr,"TRuecolor required\n");
            if (!(cx = glXCreateContext(display, vi, 0, GL_TRUE))) fprintf(stderr,"no context\n");
            cmap = XCreateColormap(display,RootWindow(display,vi->screen),vi->visual,AllocNone);
            xswa.colormap = cmap;
        } else {
	    has_opengl = 0;
        }
    }

#endif

    Aspect = (float) width / (float) height;

    if (has_opengl) {
       win = XCreateWindow(display,
                        RootWindow(display,screen),
                        wx,
                        wy,
                        width,
                        height,
                        0,
                        vi->depth,
                        InputOutput,
                        vi->visual,
                        (CWBorderPixel | CWColormap | CWEventMask | CWBackingStore | CWBackingPlanes | CWSaveUnder),
                        &xswa);
    } else {
       win = XCreateWindow(display,
                        RootWindow(display,screen),
                        wx,
                        wy,
                        width,
                        height,
                        border_width,
                        CopyFromParent,
                        InputOutput,
                        CopyFromParent,
                        (CWBackPixel | CWBorderPixel | CWBackingStore | CWBackingPlanes),
                        &xswa);
    }


    StoreDeleteWindowProp(win);

    icon_pixmap = XCreateBitmapFromData(display,
                                        win,
                                        icon_bitmap_bits,
                                        icon_bitmap_width,
                                        icon_bitmap_height);


    size_hints.flags 	  = PPosition | PSize | PMinSize;
    size_hints.x 	  = wx;
    size_hints.y 	  = wy;
    size_hints.width 	  = width;
    size_hints.height 	  = height;
    size_hints.min_width  = 0;
    size_hints.min_height = 0;

    XSetStandardProperties(display,
                           win,
                           window_name,
                           icon_name, 
                           icon_pixmap,
                           0, 0,
                           &size_hints);

    XSelectInput(display,
                 win,
                 (StructureNotifyMask|ExposureMask|ButtonPressMask 
                 |ButtonReleaseMask|ButtonMotionMask|KeyPressMask
		 |KeyReleaseMask|PointerMotionMask|EnterWindowMask));

    values.foreground = WhitePixel(display,screen);
    values.background = BlackPixel(display,screen);

    gc = XCreateGC(display,
                   win,
                   (GCForeground|GCBackground|GCArcMode),
                   &values);
    XSetArcMode(display,gc,ArcPieSlice);
    gc1 = XCreateGC(display,
                   win,
                   (GCForeground|GCBackground|GCArcMode),
                   &values);

    if ( (mfinfo = XLoadQueryFont(display,FONT))== NULL) {
       mfinfo = XQueryFont(display,XGContextFromGC(gc));}
    else {

       XSetFont(display,gc,mfinfo->fid);
    }

    labinfo = XLoadQueryFont(display,LFONT);
    slabinfo = XLoadQueryFont(display,SFONT);
    if (slabinfo == NULL) {
	gc1 = gc;
    } else {
	XSetFont(display,gc1,slabinfo->fid);
    }


    if (Arg1 >= 0.0) coloff = Arg1;

    def_colors();			/* define colors	*/

    *inct = colcells;

    stipple = XCreateBitmapFromData(display, win, stipple_bits, stipple_width,
                                        stipple_height);

    qwgrey = XCreateBitmapFromData(display, win, qwgrey_bits, qwgrey_width,
                                        qwgrey_height);
    tqwgrey = XCreateBitmapFromData(display, win, tqwgrey_bits, tqwgrey_width,
                                        tqwgrey_height);

    grayStip = XCreatePixmapFromBitmapData(display, win, gray50_bits,
             gray50_width, gray50_height, 1, 0, 1);

    molPix     = XCreateBitmapFromData(display, win,
                mol_bits, mol_width, mol_height);
    upPix      = XCreateBitmapFromData(display, win,
                up_bits, up_width, up_height);
    downPix    = XCreateBitmapFromData(display, win,
                down_bits, down_width, down_height);
    lPix       = XCreateBitmapFromData(display, win,
                l_bits, l_width, l_height);
    rPix       = XCreateBitmapFromData(display, win,
                r_bits, r_width, r_height);
    ballPix    = XCreateBitmapFromData(display, win,
                ball_bits, ball_width, ball_height);
    HourPix    = XCreateBitmapFromData(display, win,
                hourglass_bits, hourglass_width, hourglass_height);
    gPix       = XCreateBitmapFromData(display, win,
                g_bits, g_width, g_height);
    SkullPix   = XCreateBitmapFromData(display, win,
                skull_bits, skull_width, skull_height);
    FFPix      = XCreateBitmapFromData(display, win,
                ff_bits, ff_width, ff_height);
    MLFPix     = XCreateBitmapFromData(display, win,
                mlf_bits, mlf_width, mlf_height);
    HPix       = XCreateBitmapFromData(display, win,
                hbit_bits, hbit_width, hbit_height);
    VRMLPix    = XCreateBitmapFromData(display, win,
                vrml_bits, vrml_width, vrml_height);
    AlignPix   = XCreateBitmapFromData(display, win,
                align_bits, align_width, align_height);
    OrigPix    = XCreateBitmapFromData(display, win,
                orig_bits, orig_width, orig_height);
    CellPix    = XCreateBitmapFromData(display, win,
                cell_bits, cell_width, cell_height);
    SurfPix    = XCreateBitmapFromData(display, win,
                surf_bits, surf_width, surf_height);
    FotoPix    = XCreateBitmapFromData(display, win,
                foto_bits, foto_width, foto_height);
    movPix    = XCreateBitmapFromData(display, win,
                film_bits, film_width, film_height);
    ColPix     = XCreateBitmapFromData(display, win,
                palette_bits, palette_width, palette_height);
    slowPix    = XCreateBitmapFromData(display, win,
                slow_bits, pace_width, pace_height);
    fastPix    = XCreateBitmapFromData(display, win,
                fast_bits, pace_width, pace_height);
    blastPix   = XCreateBitmapFromData(display, win,
                blast_bits, pace_width, pace_height);
    BigPix     = XCreateBitmapFromData(display, win,
                bigsmall_bits, bigsmall_width, bigsmall_height);
    OGLPix     = XCreateBitmapFromData(display, win,
                ogl_bits, ogl_width, ogl_height);
    stopPix     = XCreateBitmapFromData(display, win,
                stop_bits, stop_width, stop_height);
    mapPix    = XCreateBitmapFromData(display, win,
                map_bits, map_width, map_height);
    triPix    = XCreateBitmapFromData(display, win,
                tri_bits, tri_width, tri_height);

#ifdef DOBACK
#ifdef VMS
    molback = XCreatePixmap(display, win,Mwidth,Mheight,
        DefaultDepth(display,screen));
#else
    if (has_opengl) {
        if (( molback = XCreatePixmap(display, win,Mwidth,Mheight,
            vi->depth)) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
        if (( bckwin = XCreatePixmap(display, win,BckW,BckH,
            vi->depth)) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
        if (( colmap = XCreatePixmap(display, win,256,1,
            vi->depth)) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
    } else {
	if (( molback = XCreatePixmap(display, win,Mwidth,Mheight,
	    DefaultDepth(display,screen))) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
        if (( bckwin = XCreatePixmap(display, win,BckW,BckH,
	    DefaultDepth(display,screen))) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
        if (( colmap = XCreatePixmap(display, win,256,1,
	    DefaultDepth(display,screen))) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
    }
    FakeCMap();
#endif
#else
    molback = NULL;
#endif


    if ( molback ) {
        molcur = molback;
    }
    else {
        molcur = win;
    }

    XSetStipple(display,gc,stipple);


    ZoomCursor = XCreateFontCursor(display, 120);
    AtomCursor = XCreateFontCursor(display, 40);
    WaitCursor = XCreateFontCursor(display, XC_watch);

    for (i=0; i<MAXAT; i++) {
	IANZboxes[i].win = (Window) NULL;
	BLboxes[i].win = (Window) NULL;
	ALPHboxes[i].win = (Window) NULL;
	BETboxes[i].win = (Window) NULL;
        for (j=0; j<4; j++)
	   IZboxes[i][j].win = (Window) NULL;
    }

    XMapWindow(display, win);

/* use event to display window! since event loop is in the FORTRAN code
   we have to fudge the X to do anything */

    XCheckTypedWindowEvent(display,
                           win,
                           ExposureMask,
                           &report) ;


    done = 0;

    while (!done) {

        XNextEvent(display, &event);
        switch (event.type) {
              case MapNotify: {
                                 done = 1;
              }
        break;

        default: break;    
        }  
    }

    XGetWindowAttributes(display, win, &xwa);

    if ( (xwa.width  != width ) || (xwa.height != height) )
       {
            width  = xwa.width;
            height = xwa.height;
       }                      

    XCheckTypedWindowEvent(display,
                           win,
                           ExposureMask,
                           &report) ;

    initnthe();

#ifdef DOGL
    if (has_opengl) {
       if (strstr(ServerVendor(display),"StarNet") && !(*istaro)) 
	   *fullgl = 1;
       if (*fullgl) *ifogl = 1;
       glXMakeCurrent(display,win,cx);
       Reshape(0);
       const GLubyte *glExtensions = 
		(const GLubyte *) glGetString(GL_EXTENSIONS);
       if (strstr(((const char *) glGetString(GL_VENDOR)),"Tungsten")) 
		DoMIPMAP = 0;
       if (strstr(((const char *) glGetString(GL_VENDOR)),"Intel")) 
		DoIntel = 1;

#ifdef GL_ARB_shader_objects
       if (! *noshad) {
	if (*doshad) has_shader = check_shader((const char *) glExtensions);
       }
#endif
#ifdef GL_COLOR_ATTACHMENT0_EXT
       if (! *noshad) {
	   has_fbo = init_fbo(&fbo,fbo_type,(const char *) glExtensions);
	   if (!has_fbo) {
	      fbo_type = 4;
	      has_fbo = init_fbo(&fbo,fbo_type,(const char *) glExtensions);
	   }
       }
#endif
       glClear(GL_COLOR_BUFFER_BIT);
       makeRasterFont(display);
       initOpengl();
       initthe();
       ogelem();
    }
#else
    *fullgl = 0;
#endif

    CreatewinC(DEFWINCGEOM);
    XSelectInput(display, winC, 
		SubstructureNotifyMask | ExposureMask | 
		ButtonPressMask | KeyPressMask | PointerMotionMask | 
		PointerMotionMask | EnterWindowMask | LeaveWindowMask | 
		EnterWindowMask);
    CreatewinMC(DEFWINMCGEOM);
    XSelectInput(display, winMC, 
		StructureNotifyMask | SubstructureNotifyMask |ExposureMask | 
                ButtonPressMask | ButtonReleaseMask | 
		KeyPressMask | PointerMotionMask | 
		EnterWindowMask | LeaveWindowMask | EnterWindowMask);
    DowinC = 1;
    DowinMC = 1;
    DoactC = 1;
    DoactMC = 1;


    RESwin  = CreateWindow("Molden Query Box","-10-10",QBOXWIDE,QBOXTX+20,
                            infobg,infofg,(Window)0);
    XSelectInput(display, RESwin, ExposureMask | KeyPressMask | EnterWindowMask);

    WinObj[10].win = &RESwin;
    WinObj[10].subwin = NULL;
    WinObj[10].butarr = NULL;
    WinObj[10].numbut = -1;
    WinObj[10].winup = &qbres;
    WinObj[10].init = NULL;
    WinObj[10].redraw = RedrawRESwin;

    COMMwin = CreateWindow("Molden Query Box",DEFQBOXGEOM,QBOXWIDE,QBOXTX,
                            infobg,infofg,(Window)0);
    XSelectInput(display, COMMwin, ExposureMask | KeyPressMask | EnterWindowMask);

    WinObj[11].win = &COMMwin;
    WinObj[11].subwin = NULL;
    WinObj[11].butarr = NULL;
    WinObj[11].numbut = -1;
    WinObj[11].winup = &qbcomm;
    WinObj[11].init = NULL;
    WinObj[11].redraw = RedrawCOMMwin;

    gsel.parse = 0;
    gsel.inct = 280;
#ifdef VMS
    strcpy(gsel.lastdir,"[]");
#else
    strcpy(gsel.lastdir,"./");
#endif
    strcpy(gsel.label,"Grid file:");
    gsel.pntr = gfile;

    FileSelect(&gsel);

    dsel.parse = 0;
    dsel.inct = 280;
#ifdef VMS
    strcpy(dsel.lastdir,"[]");
#else
    strcpy(dsel.lastdir,"./");
#endif
    strcpy(dsel.label,"XYZ file:");
    dsel.pntr = gfile;

    FileSelect(&dsel);

    fsel.parse = 1;
    fsel.inct = 480;
#ifdef VMS
    strcpy(fsel.lastdir,"[]");
#else
    strcpy(fsel.lastdir,"./");
#endif

    FileSelect(&fsel);

    ZMEwin = CreateWindow("Zmatrix Editor","-0+0",ZMEWINW,ZMEWINH,infobg,infofg,(Window)0);
    XSelectInput(display, ZMEwin, 
		SubstructureNotifyMask | ExposureMask | KeyPressMask | 
		ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | 
		LeaveWindowMask | PointerMotionMask | EnterWindowMask);
    subZM = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],ZMEwin);

    WinObj[16].win = &ZMEwin;
    WinObj[16].subwin = &subZM;
    WinObj[16].butarr = ZMEbut;
    WinObj[16].numbut = ZMEBUTTS;
    WinObj[16].winup = &ZMEup;
    WinObj[16].init = InitZME;
    WinObj[16].redraw = RedrawZME;

    DISTwin = CreateWindow("Molden Calculate","-20-80",
	DBWIDE,DBHIGH+2*BUTTH, infobg,infofg,(Window)0);

    subDIST = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],DISTwin);

    WinObj[12].win = &DISTwin;
    WinObj[12].subwin = &subDIST;
    WinObj[12].butarr = clbut;
    WinObj[12].numbut = NCLBUT;
    WinObj[12].winup = &distup;
    WinObj[12].init = NULL;
    WinObj[12].redraw = RedrawDIST;

    if (has_opengl) {
        if (( distpix = XCreatePixmap(display, DISTwin,DBWIDE,DBHIGH,
            vi->depth)) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
    } else {
	if (( distpix = XCreatePixmap(display, DISTwin,DBWIDE,DBHIGH,
	    DefaultDepth(display,screen))) == (Pixmap) NULL )
        {
            fprintf( stderr, "Molden: cannot create pixmap \n");
        }
    }

    XSelectInput(display, DISTwin, ExposureMask | ButtonPressMask 
	| SubstructureNotifyMask | PointerMotionMask 
	| EnterWindowMask | LeaveWindowMask | EnterWindowMask);

    DefBut(&clbut[BMONI], DISTwin, 0, DBHIGH , DBWIDE/4, BUTTH, 
        	   "Monitor", infobg, 0);
    clbut[BMONI].explstr = "Update distance on screen\nwith each new structure";

    DefBut(&clbut[BCLR],  DISTwin, DBWIDE/4, DBHIGH , DBWIDE/2, BUTTH, 
        	   "Clear Mon/Cont", infobg, 0);
    clbut[BCLR].explstr = "clear distance monitors,\nclosest contacts";

    DefBut(&clbut[BCNTCT],DISTwin, (3*DBWIDE)/4, DBHIGH , DBWIDE/4, BUTTH, 
        	   "Contact", infobg, 0);
    clbut[BCNTCT].explstr = "show closest contacts\nof selected atom";

    DefBut(&clbut[BCLOSE],DISTwin, (3*DBWIDE)/4, DBHIGH+BUTTH , DBWIDE/4, BUTTH, 
        	   "Close", infobg, 0);
    clbut[BCLOSE].explstr = "close the window";

    DefBut(&clbut[BCONN],DISTwin, 0, DBHIGH+BUTTH , (3*DBWIDE)/4, BUTTH, 
        	   "Connect/DISconnect", infobg, 0);
    clbut[BCONN].explstr = "(dis)connect atoms measured distance";

    return;
  } /* end OpenWindow */ 
  break;

  case MovePen :			/* move pen to x,y	*/
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
       savecom[count].xxval = Arg1;
       savecom[count].yyval = Arg2;
    }
    movexy(Arg1,Arg2);
    return;
  } /* end MovePen */
  break;

  case DrawLine :
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
       savecom[count].xxval = Arg1;
       savecom[count].yyval = Arg2;
    }
    drawxy(Arg1,Arg2);
    return;
  } /* end DrawLine */
  break;

  case DrawString :
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
       savecom[count].xxval = Arg1;
       savecom[count].yyval = Arg2;
    }
    if ( scount < MXSAVESTR-1 ) {
       int ns;
       scount++;
       ns = *nstr;
       if (*nstr > 254 ) ns = 254;
       strcp(str,savestr[scount],ns);
       savestr[scount][ns] = '\0';
       nsavestr[scount] = ns;
    }
    drawstring(Arg1,Arg2,&savestr[scount][0],nsavestr[scount]);
    return;
  } /* end DrawString */
  break;

  case 5 :			/* do nothing		*/
  {
    return;
  }
  break;

  case ClearScreen :
  {
    doclr();
    return;
  } /* end ClearScreen */
  break;

  case SolidLine :
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
    }
#if defined(VMS) || defined(UNDERSC)
    sollin();
#else
#ifdef CRAY
    SOLLIN();
#else
    sollin_();
#endif
#endif
    return;
  } /* end SolidLine */
  break;

  case DashedLine :
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
    }
    dashline();
    return;
  } /* end DashedLine */
  break;

  case LineWidth :
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
       savecom[count].xxval = Arg1;
    }
#if defined(VMS) || defined(UNDERSC)
    cwidth(&Arg1);
#else
#ifdef CRAY
    CWIDTH(&Arg1);
#else
    cwidth_(&Arg1);
#endif
#endif

    return;
  } /* end LineWidth */
  break;

  case ParseNorbs:
  {
    norbs = *inct;
    return;
  }
  break;

  case ChangeColor :
  {
    if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = Command;
       savecom[count].xxval = Arg1;
    }
    changepen(Arg1);
    return;
  } /* end ChangeColor */
  break;

  default: 
  {
    fprintf(stderr,"ERROR in Command= %d", Command);
    return;
  }
  break;

 } /* end main command switch */
    exit(-1);		

} 

static char *name[] =				/* colors here	*/
	{"Black", "#FF1010", "goldenrod1", "Green", "Aquamarine", "#80FFFF", "Gold", 
         "LightBlue", "Grey", "Magenta", "Lime Green", "Wheat",
         "Orange", "#0000E0", "Chocolate", "White"};

static char *nameback[] =				/* colors here	*/
	{"#000000","#FF1010","#FF9F09","#00FF00","#7FFFD4","#80FFFF",
	 "#FFBF00","#84C1D6","#9B9B9B","#FF00FF","#10B010","#EFCA8C",
         "#FF7A00","#0000E0","#B83806","#FFFFFF"};


void ParseBasicColor(activecolor,docmap)
int activecolor;
int docmap;
{
  XColor exact_def;
  float rslice,gslice,bslice;
  int i;

   rslice = colorr[activecolor]*(1.0-coloff) / 10.0;
   gslice = colorg[activecolor]*(1.0-coloff) / 10.0;
   bslice = colorb[activecolor]*(1.0-coloff) / 10.0;

   if (!docmap) XFreeColors(display, cmap,&colors[16+(activecolor-1)*10],10,0);

   for (i = 1; i < 11; i++ ) {
	exact_def.red = colorr[activecolor]*coloff + i * rslice;
	exact_def.green = colorg[activecolor]*coloff + i * gslice;
	exact_def.blue = colorb[activecolor]*coloff + i * bslice;
      
	if ( !XAllocColor(display, cmap, &exact_def) ) {
	   if (docmap) {
             cmap =  XCopyColormapAndFree(display,cmap);
             XSetWindowColormap(display,win,cmap);
             setcmap = 1;
	     i--;
	   }
	} else {
	   colors[15+(activecolor-1)*10+i] = exact_def.pixel;
	}
         
   }
}

void ParseMapColors(docmap)
int docmap;
{
  XColor exact_def;
  int i;

   if (!docmap) XFreeColors(display, cmap,mappedcols,5,0);

   for (i = 0; i < 5; i++ ) {
	exact_def.red   = (int )(mapcol[i].r)*65535;
	exact_def.green = (int )(mapcol[i].g)*65535;
	exact_def.blue  = (int )(mapcol[i].b)*65535;
      
	if ( !XAllocColor(display, cmap, &exact_def) ) {
	   if (docmap) {
             cmap =  XCopyColormapAndFree(display,cmap);
             XSetWindowColormap(display,win,cmap);
             setcmap = 1;
	     i--;
	   }
	} else {
	   mappedcols[i] = exact_def.pixel;
	}
         
   }
}

void def_col16(colnam)
char **colnam;
{
  int i;
  XColor exact_def;

    for (i = 0; i < 16; i++ ) {

      if ( !XParseColor(display, cmap, colnam[i], &exact_def) ) {
	if ( !XParseColor(display, cmap, nameback[i], &exact_def) ) {
           fprintf( stderr, "Xwin: color %s not in database\n", nameback[i]);
           exit(-1);
	}
      }

      if ( !XAllocColor(display, cmap, &exact_def) ) {
       cmap = XCopyColormapAndFree(display,cmap);
       XSetWindowColormap(display,win,cmap);
       setcmap = 1;
       i--;
      } else {
	colors[i] = exact_def.pixel;
	colorr[i] = exact_def.red;
	colorg[i] = exact_def.green;
	colorb[i] = exact_def.blue;
      }
      
    }
}

void ResetColors()
{
   int j;

   XFreeColors(display, cmap,&colors[0],16,0);
   def_col16(name);
   for (j = 1; j < 16; j++ ) ParseBasicColor(j,0);
#if defined(VMS) || defined(UNDERSC)
   wrtres();
#else
#ifdef CRAY
   WRTRES();
#else
   wrtres_();
#endif
#endif
}

void def_colors()
{
  int depth;
  int ncells;
  XColor exact_def;
  int i,j;
  static char **colnam;

/* #80ffff used to be Cyan */


  static char *shcol[SHCOLNUM][3] = 
	{{"#729FFF","#C4D7FF","#3E578C"},
	 {"#A59F80","#DAD7CA","#5B5746"},
	 {"#FFC494","#CC9D76","#8C6C51"},
	 {"#F74F41","#FCB0AA","#802921"},
	 {"#FFBF00","#FFE69C","#916D00"},
	 {"#5F985F","#B6D0B6","#314F31"},
	 {"#56B2F7","#B8DFFC","#2F6288"}
  };
/*         medium   light    dark */

  if (NColNam == 16) colnam = ColNam;
  else colnam = name;

  depth  = DisplayPlanes(display, screen);
  ncells = DisplayCells(display, screen);

  if (depth >= 8) ncells = 256;

  if (!has_opengl) cmap   = DefaultColormap(display, screen);
  
  if ( ncells <= 2 )		/* mono screen	*/
  {
    colcells = 2;
    monoscr = 1;
    colors[0] = BlackPixel(display, screen);
    for ( i = 1; i < MAX_COLORS; i++ )
    {
       colors[i] = WhitePixel(display, screen);
    }
  }

  else
  {
    def_col16(colnam);

    if ( ncells >= 256 )
    {
       colcells = 256;
       for (j = 1; j < 16; j++ ) ParseBasicColor(j,1);
       for (j = 0; j < SHCOLNUM; j++ )
       for (i = 0; i < 3; i++ ) {
		XParseColor(display, cmap, shcol[j][i], &exact_def);
		if ( !XAllocColor(display, cmap, &exact_def) ) {
		  cmap =  XCopyColormapAndFree(display,cmap);
		  XSetWindowColormap(display,win,cmap);
		  setcmap = 1;
		  XAllocColor(display, cmap, &exact_def);
		}
		colors[190+3*j+i] = exact_def.pixel;
       }
#ifdef DOGL
       ParseMapColors(1);
#endif
    }
    else if ( ncells >= 32 )
    {
       colcells = 32;
       for (i = 1; i < 11; i++ )
       {
         exact_def.red = i * 6553;
         exact_def.green = i * 4250;
         exact_def.blue = 0;
   
         if ( !XAllocColor(display, cmap, &exact_def) )
         {
           cmap = XCopyColormapAndFree(display,cmap);
           XSetWindowColormap(display,win,cmap);
           setcmap = 1;
/*           fprintf(stderr,"Xwin: all colorcells allocated, read/write\n");
           exit(-1);*/
         }
         
         colors[125+i] = exact_def.pixel;
       }
    }

  }


  if (monoscr || colcells <= 32) {
     infofg = WhitePixel(display,screen);
     infobg = BlackPixel(display,screen); 
     White = WhitePixel(display,screen);
     Black = BlackPixel(display,screen); }
  else {
     infofg = colors[15];
     infobg = colors[0];
     White = WhitePixel(display,screen);
     Black = BlackPixel(display,screen); 
  }
  if (*ibgcol) IBGcolor = *ibgcol;
  if (*ibgclo) OBGcolor = *ibgclo;
  if (*ibgmod) BGmode = *ibgmod;
}     

void FakeCMap()
{
   int i;
   unsigned long pixl;
   XImage *img;
   
   for (i=0; i<256; i++) {
	XSetForeground(display,gc,colors[i]);
	XDrawPoint(display,colmap,gc,i,0);
   }
   img = XGetImage(display,colmap,0,0,256,1,AllPlanes,ZPixmap);
   for (i=0; i<256; i++) {
	pixl = XGetPixel(img,i,0);
	colors[i] = pixl;
   }
   XDestroyImage(img);
}

static int isdraw = 0;

void movexy(float xval,float yval)
{
#ifdef DOGL
  gstart_xlx = (xval-xoff)*scale*2.0 - 1.0;
  gstart_yly = (yval-yoff)*scale*2.0 - 1.0;

  if (*fullgl && !*ifdogl) {
	if (isdraw) glEnd();
	isdraw = 1;
	glBegin(GL_LINES);
  }
#endif

  start_xlx = (xval-xoff) * height * scale;
  start_yly = (1.0- yval -yoff) * height * scale;
}

void drawxy(float xval,float yval)
{
  xlx = (xval-xoff) * height * scale;
  yly = (1.0 - yval - yoff) * height * scale;

#ifdef DOGL

  gxlx = (xval-xoff)*scale*2.0 - 1.0;
  gyly = (yval-yoff)*scale*2.0 - 1.0;

  if (*fullgl && !*ifdogl) {
	if (isdraw) {
	   glVertex2f(gstart_xlx, gstart_yly);     
	   glVertex2f(gxlx,gyly);
/*
fprintf(stderr,"gstart_xlx %f gstart_yly %f\n",gstart_xlx,gstart_yly);
fprintf(stderr,"gxlx %f gyly %f\n",gxlx,gyly);
*/
	}
	gstart_xlx = gxlx;
	gstart_yly = gyly;
  } else {
#endif
	XDrawLine(display, molcur, gc, xlx, yly, start_xlx, start_yly);
#ifdef DOGL
  }
#endif

  start_xlx = xlx;
  start_yly = yly;

}

void drawstring(float xval,float yval,char *strval,int nval)
{
  xlx = (xval-xoff) * height * scale;
  yly = (1.0 - yval -yoff) * height * scale;
#ifdef DOGL
/*
  if (*fullgl && !*ifdogl) {
	gxlx = (xval-xoff)*scale*2.0 -1.0;
	gyly = (yval-yoff)*scale*2.0 -1.0;
	if (isdraw) {
	   glEnd();
	   isdraw = 0;
        }
#if defined(VMS) || defined(UNDERSC)
	drwstr(&gxlx,&gyly,strval,&nval,&MONE);
#else
#ifdef CRAY
	DRWSTR(&gxlx,&gyly,strval,&nval,&MONE);
#else
	drwstr_(&gxlx,&gyly,strval,&nval,&MONE);
#endif
#endif
  } else {
*/
#endif
	XDrawString(display, molcur, gc, xlx, yly, strval, nval);
#ifdef DOGL
/*
  } 
*/
#endif

}

#if defined(VMS) || defined(UNDERSC)
void sollin()
#else
#ifdef CRAY
void SOLLIN()
#else
void sollin_()
#endif
#endif

{
   if (!xison) return;

   isdash = 0;
   XSetLineAttributes(display, gc, linwid, LineSolid, CapButt, JoinMiter);

} 

void dashline()
{
   isdash = 1;
   if ( monoscr ) {
        XSetBackground(display, gc, BlackPixel(display,screen));
        XSetLineAttributes(display, gc, linwid, LineDoubleDash,
                                      CapButt, JoinMiter);
   }
}

#if defined(VMS) || defined(UNDERSC)
void dash(on)
#else
#ifdef CRAY
void DASH(on)
#else
void dash_(on)
#endif
#endif
int *on;
{
   if (!xison) return;
   if (*on) XSetLineAttributes(display, gc, linwid, LineOnOffDash, 
                               CapButt, JoinMiter);
   else XSetLineAttributes(display, gc, linwid, LineSolid,
                               CapButt, JoinMiter);
}

#if defined(VMS) || defined(UNDERSC)
void cwidth(linpass)
#else
#ifdef CRAY
void CWIDTH(linpass)
#else
void cwidth_(linpass)
#endif
#endif

float *linpass;
{
  linwid = (int) *linpass;
  if (linwid > linmax) linwid = linmax;
#ifdef DOGL
  if (*fullgl && !*ifdogl) {
	if (isdraw) {
	   glEnd();
	   isdraw = 0;
        }
	glLineWidth(*linpass);
   }
#endif
}

void changepen(float pen)
{
  foreground_pixel = colors[(int)pen];

#ifdef DOGL
  if (*fullgl && !*ifdogl) {
	if (isdraw) {
	   glEnd();
	   isdraw = 0;
        }
	glColor3f(((GLfloat) colorr[(int) pen]) / 65535.0,
		  ((GLfloat) colorg[(int) pen]) / 65535.0,
		  ((GLfloat) colorb[(int) pen]) / 65535.0);
  } else {
#endif
	XSetForeground(display, gc, foreground_pixel);
#ifdef DOGL
  } 
#endif

}

#if defined(VMS) || defined(UNDERSC)
void setcol(pen)
#else
#ifdef CRAY
void SETCOL(pen)
#else
void setcol_(pen)
#endif
#endif
int *pen;
{
unsigned long f_pixel;

  if (!xison) return;

  if (*pen < MAX_COLORS && *pen >= 0) {
	f_pixel = colors[*pen];
	XSetForeground(display, gc, f_pixel);
  }

}

static int CheckForConfig()
{
  XEvent ev;
  char   foo;

  /* returns true if there's a config event in which mainW changes size
     in the event queue */

  foo = 0;
  XCheckIfEvent(display, &ev, IsConfig, &foo);
  return foo;
}

static Bool IsConfig(dpy, ev, arg)
Display *dpy;
XEvent  *ev;
char    *arg;
{
  XConfigureEvent *cev;

  if (ev->type == ConfigureNotify) {
    cev = (XConfigureEvent *) ev;
    if (cev->window == win && (cev->width != width || cev->height != height))
      *arg = 1;
  }
  return False;
}

static int v2d;

void gl2DInit()
{

#ifdef DOGL
    if (*fullgl && !*ifdogl && !isgl2D) {
	v2d = width;
	if (v2d > height) v2d = height;
	glViewport(0,0,v2d,v2d);
        glXMakeCurrent(display,win,cx);
	glClearColor(0.0,0.0,0.0,1.0);
	glDisable(GL_LIGHTING);           
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLineWidth(1.0);
	glMatrixMode (GL_MODELVIEW);
	glLoadIdentity ();
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	gluOrtho2D(-1.0, 1.0, -1.0, 1.0);
        glEnable(GL_COLOR_MATERIAL);
	glRasterPos2f(-1.0,-1.0);
	isdraw = 0;
	isgl2D = 1;
	if (StarNet) {
	   if (!glIsList(theDens)) {
		theDens = glGenLists(1);
		glNewList(theDens, GL_COMPILE_AND_EXECUTE);
	   }
	}
    }
#endif
}

void gl2DEnd()
{
#ifdef DOGL
    if (*fullgl && !*ifdogl && isgl2D) {
	glEnd();
        glXSwapBuffers(display, win);
	if (StarNet) glDeleteLists(theDens,1);
        glDisable(GL_COLOR_MATERIAL);
        if (dogif && count > 0) {
           picnum++;
           if (picnum < *picmax) {
		glXWaitGL();
		sprintf(stemp, "%s%03d.gif",GifFile,picnum);
		WOGLGIF(stemp);
	   }
	}
	isgl2D = 0;
    }
#endif
}

void RedrawWin()
{
     int cnt = 0;
     int i;

     if (count <= 0) return;

#ifdef DOGL
     if (*fullgl) {
	gl2DInit();
     } else {
#endif
	if ( molback ==  molcur ) {
	  if (denmode) XSetForeground(display, gc, colors[0]);
	  else XSetForeground(display, gc, colors[IBGcolor]);
          XFillRectangle(display,molcur,gc,0,0,width,height);
          XSetForeground(display, gc, WhitePixel(display,screen));
	} else {
          XClearWindow(display,win);
	}
#ifdef DOGL
     }
#endif

     for (i=1; i<=count; i++)  
     {
       switch(savecom[i].evtype){

       case MovePen : {
          movexy(savecom[i].xxval,savecom[i].yyval);
          }
       break;

       case DrawLine : {
          drawxy(savecom[i].xxval,savecom[i].yyval);
          }
       break;


       case DrawString : {
          cnt++;
          drawstring(savecom[i].xxval,savecom[i].yyval,
                     &savestr[cnt][0],nsavestr[cnt]);
          }
       break;
 

       case SolidLine : {
#if defined(VMS) || defined(UNDERSC)
          sollin();
#else
#ifdef CRAY
	  SOLLIN();
#else
	  sollin_();
#endif
#endif
          }
       break;

       case DashedLine : {
          dashline();
          }
       break;

       case LineWidth : {
#if defined(VMS) || defined(UNDERSC)
          cwidth(&savecom[i].xxval);
#else
#ifdef CRAY
          CWIDTH(&savecom[i].xxval);
#else
          cwidth_(&savecom[i].xxval);
#endif
#endif

          }
       break;

       case ChangeColor : {
          changepen(savecom[i].xxval);
          }
       break;

       case FillPoly : {
	  poldrw(savecom[i].points,&savecom[i].npoints,
		&savecom[i].icol,&savecom[i].icon,&savecom[i].isgrey);
          }
       break;
       default: break;
       } /* end command switch */
     } /*end for */

#ifdef DOGL
     if (*fullgl) {
	gl2DEnd();
     } else {
#endif
        if ( molback == molcur ) 
		XCopyArea(display,molcur,win,gc,0,0,width,height,0,0);
#ifdef DOGL
     }
#endif

} /* end ReDraw */

#if defined(VMS) || defined(UNDERSC)
void gethei(hei)
#else
#ifdef CRAY
void GETHEI(hei)
#else
void gethei_(hei)
#endif
#endif
int *hei;
{ 
  *hei = height;
  return;
}

#if defined(VMS) || defined(UNDERSC)
void drawseg(segments,npoints,iinv)
#else
#ifdef CRAY
void DRAWSEG(segments,npoints,iinv)
#else
void drawseg_(segments,npoints,iinv)
#endif
#endif

XSegment *segments;
int *npoints;
int *iinv;
{
  int con1,con2;

  if (!xison) return;

  if (*npoints == 1) {
     con1 = ((segments[0].x1 >= 0 && segments[0].y1 >= 0)  && 
             (segments[0].x1 <= (int) width && segments[0].y1 <= (int) height));
     con2 = ((segments[0].x2 >= 0 && segments[0].y2 >= 0)  && 
             (segments[0].x2 <= (int) width && segments[0].y2 <= (int) height));
     if (con1 || con2) {
	if (monoscr && *iinv) XSetFunction(display,gc,GXxor);
	XDrawSegments(display, molcur, gc, segments, *npoints);
	if (monoscr && *iinv) XSetFunction(display,gc,GXcopy);
     }
     return;
  }
  if (monoscr && *iinv) XSetFunction(display,gc,GXxor);
  XDrawSegments(display, molcur, gc, segments, *npoints);
  if (monoscr && *iinv) XSetFunction(display,gc,GXcopy);

}

#if defined(VMS) || defined(UNDERSC)
void drwseg(segments,npoints,iinv)
#else
#ifdef CRAY
void DRWSEG(segments,npoints,iinv)
#else
void drwseg_(segments,npoints,iinv)
#endif
#endif

XSegment *segments;
int *npoints;
int *iinv;
{
  XDrawSegments(display, win, gc, segments, *npoints);

}

#if defined(VMS) || defined(UNDERSC)
void drwpol(points,npoints,icol,icon,isgrey,rec)
#else
#ifdef CRAY
void DRWPOL(points,npoints,icol,icon,isgrey,rec)
#else
void drwpol_(points,npoints,icol,icon,isgrey,rec)
#endif
#endif

XPoint *points;
int *npoints;
int *icol;
int *icon;
int *isgrey;
int *rec;
{
/*  XPoint *tempp;*/
  int i;

  if (!xison) return;

  if (*rec) {
     if ( count < MAXSAVE-1 ) {
       count++;
       savecom[count].evtype = FillPoly;
       savecom[count].points = (XPoint *) malloc(sizeof(XPoint)*(*npoints));
	for (i=0; i<*npoints; i++)  savecom[count].points[i] = points[i];
       savecom[count].npoints = *npoints;
       savecom[count].icol = *icol;
       savecom[count].icon = *icon;
       savecom[count].isgrey = *isgrey;
     }
  }
  XSetForeground(display, gc, colors[*icol]);
  if (*icon == 1) XFillPolygon(display,molcur,gc,points,*npoints,Convex,CoordModeOrigin);
  else {
#if defined(VMS) || defined(UNDERSC)
        if (*isgrey == 1) ststip();
#else
#ifdef CRAY
        if (*isgrey == 1) STSTIP();
#else
        if (*isgrey == 1) ststip_();
#endif
#endif
       XFillPolygon(display,molcur,gc,points,*npoints,Nonconvex,CoordModeOrigin);
#if defined(VMS) || defined(UNDERSC)
        if (*isgrey == 1) unstip();
#else
#ifdef CRAY
        if (*isgrey == 1) UNSTIP();
#else
        if (*isgrey == 1) unstip_();
#endif
#endif
  }
  if (colcells < 256 || (*icon == 0 && colcells >= 256) ) {
     if (monoscr) {
         XSetForeground(display, gc, colors[0]);
         if (isdash) XSetLineAttributes(display, gc, linwid, LineSolid, CapButt, JoinMiter);
     }
     else XSetForeground(display, gc, colors[2]);
     if (*icon == 0 && *isgrey == 1 && !monoscr) XSetForeground(display, gc, colors[1]);
     XDrawLines(display,molcur,gc,points,*npoints,CoordModeOrigin);
     if (monoscr && isdash) dashline();
/*     tempp = points;
     XDrawSegments(display, molcur, gc, tempp, 1);
     tempp++;
     XDrawSegments(display, molcur, gc, tempp, 1);
     tempp++;
     XDrawSegments(display, molcur, gc, tempp, 1);*/
  }

}

void glpoly(points,npoints,icol)
XPoint *points;
int npoints;
int icol;
{
  int i;

#ifdef DOGL
  GLfloat g0x, g0y, g1x, g1y, g2x, g2y;

     glDisable(GL_DEPTH_TEST);
     glDisable(GL_COLOR_MATERIAL);

     glColor3f(((GLfloat) colorr[icol]) / 65535.0,
	  ((GLfloat) colorg[icol]) / 65535.0,
	  ((GLfloat) colorb[icol]) / 65535.0);

     g0x = (((GLfloat) points[0].x/height) - xoff)*scale*2.0 - 1.0;
     g0y = (1.0 - ((GLfloat) points[0].y/height) - yoff)*scale*2.0 - 1.0;

     glBegin(GL_POLYGON);

     for (i=1; i<npoints-1; i++) {
	g1x = (((GLfloat) points[i].x/height) - xoff)*scale*2.0 - 1.0;
	g1y = (1.0 - ((GLfloat) points[i].y/height) - yoff)*scale*2.0 - 1.0;
	g2x = (((GLfloat) points[i+1].x/height) - xoff)*scale*2.0 - 1.0;
	g2y = (1.0 - ((GLfloat) points[i+1].y/height) - yoff)*scale*2.0 - 1.0;
	
	glVertex2f(g0x,g0y);
	glVertex2f(g1x,g1y);
	glVertex2f(g2x,g2y);
     }

     glEnd();

#endif

}

void poldrw(points,npoints,icol,icon,isgrey)
XPoint *points;
int *npoints;
int *icol;
int *icon;
int *isgrey;
{
  XPoint *tmppnts;
  int i;
#ifdef DOGL
  GLfloat g0x, g0y, g1x, g1y, g2x, g2y;
#endif

  if (!xison) return;

#ifdef DOGL
  
  if (*fullgl && !*ifdogl) {

     if (isdraw) {
	glEnd();
	isdraw = 0;
     }

     glpoly(points,*npoints,*icol);

     glColor3f(((GLfloat) colorr[2]) / 65535.0,
	  ((GLfloat) colorg[2]) / 65535.0,
	  ((GLfloat) colorb[2]) / 65535.0);

     if (*icon == 0 && *isgrey == 1) {
        glColor3f(((GLfloat) colorr[1]) / 65535.0,
	  ((GLfloat) colorg[1]) / 65535.0,
	  ((GLfloat) colorb[1]) / 65535.0);
     }

     glBegin(GL_LINES);
     glLineWidth(3.0);
     for (i=0; i<*npoints; i++) {
	g0x = (((GLfloat) points[i].x/height) - xoff)*scale*2.0 - 1.0;
	g0y = (1.0 - ((GLfloat) points[i].y/height) - yoff)*scale*2.0 - 1.0;
	glVertex2f(g0x,g0y);
     }
     glEnd();
  }

     

#else
  tmppnts = (XPoint *) malloc(sizeof(XPoint)*(*npoints));
  for (i=0; i<*npoints; i++) {
      tmppnts[i].x = (short) (((float) points[i].x - xoff)*scale);
      tmppnts[i].y = (short) (((float) points[i].y - yoff)*scale);
  }

  XSetForeground(display, gc, colors[*icol]);

  if (*icon == 1) 
	XFillPolygon(display,molcur,gc,
	tmppnts,*npoints,Convex,CoordModeOrigin);
  else {

#if defined(VMS) || defined(UNDERSC)
        if (*isgrey == 1) ststip();
#else
#ifdef CRAY
        if (*isgrey == 1) STSTIP();
#else
        if (*isgrey == 1) ststip_();
#endif
#endif
       XFillPolygon(display,molcur,gc,
	tmppnts,*npoints,Nonconvex,CoordModeOrigin);

#if defined(VMS) || defined(UNDERSC)
        if (*isgrey == 1) unstip();
#else
#ifdef CRAY
        if (*isgrey == 1) UNSTIP();
#else
        if (*isgrey == 1) unstip_();
#endif
#endif
  }

  if (colcells < 256 || (*icon == 0 && colcells >= 256) ) {
     if (monoscr) {
         XSetForeground(display, gc, colors[0]);
         if (isdash) XSetLineAttributes(display, gc, linwid, LineSolid, CapButt, JoinMiter);
     }
     else XSetForeground(display, gc, colors[2]);
     if (*icon == 0 && *isgrey == 1 && !monoscr) XSetForeground(display, gc, colors[1]);
     XDrawLines(display,molcur,gc,tmppnts,*npoints,CoordModeOrigin);
     if (monoscr && isdash) dashline();
  }
#endif

}

#if defined(VMS) || defined(UNDERSC)
void plsph(xori,yori,fwidth,ia)
#else
#ifdef CRAY
void PLSPH(xori,yori,fwidth,ia)
#else
void plsph_(xori,yori,fwidth,ia)
#endif
#endif

int *xori;
int *yori;
int *fwidth;
int *ia;
{
  int xc,yc,xce,yce;
  unsigned int wi,hi,wi1;

  wi = (unsigned int) *fwidth;
  hi = wi;

  xc = *xori - wi/2;
  yc = *yori - hi/2;
  xce = *xori + wi/2;
  yce = *yori + hi/2;

  if (xce < 0 && yce < 0) return;
  if (xc > (int) width && yc > (int) height) return;

  XFillArc(display, molcur, gc, xc,yc, wi, hi, 0,360*64);

  XSetBackground(display, gc, BlackPixel(display,screen));
  XSetFillStyle(display,gc,FillOpaqueStippled);
  XSetStipple(display,gc,stipple);
  XFillArc(display, molcur, gc, xc,yc, wi, hi, 90*64,180*64);

  XSetFillStyle(display,gc,FillSolid);
  wi1 =  wi*0.50;
  XFillArc(display, molcur, gc, *xori - wi1/2,yc, wi1, hi, 0,360*64);
  if (*ia >= 2 && (ZMEup || cflag || ATMup || SelDel || ONIup || scoup)) {
     XSetForeground(display, gc, colors[rimcols[*ia]]);
     XDrawArc(display, molcur, gc, xc,yc, wi, hi, 0,360*64);
  }

}

#if defined(VMS) || defined(UNDERSC)
void plsel(xori,yori,ia)
#else
#ifdef CRAY
void PLSEL(xori,yori,ia)
#else
void plsel_(xori,yori,ia)
#endif
#endif

int *xori;
int *yori;
int *ia;
{
  int xc,yc;
  unsigned int wi;

  wi = 20;

  xc = *xori - wi/2;
  yc = *yori - wi/2;

  if (*ia >= 2 && (ZMEup || cflag || ATMup || SelDel || ONIup || scoup)) {
     XSetForeground(display, gc, colors[rimcols[*ia]]);
     XFillArc(display, molcur, gc, xc,yc, wi, wi, 0,360*64);
  }

}


#if defined(VMS) || defined(UNDERSC)
void ststip()
#else
#ifdef CRAY
void STSTIP()
#else
void ststip_()
#endif
#endif
{
  if (monoscr) {
     XSetFillStyle(display,gc,FillOpaqueStippled);
     XSetStipple(display,gc,stipple);
  }
}


#if defined(VMS) || defined(UNDERSC)
void unstip()
#else
#ifdef CRAY
void UNSTIP()
#else
void unstip_()
#endif
#endif
{
  if (monoscr) {
     XSetFillStyle(display,gc,FillSolid);
  }
}

#if defined(VMS) || defined(UNDERSC)
void doexp()
#else
#ifdef CRAY
void DOEXP()
#else
void doexp_()
#endif
#endif
{
     if (*doesp && !denmode) PlotColIndex();

     if ( molback == molcur ) {
          XCopyArea(display,molcur,win,gc,0,0,width,height,0,0);
     }
     if (dogif) {
        picnum++;
	if (picnum < *picmax) {
/*
	    sprintf(stemp, "convert X:MOLDEN gif87:%s%d.gif",GifFile,picnum);
	    system(stemp);
*/
	   sprintf(stemp, "%s%03d.gif",GifFile,picnum);
	   ToGIF(molcur,stemp);
	}
     }
}

void doclr()
{

    if (denmode && *ifdogl) return;
    if (!xison) return;

    if ( molback ==  molcur ) {

       if (denmode) XSetForeground(display, gc, colors[0]);
       else XSetForeground(display, gc, colors[IBGcolor]);
       XFillRectangle(display,molcur,gc,0,0,width,height);
       XSetForeground(display, gc, WhitePixel(display,screen));
         
    }
    else {
       XGetWindowAttributes(display, win, &xwa);

       if ( (xwa.width  != width ) || (xwa.height != height) )
       {
            width  = xwa.width;
            height = xwa.height;
       }                      

       XClearArea(display, win, 0,0,0,0,0);
    }
} 

#if defined(VMS) || defined(UNDERSC)
void dlogo()
#else
#ifdef CRAY
void DLOGO()
#else
void dlogo_()
#endif
#endif
{
     XSetBackground(display, gc, infobg);
     XSetForeground(display, gc, infofg);
     XCopyPlane(display,molPix,molcur,gc,0,0,mol_width,mol_height,15,15,(unsigned long)1);
}

#define QPOSINT  1
#define QPOSREAL 2
#define QREAL    3
#define QSTRING  0

void TrmStr(qp)
QBOXSTRU        *qp;
{
  int len,i,j;

  len = strlen(qp->str);

  j = len;
  for (i=len-1; i >= 0; i--) {
	if (qp->str[i] != ' ') {
	   j = i+1;
	   break;  
	}
  }
  
  len = j;
  qp->str[len] = '\0';
}

void molcopy(obj, cop, len)
     const char *obj;
     char *cop;
     int len;
{

  if (obj == cop || len <= 0) return;

  if (obj < cop && obj+len > cop) { 

    obj = obj + len - 1;
    cop = cop + len - 1;
    for ( ; len>0; len--, obj--, cop--) *cop = *obj;

  } else { 

    for ( ; len>0; len--, obj++, cop++) *cop = *obj;

  }
}

int DirKey(qp,c,ks)
QBOXSTRU	*qp;
int c;
KeySym ks;
{
  int len, retval;

  if(DEBUG)fprintf(stderr,"DirKey in\n");

  if (qp->fake) return(-1);

  retval = -1;
  if (qp->str == NULL) {
	len = 0;
  } else {
	len = strlen(qp->str);
  }
  if (qp->curpos < 0) qp->curpos = 0;
 
  if (qp->qbopt > QSTRING ) { 
    if ((c>='\060' && c<='\071') || (c=='+' && qp->qbopt == QREAL) 
    || (c=='-' && qp->qbopt == QREAL) || (c=='.' && qp->qbopt >= QPOSREAL)) {
            if (len >= qp->strmax) {
		if (*ibell) XBell(display,0); 
		return(-1);
	    }
	    molcopy(&qp->str[qp->wnd_start+qp->curpos],
		    &qp->str[qp->wnd_start+qp->curpos+1],
		    (len-(qp->wnd_start+qp->curpos)+1));
            qp->str[qp->wnd_start+qp->curpos]=c; retval = 0;
	    qp->curpos++;
    }
  }
  else 
  {
   if (c>=' ' && c<'\177') { 
    if (len >= qp->strmax) {
	if (*ibell) XBell(display,0); 
	return(-1);
    }
    molcopy(&qp->str[qp->wnd_start+qp->curpos],
	    &qp->str[qp->wnd_start+qp->curpos+1],
	    (len-(qp->wnd_start+qp->curpos)+1));
    qp->str[qp->wnd_start+qp->curpos]=c; retval = 0;
    qp->curpos++;
   }
  }

  if (ks==XK_Left) {
        if (qp->curpos > 0) {
	   qp->curpos--; retval = 0;
	} else {
	   if (qp->wnd_start > 0) {
		qp->wnd_start--; retval = 0;
	   }
	}
  }

  if (ks==XK_Right) {
        if (qp->curpos == qp->wlen) {
	   if (qp->wnd_start < (qp->strmax - qp->wlen)) {
	      if (strlen(qp->str) > qp->wlen) {
	      if (qp->wnd_start < (strlen(qp->str) - qp->wlen)) {
		if (qp->wnd_start < strlen(qp->str)) {
		   qp->wnd_start++; retval = 0;
		}
	      }
	      }
	   }
	} else if (qp->curpos <= qp->wlen && qp->curpos < strlen(qp->str)) {
	   qp->curpos++; retval = 0;
	}
  }

  if (retval) {
     if (c=='\010' && qp->curpos > 0) {
        if (len==0) {
	   if (*ibell) XBell(display,0); 
	   return(-1);
	}
	molcopy(&qp->str[qp->wnd_start+qp->curpos],
		&qp->str[qp->wnd_start+qp->curpos-1],
		(len-(qp->wnd_start+qp->curpos)+1));
	qp->curpos--;
     }

     else if (c=='\004' || c=='\177') {
        if (len==0) {
	   if (*ibell) XBell(display,0); 
	   return(-1);
	}
	molcopy(&qp->str[qp->wnd_start+qp->curpos+1],
		&qp->str[qp->wnd_start+qp->curpos],
		(len-(qp->wnd_start+qp->curpos)));
     }

     else if (c=='\025' || c=='\013') {
       qp->str[0] = '\0';
     }

     else if (c=='\012' || c=='\015') {
       return(-2);
     }

     else {
	if (*ibell) XBell(display,0); 
	return(-1);
     }

  }

  PromptBox(qp);
  return(0);
}

int ChkKey(qp,c)
QBOXSTRU	*qp;
int c;
{
  int retval;

  if (qp->fake) return(-1);

  retval = -1;
 
  if (qp->qbopt > QSTRING ) { 
    if ((c>='\060' && c<='\071') || (c=='+' && qp->qbopt == QREAL) 
    || (c=='-' && qp->qbopt == QREAL) || (c=='.' && qp->qbopt >= QPOSREAL))
             retval = 0;
  } else if (c>=' ' && c<'\177') retval = 0;

  return(retval);
}

int KeyChk(qp,c,ks)
QBOXSTRU	*qp;
int c;
KeySym ks;
{
     int retval;

     if (DEBUG) fprintf(stderr,"KeyChk in\n");

     if (qp == NULL) return(0);
     if (qp->fake) return(0);

     qp->changed = 1;

     retval = 0;

     if (DirKey(qp,c,ks) == -2) {

          retval = 1;
          if (qp->pop) {
		XDestroyWindow(display,qp->win);
		XSync(display, False);
		qp->active = 0;
		if (qp->win == QBox) qboxup = 0;
	  }

//          if (ks != XK_Return) *Sinct = qp->qbinct;
          *Sinct = qp->qbinct;

          if (qp->qbopt == 1) *Sincp = atoi(qp->str);
          else {
		cpstr(qp->str,Sstr,strlen(qp->str));
                *Snstr = strlen(qp->str);
          }
	  if (qp->iflt != NULL) *qp->iflt = atoi(qp->str);
	  if (qp->i2flt != NULL) *qp->i2flt = atoi(qp->str);
	  if (qp->qflt != NULL) *qp->qflt = atof(qp->str);
	  if (qp->dflt != NULL) *qp->dflt = atof(qp->str);

          if (qp->win == ZMEwin) {
             if (*backb) {ActBut(&cbut[BDECRF],1); ActBut(&cbut[BUNSC],1);}
             ActBut(&cbut[BDIST],1);
             ActBut(&cbut[BANGLE],1);
             ActBut(&cbut[BDIHED],1);
             ActBut(&cbut[BREADF],1);
             if (denm) ActBut(&cbut[BDENMOD],1);
             *iwropt = ZMEopt-ZMEGAM + 1; 
	     if (*iwropt == 5) *iwropt = 7;
          }

          if (qp->win == ATMwin && qp->qbopt == QREAL) qdpptr->ihasq = 1;

	  if (qp->shfilint == -1) {
		qp->callback(qp->str);
	  } else {
		qp->callback(&shfiles[qp->shfilint],qp->str);
	  }

          if (qp->win == COMMwin ) {
	     update_model = 1;
	  }

          if (qp->win == RESwin ) {
             if (strstr(qp->str,"neigh")) {
		bflag = 1; retval = 0; bretval = 460;
		strcpy(molwstr,"Click on residu/hetatm to activate !");
		StatusStr(0,1);
		XDefineCursor(display,win,AtomCursor);
             } else if (strstr(qp->str,"col")) {
                if (!monoscr) {
		    if (DoPopUp(RESwin,0,0,NULL,Sincp,0) == -1) *Sincp = 0;
		}
                else *Sincp = 0;
	     }
             else *Sincp = 0;
	     strcpy(qp->str,DEFSTRNAME);
	     qp->curpos = 0;
	     PromptBox(qp);
	     update_model = 1;
          }
     }

     return(retval);
}

void PFake(win,x,y,w,h,bgcol)
Window win;
int x;
int y;
int w;
int h;
int bgcol;
{
   XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinMiter);
   if (bgcol == -1) XSetForeground(display, gc, White);
   else XSetForeground(display, gc, colors[bgcol]);
   XDrawRectangle(display, win, gc, x, y, w-QBOXFR, h-14);
   XFillRectangle(display, win, gc, x, y, w-QBOXFR, h-14);
   XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
   XSetForeground(display, gc, Black);
}

void PromptBox(qp)
QBOXSTRU	*qp;
{
  int qlen,tpos,cpos;
  int xpos,ypos;
  int RectThick,wlen;

  if (DEBUG) fprintf(stderr,"PromptBox in\n");

  if (qp->fake) {
	PFake(qp->win,qp->x,qp->y,qp->w,qp->h,qp->bgcol);
	return;
  }

  if (qp->prompt != NULL) {
	qlen = XTextWidth(mfinfo,qp->prompt, strlen(qp->prompt));
	qlen = qlen + 5;
  }
  else qlen = 0;

  RectThick = 2;
  if (!qp->active) RectThick = -1*RectThick;
  tpos = (qp->h-14-10)/2; tpos = 10 + tpos;
  if (tpos < 0) tpos = 0;
  butje(qp->win,qp->x+qlen,qp->y,qp->w-qlen-QBOXFR,qp->h-14,QBOXFR,qp->bgcol,qp->col,0,None,0,0,0,RectThick);
  if (qp->prompt != NULL) XDrawString(display, qp->win, gc, qp->x, qp->y+tpos, qp->prompt, strlen(qp->prompt));

  xpos = qp->x+qlen+QBOXFR+QBOXBORD;
  ypos = qp->y+tpos;

  wlen = qp->wlen;
  if (qp->strmax < wlen) wlen = qp->strmax;
  if (qp->str != NULL) {
     if (strlen(qp->str) < wlen) wlen = strlen(qp->str);

     XDrawString(display, qp->win, gc, xpos, ypos, 
	&qp->str[qp->wnd_start], wlen);
  }

  if (qp->active) {
	ypos = ypos - ASCENT;
	cpos = XTextWidth(mfinfo, &qp->str[0], qp->curpos);
	XDrawLine(display, qp->win, gc, xpos+cpos, ypos-1, 
					xpos+cpos, ypos+CHIGH);
	XDrawLine(display, qp->win, gc, xpos+cpos, ypos+CHIGH, 
					xpos+3+cpos, ypos+CHIGH+3);
	XDrawLine(display, qp->win, gc, xpos+cpos, ypos+CHIGH, 
					xpos-2+cpos, ypos+CHIGH+2);
  }

  if (qp->win == QBox && qp->active) {
	DrwBut(&qboxclose[0]);
	DrwBut(&qboxclose[1]);
  }
  XFlush(display);

  if (DEBUG) fprintf(stderr,"PromptBox out\n");
}

int ClickBox(qbox,num,x,y)
QBOXSTRU	*qbox;
int x,y,num;
{
  int qlen;
  int bnum;
  int slen;
  double rtmp;
  QBOXSTRU *qp;

  bnum = -1;

  for (bnum=0; bnum<num; bnum++) {
    qp = &qbox[bnum];
    if (!qp->fake) {
	if (qp->prompt != NULL) {
	    qlen = XTextWidth(mfinfo,qp->prompt, strlen(qp->prompt));
	    qlen = qlen + 5;
	}
	else qlen = 0;

	if (VIERKANT(x, y, qp->x+qlen, qp->y, qp->w-qlen-QBOXFR, 27)) {
	  if (qp->str != NULL) {
	    slen = XTextWidth(mfinfo,qp->str, strlen(qp->str));
	    rtmp = (double)  (x - (qp->x+qlen+QBOXFR+QBOXBORD))/slen;
	    if (rtmp > 1.0)  rtmp = 1.0;
	    if (rtmp < 0.0)  rtmp = 0.0;
	    qp->curpos = (int) (rtmp*((double) (strlen(qp->str))));
	    break;
	  }
	}
    }
  }

  if (bnum<num && bnum != -1)  return (bnum);

  return -1;

}

int CheckBox(qbox,num,win,x,y)
QBOXSTRU	*qbox;
Window win;
int x,y,num;
{
  int qlen;
  int bnum;
  QBOXSTRU *qp;

  bnum = -1;

  for (bnum=0; bnum<num; bnum++) {
    qp = &qbox[bnum];
    if (!qp->fake && win == qp->win && !qp->active) {
	if (qp->prompt != NULL) {
	    qlen = XTextWidth(mfinfo,qp->prompt, strlen(qp->prompt));
	    qlen = qlen + 5;
	}
	else qlen = 0;

	if (VIERKANT(x, y, qp->x+qlen, qp->y, qp->w-qlen-QBOXFR, 27)) break;
    }
  }

  if (bnum<num && bnum != -1)  return (bnum);

  return -1;

}

void qboxstr(qp,win,active,fake,bgcol,x,y,w,h,col,prompt,defstr,strmax,iopt,qinct,mxstr,callback)
QBOXSTRU	*qp;
Window		*win;
int		active;
int		fake;
int		bgcol;
int		x,y,w,h;
int		col;
char		*prompt;
char		*defstr;
int		strmax;
int		iopt;
int		qinct;
int		mxstr;
ptr_void_proc	callback;
{
  int lchr,qlen,mx;

  qp->active = active;
  qp->fake = fake;
  qp->bgcol = bgcol;
  qp->x = x;  qp->y = y;  qp->w = w;  qp->h = h;
  qp->col = col;
  qp->iflt = NULL;
  qp->i2flt = NULL;
  qp->qflt = NULL;
  qp->dflt = NULL;
  qp->changed = 0;
  qp->shfilint = -1;
  qp->expldone = 0;

  if (win == NULL) {
       if (qboxup) {
	   XDestroyWindow(display,QBox);
	   XSync(display, False);
       }
       QBox = CreateWindow("Molden Query Box",DEFQBOXGEOM,QBOXWIDE,QBOXHIGH+30,
                            infobg,infofg,(Window)0);
       qboxup = 1;
       qp->win = QBox;
       qp->pop = 1;
       XSelectInput(display, QBox, 
	ExposureMask | KeyPressMask | ButtonPressMask | EnterWindowMask);
       XMapWindow(display,QBox);
  }
  else {qp->win = *win; qp->pop = 0;}

  if (mxstr != -1) {
     qp->str = (char *) malloc(sizeof(char)*(MAXPATHLEN+1));
     mx = MAXPATHLEN;
  } else {
     qp->str = (char *) malloc(sizeof(char)*(MAXSTRLEN+1));
     mx = MAXSTRLEN;
  }

  memset(qp->str,'\0',sizeof(*qp->str));
  memset(qp->str,'\0',mx+1);
  if (defstr == NULL) strcpy(qp->str,DEFSTRNAME);
  else strcpy(qp->str,defstr);
  if (strmax) {
	qp->strmax = strmax;
	if (strmax > mx)
	  fprintf(stderr,"qboxstr: strmax longer than allowed\n");
  } else qp->strmax = mx;

  qp->wnd_start = 0;
  qp->curpos = strlen(qp->str);
  qp->prompt = prompt;

  qp->qbopt = iopt;
  qp->qbinct = qinct;
  qp->callback = callback;

  lchr = XTextWidth(mfinfo," ",1);
  if (qp->prompt != NULL) {
	qlen = XTextWidth(mfinfo,qp->prompt, strlen(qp->prompt));
	qlen = qlen + 5;
  } else {
	qlen = 0;
  }

  qp->wlen = (qp->w - qlen - 2*QBOXFR - 2*QBOXBORD) / lchr;

  if (qp->win == QBox) {
	DefBut(&qboxclose[0], QBox, 10, QBOXHIGH, 50, 23,
	"Apply", infobg, -15);
	DefBut(&qboxclose[1], QBox, 70, QBOXHIGH, 50, 23,
	"Cancel", infobg, -15);
  }


}

void dummyproc()
{
 int i;

 i = 1;
/*
 fprintf(stderr,"I am a dummy\n");
*/
}


int QBoxPaste(ParWin,qp,nboxes)
Window ParWin;
QBOXSTRU *qp;
int nboxes;
{
int i, j, ret_val, is_ok,format,done;
unsigned long len,bytes_left;
Atom type, XA_CLIPBOARD;

   done = 0;
   ret_val = 0;
   for (i=0; i<nboxes; i++) {
	if (ParWin == qp[i].win && qp[i].active) {
		ret_val = 1;
		nbytes_select = 0;
		if (XGetSelectionOwner(display,XA_PRIMARY)) {
		   XConvertSelection(display,XA_PRIMARY,XA_STRING,XA_PRIMARY,
					qp[i].win,CurrentTime);
		   XFlush(display);
		   while (!done) {
			XNextEvent(display, &event);
			switch (event.type) {
			case SelectionNotify:    
			   if (XGetWindowProperty(display,qp[i].win,
					XA_PRIMARY, 0,10000000L,True,XA_STRING,
					&type,&format,&len,&bytes_left,
				(unsigned char**) &select_pointer) == Success) {
				if (type == XA_STRING) 
					nbytes_select = (int) len;
			   }
			   done = 1;
			   break;
			case SelectionClear:    
			   done = 1;
			   break;
			}
		   }

		}
		if (nbytes_select == 0) {
		   select_pointer = XFetchBytes(display, &nbytes_select);
		}
		if (nbytes_select >= MAXPATHLEN) 
			nbytes_select = MAXPATHLEN-1;
		if (nbytes_select >= qp[i].strmax) 
			nbytes_select = qp[i].strmax;
		if (select_pointer != NULL) {
			is_ok = 1;
			for (j=0; j<nbytes_select; j++)
			   if (ChkKey(&qp[i],select_pointer[j])) is_ok = 0;
			if (is_ok) {
			   int len,na,nb;
			   len = strlen(qp[i].str);
			   nb = qp[i].strmax - (len + nbytes_select);
			   na = qp[i].strmax - (qp[i].curpos + nbytes_select);
			   if (na > 0) na = 0;
			   
			   if (qp[i].curpos + nbytes_select <= qp[i].strmax)
				molcopy(&qp[i].str[qp[i].curpos],
				   &qp[i].str[qp[i].curpos+nbytes_select],
				   (len-qp[i].curpos+1+nb));
			   molcopy(select_pointer,
				   &qp[i].str[qp[i].curpos],nbytes_select+na);
			   if (na < 0) qp[i].str[qp[i].strmax] = '\0';
			   PromptBox(&qp[i]);
			} else if (*ibell)  XBell(display,0);
		}
	}
   }
   return (ret_val);
}

void RedrawList(lp)
LISTSTRU *lp;
{
 int itm;
 
 itm  = QBOXWIDE;
 if (lp->wwin) itm = lp->wwin;

/* Label Box */

      XSetForeground(display, gc, infobg);
      if (lp->label != NULL) {
	  butje(lp->win,0,0,itm,lp->y-4,4,0,0,1,None,0,0,0,0);
	  LineString(lp->win,lp->label,lp->x+5,lp->y-15);
      }

/* List Box 3d BackGround */

      if (monoscr) {
          XSetFillStyle(display, gc, FillStippled);
          XSetStipple(display, gc, hlfgrey);
          XSetForeground(display, gc, infobg);
          XFillRectangle(display, lp->win, gc, 0, lp->y, itm, lp->h+1);
          XSetFillStyle(display,gc,FillSolid);}
      else butje(lp->win,0,lp->y-5,itm,lp->h+10,4,0,0,1,None,0,0,0,0);

/* the central ListBox */

      RedrawLBox(lp);

/* The scrollbar */

      RedrawScroll(&lp->scrbar);

      DrwBut(&lp->arrbut[0]);
      DrwBut(&lp->arrbut[1]);
      XFlush(display);
      XSync(display, False);
}

void ParseLGAM()
{
   if (jobcom->ibatch) {
      if (iresopt) {
	sprintf(rungam,"$GAMESS_ROOT/utilities/rungamess %s -n %s %s",
		reskey[iresopt],qboxes[QENAME].str,qboxes[QJNAME].str);
      } else {
	sprintf(rungam,"$GAMESS_ROOT/utilities/rungamess %s",
		qboxes[QJNAME].str);
      }
   } else {
      if (iresopt) {
	sprintf(rungam,
	   "$GAMESS_ROOT/utilities/rungamess %s -n %s %s -nqs -q %s",
	   reskey[iresopt],qboxes[QENAME].str,qboxes[QJNAME].str,
#ifdef DOQUEUE
	   ques[qopt]);
#else
	   qboxes[QQNAME].str);
#endif
      } else {
	sprintf(rungam,"$GAMESS_ROOT/utilities/rungamess %s -nqs -q %s",
		qboxes[QJNAME].str,
#ifdef DOQUEUE
		ques[qopt]);
#else
		qboxes[QQNAME].str);
#endif
      }
   }
}

int CheckChargeMult()
{
   int i,ne,ionil;

   ne = 0;

   ionil = 0;

   if (ioniom) {
     ionil = 3 - (lnkat / 10000);
     lnkat -= (lnkat / 10000) * 10000;
   } else {
     lnkat = 0;
   }

   if (*zmptrp->ihaszm) {
	for (i=0; i<*zmptrp->nz; i++) {
	   if (ioniom && (xyzp->ityp[i]/10000 >= ionil)) continue;
	   if (zmptrp->ianz[i] >= 0 && zmptrp->ianz[i] < 99) {
		ne = ne + zmptrp->ianz[i];
	   }
	}
   } else {
      if (jobcom->iwxyz) {
	for (i=0; i<*xyzp->iatoms; i++) {
	   if (ioniom && (xyzp->ityp[i]/10000 >= ionil)) continue;
	   if (xyzp->ianz[i] >= 0 && xyzp->ianz[i] < 99) {
		ne = ne + xyzp->ianz[i];
	   }
	}
      } else {
	return(0);
      }
   }
/*
   fprintf(stderr,"ionil %d ne %d itotc %d lnkat %d mult %d\n",
                   ionil,ne,jobcom->itotc,lnkat,jobcom->imult);
*/
   ne = ne - jobcom->itotc + lnkat;
   if (ne % 2 == jobcom->imult % 2) return(1);
   return(0);
}

void ParseLine()
{
   char *scfd;
   char *mopo;
   int i, isl, ism;

   if (jmode == 3) return;

   if (jmode == 1 && ONIup) {

	ism = isl = 0;
	for (i=0;i<*xyzp->iatoms;i++) {
	   if (xyzp->ityp[i] >= 20000) isl = 1;
	   if (xyzp->ityp[i] >= 10000 && xyzp->ityp[i] < 20000) ism = 1;
	}
	ioniom = 0;
	if (isl && ism) ioniom = 2;
	if ( (isl && ! ism) || (ism && ! isl) ) ioniom = 1;

	if (strcmp(mkey[imopth],"AM1") == 0 || 
	    strcmp(mkey[imopth],"dreiding") == 0 || 
	    strcmp(mkey[imopth],"Amber") == 0) {
   	   sprintf(*olev,"%s",mkey[imopth]);
	} else {
   	   sprintf(*olev,"%s/%s",mkey[imopth],bkey[ibopth]);
	}
	if (strcmp(mkey[imoptm],"AM1") == 0 || 
	    strcmp(mkey[imoptm],"dreiding") == 0 || 
	    strcmp(mkey[imoptm],"Amber") == 0) {
   	   sprintf(*(olev+1),"%s",mkey[imoptm]);
	} else {
   	   sprintf(*(olev+1),"%s/%s",mkey[imoptm],bkey[iboptm]);
	}
	if (strcmp(mkey[imoptl],"AM1") == 0 || 
	    strcmp(mkey[imoptl],"dreiding") == 0 || 
	    strcmp(mkey[imoptl],"Amber") == 0) {
   	   sprintf(*(olev+2),"%s",mkey[imoptl]);
	} else {
   	   sprintf(*(olev+2),"%s/%s",mkey[imoptl],bkey[iboptl]);
	}
/*
	if (ioniom == 0) DeActOButs();
	if (ioniom >= 1) ActOButs();
*/
   }

   if (imolopt[jmode] && jmode != 2) {

	if (ioniom == 0) {
	   sprintf(qboxes[QGLIN1].str,"#P %s/%s %s",
		mkey[imopt[jmode]],bkey[ibopt[jmode]],tkey[itopt[jmode]]);
	} else if(ioniom == 1) {
	   sprintf(qboxes[QGLIN1].str,"#P ONIOM(%s:%s) %s",
	      olev[0],olev[2],tkey[itopt[jmode]]);
	} else {
	   sprintf(qboxes[QGLIN1].str,"#P ONIOM(%s:%s:%s) %s",
	      olev[0],olev[1],olev[2],tkey[itopt[jmode]]);
	}  
   } else {
	if (jmode == 2) {

	   mopo = tkey[itopt[2]];
	   if (!imolopt[2] && itopt[2] == 1) mopo = nullstr;

           if (ispopt) {
	      if (icopt != 3) {
	        sprintf(qboxes[QGLIN1].str,"%s %s %s CHARGE=%s T=24.0H NOINTER +",
		mkey[imopt[jmode]],mopo,spopt[ispopt],copt[icopt]);
	      } else {
	        sprintf(qboxes[QGLIN1].str,"%s %s %s T=24.0H NOINTER +",
		mkey[imopt[jmode]],mopo,spopt[ispopt]);
	      }
	   } else {
	      if (icopt != 3) {
	        sprintf(qboxes[QGLIN1].str,"%s %s CHARGE=%s T=24.0H NOINTER +",
		mkey[imopt[jmode]],mopo,copt[icopt]);
	      } else {
	        sprintf(qboxes[QGLIN1].str,"%s %s T=24.0H NOINTER +",
		mkey[imopt[jmode]],mopo);
	      }
	   }
	} else {
	   if (ioniom == 0) {
	      sprintf(qboxes[QGLIN1].str,"# %s/%s %s",
		   mkey[imopt[jmode]],bkey[ibopt[jmode]],tkey[itopt[jmode]]);
	   } else if(ioniom == 1) {
	      sprintf(qboxes[QGLIN1].str,"# ONIOM(%s:%s) %s",
	         olev[0],olev[2],tkey[itopt[jmode]]);
	   } else {
	      sprintf(qboxes[QGLIN1].str,"# ONIOM(%s:%s:%s) %s",
	         olev[0],olev[1],olev[2],tkey[itopt[jmode]]);
	   }
 	}
   }
   qboxes[QGLIN1].wnd_start = 0;
   qboxes[QGLIN1].curpos = strlen(qboxes[QGLIN1].str);
 
   if (iscfd) {
	scfd = nullstr;
   } else {
	scfd = scfdir;
   }

   if (imolopt[jmode]) {
     if (jmode == 1) {
	if (imolopt[jmode] == 1) {
	   sprintf(qboxes[QGLIN2].str,"# GFINPUT IOP(6/7=3) 6D 10F %s",scfd);
	} else {
	   sprintf(qboxes[QGLIN2].str,"# GFINPUT IOP(6/7=1) 6D 10F %s",scfd);
	}
     } else if (jmode == 2) {
	if (imolopt[jmode] == 1) {
	   sprintf(qboxes[QGLIN2].str,"GRAPH AUX PRNT=2 COMPFG");
	}
     }
   } else {
	if (jmode == 2) {
	   sprintf(qboxes[QGLIN2].str," ");
	} else {
	   sprintf(qboxes[QGLIN2].str,"# %s",scfd);
	}
   }
   qboxes[QGLIN2].wnd_start = 0;
   qboxes[QGLIN2].curpos = strlen(qboxes[QGLIN2].str);

}

int CreateSUB(imd)
int imd;
{
  jmode = imd;
  if (jmode > 3) {
	if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
	"Not Implemented",0)) {
	}
	return(0);
  }

  SUBup = 1;
  topt = toph[jmode];
  tkey = tkeyh[jmode];
  toptn = topn[jmode];

  mopt = moph[jmode];
  mkey = mkeyh[jmode];
  moptn = mopn[jmode];

  bopt = boph[jmode];
  bkey = bkeyh[jmode];
  boptn = bopn[jmode];

  if (jmode == 2) {
     molopt = molopt2;
  } else if (jmode == 3) {
     molopt = molopt3;
  } else {
     molopt = molopt1;
  }

  SUBwin = CreateWindow(subwname[jmode],"-80-80",
			 SBOXWIDE,SBOXHIGH,infobg,infofg,(Window)0);
  XSelectInput(display, SUBwin, 
	ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask |
	EnterWindowMask);

  XMapWindow(display,SUBwin);

  WinObj[13].win = &SUBwin;
  WinObj[13].subwin = NULL;
  WinObj[13].butarr = sbut;
  WinObj[13].numbut = NBUTSS;
  WinObj[13].winup = &SUBup;
  WinObj[13].init = NULL;
  WinObj[13].redraw = RedrawSUB;

  DefBut(&sbut[STASK], SUBwin, SBOXOFFX, 20, SBOXBLEN, 23, 
	"Task", infobg, -15);
  DefBut(&sbut[SMETH], SUBwin, SBOXOFFX, 20+BUTTN, SBOXBLEN, 23, 
	"Method", infobg, -15);
  DefBut(&sbut[SBASS], SUBwin, SBOXOFFX, 20+2*BUTTN, SBOXBLEN, 23, 
	"Basis Set", infobg, -15);
  if (jmode == 2) ActBut(&sbut[SBASS],2);
  DefBut(&sbut[SCHAR], SUBwin, SBOXOFFX, 20+4*BUTTN, SBOXBLEN, 23, 
	"Charge", infobg, -15);
  DefBut(&sbut[SSPIN], SUBwin, SBOXOFFX, 20+5*BUTTN, SBOXBLEN, 23, 
	"Spin", infobg, -15);
  DefBut(&sbut[SMOLD], SUBwin, SBOXOFFL+100, 20+BUTTN, 110, 23, 
	"Molden", infobg, -15);
  if (!jmode) ActBut(&sbut[SMOLD],2);
  DefBut(&sbut[SREST], SUBwin, SBOXOFFL+100, 20+BUTTN, 110, 23, 
	"Restart", infobg, -15);
  if (jmode) ActBut(&sbut[SREST],2);
  DefBut(&sbut[SDIRE], SUBwin, SBOXOFFL+100, 24+2*BUTTN, 15, 15, 
	" ", infobg, -15);
  DefBut(&sbut[SZMAT], SUBwin, SBOXOFFL+200, 24+2*BUTTN, 15, 15, 
	" ", infobg, -15);
  DefBut(&sbut[SWXYZ], SUBwin, SBOXOFFL+230, 24+3*BUTTN, 15, 15, 
	" ", infobg, -15);
  DefBut(&sbut[SHESS], SUBwin, SBOXOFFL+100, 24+2*BUTTN, 15, 15, 
	" ", infobg, -15);
  if (jmode != 1) ActBut(&sbut[SDIRE],2);
  if (jmode != 1) ActBut(&sbut[SZMAT],2);
  if (jmode != 1 && jmode != 3) ActBut(&sbut[SWXYZ],2);
  if (jmode) ActBut(&sbut[SHESS],2);

  DefBut(&sbut[SBATC], SUBwin, SBOXOFFL+100, 24+3*BUTTN, 15, 15, 
	" ", infobg, -15);
  DefBut(&sbut[SONI], SUBwin, SBOXOFFL+165, 24+3*BUTTN, 15, 15, 
	" ", infobg, -15);
  if (jmode != 1) ActBut(&sbut[SONI],2);
  DefBut(&sbut[SQUEU], SUBwin, SBOXOFFL+173, 15+6*BUTTN, 110,23, 
	"short", infobg, -15);
#ifndef DOQUEUE
  ActBut(&sbut[SQUEU],2);
#endif
  DefBut(&sbut[SSUBM], SUBwin, SBOXOFFX, 30+12*BUTTN, 110, 23, 
	"Submit", infobg, -4);
  DefBut(&sbut[SCLOS], SUBwin, SBOXOFFX+120, 30+12*BUTTN, 110, 23, 
	"Close", infobg, -4);
  if (jmode && jmode != 3) {
	qboxstr(&qboxes[QGLIN1],&SUBwin,1,0,190,10,20+7*BUTTN, 
		SBOXWIDE-20,QBOXHIGH,2,"Keywrd",NULL,SUBLEN1,0,2000,-1,
		dummyproc);
	qboxstr(&qboxes[QGLIN2],&SUBwin,0,0,190,10,25+8*BUTTN, 
		SBOXWIDE-20,QBOXHIGH,2,"      ",NULL,SUBLEN1,0,2000,-1,
		dummyproc);
  }
  qboxstr(&qboxes[QGTITL],&SUBwin,0,0,190,10,30+10*BUTTN, 
	SBOXWIDE-20,QBOXHIGH,2,"Title ","title",SUBLEN1,0,2000,-1,
	dummyproc);
  qboxstr(&qboxes[QJNAME],&SUBwin,0,0,190,SBOXOFFL+100,24+4*BUTTN, 
	230,QBOXHIGH,2,"Job Name   ","test",SUBLEN2,0,2000,-1,
	dummyproc);

#ifndef DOQUEUE
  qboxstr(&qboxes[QQNAME],&SUBwin,0,0,190,SBOXOFFL+100,30+5*BUTTN, 
	230,QBOXHIGH,2,"Queue Name ","short",SUBLEN2,0,2000,-1,
	dummyproc);
#endif

  if (!jmode) {
#ifndef DOQUEUE
	qboxstr(&qboxes[QTIME],&SUBwin,0,0,190,SBOXOFFL+100,36+6*BUTTN, 
		230,QBOXHIGH,2,"Job Time   ","10",SUBLEN2,1,2000,-1,
		dummyproc);
#endif
	qboxstr(&qboxes[QENAME],&SUBwin,0,0,190,SBOXOFFL+100,42+7*BUTTN, 
		230,QBOXHIGH,2,"ED Name    ","edtest",SUBLEN2,0,2000,-1,
		dummyproc);
  }

  sbut[STASK].str = topt[itopt[jmode]];
  sbut[STASK].style = 1;
  sbut[SMETH].str = mopt[imopt[jmode]];
  sbut[SMETH].style = 1;
  if (jmode != 2) {
	sbut[SBASS].str = bopt[ibopt[jmode]];
	sbut[SBASS].style = 1;
  }
  sbut[SSPIN].str = spopt[ispopt];
  sbut[SSPIN].style = 1;
  sbut[SCHAR].str = copt[icopt];
  sbut[SCHAR].style = 1;
  if (jmode) {
	sbut[SMOLD].str = molopt[imolopt[jmode]];
	sbut[SMOLD].style = 1;
  }
  if (!jmode) {
	sbut[SREST].str = resopt[iresopt];
	sbut[SREST].style = 1;
  }
  if (jmode == 1) {
     if (iscfd) {
	TogUp(&sbut[SDIRE]);
     } else {
	TogDown(&sbut[SDIRE]);
     }
     if (izmat) {
	TogUp(&sbut[SZMAT]);
	tkey = tkey2;
     } else {
	TogDown(&sbut[SZMAT]);
	tkey = tkey2b;
     }
     if (ionon == 0) {
	TogUp(&sbut[SONI]);
     } else {
	TogDown(&sbut[SONI]);
     }
  }
  if (!jmode) {
     if (ihess) {
	TogUp(&sbut[SHESS]);
     } else {
	TogDown(&sbut[SHESS]);
     }
  }
  if (jobcom->ibatch) {
	TogUp(&sbut[SBATC]);
  } else {
	TogDown(&sbut[SBATC]);
  }

  if (jobcom->iwxyz) {
	TogDown(&sbut[SWXYZ]);
  } else {
	TogUp(&sbut[SWXYZ]);
  }

#ifdef DOQUEUE
  sbut[SQUEU].str = ques[qopt];
#endif

  if (jmode && jmode != 3) ParseLine();

  return(1);
}

void RedrawSUB()
{
  int i;

  butje(SUBwin,0,0,SBOXWIDE,SBOXHIGH,4,0,0,1,None,0,0,0,0);
  for (i=0; i<NBUTSS; i++) DrwBut(&sbut[i]);
  LineString(SUBwin, "Task", SBOXOFFL, 35);
  if (jmode) ULineString(SUBwin, "Extra print keys for Molden",SBOXOFFL+100, 35);
  else ULineString(SUBwin, "Dumpfile Control",SBOXOFFL+100, 35);
  if (jmode == 1) LineString(SUBwin, "Direct Mode", SBOXOFFL+125, 35+2*BUTTN);
  if (jmode == 1) LineString(SUBwin, "Opt. Z-matrix", SBOXOFFL+225, 35+2*BUTTN);
  if (jmode == 1 || jmode == 3) LineString(SUBwin, "Write XYZ", SBOXOFFL+250, 35+3*BUTTN);
  if (jmode == 0) LineString(SUBwin, "PickUp Hessian", SBOXOFFL+125, 35+2*BUTTN);
  if (jmode == 1) LineString(SUBwin, "ONIOM", SBOXOFFL+185, 35+3*BUTTN);
  LineString(SUBwin, "Batch", SBOXOFFL+125, 35+3*BUTTN);
#ifdef DOQUEUE
  LineString(SUBwin, "Queue Name", SBOXOFFL+100, 30+6*BUTTN);
#endif
  LineString(SUBwin, "Method", SBOXOFFL, 35+BUTTN);
  if (jmode != 2) LineString(SUBwin, "Basis Set", SBOXOFFL, 35+2*BUTTN);
  LineString(SUBwin, "Charge", SBOXOFFL, 35+4*BUTTN);
  LineString(SUBwin, "Spin", SBOXOFFL, 35+5*BUTTN);
  if (jmode) {
     PromptBox(&qboxes[QGLIN1]);
     PromptBox(&qboxes[QGLIN2]);
  }
  PromptBox(&qboxes[QGTITL]);
  PromptBox(&qboxes[QJNAME]);
#ifndef DOQUEUE
  PromptBox(&qboxes[QQNAME]);
#endif
  if (!jmode) {
#ifndef DOQUEUE
     PromptBox(&qboxes[QTIME]);
#endif
     PromptBox(&qboxes[QENAME]);
  }

  if (jmode == 3) {
	if (system("which nwchem > /dev/null 2>&1")) {
	   if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"nwchem: command NOT found !",1)) {
		   XDestroyWindow(display,SUBwin);
		   SUBup = 0;
	   }
	}
  }

}

int ButtonsSUB(i)
int i;
{
  LSSTRU List;
  int redraw=0;
  int j,k,ionij,nconn;

  switch (i) {
  case STASK:	
		List.list = topt; List.nents = toptn;
		if (DoPopUp(SUBwin,
			sbut[STASK].x+SBOXBLEN/2,sbut[STASK].y+BUTTH,
			&List,&itopt[jmode],1) == -1) break;
		sbut[STASK].str = topt[itopt[jmode]];
		if (!jmode && itopt[jmode] == 12) {
		   iresopt = 1;
		   sbut[SREST].str = resopt[iresopt];
		   DrwBut(&sbut[SREST]);
		}
		redraw = 1;
		break;
  case SMETH: 
		List.list = mopt; List.nents = moptn;
		if (DoPopUp(SUBwin,
			sbut[SMETH].x+SBOXBLEN/2,sbut[SMETH].y+BUTTH,
			&List,&imopt[jmode],1) == -1) break;
		sbut[SMETH].str = mopt[imopt[jmode]];
		redraw = 1;
		break;
  case SBASS: 
		List.list = bopt; List.nents = boptn;
		if (DoPopUp(SUBwin,
			sbut[SBASS].x+SBOXBLEN/2,sbut[SBASS].y+BUTTH,
			&List,&ibopt[jmode],1) == -1) break;
		sbut[SBASS].str = bopt[ibopt[jmode]];
		redraw = 1;
		break;
#ifdef DOQUEUE
  case SQUEU: 
		List.list = ques; List.nents = nques;
		if (DoPopUp(SUBwin,
			sbut[SQUEU].x+110/2,sbut[SQUEU].y+BUTTH,
			&List,&qopt,1) == -1) break;
		sbut[SQUEU].str = ques[qopt];
		redraw = 1;
		break;
#endif
  case SCHAR: 
		List.list = copt; List.nents = 7;
		if (DoPopUp(SUBwin,
			sbut[SCHAR].x+SBOXBLEN/2,sbut[SCHAR].y+BUTTH,
			&List,&icopt,1) == -1) break;
		sbut[SCHAR].str = copt[icopt];
		redraw = 1;
		break;
  case SSPIN: 
		List.list = spopt; List.nents = 8;
		if (DoPopUp(SUBwin,
			sbut[SSPIN].x+SBOXBLEN/2,sbut[SSPIN].y+BUTTH,
			&List,&ispopt,1) == -1) break;
		sbut[SSPIN].str = spopt[ispopt];
		redraw = 1;
		break;
  case SMOLD: 
		List.list = molopt; 
		if (jmode == 2 || jmode == 3) {
		   List.nents = 2;
		} else {
		   List.nents = 3;
		}
		if (DoPopUp(SUBwin,
			sbut[SMOLD].x+110/2,sbut[SMOLD].y+BUTTH,
			&List,&imolopt[jmode],1) == -1) break;
		sbut[SMOLD].str = molopt[imolopt[jmode]];
		redraw = 1;
		jobcom->iextopt = imolopt[jmode];
		break;
  case SREST: 
		List.list = resopt; 
		List.nents = 10;
		if (DoPopUp(SUBwin,
			sbut[SREST].x+110/2,sbut[SREST].y+BUTTH,
			&List,&iresopt,1) == -1) break;
		sbut[SREST].str = resopt[iresopt];
		redraw = 1;
		break;
  case SDIRE: 
		iscfd = TogBut(&sbut[SDIRE]);
		redraw = 1;
		break;
  case SHESS: 
		ihess = TogBut(&sbut[SHESS]);
		if (ihess) {
		   iresopt = 0;
		} else {
		   iresopt = 1;
		}
		sbut[SREST].str = resopt[iresopt];
		DrwBut(&sbut[SREST]);
		redraw = 1;
		break;
  case SBATC: 
		jobcom->ibatch = TogBut(&sbut[SBATC]);
		break;
  case SSUBM: 

		/* If ONIOM, should check the charge/mult for levels H, H+M 
		   and eventually H+M+L */

		if (ioniom == 1) {
		  int ism, isl;

		  lnkat = 0;

		  /* Counting the number of Link atoms between H and lower 
		     levels*/

		  ism = isl = 0;
		  for (j=0;j<*xyzp->iatoms;j++) {
	   	     if (xyzp->ityp[j] >= 20000) isl = 1;
	   	     if (xyzp->ityp[j] >= 10000 && xyzp->ityp[j] < 20000) ism = 1;
		     ionij = xyzp->ityp[j] / 10000;
		     if (ionij != 0) continue;
		     nconn = xyzp->iconn[j*(MXCON+1)];
		     for (k=1;k<=nconn;k++) {
		       if (xyzp->ityp[xyzp->iconn[j*(MXCON+1)+k]-1]/10000 > 0) lnkat++;
		     }
		  }
		  lnkat += 20000;
		  jobcom->itotc = jobcom->icopth;
		  jobcom->imult = jobcom->ispopth;
		  if (CheckChargeMult()) {
	           if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		       "WARNING: inconsistent multiplicity and charge for H level",0)) {
		       i = 0;
	           }
/*
	           break;
*/
		  }
		  icopt = jobcom->icoptm+3;
		  ispopt = jobcom->ispoptm-1;
		  if (ism == 0 && isl == 1) {
		     icopt = jobcom->icoptl+3;
		     ispopt = jobcom->ispoptl-1;
		  }

		}  else if (ioniom == 2) {

	          lnkat = 0;

		  /* Counting the number of Link atoms between H and 
		       lower levels*/

		 for (j=0;j<*xyzp->iatoms;j++) {
		         ionij = xyzp->ityp[j] / 10000;
			 if(ionij != 0) continue;
		         nconn = xyzp->iconn[j*(MXCON+1)];
		         for (k=1;k<=nconn;k++) {
		           if (xyzp->ityp[xyzp->iconn[j*(MXCON+1)+k]-1]/10000 > 0) lnkat++;
		         }
		  }
		  lnkat += 20000;
		  jobcom->itotc = jobcom->icopth;
		  jobcom->imult = jobcom->ispopth;
		  if (CheckChargeMult()) {
	               if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
			"WARNING: inconsistent multiplicity and charge for H level",0)) {
		           i = 0;
	               }
/*
	               break;
*/
		  }
	          lnkat = 0;

		  /* Counting the number of Link atoms between H+M and 
		     lower levels*/

		  for (j=0;j<*xyzp->iatoms;j++) {
			ionij = xyzp->ityp[j] / 10000;
			if (ionij == 2) continue;
			nconn = xyzp->iconn[j*(MXCON+1)];
			for (k=1;k<=nconn;k++) {
			   if (xyzp->ityp[xyzp->iconn[j*(MXCON+1)+k]-1]/10000 == 2) lnkat++;
			}
		  }
		  lnkat += 20000;
		  jobcom->itotc = jobcom->icoptm;
		  jobcom->imult = jobcom->ispoptm;
		  if (CheckChargeMult()) {
		     if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
			"WARNING: inconsistent multiplicity and charge for M level",0)) {
		           i = 0;
		     }
/*
		     break;
*/
		  }
		  icopt = jobcom->icoptl+3;
		  ispopt = jobcom->ispoptl-1;
		}
		lnkat = 0;
		jobcom->itotc = icopt - 3;
		jobcom->imult = ispopt + 1;
		jobcom->ito = itopt[jmode] + 1;
		jobcom->imo = imopt[jmode] + 1;
		jobcom->ibo = ibopt[jmode] + 1;
		jobcom->ihs = ihess;
#ifdef DOQUEUE
		jobcom->itm = quetims[qopt];
#else
		if (jmode != 3) {
		   if (qboxes[QTIME].str) {
			jobcom->itm = atoi(qboxes[QTIME].str);
		   }
		}
#endif

		if (CheckChargeMult()) {
		   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
			"WARNING: inconsistent multiplicity and charge",0)) {
			i = 0;
		   }
/*
		   break;
*/
		}
		
		if (!jmode) ParseLGAM();

		if (jmode && jmode != 3) {
		   cpstr(qboxes[QGLIN1].str,glin1,SUBLEN1);
		   cpstr(qboxes[QGLIN2].str,glin2,SUBLEN1);
		}
		cpstr(qboxes[QGTITL].str,gtitl,SUBLEN1);
		cpstr(qboxes[QJNAME].str,jname,SUBLEN2);
#ifdef DOQUEUE
		cpstr(ques[qopt],qname,SUBLEN2);
#else
		cpstr(qboxes[QQNAME].str,qname,SUBLEN2);
#endif
		if (!jmode) cpstr(rungam,ename,SUBLEN1);
		if (TogBut(&ZMEbut[ZMESUB])) {
		   XDestroyWindow(display,SUBwin);
		   SUBup = 0;
		}
		return(1);
		break;
  case SZMAT: 
		izmat = TogBut(&sbut[SZMAT]);
		if (izmat) {
		   tkey = tkey2;
		} else {
		   tkey = tkey2b;
		}
		redraw = 1;
		break;
  case SWXYZ: 
		jobcom->iwxyz = 1 - TogBut(&sbut[SWXYZ]);
		break;
  case SONI: 
		ionon = 1 - TogBut(&sbut[SONI]);

		if (ionon == 0) {
	           if (ONIup) {
			XDestroyWindow(display,ONIwin);
			ONIup = 0;
		   }
		} else {
		   if (!ONIup) {
			CreateONI();
			*Sinct = 401; return(0);
		   }
		}
		redraw = 1;
		break;
   case SCLOS: 
		if (TogBut(&ZMEbut[ZMESUB])) {
		   XDestroyWindow(display,SUBwin);
		   SUBup = 0;
		}
		break;
  default: break;
  }

  if (redraw && jmode) {
  	RedrawSUB();
	ParseLine();
	PromptBox(&qboxes[QGLIN1]);
	PromptBox(&qboxes[QGLIN2]);
  }
  if (redraw && !jmode) ParseLGAM();

  return(0);

}

void spa_not_substr(char *fname,char *substr)
{
   int i,n,ns,ss;
   char *ptr1,ptr2;

   if (fname == NULL) return;
   if (substr == NULL) return;

   n = strlen(fname);
   ns = strlen(substr);
   ptr1 = myStrcasestr(fname,substr);
   ss = (int) (ptr1 - fname);
   
   for (i = 0; i < ss; i++) {
	fname[i] = ' ';
   }

   for (i = ss+ns; i < n; i++) {
	fname[i] = ' ';
   }
}

#define MXLLIN 140

void RedrawLBox(lp)
LISTSTRU *lp;
{
      int i,nen,isel;
      char drawstrc[MXLLIN];
      XRectangle xr;

      drawstrc[MXLLIN-1] = '\0';

      XSetForeground(display, gc, lp->fgc);
      XFillRectangle(display, lp->win, gc, lp->x+1, lp->y+1, lp->w-1, lp->h-1);

      XSetForeground(display, gc, lp->bgc);
      XDrawRectangle(display, lp->win, gc, lp->x, lp->y, lp->w, lp->h);

      if (lp->list.nents == NULL) return;

      nen = MINI(lp->mxents,*lp->list.nents);
      if (lp->lpnt > *lp->list.nents - lp->mxents) {
	 lp->lpnt = *lp->list.nents - lp->mxents;
	 if (lp->lpnt < 0) lp->lpnt = 0;
      }

      xr.x = lp->x;
      xr.y = lp->y;
      xr.width = lp->w;
      xr.height = lp->h;

      XSetClipRectangles(display, gc1, 0,0, &xr, 1, Unsorted);

      for (i=0; i<nen; i++) {
	 isel = 0;
	 if (lp->dosel) {
		if (lp->list.slst != NULL) {
		   if (lp->list.slst[i+lp->lpnt]) isel = 1;
		} else {
		   if (i+lp->lpnt == lp->select) isel = 1;
		}
	 }
         if (isel) {

	      if (lp->list.svgs != NULL) {

		  XSetLineAttributes(display, gc, 3, LineSolid, CapButt, 
			JoinMiter);
		  XSetForeground(display, gc, lp->bgc);
		  XDrawRectangle(display, lp->win, gc, 
		    lp->x, lp->y+i*lp->h/lp->mxents, lp->w, lp->h/lp->mxents);
		  XSetForeground(display, gc, lp->fgc);

		  if (lp->list.svgs[lp->lpnt+i].array != NULL) {
		  	DrawSVG(lp->x, lp->y+i*lp->h/lp->mxents, 
			lp->w, lp->h/lp->mxents,lp->list.svgs[lp->lpnt+i],MLTwin);
			strncpy(drawstrc,lp->list.list[lp->lpnt+i],MXLLIN-1);
			XSetForeground(display, gc, lp->bgc);
                  	LineString(lp->win,drawstrc,lp->x+205,
			lp->y+90+i*lp->h/lp->mxents);
		  } else if (lp->list.list != NULL) {
			strncpy(drawstrc,lp->list.list[lp->lpnt+i],MXLLIN-1);
			XSetForeground(display, gc, lp->bgc);
                  	LineString(lp->win,drawstrc,lp->x+5,
			lp->y+12+i*lp->h/lp->mxents);
		  }

	      } else if (lp->list.list == NULL) {

		  XSetForeground(display, gc, lp->bgc);
		  XFillRectangle(display, lp->win, gc, 
		    lp->x, lp->y+i*lp->h/lp->mxents, lp->w, lp->h/lp->mxents);
		  XSetForeground(display, gc, lp->fgc);

		  if (lp->list.flst == NULL)
			sprintf(drawstrc,"%4d      %11.6f",lp->lpnt+i+1,
			lp->list.rlst[lp->lpnt+i]);
		  else if (lp->list.rlst == NULL)
		  	sprintf(drawstrc,"%4d      %3.2f",lp->lpnt+i+1,
			lp->list.flst[lp->lpnt+i]);
		  else
		  	sprintf(drawstrc,"%4d      %11.6f      %3.2f",lp->lpnt+i+1,
			lp->list.rlst[lp->lpnt+i],lp->list.flst[lp->lpnt+i]);
                  LineString(lp->win,drawstrc,lp->x+5,
			lp->y+12+i*lp->h/lp->mxents);
	      } else {

		  XSetForeground(display, gc, lp->bgc);
		  XFillRectangle(display, lp->win, gc, 
		    lp->x, lp->y+i*lp->h/lp->mxents, lp->w, lp->h/lp->mxents);
		  XSetForeground(display, gc, lp->fgc);

		  if (lp->list.ilst == NULL) {

		  	if (lp->list.rlst != NULL && lp->list.flst == NULL) 
		  	   sprintf(drawstrc,"%4d      %11.6f      %s",
				lp->lpnt+i+1,lp->list.rlst[lp->lpnt+i],
				lp->list.list[lp->lpnt+i]);
		  	if (lp->list.rlst != NULL && lp->list.flst != NULL) 
		  	   sprintf(drawstrc,"%4d   %11.3f        %6.2f   %s",
				lp->lpnt+i+1,lp->list.rlst[lp->lpnt+i],
				lp->list.flst[lp->lpnt+i],
				lp->list.list[lp->lpnt+i]);
			else if (lp->list.rlst == NULL && 
				 lp->list.flst == NULL) {
			   if (lp->list.list[lp->lpnt+i] != NULL) 
			   strncpy(drawstrc,lp->list.list[lp->lpnt+i],MXLLIN-1);
			}

		  } else {

			XDrawRectangle(display, lp->win, gc, 
		    lp->x, lp->y+i*lp->h/lp->mxents, lp->w, lp->h/lp->mxents);
			XFillRectangle(display, lp->win, gc, 
		    lp->x, lp->y+i*lp->h/lp->mxents, lp->w, lp->h/lp->mxents);
			XSetForeground(display, gc, lp->fgc);
			strncpy(drawstrc,lp->list.list[lp->list.ilst[lp->lpnt+i]],MXLLIN-1);
		  }
                  LineString(lp->win,drawstrc,lp->x+5,
			lp->y+12+i*lp->h/lp->mxents);
	      }
              XSetForeground(display, gc, lp->bgc);

         } else {

	      if (lp->list.svgs != NULL) {

		  XSetLineAttributes(display, gc, 1, LineSolid, CapButt, 
			JoinMiter);
		  XSetForeground(display, gc, lp->bgc);
		  XDrawRectangle(display, lp->win, gc, 
		    lp->x, lp->y+i*lp->h/lp->mxents, lp->w, lp->h/lp->mxents);
		  XSetForeground(display, gc, lp->fgc);

		  if (lp->list.svgs[lp->lpnt+i].array != NULL) {
		  	DrawSVG(lp->x, lp->y+i*lp->h/lp->mxents, 
			lp->w, lp->h/lp->mxents,lp->list.svgs[lp->lpnt+i],MLTwin);
			strncpy(drawstrc,lp->list.list[lp->lpnt+i],MXLLIN-1);
			XSetForeground(display, gc, lp->bgc);
                  	LineString(lp->win,drawstrc,lp->x+205,
			lp->y+90+i*lp->h/lp->mxents);
		  } else if (lp->list.list != NULL) {
			strncpy(drawstrc,lp->list.list[lp->lpnt+i],MXLLIN-1);
			XSetForeground(display, gc, lp->bgc);
                  	LineString(lp->win,drawstrc,lp->x+5,
			lp->y+12+i*lp->h/lp->mxents);
		  }

	      } else if (lp->list.list == NULL) {

		  if (lp->list.flst == NULL) {
		  	sprintf(drawstrc,"%4d      %11.6f",lp->lpnt+i+1,
			lp->list.rlst[lp->lpnt+i]);
		  }
		  else if (lp->list.rlst == NULL) {
		  	sprintf(drawstrc,"%4d      %3.2f",lp->lpnt+i+1,
			lp->list.flst[lp->lpnt+i]);
		  }
		  else {
		  	sprintf(drawstrc,"%4d      %11.6f      %3.2f",lp->lpnt+i+1,
			lp->list.rlst[lp->lpnt+i],lp->list.flst[lp->lpnt+i]);
		  }

	          LineString(lp->win,drawstrc,lp->x+5,
			lp->y+12+i*lp->h/lp->mxents);
	      } else {

		  if (lp->list.ilst == NULL) {

		  	if (lp->list.rlst != NULL && lp->list.flst == NULL) 
		  	   sprintf(drawstrc,"%4d      %11.6f      %s",
				lp->lpnt+i+1,lp->list.rlst[lp->lpnt+i],
				lp->list.list[lp->lpnt+i]);
		  	if (lp->list.rlst != NULL && lp->list.flst != NULL) 
		  	   sprintf(drawstrc,"%4d   %11.3f        %6.2f   %s",
				lp->lpnt+i+1,lp->list.rlst[lp->lpnt+i],
				lp->list.flst[lp->lpnt+i],
				lp->list.list[lp->lpnt+i]);
			else if (lp->list.rlst == NULL && 
				 lp->list.flst == NULL) {
			   if (lp->list.list[lp->lpnt+i] != NULL) 
			   strncpy(drawstrc,lp->list.list[lp->lpnt+i],MXLLIN-1);
			}

		  } else {
			strncpy(drawstrc,
			lp->list.list[lp->list.ilst[lp->lpnt+i]],MXLLIN-1);
		  }


	          LineString(lp->win,drawstrc,lp->x+5,
			lp->y+12+i*lp->h/lp->mxents);

		  if (lp->sub != NULL) {
			if (myStrcasestr(drawstrc,lp->sub)) {
			   XSetForeground(display, gc, lp->hlc);
			   spa_not_substr(drawstrc,lp->sub);
			   LineString(lp->win,drawstrc,lp->x+5,
				lp->y+12+i*lp->h/lp->mxents);
			   LineString(lp->win,drawstrc,lp->x+6,
				lp->y+13+i*lp->h/lp->mxents);

			}
		  }
		  XSetForeground(display, gc, lp->bgc);
	      }
	  }
      }

      XSetClipMask(display, gc1, None);

      XFlush(display);
}

void DefList(lp,win,x,y,w,h,label,mx,lstr,rlist,flst,slist,nentries,svgs)
LISTSTRU	*lp;
Window		win;
int		x,y;
unsigned int	w,h;
char		*label;
int		mx;
char		**lstr;
float		*rlist;
double		*flst;
int		*slist;
int		*nentries;
SVGFSTRUC	*svgs;
{
  int ggx, ggy;
  unsigned int ggw, ggh, ggb, ggd;
  Window rt;

  lp->win = win;
  lp->x = x;  lp->y = y;  lp->w = w;  lp->h = h;
  lp->mxents = mx;
  lp->list.list = lstr;
  lp->list.rlst = rlist;
  lp->list.flst = flst;
  lp->list.ilst = NULL;
  lp->list.slst = slist;
  lp->list.svgs = svgs;
  lp->list.nents = nentries;
  lp->lpnt = 0;
  lp->select = 0;
  lp->label = label;
  lp->fgc = infofg;
  lp->bgc = infobg;
  lp->hlc = infofg;
  lp->sub = NULL;
  lp->dosel = 1;

  lp->wwin = 0;
  if (XGetGeometry(display,lp->win,&rt,
	&ggx, &ggy, &ggw, &ggh, &ggb, &ggd) == True ) lp->wwin = ggw;

  DefScroll(&lp->scrbar,lp->win,lp->x+lp->w,lp->y+BARRH,BARRW,
             lp->h-2*BARRH,lp->list.nents,&lp->lpnt,lp->mxents,NULL);

  DefBut(&lp->arrbut[0], lp->win, lp->x+lp->w, lp->y            ,
	BARRW, BARRH, " ", infobg, 0);
  DefBut(&lp->arrbut[1], lp->win, lp->x+lp->w, lp->y+lp->h-BARRH+1, 
	BARRW, BARRH, " ", infobg, 0);

  lp->arrbut[0].pix = upPix;
  lp->arrbut[0].pw  = up_width;
  lp->arrbut[0].ph  = up_height;

  lp->arrbut[1].pix = downPix;
  lp->arrbut[1].pw  = down_width;
  lp->arrbut[1].ph  = down_height;
}

int PressList(lp,x,y)
LISTSTRU	*lp;
int		x;
int		y;
{
      int i;

  if (VIERKANT(x, y,lp->x,lp->y,lp->w,lp->h)){

      lp->select = lp->lpnt + lp->mxents*(y - lp->y) / lp->h;
      if (lp->list.slst != NULL) {
	   if (lp->list.slst[lp->select]) {
		lp->list.slst[lp->select] = 0;
	   } else {
		lp->list.slst[lp->select] = 1;
	   }
      }
      RedrawList(lp);
      return 1;

  } else {

      i=Clickwin(lp->arrbut,2,x,y,1);

      if (i>=0) {

	  switch (i) {

          case BARR1: 

		if (*lp->list.nents > lp->mxents) 
		    if (lp->lpnt) {
			lp->lpnt--;RedrawLBox(lp); RedrawScroll(&lp->scrbar);
		    }
#ifdef HASTIMER
		Timer(100,0);
		while (!XCheckWindowEvent(display, lp->win, 
			ButtonReleaseMask, &event)) {

			if (*lp->list.nents > lp->mxents) 
			   if (lp->lpnt) {
				lp->lpnt--;
				RedrawLBox(lp); RedrawScroll(&lp->scrbar);
				Timer(50,0);
			   }
		}
#endif
		break;

          case BARR2:	
		if (*lp->list.nents > lp->mxents) {
			lp->lpnt++; 
			if (lp->lpnt > *lp->list.nents-lp->mxents) 
				lp->lpnt = *lp->list.nents-lp->mxents;
			RedrawLBox(lp); RedrawScroll(&lp->scrbar);
		}
#ifdef HASTIMER
		Timer(100,0);
		while (!XCheckWindowEvent(display, lp->win, 
			ButtonReleaseMask, &event)) {

			if (*lp->list.nents > lp->mxents) {
				lp->lpnt++; 
				if (lp->lpnt > *lp->list.nents-lp->mxents) {
					lp->lpnt = *lp->list.nents-lp->mxents;
                               	} else {
					RedrawLBox(lp);
					RedrawScroll(&lp->scrbar);
				}
				Timer(50,0);
                        }
		}
#endif
		break;
          }
      }
      ScrollPage(lp,&lp->scrbar,x,y);
      return 0;
  }

}

/**********************************************/
void DefBut(bp,win,x,y,w,h,str,bg,fg)
BSTRU         *bp;
Window        win;
int           x,y,w,h;
char         *str;
unsigned long bg;
int fg;
{
  bp->win = win;
  bp->x = x;  bp->y = y;  bp->w = w;  bp->h = h;
  if (!w) {
	bp->w = XTextWidth(mfinfo,str,strlen(str)) + 2*SPACING;
  } else {
	bp->w = w;
  }
  bp->str = str;
  if (monoscr || colcells <= 32) {bp->fg = infobg; bp->bg = infofg;}
  else {bp->fg = fg;  bp->bg = bg;}
  bp->lit = 0;
  bp->active = 1;
  bp->toggle = 1;
  bp->pix = None;
  bp->style = 0;
  bp->fwidth = 3;
  bp->lastused = 0;
  bp->explstr = NULL;

  if (!hlfgrey) {
    hlfgrey = XCreatePixmapFromBitmapData(display, win, hlfgrey_bits,
		       hlfgrey_width, hlfgrey_height, 1, 0, 1);
    if (!hlfgrey) fprintf(stderr,"Unable to create hlfgrey bitmap\n");
  }
}



void ActBut(bp,act)
BSTRU *bp;
int           act;
{
  if (bp->active != act) {
    bp->active = act;
    DrwBut(bp);
  }
}

int TogBut(bp)
BSTRU *bp;
{
  if (bp->toggle) bp->toggle = 0;
  else bp->toggle = 1;
  DrwBut(bp);
  return (bp->toggle);
}


void TogDown(bp)
BSTRU *bp;
{
  bp->toggle = 0;
  DrwBut(bp);
}

void TogUp(bp)
BSTRU *bp;
{
  bp->toggle = 1;
  DrwBut(bp);
}

/**********************************************/
void DrwBut(bp)
BSTRU *bp;
{
  int x,y,w,h,r,x1,y1;

  if (bp->active == 2) return;
  if (bp->str == NULL) return;

  x = bp->x;  y=bp->y;  w=bp->w;  h=bp->h;  r=bp->fwidth;

  if (bp->active < 1) bp->lit = 0;
  if (bp->lit) {
    r -= 1;
    if (r<0) r = 0;
  }

  if (bp->lastused == 1) {
	butje(bp->win,x,y,w,h,r,0,bp->fg,bp->toggle,bp->pix,bp->pw,bp->ph,bp->style,2);
  } else if (bp->lastused == -1) {
	butje(bp->win,x,y,w,h,r,bp->bg,bp->fg,bp->toggle,bp->pix,bp->pw,bp->ph,-bp->style,2);
  } else butje(bp->win,x,y,w,h,r,0,bp->fg,bp->toggle,bp->pix,bp->pw,bp->ph,bp->style,0);

  if (bp->lit) {
      if (monoscr || colcells <= 32) {
           XDrawRectangle(display, bp->win, gc, x+2, y+2, w-4, h-4);
           XDrawRectangle(display, bp->win, gc, x+1, y+1, w-2, h-2);
      }
      else XDrawRectangle(display, bp->win, gc, x+1, y+1, w-2, h-2);
  }

  if (bp->pix == None || (bp->pix != None && bp->style == 1)) { 
    x1 = MIDDLEX(mfinfo, x + w/2, bp->str);
    y1 = MIDDLEY(mfinfo, y + h/2);

    if (bp->active == 1) {
      XDrawString(display, bp->win, gc, x1,y1, bp->str, strlen(bp->str));
    }
    else {  
      XSetFillStyle(display, gc, FillStippled);
      XSetStipple(display, gc, grayStip);
      XDrawString(display, bp->win, gc, x1,y1, bp->str, strlen(bp->str));
      XSetFillStyle(display,gc,FillSolid);
    }
  }

}


void SelBut(bp)
BSTRU *bp;
{

  XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinMiter);
  XSetForeground(display, gc, Black);
  XDrawRectangle(display, bp->win, gc, bp->x-2, bp->y-2, bp->w+4, bp->h+4);
  XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);

}

/***************************************************/
int Clickwin(but,num,x,y,check)
BSTRU  *but;
int x,y,num,check;
{
  BSTRU  *bp;
  int    bnum;

  for (bnum=0; bnum<num; bnum++) {
    bp = &but[bnum];
    if (bp->active != 2) if (VIERKANT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
  }

  if (bnum<num) {   /* found one */
    if (check) {
	if (ChkBut(bp)) return (bnum);
    } else {
	return (bnum);
    }
  }

  return -1;
}

/**********************************************/
int ChkBut(bp)
BSTRU *bp;
{

  int          rval, inval;
#ifndef HASTIMER
  Window       rW, cW;
  int          x, y, rx, ry;
  unsigned int mask;
#endif

  if (bp->active != 1) return 0;   

  inval = bp->lit;
  bp->lit = !bp->lit;

  DrwBut(bp);  XFlush(display);
#ifdef HASTIMER
  Timer(120,0);  /* long enough for turn on to be visible */

#else
  while (XQueryPointer(display,bp->win,&rW,&cW,&rx,&ry,&x,&y,&mask)) {
    if (!(mask & Button1Mask)) break;    /* button released */

    if (bp->lit==inval && VIERKANT(x, y, bp->x, bp->y, bp->w, bp->h)) {
      bp->lit = !inval;  DrwBut(bp);  XFlush(display);
    }
    
    if (bp->lit!=inval && !VIERKANT(x, y, bp->x, bp->y, bp->w, bp->h)) {
      bp->lit = inval;  DrwBut(bp);  XFlush(display);
    }
  }
#endif

  rval = (bp->lit != inval);
  
  if (bp->lit ) 
    { bp->lit = 0;  DrwBut(bp);  XFlush(display); }

  return(rval);
}

#define EXPLSPACE 5
void DoExpl()
{
  Window win;
  int x,y,xt,yt,i,j;
  int wit,hit,bw,xp,retval,nlines,wittmp,ql;
  char *p, *q;
  BSTRU *bp;
  QBOXSTRU *qp;
  
  qp = NULL;

  if ((!expldat.borq && expldat.barr == NULL) ||
      (expldat.borq && expldat.qarr == NULL)) return;

  if (expldat.winup != NULL) if (! *expldat.winup) return;
  if (animptr.on || *movie) return;

  expldat.active = 1;
  signal(SIGALRM,SIG_IGN);

  if (expldat.borq) {
	qp = &expldat.qarr[expldat.button];
	win = qp->win;
	x = qp->x; y = qp->y;
	p = qp->explstr;
	q = qp->explstr;
  } else {
	bp = &expldat.barr[expldat.button];
	win = bp->win;
	x = bp->x; y = bp->y;
	p = bp->explstr;
	q = bp->explstr;
  }

  XGetWindowAttributes(display, win, &xwa);

  nlines = 0;
  wit = 0;

  while ((p = strchr(q, '\n'))) {
     ql = (int) (p-q);
     wittmp = XTextWidth(mfinfo,q,ql) + 2*EXPLSPACE;
     if (wittmp > wit) wit = wittmp;
     p++;
     q = p;
     nlines++;
  }
  ql = strlen(q);
  wittmp = XTextWidth(mfinfo,q,ql) + 2*EXPLSPACE;
  if (wittmp > wit) wit = wittmp;
  nlines++;

  hit = EXPLSPACE + LINEHIGH*nlines + EXPLSPACE;
  xt = x-wit/2; yt = y-hit/2;
  if (x+wit > xwa.width) xt = xwa.width-wit; 
  if (xt < 0) xt = 0; 
  if (yt < 0) yt = 0; 
  
  XSelectInput(display, expldat.win, 
  ( ExposureMask | PointerMotionMask | VisibilityChangeMask ));

  XMoveResizeWindow(display, expldat.win, xt, yt, wit, hit);

  XMapRaised(display,expldat.win);

  XSync(display, False);

  XNextEvent(display, &event);

  XSetForeground(display, gc, colors[0]);

  nlines = 0;
  if (expldat.borq) {
	p = qp->explstr;
	q = qp->explstr;
  } else {
	p = bp->explstr;
	q = bp->explstr;
  }

  while ((p = strchr(q, '\n'))) {
		ql = (int) (p-q);
	        XDrawString(display, expldat.win, gc, 
			EXPLSPACE, CHIGH+nlines*LINEHIGH+EXPLSPACE, q, ql);
		p++;
		q = p;
		nlines++;
  }
  ql = strlen(q);
  XDrawString(display, expldat.win, gc, 
		EXPLSPACE, CHIGH+nlines*LINEHIGH+EXPLSPACE, q, ql);

  XFlush(display);

  XMaskEvent(display, PointerMotionMask | ButtonPressMask, &event);


  XUnmapWindow(display,expldat.win);
  XSync(display, False);
  expldat.active = 0;
  expldat.barr = NULL;
  expldat.qarr = NULL;
  expldat.win = -1;

  if (qp== NULL) return;
  if (qp->explstr == NULL) return;

  if (qp->explstr == BLstr) {
     for (i=0; i<*zmptrp->nz; i++) {
	BLbox[i].expldone = 1;
     }
  } else if (qp->explstr == ALPHstr) {
     for (i=0; i<*zmptrp->nz; i++) {
	ALPHbox[i].expldone = 1;
     }
  } else if (qp->explstr == BETstr) {
     for (i=0; i<*zmptrp->nz; i++) {
	BETbox[i].expldone = 1;
     }
  } else if (qp->explstr == IZstr) {
     for (i=0; i<*zmptrp->nz; i++) {
	for (j=0; j<4; j++) {
	   IZbox[i*4+j].expldone = 1;
	}
     }
  } else if (qp->explstr == IANZstr) {
     for (i=0; i<*zmptrp->nz; i++) {
	IANZbox[i].expldone = 1;
     }
  }

}

int StringWidth(str)
char *str;
{
  return(XTextWidth(mfinfo, str, strlen(str)));
}

void butje(bwin,x,y,w,h,r,bgcol,sh_ind,iopt,pix,pw,ph,style,rec)
Window bwin;
int x,y,w,h,r,bgcol,sh_ind,iopt;
Pixmap pix;
int pw,ph,style,rec;
{
  int i,x1,y1;
  int dark,light,medium;
  XPoint butb[10], butc[10], buta[5];

  if (DEBUG) fprintf(stderr,"butje in\n");

  if (bwin == (Window) NULL) return;
 
  buta[0].x = x+r;        buta[0].y = y+r;
  buta[1].x = x+r;        buta[1].y = y+h-r;
  buta[2].x = x+w-r;      buta[2].y = y+h-r;
  buta[3].x = x+w-r;      buta[3].y = y+r;
  buta[4].x = buta[0].x;  buta[4].y = buta[0].y;


  butb[0].x = x;            butb[0].y = y+h;
  butb[1].x = buta[1].x;    butb[1].y = buta[1].y;
  butb[2].x = buta[2].x;    butb[2].y = buta[2].y;
  butb[3].x = buta[3].x;    butb[3].y = buta[3].y;
  butb[4].x = x+w;          butb[4].y = y;
  butb[5].x = x+w;          butb[5].y = y+h;
  butb[6].x = x;            butb[6].y = y+h;

  butc[0].x = x;            butc[0].y = y+h;
  butc[1].x = buta[1].x;    butc[1].y = buta[1].y;
  butc[2].x = buta[0].x;    butc[2].y = buta[0].y;
  butc[3].x = buta[3].x;    butc[3].y = buta[3].y;
  butc[4].x = x+w;          butc[4].y = y;
  butc[5].x = x;            butc[5].y = y;
  butc[6].x = x;            butc[6].y = y+h;


  if (monoscr || colcells <= 32) {

    XSetForeground(display, gc, White);
    XFillRectangle(display, bwin, gc, x, y, w, h);
    XSetForeground(display, gc, Black);
    XDrawRectangle(display, bwin, gc, x, y, w, h);

    XSetForeground(display, gc, Black);
    XSetFillStyle(display, gc, FillStippled);
    XSetStipple(display, gc, hlfgrey);
    XFillPolygon(display, bwin, gc, butc, 7, Nonconvex, CoordModeOrigin);
    XSetFillStyle(display,gc,FillSolid);

    XSetForeground(display, gc, Black);
    XDrawLines(display, bwin, gc, buta, 5, CoordModeOrigin);  

    XDrawLine(display, bwin, gc, x+1,   y+1,  buta[0].x,buta[0].y);
    XDrawLine(display, bwin, gc, x+1,   y+h-1,buta[1].x,buta[1].y);
    XDrawLine(display, bwin, gc, x+w-1, y+h-1,buta[2].x,buta[2].y);
    XDrawLine(display, bwin, gc, x+w-1, y+1,  buta[3].x,buta[3].y);

  } else {  

    if (sh_ind >= 0) {
	dark   = shcolors[sh_ind]+DARK;
	light  = shcolors[sh_ind]+LIGHT;
	medium = shcolors[sh_ind]+MEDIUM;
    }
    else {
	dark   = 15-(sh_ind+1)*10+3;
	light  = 15-(sh_ind+1)*10+10;
	medium = 15-(sh_ind+1)*10+7;
    }

    XSetForeground(display, gc, colors[medium] );
    XFillRectangle(display, bwin, gc, x+1, y+1, w-1, h-1);

    if (!iopt) XSetForeground(display, gc, colors[dark]);
    else XSetForeground(display, gc, colors[light]);

    if (DoIntel) {
       for (i=0; i<=r; i++) {
         XDrawLine(display, bwin, gc, x+i, y+i, x+w, y+i);
         XDrawLine(display, bwin, gc, x+i, y+i, x+i, y+h);
       }
    } else {
       for (i=1; i<=r; i++) {
         XDrawLine(display, bwin, gc, x+i, y+i, x+w, y+i);
         XDrawLine(display, bwin, gc, x+i, y+i, x+i, y+h);
       }
    }

    if (!iopt) XSetForeground(display, gc, colors[light]);
    else XSetForeground(display, gc, colors[dark]);

    if (DoIntel) {
       for (i=0; i<=r; i++) {
         XDrawLine(display, bwin, gc, x+i, y+h-i, x+w, y+h-i);
         XDrawLine(display, bwin, gc, x+w-i, y+h, x+w-i, y+i);
       }
    } else {
       for (i=1; i<=r; i++) {
         XDrawLine(display, bwin, gc, x+i, y+h-i, x+w, y+h-i);
         XDrawLine(display, bwin, gc, x+w-i, y+h, x+w-i, y+i);
       }
    }

    if (rec) {

        XSetLineAttributes(display, gc, ABS(rec), 
				LineSolid, CapButt, JoinMiter);
	if (rec > 0) {
	    XSetForeground(display, gc, Black);
	} else {  
	    if (bgcol == -1) XSetForeground(display, gc, White);
	    else XSetForeground(display, gc, colors[bgcol]);
	}
	XDrawRectangle(display, bwin, gc, x, y, w, h);
        XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
    }

  }
    

  XSetForeground(display, gc, Black);

  if (pix != None || style) {                 

    if (monoscr || colcells <= 32) XSetBackground(display, gc, White);
    else XSetBackground(display, gc, colors[medium]);

    if (style) {
	x1 = x+(1+w-2*tri_width);
	y1 = y+(1+h-tri_height)/2;
	XCopyPlane(display, triPix, bwin, gc, 0,0,tri_width,tri_height, x1,y1, 1);
	XSetBackground(display, gc, White);
    } else {
	x1 = x+(1+w-pw)/2;
	y1 = y+(1+h-ph)/2;

	XCopyPlane(display, pix, bwin, gc, 0,0,pw,ph, x1,y1, 1);
	XSetBackground(display, gc, White);
    }
  }

  if (DEBUG) fprintf(stderr,"butje out\n");

}

/***************************************************/
void CreatewinC(geom)
char *geom;
{


  if (DEBUG) fprintf(stderr,"CreatewinC in\n");

  winC = CreateWindow("Molden Control",geom,WINCWIDE, WINCHIGH, infobg, infofg,(Window)0);

  subC = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],winC);

  DefBut(&dbut[BPSI],   winC, PLOFFX+BOFFX, PLOFFY+24            , 60, BUTTH, 
	   "Orbital", infobg, CNTCOL);
  dbut[BPSI].explstr = "Select orbital to display\nFor open shell:\nselect alpha or beta orbitals";
  DefBut(&dbut[BHOMO],  winC, PLOFFX+BOFFX, PLOFFY+24+BUTTN  , 60, BUTTH, 
	   "Homo", infobg, CNTCOL);
  dbut[BHOMO].explstr = "Highest Occupied Molecular Orbital\nis displayed";
  DefBut(&dbut[BLUMO],  winC, PLOFFX+BOFFX+65, PLOFFY+24+BUTTN, 60, BUTTH, 
	   "Lumo", infobg, CNTCOL);
  dbut[BLUMO].explstr = "Lowest Unoccupied Molecular Orbital\nis displayed";
  DefBut(&dbut[BNDEN],  winC, PLOFFX+BOFFX, PLOFFY+24+BUTTN*2, 60, BUTTH, 
	   "Density", infobg, CNTCOL);
  dbut[BNDEN].explstr = "Display electron density";
  DefBut(&dbut[BLAPL],  winC, PLOFFX+BOFFX+65, PLOFFY+24+BUTTN*2, 60, BUTTH, 
	   "Laplac.", infobg, CNTCOL);
  dbut[BLAPL].explstr = "Display Laplacian of\nelectron density";
  DefBut(&dbut[BELF],  winC, PLOFFX+BOFFX+65, PLOFFY+24+BUTTN*3, 60, BUTTH, 
	   "ELF", infobg, CNTCOL);
  dbut[BELF].explstr = "Display Electron Localization Funtion";
  DefBut(&dbut[BBONDS], winC, PLOFFX+BOFFX, PLOFFY+24+BUTTN*4, 60, BUTTH, 
	   "Bonds", infobg, CNTCOL);
  dbut[BBONDS].explstr = "Display Difference Density:\nMolecular minus Atomic";
  DefBut(&dbut[BORI],   winC, PLOFFX+BOFFX+65,PLOFFY+36+BUTTN*4,TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  dbut[BORI].explstr = "Use oriented atomic density in\ncalculation of Difference Density:\nMolecular minus Atomic";
  DefBut(&dbut[BATOM],  winC, PLOFFX+BOFFX, PLOFFY+24+BUTTN*5, 60, BUTTH, 
	   "Atomic", infobg, CNTCOL);
  dbut[BATOM].explstr = "Display Difference Density:\nMolecular minus Atomic\nOnly contributions where \nAO1,AO2 are on the same atom";
  DefBut(&dbut[BOVRLP], winC, PLOFFX+BOFFX, PLOFFY+24+BUTTN*6, 60, BUTTH, 
	   "Overlap", infobg, CNTCOL);
  dbut[BOVRLP].explstr = "Display Difference Density:\nMolecular minus Atomic\nOnly overlap contributions only:\nAO1,AO2 not on the same atom";
  DefBut(&dbut[BELPOT], winC, PLOFFX+BOFFX, PLOFFY+24+BUTTN*7, 60, BUTTH, 
	   "Elec. Pot", infobg, CNTCOL);
  dbut[BELPOT].explstr = "Calculate Electrostatic Potential";

  DefBut(&dbut[BCOMM],  winC, MSOFFX+BOFFX, MSOFFY+24+BUTTN*0, 70, BUTTH, 
	   "PlotPlane", infobg, CNTCOL);
  dbut[BCOMM].explstr = "commands that define the plotplane\nfor euclid plots\nand the grid size\n(also for space plots)";
  DefBut(&dbut[BMAXMIN],winC, MSOFFX+BOFFX, MSOFFY+24+BUTTN*1, 70, BUTTH, 
	   "Maxi/Mini", infobg, CNTCOL);
  dbut[BMAXMIN].explstr = "show the maxima and minima\nfor euclid plots";
  DefBut(&dbut[BPOST],  winC, MSOFFX+BOFFX, MSOFFY+24+BUTTN*2, 70, BUTTH, 
	   "Postscript", infobg, CNTCOL);
  dbut[BPOST].explstr = "write a postscript file\nof current plot";
  DefBut(&dbut[BMOLMOD],winC, MSOFFX+BOFFX, MSOFFY+24+BUTTN*3, 70, BUTTH, 
	   "Mol. Mode", infobg, CNTCOL);
  dbut[BMOLMOD].explstr = "switch back to the molecular mode";

  DefBut(&dbut[BEUCL],  winC, PMOFFX+30, PMOFFY+26, 60, BUTTH-2, 
	   "Euclid", infobg, CNTCOL);
  dbut[BEUCL].explstr = "2D contour plot of orbital/density\nin a plane";
  DefBut(&dbut[B3D],    winC, PMOFFX+15, PMOFFY+26+(BUTTH+2)*1, 40, BUTTH-2, 
	   "3D", infobg, CNTCOL);
  dbut[B3D].explstr = "3D plot of orbital/density\nin a plane";
  DefBut(&dbut[B3DX],   winC, PMOFFX+65, PMOFFY+26+(BUTTH+2)*1, 40, BUTTH-2, 
	   "3D-X", infobg, CNTCOL);
  dbut[B3DX].explstr = "3D plot of orbital/density\nin a plane:\nXwindows rendering";
  DefBut(&dbut[BSPACE], winC, PMOFFX+5, PMOFFY+26+(BUTTH+2)*2, 50, BUTTH-2, 
	   "Space", infobg, CNTCOL);
  dbut[BSPACE].explstr = "iso-surface of orbital/density\ncalculated in a 3D grid";
  DefBut(&dbut[BVRML2], winC, PMOFFX+63, PMOFFY+26+(BUTTH+2)*2, 24, 24, 
	   "VRML", infobg, CNTCOL);
  dbut[BVRML2].explstr = "write a Virtual Reality Modeling Language\nrepresentation of the current plot";
  DefBut(&dbut[BSRF2],  winC, PMOFFX+93, PMOFFY+26+(BUTTH+2)*2, 24, 24, 
	   "SRF", infobg, CNTCOL);
  dbut[BSRF2].explstr = "convert space plot so it can be\ndisplayed in molecular mode";

  DefBut(&dbut[BINCRS], winC, D3OFFX+BOFFX, D3OFFY+24+BUTTN*0, 80, BUTTH, 
	   "Incr. Scale", infobg, CNTCOL);
  dbut[BINCRS].explstr = "increase the heigth of the 3D plot.";
  DefBut(&dbut[BDECRS], winC, D3OFFX+BOFFX, D3OFFY+24+BUTTN*1, 80, BUTTH, 
	   "Decr. Scale", infobg, CNTCOL);
  dbut[BDECRS].explstr = "decrease the heigth of the 3D plot.";
  DefBut(&dbut[BCONT],  winC, D3OFFX+BOFFX, D3OFFY+24+BUTTN*2, TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  dbut[BCONT].explstr = "toggle contours on/off in the 3D plot.";
  DefBut(&dbut[BMOL],   winC, D3OFFX+BOFFX, D3OFFY+24+BUTTN*3, TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  dbut[BMOL].explstr = "toggle molecule on/off in the 3D plot.";

  DefBut(&dbut[BSTEP],  winC, CNOFFX+BOFFX, CNOFFY+24+BUTTN*0, 60, BUTTH, 
	   "Step", infobg, CNTCOL);
  dbut[BSTEP].explstr = "function value increment between\nconsequtive contour lines ";
  DefBut(&dbut[BCUT],   winC, CNOFFX+BOFFX, CNOFFY+24+BUTTN*1, 60, BUTTH, 
	   "Cut", infobg, CNTCOL);
  dbut[BCUT].explstr = "contours above cutoff are not shown";

  DefBut(&dbut[BFILL],  winC, SPOFFX+BOFFX, SPOFFY+24, TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);

  DefBut(&dbut[BWRBAS], winC, BSOFFX+BOFFX, BSOFFY+24+BUTTN*0, 70, BUTTH, 
	   "Write Grid", infobg, CNTCOL);
  dbut[BWRBAS].explstr = "write 2D/3D grid as\ngridfile/3dgrifile";
  DefBut(&dbut[BRDBAS], winC, BSOFFX+BOFFX, BSOFFY+24+BUTTN*1, 70, BUTTH, 
	   "Read Grid", infobg, CNTCOL);
  dbut[BRDBAS].explstr = "read 2D/3D grid as\ngridfile/3dgrifile";

  DefBut(&dbut[BCUBE],  winC, QOFFX+BOFFX, QOFFY+3, 70, BUTTH, 
	   "Rd/Wr Cube", infobg, CNTCOL);
  dbut[BCUBE].explstr = "read/write Gaussian cube file (3D grid)";

  DefBut(&dbut[BQUIT],  winC, QOFFX+BOFFX+80, QOFFY+1, 22, 22, 
	   "Quit", infobg, CNTCOL);
  dbut[BQUIT].explstr = "exit molden";

  DefBut(&dbut[BGIF2],  winC, MSOFFX+BOFFX+90, MSOFFY+24+BUTTN*2, 22, 22, 
	   "Quit", infobg, CNTCOL);
  dbut[BGIF2].explstr = "Make a gif file of each screen update.";

  DefBut(&dbut[BLOCAL], winC, PLOFFX+BOFFX+65, PLOFFY+24, 60, BUTTH, 
	   "Local", infobg, CNTCOL);
  dbut[BLOCAL].explstr = "Boys localization of orbitals";

#ifdef DOGL
  DefBut(&dbut[BOGL],  winC, PMOFFX+93, PMOFFY+21, 24, 24, 
	   "Ogl", infobg, CNTCOL);
  dbut[BOGL].explstr = "switch between Xwindows (primitive)\nand OpenGL (quality) rendering";
#endif

  dbut[BVRML2].pix = VRMLPix;
  dbut[BVRML2].pw  = vrml_width;
  dbut[BVRML2].ph  = vrml_height;

  dbut[BSRF2].pix = SurfPix;
  dbut[BSRF2].pw  = surf_width;
  dbut[BSRF2].ph  = surf_height;

  dbut[BQUIT].pix = SkullPix;
  dbut[BQUIT].pw  = skull_width;
  dbut[BQUIT].ph  = skull_height;

  dbut[BGIF2].pix = FotoPix;
  dbut[BGIF2].pw  = foto_width;
  dbut[BGIF2].ph  = foto_height;

#ifdef DOGL
  dbut[BOGL].pix = OGLPix;
  dbut[BOGL].pw  = ogl_width;
  dbut[BOGL].ph  = ogl_height;

  if (*ifdogl) TogDown(&dbut[BOGL]);
  else TogUp(&dbut[BOGL]);
#endif

  WinObj[1].win = &winC;
  WinObj[1].subwin = &subC;
  WinObj[1].butarr = dbut;
  WinObj[1].numbut = NBUTTS;
  WinObj[1].winup = NULL;
  WinObj[1].redraw = NULL;

  if (DEBUG) fprintf(stderr,"CreatewinC out\n");
}
  

void CreatewinMC(geom)
char *geom;
{


  if (DEBUG) fprintf(stderr,"CreatewinMC in\n");

  winMC = CreateWindow("Molden Control",geom,WINMCWIDE, WINMCHIGH, infobg, infofg,(Window)0);

  subMC = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],winMC);

  DefBut(&cbut[BFIRST], winMC, POFFX+BOFFX , POFFY+24         , 60, BUTTH, 
	   "First", infobg, CNTCOL);
  cbut[BFIRST].explstr = "When multiple structures available:\nMD trajectory, Geometry optimisation etc.\nGo to the first structure";

  DefBut(&cbut[BNEXT] , winMC, POFFX+BOFFX-5 , POFFY+24+BUTTN   , 35, BUTTH, 
	   "Next", infobg, CNTCOL);
  cbut[BNEXT].explstr = "When multiple structures available:\nMD trajectory, Geometry optimisation etc.\nGo to the next structure";

  DefBut(&cbut[BPREV] , winMC, POFFX+BOFFX+33 , POFFY+24+BUTTN   , 33, BUTTH, 
	   "Prev", infobg, CNTCOL);
  cbut[BPREV].explstr = "When multiple structures available:\nMD trajectory, Geometry optimisation etc.\nGo to the previous structure";

  DefBut(&cbut[BMOVIE], winMC, POFFX+BOFFX , POFFY+24+BUTTN*2 , 60, BUTTH, 
	   "Movie", infobg, CNTCOL);
  cbut[BMOVIE].explstr = "When multiple structures available:\nMD trajectory, Geometry optimisation etc.\nDisplay all structures as a movie";

  DefBut(&cbut[BMOLF], winMC,  POFFX+BOFFX+63,  POFFY+22, 24, 24, 
	   " ", infobg, CNTCOL);
  cbut[BMOLF].explstr = "Multiple outputs available in\nMolden format file\nClick two select output";

  DefBut(&cbut[BHOUR], winMC,  POFFX+BOFFX+70 , POFFY+24+BUTTN , 20, 25, 
	   " ", infobg, CNTCOL);
  cbut[BHOUR].explstr = "Set Minimum time\nbetween Movie frames";


  DefBut(&cbut[BSOLID], winMC, DMOFFX+BOFFX, DMOFFY+24        , TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  cbut[BSOLID].explstr = "Toggle between stick and\nSolid drawing modes";

  DefBut(&cbut[BATCOL], winMC, DMOFFX+BOFFX, DMOFFY+24+BUTTN  , TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  TogDown(&cbut[BATCOL]); 
  cbut[BATCOL].explstr = "Color by Atom or\nSubstructure (residue)";

  DefBut(&cbut[BSHADE], winMC, DMOFFX+BOFFX, DMOFFY+24+BUTTN*2, TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  cbut[BSHADE].explstr = "Apply depth shading";

  DefBut(&cbut[BPERSP], winMC, DMOFFX+BOFFX, DMOFFY+24+BUTTN*3, TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  cbut[BPERSP].explstr = "Toggle Perspective or\nOrthographic projection";

  DefBut(&cbut[BLABEL], winMC, DMOFFX+BOFFX, DMOFFY+24+BUTTN*4, TOGGWH, TOGGWH, 
	   " ", infobg, CNTCOL);
  DefBut(&cbut[BBACKB], winMC, DMOFFX+BOFFX, DMOFFY+24+BUTTN*5, TOGGWH, TOGGWH, 
	   "", infobg, CNTCOL);
  cbut[BBACKB].explstr = "Switch All Atom vs Backbone Atoms Only\nOnly for Protein Structures\nIn Solid mode,\nbackbone is drawn in cartoon style";

  DefBut(&cbut[BZOOMIN],  winMC, XOFFX+10, XOFFY+20+9, 30, 23, 
	   "In", infobg, CNTCOL);
  cbut[BZOOMIN].explstr = "Translate structure\nalong Z-axis. Alternative:\nCtrl+left mouse button+drag";

  DefBut(&cbut[BZOOMOUT], winMC, XOFFX+10, XOFFY+20+9+BUTTN, 30, 23, 
	   "Out", infobg, CNTCOL);
  cbut[BZOOMOUT].explstr = "Translate structure\nalong Z-axis. Alternative:\nCtrl+left mouse button+drag";

  DefBut(&cbut[BDENMOD], winMC, MOFFX+BOFFX, MOFFY+24     , 80, BUTTH, 
	   "Dens. Mode", infobg, CNTCOL);
  cbut[BDENMOD].explstr = "Switch to Density/Orbital mode";

  DefBut(&cbut[BREADF],  winMC, MOFFX+BOFFX-5, MOFFY+24+BUTTN*1, 40, BUTTH, 
	   "Read", infobg, CNTCOL);
  cbut[BREADF].explstr = "Read new structure from file";

  DefBut(&cbut[BWRITF],  winMC, MOFFX+BOFFX+45, MOFFY+24+BUTTN*1, 45, BUTTH, 
	   "Write", infobg, CNTCOL);
  cbut[BWRITF].explstr = "Write current structure to file";

  DefBut(&cbut[BZMAT],   winMC, MOFFX+BOFFX, MOFFY+24+BUTTN*2, 80, BUTTH, 
	   "ZMAT Editor", infobg, CNTCOL);
  cbut[BZMAT].explstr = "Edit internal coordinates of structure\nEdit Phi,Psi,Chi (Proteins Only)\nAnimate internal coordinates\nSubmit Gaussian/Gamess/Mopac jobs";
  DefBut(&cbut[BPOSTT],  winMC, MOFFX+BOFFX, MOFFY+24+BUTTN*3, 80, BUTTH, 
	   "PostScript", infobg, CNTCOL);

  DefBut(&cbut[BAUTH],   winMC, MIOFFX+6, MIOFFY+MICONY, 24, 24, 
	   "Auth", infobg, CNTCOL);
  cbut[BAUTH].explstr = "Apply force field\nOptimise with Amber/GAFF/Tinker\nSet atom properties:\nStickColor, Residue, Charge";

  DefBut(&cbut[BGIF],    winMC, MIOFFX+6, MIOFFY+MICONY+4+BUTTN, 24, 24, 
	   "Foto", infobg, CNTCOL);
  cbut[BGIF].explstr = "picture of each screen update.\nstick mode: GIF";

  DefBut(&cbut[BMOV],    winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*2, 24, 24, 
	   "Movie", infobg, CNTCOL);
  cbut[BMOV].explstr = "Create movie of screen updates.\n";

  DefBut(&cbut[BPAL],    winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*3, 24, 24, 
	   "Palette", infobg, CNTCOL);
  cbut[BPAL].explstr = "Change/Set Colors\nElement Properties\nSet Depth Shading";

  DefBut(&cbut[BCELL],   winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*4, 24, 24, 
	   "Cell", infobg, CNTCOL);
  cbut[BCELL].explstr = "Display/Create/Edit\nCrystal Structures";

  DefBut(&cbut[BORIG],   winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*5, 24, 24, 
	   "Origin", infobg, CNTCOL);
  cbut[BORIG].explstr = "Click on an atom\nto set new origin";

  DefBut(&cbut[BSURF],   winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*6, 24, 24, 
	   "Surface", infobg, CNTCOL);
  cbut[BSURF].explstr = "Create Surfaces,\nCalculate Charges,\nMultipoles,Dipole";

  DefBut(&cbut[BVRML],   winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*7, 24, 24, 
	   "VRML", infobg, CNTCOL);
  cbut[BVRML].explstr = "Virtual Reality Modeling Language,\nPovray, OpenGl helper program";

  DefBut(&cbut[BHYD],    winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*8, 24, 24, 
	   "Quit", infobg, CNTCOL);
  cbut[BHYD].explstr = "(Re)Calculate Hydrogen Bonds,\nSet Parameters Hydrogen Bonds,\n(Un)Display Hydrogens";

  DefBut(&cbut[BALIGN],  winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*9, 24, 24, 
	   "Align", infobg, CNTCOL);
  cbut[BALIGN].explstr = "Align two molecules,\nInteractive Docking";

  DefBut(&cbut[BQUITT],  winMC, MIOFFX+6, MIOFFY+MICONY+(4+BUTTN)*10, 24, 24, 
	   "Quit", infobg, CNTCOL);
  cbut[BQUITT].explstr = "Exit Molden";


  DefBut(&cbut[BDIST],  winMC, CLOFFX+BOFFX, CLOFFY+24        , 80, BUTTH, 
	   "Distance", infobg, CNTCOL);
  cbut[BDIST].explstr = "Calculate interatomic distance\nClick on two atoms";

  DefBut(&cbut[BANGLE], winMC, CLOFFX+BOFFX, CLOFFY+24+BUTTN*1, 80, BUTTH, 
	   "Angle", infobg, CNTCOL);
  cbut[BANGLE].explstr = "Calculate angle\nClick on three atoms";

  DefBut(&cbut[BDIHED], winMC, CLOFFX+BOFFX, CLOFFY+24+BUTTN*2, 80, BUTTH, 
	   "Dihedral", infobg, CNTCOL);
  cbut[BDIHED].explstr = "Calculate dihedral angle\nClick on four atoms";

  DefBut(&cbut[BCONV],  winMC, CVOFFX+BOFFX, CVOFFY+24        , 80, BUTTH, 
	   "SCF conv.", infobg, CNTCOL);
  cbut[BCONV].explstr = "Self Consistent Field convergence\nGamess/Gaussian/Molf Only";

  DefBut(&cbut[BGEOM],  winMC, CVOFFX+BOFFX, CVOFFY+24+BUTTN*1, 80, BUTTH, 
	   "Geom. conv.", infobg, CNTCOL);
  cbut[BGEOM].explstr = "Geometry convergence, for\nmultiple structures combined\nwith Energy/Step/Force info";

  DefBut(&cbut[BLEFT],  winMC, XOFFX+50   , XOFFY+5+BUTTN*1, 23, 23, 
	   "<", infobg, CNTCOL);
  cbut[BLEFT].explstr = "Translate structure\nalong X-axis. Alternative:\nShift+left mouse button+drag";

  DefBut(&cbut[BRIGHT], winMC, XOFFX+50+50, XOFFY+5+BUTTN*1, 23, 23, 
	   ">", infobg, CNTCOL);
  cbut[BRIGHT].explstr = "Translate structure\nalong X-axis. Alternative:\nShift+left mouse button+drag";

  DefBut(&cbut[BUP],    winMC, XOFFX+50+25, XOFFY+5        , 23, 23, 
	   "^", infobg, CNTCOL);
  cbut[BUP].explstr = "Translate structure\nalong Y-axis. Alternative:\nShift+left mouse button+drag";

  DefBut(&cbut[BDOWN],  winMC, XOFFX+50+25, XOFFY+5+BUTTN*2, 23, 23, 
	   "v", infobg, CNTCOL);
  cbut[BDOWN].explstr = "Translate structure\nalong Y-axis. Alternative:\nShift+left mouse button+drag";

  DefBut(&cbut[BPACE],  winMC, XOFFX+50+25, XOFFY+5+BUTTN*1, 23, 23, 
	   " ", infobg, CNTCOL);
  cbut[BPACE].explstr = "In old style rotation\nSet rotation increment:\nSmall,Medium or Large";

  DefBut(&cbut[BBALL],  winMC, XOFFX+50+65, XOFFY+5+BUTTN*2+7, 15, 15, 
	   " ", infobg, CNTCOL);
  cbut[BBALL].explstr = "Toggle: default rotation style/\nold style rotation";

  DefBut(&cbut[BJCPL],  winMC, CLOFFX+BOFFX+70, CLOFFY+5, 15, 15, 
	   "J", infobg, CNTCOL);
  cbut[BJCPL].explstr = "Calculate J coupling two atoms";

  if ( colcells < 16 ) ActBut(&cbut[BSHADE],0);
  if (monoscr) ActBut(&cbut[BATCOL],0);
  
  cbut[BUP].pix = upPix;
  cbut[BUP].pw  = up_width;
  cbut[BUP].ph  = up_height;

  cbut[BDOWN].pix = downPix;
  cbut[BDOWN].pw  = down_width;
  cbut[BDOWN].ph  = down_height;

  cbut[BLEFT].pix = lPix;
  cbut[BLEFT].pw  = l_width;
  cbut[BLEFT].ph  = l_height;

  cbut[BRIGHT].pix = rPix;
  cbut[BRIGHT].pw  = r_width;
  cbut[BRIGHT].ph  = r_height;

  cbut[BBALL].pix = ballPix;
  cbut[BBALL].pw  = ball_width;
  cbut[BBALL].ph  = ball_height;

  cbut[BAUTH].pix = FFPix;
  cbut[BAUTH].pw  = ff_width;
  cbut[BAUTH].ph  = ff_height;

  cbut[BMOLF].pix = MLFPix;
  cbut[BMOLF].pw  = mlf_width;
  cbut[BMOLF].ph  = mlf_height;

/* Old, sigh
  cbut[BAUTH].pix = gPix;
  cbut[BAUTH].pw  = g_width;
  cbut[BAUTH].ph  = g_height;
*/

  cbut[BQUITT].pix = SkullPix;
  cbut[BQUITT].pw  = skull_width;
  cbut[BQUITT].ph  = skull_height;

  cbut[BHYD].pix = HPix;
  cbut[BHYD].pw  = hbit_width;
  cbut[BHYD].ph  = hbit_height;

  cbut[BORIG].pix = OrigPix;
  cbut[BORIG].pw  = orig_width;
  cbut[BORIG].ph  = orig_height;

  cbut[BSURF].pix = SurfPix;
  cbut[BSURF].pw  = surf_width;
  cbut[BSURF].ph  = surf_height;

  cbut[BVRML].pix = VRMLPix;
  cbut[BVRML].pw  = vrml_width;
  cbut[BVRML].ph  = vrml_height;

  cbut[BALIGN].pix = AlignPix;
  cbut[BALIGN].pw  = align_width;
  cbut[BALIGN].ph  = align_height;

  cbut[BCELL].pix = CellPix;
  cbut[BCELL].pw  = cell_width;
  cbut[BCELL].ph  = cell_height;

  cbut[BGIF].pix = FotoPix;
  cbut[BGIF].pw  = foto_width;
  cbut[BGIF].ph  = foto_height;

  cbut[BPAL].pix = ColPix;
  cbut[BPAL].pw  = palette_width;
  cbut[BPAL].ph  = palette_height;

  cbut[BHOUR].pix = HourPix;
  cbut[BHOUR].pw  = hourglass_width;
  cbut[BHOUR].ph  = hourglass_height;

  cbut[BMOV].pix = movPix;
  cbut[BMOV].pw  = film_width;
  cbut[BMOV].ph  = film_height;

  cbut[BPACE].pw  = pace_width;
  cbut[BPACE].ph  = pace_height;
  if (coarse==2) cbut[BPACE].pix = blastPix; 
  else if(coarse==1) cbut[BPACE].pix = fastPix;
  else cbut[BPACE].pix = slowPix;
  if (*ball) TogDown(&cbut[BBALL]);
  else TogUp(&cbut[BBALL]);
  if (*shade) TogDown(&cbut[BSHADE]);
  else TogUp(&cbut[BSHADE]);

  WinObj[0].win = &winMC;
  WinObj[0].subwin = &subMC;
  WinObj[0].butarr = cbut;
  WinObj[0].numbut = NBUTTS2;
  WinObj[0].winup = NULL;
  WinObj[0].redraw = NULL;

  if (DEBUG) fprintf(stderr,"CreatewinMC out\n");
}

/***************************************************/
void DirBox(hwin,vis)
Window  hwin;
int vis;
{
  if (vis) XMapRaised(display, hwin);
  else     XUnmapWindow(display, hwin);

}


/***************************************************/
void RedrawwinC(x,y,w,h)
int x,y,w,h;
{
  int  i;
  XRectangle xr;

  if (DEBUG) fprintf(stderr,"RedrawwinC in\n");
  xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
  XSetClipRectangles(display, gc, 0,0, &xr, 1, Unsorted);

  if (monoscr) {
	XSetFillStyle(display, gc, FillStippled);
	XSetStipple(display, gc, grayStip);
	XSetForeground(display, gc, infobg);
	XFillRectangle(display, winC, gc, PLOFFX, PLOFFY+22,120 ,198);
	XFillRectangle(display, winC, gc, MSOFFX, MSOFFY+22,120 ,102);
	XFillRectangle(display, winC, gc, PMOFFX, PMOFFY+22,120 ,73);
	XFillRectangle(display, winC, gc, D3OFFX, D3OFFY+22,120 ,52);
	XFillRectangle(display, winC, gc, CNOFFX, CNOFFY+22,120 ,50);
	XFillRectangle(display, winC, gc, BSOFFX, BSOFFY+22,120 ,50);
	XSetForeground(display, gc, infofg);
	XSetFillStyle(display, gc, FillSolid);}
  else {
	butje(winC,PLOFFX,PLOFFY,140,220,1,0,0,1,None,0,0,0,0);
	butje(winC,MSOFFX,MSOFFY,140,124,1,0,0,1,None,0,0,0,0);
	butje(winC,SPOFFX,SPOFFY,140,50,1,0,0,1,None,0,0,0,0);
	butje(winC,PMOFFX,PMOFFY,120,95,1,0,0,1,None,0,0,0,0);
	butje(winC,D3OFFX,D3OFFY,120,126,1,0,0,1,None,0,0,0,0);
	butje(winC,CNOFFX,CNOFFY,120,75,1,0,0,1,None,0,0,0,0);
	butje(winC,BSOFFX,BSOFFY,120,75,1,0,0,1,None,0,0,0,0);
	butje(winC,QOFFX,QOFFY,120,25,1,0,0,1,None,0,0,0,0);
  }


  for (i=0; i<NBUTTS; i++) 
	DrwBut(&dbut[i]);

  ULineString(winC, "Plot Function:"  , PLOFFX+BOFFX, PLOFFY+15);
  ULineString(winC, "Miscellaneous:"  , MSOFFX+BOFFX, MSOFFY+15);
  ULineString(winC, "Plot Mode:"      , PMOFFX+30   , PMOFFY+15);
  ULineString(winC, "3D subcommands:" , D3OFFX+BOFFX, D3OFFY+15);
  ULineString(winC, "Contour subcomm.", CNOFFX+BOFFX, CNOFFY+15);
  ULineString(winC, "Space subcomm."  , SPOFFX+BOFFX, SPOFFY+15);
  ULineString(winC, "Basisset Differ.", BSOFFX+BOFFX, BSOFFY+15);
  ULineString(winC, "Status line:"    , S2OFFX+5 , S2OFFY);

  LineString(winC, "Orient"  , PLOFFX+BOFFX+88,PLOFFY+50+BUTTN*4);
  LineString(winC, "Fill"    , SPOFFX+BOFFX+28, SPOFFY+38);
  LineString(winC, "Contours", D3OFFX+BOFFX+28, D3OFFY+38+BUTTN*2);
  LineString(winC, "Molecule", D3OFFX+BOFFX+28, D3OFFY+38+BUTTN*3);

  XDrawRectangle(display, winC, gc, S2OFFX, S2OFFY+7,240 ,20);
  XDrawString(display,winC,gc,S2OFFX+5,S2OFFY+20,densstr,MINI(MAXSTRLMW,strlen(densstr)));

  XSetClipMask(display, gc, None);
  if (DEBUG) fprintf(stderr,"RedrawwinC out\n");
}


/***************************************************/
void RedrawwinMC(x,y,w,h)
int x,y,w,h;
{
  int  i,r;

  if (DEBUG) fprintf(stderr,"RedrawwinMC in\n");

  if (monoscr) {
	XSetForeground(display, gc, infobg);
	XSetBackground(display, gc, infofg);
	XSetFillStyle(display, gc, FillOpaqueStippled);
	XSetStipple(display, gc, grayStip);
	XFillRectangle(display, winMC, gc, POFFX+5, POFFY+22 ,98 ,80);
	XFillRectangle(display, winMC, gc, MOFFX+5, MOFFY+22 ,98 ,95);
	if (!pdb) XFillRectangle(display, winMC, gc, FOFFX, 48,100 ,95);
	XFillRectangle(display, winMC, gc, CLOFFX, CLOFFY+22,100 ,72);
	XFillRectangle(display, winMC, gc, CVOFFX, CVOFFY+22,100 ,52);
	XSetFillStyle(display, gc, FillSolid);
	XSetForeground(display, gc, infofg);
	if (pdb) XFillRectangle(display, winMC, gc, FOFFX, FOFFY,100 ,146);
	else XFillRectangle(display, winMC, gc, FOFFX, FOFFY,110 ,44);
  }
  else {
	r = 1;
	if (DoIntel) r = 2;
	butje(winMC,POFFX,POFFY,108,101,r,0,0,1,None,0,0,0,0);
	butje(winMC,MOFFX,MOFFY,108,125,r,0,0,1,None,0,0,0,0);
	butje(winMC,DMOFFX,DMOFFY,108,176,r,0,0,1,None,0,0,0,0);

	butje(winMC,MIOFFX,MIOFFY,35,315,r,0,0,1,None,0,0,0,0);

	butje(winMC,FOFFX,FOFFY,107,146,r,0,0,1,None,0,0,0,0);
	butje(winMC,CLOFFX,CLOFFY,107,96,r,0,0,1,None,0,0,0,0);
	butje(winMC,CVOFFX,CVOFFY,107,75,r,0,0,1,None,0,0,0,0);

	butje(winMC,XOFFX,XOFFY,141,86,r,0,0,1,None,0,0,0,0);
  }



  for (i=0; i<NBUTTS2; i++) {
	if (! ( (i == BMOLF && ntits <= 1) || 
	        (i == BJCPL && nmrptr->ihsnmr != 2) ) )
	   DrwBut(&cbut[i]);
  }

  ULineString(winMC, "Select Point:", POFFX+BOFFX , POFFY+15);
  ULineString(winMC, "Draw Mode:"   , DMOFFX+BOFFX , DMOFFY+15);
  ULineString(winMC, "Zoom:"        , XOFFX+10 , XOFFY+20);
  if (pdb) {
	ULineString(winMC, "Add to BackBone:", FOFFX+BOFFX, FOFFY+15);
	LineString(winMC, "SulfurBridge",      FOFFX+BOFFX+20, FOFFY+38+BUTTN*3);
	LineString(winMC, "H-bonds",           FOFFX+BOFFX+20, FOFFY+38+BUTTN*4);
  } else {
	if (frfor) {
	   if (nmrptr->ihsnmr) {
		ULineString(winMC, "Spectrum:", FOFFX+BOFFX , FOFFY+15);
		LineString(winMC, "NMR Spectr."         , 
			FOFFX+BOFFX+20 , FOFFY+38);
	   } else if (*ihasex) {
		ULineString(winMC, "Spectrum:", FOFFX+BOFFX , FOFFY+15);
		LineString(winMC, "UV spectrum"         , 
			FOFFX+BOFFX+20 , FOFFY+38);
	   } else {
		ULineString(winMC, "Frequecies:", FOFFX+BOFFX , FOFFY+15);
		LineString(winMC, "Norm. Mode"         , 
			FOFFX+BOFFX+20 , FOFFY+38);
	   }
	} else {
	   ULineString(winMC, "Render Forces:", FOFFX+BOFFX , FOFFY+15);
	   LineString(winMC, "Forces"         , FOFFX+BOFFX+28 , FOFFY+38);
	}
  }

  ULineString(winMC, "Calculate :"   , CLOFFX+BOFFX, CLOFFY+15);
  ULineString(winMC, "Miscellaneous:", MOFFX+BOFFX , MOFFY+15);
  ULineString(winMC, "Status line:"  , SOFFX+5  , SOFFY);
  ULineString(winMC, "Convergence:"  , CVOFFX+BOFFX, CVOFFY+15);

  LineString(winMC, "Solid",      DMOFFX+BOFFX+28, DMOFFY+38);
  LineString(winMC, "StickColor", DMOFFX+BOFFX+28, DMOFFY+38+BUTTN);
  LineString(winMC, "Shade",      DMOFFX+BOFFX+28, DMOFFY+38+BUTTN*2);
  LineString(winMC, "Perspect.",     DMOFFX+BOFFX+28, DMOFFY+38+BUTTN*3);
  LineString(winMC, "Label",      DMOFFX+BOFFX+28, DMOFFY+38+BUTTN*4);
  LineString(winMC, "BackBone",   DMOFFX+BOFFX+28, DMOFFY+38+BUTTN*5);

  XDrawRectangle(display, winMC, gc, SOFFX, SOFFY+7,240 ,20);
  XDrawString(display,winMC,gc,SOFFX+5,SOFFY+20,molwstr,MINI(MAXSTRLMW,strlen(molwstr)));

  if (DEBUG) fprintf(stderr,"RedrawwinMC out\n");
}

void RedrawCOMMwin()
{
  int xboff,yboff,boff;

  xboff = 10; boff = 20; yboff = boff+30;
  XSetForeground(display, gc, infobg);
  PromptBox(&qboxes[QCOMM]); 

  butje(COMMwin,0,yboff-boff,QBOXWIDE,QBOXTX-boff-10,4,0,0,1,None,0,0,0,0);
  XDrawString(display,COMMwin,gc,xboff,yboff ,
  "The following commands are available:",37);
  XDrawString(display,COMMwin,gc,xboff,yboff+20 ,
  "Plane  = (atom1,atom2,atom3)  3 atoms define the plotplane             ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+30 ,
  "Rot    = (atom1,atom2,nnn.nn) rotate this plane  n.nn degrees around   ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+40 ,
  "                              the axis from atom1 and atom2, which must",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+50 ,
  "                              be one of the atoms used with plane      ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+60 ,
  "Center = atom1                coordinates of atom1 define plane center ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+70,
  "Center = (n.nn,n.nn,n.nn)     specify coordinates for plane center     ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+80,
  "Line   = atom1                vector; plane center - atom1 taken as    ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+90,
  "                              the outvector of the plotplane           ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+100,
  "Line   = (n.nn,n.nn,n.nn)     specify the outvector of the plotplane   ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+110,
  "Edge   = n.nn                 specify the size of the plotplane        ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+120,
  "Lift   = n.nn                 translate the center of the plotplane    ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+130,
  "                              along the outvector of the plane         ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+150,
  "Where atom[1-n] is an integer indicating the atoms number in the list  ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+170,
  "align                         center graph = center molecule           ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+180,
  "phase                         toggle the phase (sign) of the plot      ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+200,
  "nptsx  = n                    number of points in the x-direction      ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+210,
  "nptsy  = n                    number of points in the y-direction      ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+220,
  "nptsz  = n                    number of points in the z-direction      ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+230,
  "edx    = n.nn                 size of the plotplane in the x-direction ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+240,
  "edy    = n.nn                 size of the plotplane in the y-direction ",71);
  XDrawString(display,COMMwin,gc,xboff,yboff+250,
  "edz    = n.nn                 size of the plotplane in the z-direction ",71);
}

void RedrawRESwin()
{
  int i;
  int xboff,yboff,boff;

  xboff = 10; boff = 20; yboff = boff+30;
  XSetForeground(display, gc, infobg);
  PromptBox(&qboxes[QRESI]); 

  butje(RESwin,0,yboff-boff,QBOXWIDE,QBOXTX-boff-10,4,0,0,1,None,0,0,0,0);
  XDrawString(display,RESwin,gc,xboff,yboff ,
  "The following commands are available:",37);
  XDrawString(display,RESwin,gc,xboff,yboff+20 ,
  "all [amino|nucl] [col] [surf] display all residues                     ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+30 ,
  "clear [surf]                  clear all displayed residues             ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+40 ,
  "ala [col] [surf]              display all alanines                     ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+50 ,
  "                              Valid strings are:                       ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+60 ,
  "                              gly ala ser cys thr ile val met asp asn  ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+70,
  "                              leu lys glu gln pro arg his phe tyr trp  ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+80,
  "pos [col] [surf]              positively charged residues: lys arg his ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+90,
  "neg [col] [surf]              negatively charged residues: asp glu     ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+100,
  "cha [col] [surf]              charged residues: pos + neg              ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+110,
  "pol [col] [surf]              polar residues: cha + ser thr asn gln    ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+120,
  "aro [col] [surf]              aromatic aminoacids: phe + tyr + trp     ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+130,
  "ali [col] [surf]              display all aliphatic aminoacids:        ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+140,
  "                              gly + ala + val + leu + ile + pro        ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+150,
  "(aikknx) [col] [surf]         display all aminoacids specified by one  ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+160,
  "                              letter code pattern (max. 20 residues)   ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+170,
  "hel [rod | ball] [incl] [col] helix      [display type] [+backbone]    ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+180,
  "bet [rod | ball] [incl] [col] beta sheet [display type] [+backbone]    ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+200,
  "All previous symbols can be combined, and negated by the use of: not   ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+220,
  "20-30[:ChainNr] [col] [surf]  display residues number 20 through 31    ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+230,
  "20-30[:ChainNr] [hel|bet|rnd] set secondary structure of res. 20 to 30 ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+240,
  "neigh[=r] [surf]              display all neighbours at distance r Angs",71);
  XDrawString(display,RESwin,gc,xboff,yboff+250,
  "suron [mapped [local|global]] surface drawing mode ON, [map potential] ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+260,
  "suroff                        switches off surface drawing mode        ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+270,
  "all surf                      all currently displayed atoms as surface ",71);
  XDrawString(display,RESwin,gc,xboff,yboff+280,
  "[col]                         color select,if omitted def. per amin.a  ",71);
}

void filecall(char *str)
{
	cpstr(str,gfile,SUBLEN1);
}

void fwincall(char *str)
{
	getfiles(&fsel,str);
	RedrawFwin(&fsel);
}

void substrcall(char *str)
{
	getfiles(&fsel,fsel.lastdir);
	RedrawFwin(&fsel);
}

void getpdbcall(char *str)
{
	if (!CheckWGET()) {
	    GetPDBWWW(qboxes[QPDB].str,strname);
	    if (ParseFile(strname,qboxes[QPDB].str)) return;
	}
}



int PDBFile(strname)
char *strname;
{
   int naat;
   struct stat st_record;

   stat(strname, &st_record);
   if (st_record.st_size <= 1) {
	fprintf(stderr,"Empty file !\n");
	return(0);
   }

   naat = 0;

   if (!IsBinary(strname)) {
	int ispdb,i;
	FILE *f;
	char cmdfil[MAXCMD];

	ispdb = 0;
	f = fopen(strname,"r");

	for (i = 0; i < 10; i++) {       
	   fgets(cmdfil,MAXCMD,f);
           if (strstr(cmdfil,"HEADER")) ispdb = 1;

	}

	if (ispdb) {
	   rewind(f);
	   while (1) {
		if (fgets(cmdfil,MAXCMD,f) == NULL) break;
		if (strstr(cmdfil,"ATOM") || strstr(cmdfil,"HETATM")) naat++;
	   }
	   naat = naat * 3;
	}
	fclose(f);
   }
   return(naat);
}

int NAtMax(strname)
char *strname;
{
   int mx;

   mx = 0;

   if (!IsBinary(strname)) {
	int i,mxh;
	FILE *f;
	char cmdfil[MAXCMD];

	f = fopen(strname,"r");

	rewind(f);
	mx = 0;
	while (1) {
		if (fgets(cmdfil,MAXCMD,f) == NULL) break;
		if (strstr(cmdfil,"V2000")) {
		    sscanf(cmdfil,"%d",&mxh);
		    if (mxh > mx) mx = mxh;
		}
	}
	fclose(f);
   }
   return(mx);
}

#define MXSTRFOR 151

#if defined(VMS) || defined(UNDERSC)
void nxtlin(str,istat)
#else
#ifdef CRAY
void NXTLIN(str,istat)
#else
void nxtlin_(str,istat)
#endif
#endif
#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *istat;
{
   int i1,i2;
   int i,n;
   char *t;

   if (COO[istruct] == NULL || nomemf) {
#if defined(VMS) || defined(UNDERSC)
	nxline(str,istat);
#else
#ifdef CRAY
	NXLINE(str,istat);
#else
	nxline_(str,istat);
#endif
#endif
	return;
   }

   if (COO[istruct]->memfil.str != NULL) {

	*istat = 0;
	i1 = COO[istruct]->memfil.line_index[COO[istruct]->memfil.currl];
	COO[istruct]->memfil.currl++;

	if (COO[istruct]->memfil.currl < COO[istruct]->memfil.nlines) {
	   i2 = COO[istruct]->memfil.line_index[COO[istruct]->memfil.currl];
	   n = i2 - i1 - 1;
	} else {
	   if (COO[istruct]->memfil.currl == COO[istruct]->memfil.nlines) {
		n = COO[istruct]->memfil.size - i1 - 1;
	   } else {
		COO[istruct]->memfil.currl = COO[istruct]->memfil.nlines - 1;
		*istat = 1;
		return;
	   }
	}

	if (n > MXSTRFOR) n = MXSTRFOR;
	if (n < 0) n = 0;

#ifdef VMS
   for (i=0; i<n; i++)
       {str->dsc$a_pointer[i] = COO[istruct]->memfil.str[i1+i];}
#else
#ifdef CRAY
   strncpy(_fcdtocp(str),&COO[istruct]->memfil.str[i1],n);
#else
   strncpy(str,&COO[istruct]->memfil.str[i1],(size_t) n);
   str[n] = '\0';
   for (i=n; i<137; i++) str[i] = ' ';
#endif
#endif

   } else {
   
#if defined(VMS) || defined(UNDERSC)
   nxline(str,istat);
#else
#ifdef CRAY
   NXLINE(str,istat);
#else
   nxline_(str,istat);
#endif
#endif

   }

}


#if defined(VMS) || defined(UNDERSC)
void redel(str,n)
#else
#ifdef CRAY
void REDEL(str,n)
#else
void redel_(str,n)
#endif
#endif
#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *n;
{
    int i;
    int istat;

   if (COO[istruct] == NULL || nomemf) {
#if defined(VMS) || defined(UNDERSC)
    readel(str,n);
#else
#ifdef CRAY
    READEL(str,n);
#else
    readel_(str,n);
#endif
#endif
    return;
   }

   if (COO[istruct]->memfil.str != NULL) {
    for (i=0; i<*n; i++) {
#if defined(VMS) || defined(UNDERSC)
	nxtlin(str,&istat);
#else
#ifdef CRAY
	NXTLIN(str,&istat);
#else
	nxtlin_(str,&istat);
#endif
#endif
    }
   } else {

#if defined(VMS) || defined(UNDERSC)
    readel(str,n);
#else
#ifdef CRAY
    READEL(str,n);
#else
    readel_(str,n);
#endif
#endif

   }
}

#if defined(VMS) || defined(UNDERSC)
void rewmf()
#else
#ifdef CRAY
void REWMF()
#else
void rewmf_()
#endif
#endif
{
#if defined(VMS) || defined(UNDERSC)
    rewmd(mfdata->mollin);
#else
#ifdef CRAY
    REWMD(mfdata->mollin);
#else
    rewmd_(mfdata->mollin);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void prsqmf()
#else
#ifdef CRAY
void PRSQMF()
#else
void prsqmf_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
    prsqmd(mfdata->mollin);
#else
#ifdef CRAY
    PRSQMD(mfdata->mollin);
#else
    prsqmd_(mfdata->mollin);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void prsomf()
#else
#ifdef CRAY
void PRSOMF()
#else
void prsomf_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
    prsomd(mfdata->mollin);
#else
#ifdef CRAY
    PRSOMD(mfdata->mollin);
#else
    prsomd_(mfdata->mollin);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void prsgmf(iopt)
#else
#ifdef CRAY
void PRSGMF(iopt)
#else
void prsgmf_(iopt)
#endif
#endif
int *iopt;
{

#if defined(VMS) || defined(UNDERSC)
    prsgmd(iopt,mfdata->mollin);
#else
#ifdef CRAY
    PRSGMD(iopt,mfdata->mollin);
#else
    prsgmd_(iopt,mfdata->mollin);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void parsmf()
#else
#ifdef CRAY
void PARSMF()
#else
void parsmf_()
#endif
#endif
{

#if defined(VMS) || defined(UNDERSC)
    parsmd(mfdata->mollin);
#else
#ifdef CRAY
    PARSMD(mfdata->mollin);
#else
    parsmd_(mfdata->mollin);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void rewfil()
#else
#ifdef CRAY
void REWFIL()
#else
void rewfil_()
#endif
#endif
{

 if (COO[istruct] == NULL || nomemf) {
#if defined(VMS) || defined(UNDERSC)
    rwfile();
#else
#ifdef CRAY
    RWFILE();
#else
    rwfile_();
#endif
#endif
    return;
 }

 if (COO[istruct]->memfil.str != NULL) {
   COO[istruct]->memfil.currl = 0;
 } else {

#if defined(VMS) || defined(UNDERSC)
    rwfile();
#else
#ifdef CRAY
    RWFILE();
#else
    rwfile_();
#endif
#endif

 }
}

#if defined(VMS) || defined(UNDERSC)
void bckfil()
#else
#ifdef CRAY
void BCKFIL()
#else
void bckfil_()
#endif
#endif
{

 if (COO[istruct] == NULL || nomemf) {
#if defined(VMS) || defined(UNDERSC)
    bcfile();
#else
#ifdef CRAY
    BCFILE();
#else
    bcfile_();
#endif
#endif
    return;
 }

 if (COO[istruct]->memfil.str != NULL) {
   COO[istruct]->memfil.currl--;
   if (COO[istruct]->memfil.currl < 0) COO[istruct]->memfil.currl = 0;
 } else {

#if defined(VMS) || defined(UNDERSC)
    bcfile();
#else
#ifdef CRAY
    BCFILE();
#else
    bcfile_();
#endif
#endif

 }
}

int GetLineIndx(int idel,FILEOP *fileop)
{
   int i,ipos;

   ipos = fileop->fpos[idel];

   for (i=0; i < fileop->nlines; i++) {
	if (fileop->line_index[i] == ipos) return(i);
   }

   return(-1);
}

void wrtfields(char *strn,FILEOP *fileop,int iopt)
{
   FILE *f;
   int i;

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   f = fopen(strn, "w");

   if (f != NULL && FLDS.FldNames[0] != NULL) {
	if (strstr("logact",FLDS.FldNames[iopt])) fprintf(f,"affinity\n");
	for (i=0; i < fileop->nfiles; i++) {
	   fprintf(f,"%s\n",FLDS.Fields[iopt][i]);
	}
	fclose(f);
	strcpy(molwstr,"Wrote file: ");
	strcat(molwstr,strn);
	StatusStr(0,1);
   }

#if defined(VMS) || defined(UNDERSC)
   curs(&ZERO);
#else
#ifdef CRAY
   CURS(&ZERO);
#else
   curs_(&ZERO);
#endif
#endif

}

void wrtfilmem(char *strn,FILEOP *fileop)
{
   FILE *f;
   int i;

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   f = fopen(strn, "w");

   if (f != NULL) {

	size_t nl = fwrite(fileop->str, sizeof(char), fileop->size, f);
	if (nl != fileop->size) {
	   fprintf(stderr,"Error writing file: %s\n", strn);
	}
	fclose(f);
   }
   strcpy(molwstr,"Wrote file: ");
   strcat(molwstr,strn);
   StatusStr(0,1);

   wrsvgs(strn);

#if defined(VMS) || defined(UNDERSC)
   curs(&ZERO);
#else
#ifdef CRAY
   CURS(&ZERO);
#else
   curs_(&ZERO);
#endif
#endif

}

int GetField(int m, int imol, int *iflds, char *FileC,char **ptr)
{
  int M,N,i;
  char *ptr2;

  *ptr = strchr(*ptr,'<');
  M = (int) (*ptr - FileC);

  if (*ptr != NULL && M < m) {
	(*ptr)++;

	ptr2 = strchr(*ptr,'>');
	M = (int) (ptr2 - FileC);

	if (ptr2 != NULL && M < m) {

	   (*iflds)++;
	   N = (int) (ptr2 - *ptr);

	   if (FLDS.FldNames[*iflds] == NULL) {
		FLDS.FldNames[*iflds] = 
			(char *) malloc(sizeof(char)*(N+1));
		strncpy(FLDS.FldNames[*iflds],*ptr,N);
		FLDS.FldNames[*iflds][N] = '\0';
	   }

	   if (FLDS.Fields[*iflds] == NULL) {
		FLDS.Fields[*iflds] = (char **) malloc(sizeof(char *)*(MAXFIELD));
	   }

	   ptr2++;

	   *ptr = strchr(ptr2,'\n');
	   M = (int) (*ptr - FileC);

	   if (*ptr != NULL && M < m) {

		(*ptr)++;
		ptr2 = strchr(*ptr,'\n');
	   	M = (int) (ptr2 - FileC);
		if (ptr2 != NULL && M < m) {
		   N = (int) (ptr2 - *ptr);
		   FLDS.Fields[*iflds][imol] = 
			(char *) malloc(sizeof(char)*(N+1));
		   if (FLDS.Fields[*iflds][imol] != NULL) {
			strncpy(FLDS.Fields[*iflds][imol],*ptr,N);
			FLDS.Fields[*iflds][imol][N] = '\0';
		   }
		}
	   }
	   return(1);
	} else {
	   return(0);
	}
  } else {
	return(0);
  }
  return(0);
}

void ParseFields(FILEOP *fileop)
{
  char *FileC;
  char *ptr, *ptr2;
  int N,iflds,i,j,m,M;

  if (fileop->opt) {

     if (fileop->nfiles > 1 && !FLDS.done) {

	for (i=0; i < MAXFIELD; i++) {
	   FLDS.FldNames[i] = NULL;
	   FLDS.Fields[i] = (char **) malloc(sizeof(char *)*(fileop->nfiles));
	}

	for (i=0; i < fileop->nfiles; i++) {
	   
     	   iflds = -1;

	   if (i+1 == fileop->nfiles) {
		m = fileop->size - fileop->fpos[i];
           } else {
		m = fileop->fpos[i+1] - fileop->fpos[i];
	   }

	   FileC = (char *) malloc(sizeof(char)*(m+1));
	   strncpy(FileC,&fileop->str[fileop->fpos[i]],m);
	   FileC[m] = '\0';

	   ptr = strstr(FileC,"M  END");
	   M = (int) (ptr - FileC);

	   if (ptr != NULL && M < m) {
		while (GetField(m,i,&iflds,FileC,&ptr)) {};
	   }
	   free(FileC);
	}

     }
  }

  FLDS.nfields = iflds + 1;

  if (DEBUG) {
	for (j=0; j < FLDS.nfields; j++) {
	   fprintf(stderr,"\nfield %s\n\n",FLDS.FldNames[j]);
	   for (i=0; i < fileop->nfiles; i++) {
		fprintf(stderr,"%d value %s\n",i,FLDS.Fields[j][i]);
	   }
	}
  }

  FLDS.done = 1;

}

void DelMemFile(int *idel,FILEOP *fileop)
{
  int i,lineB,lineE,n,m,N,M;

  DeletingFile = 1;

  if (fileop->opt && fileop->list) {

     lineB = GetLineIndx(*idel,fileop);

     if (*idel == fileop->nfiles -1) {
	lineE = fileop->nlines - 1;
     } else {
	lineE = GetLineIndx((*idel)+1,fileop);
     }

     if (lineB != -1 && lineE != -1) {
	N = fileop->size - lineE;
	M = lineE - lineB;

	for (i=0; i < N; i++) {
	   fileop->line_index[lineB+i] = fileop->line_index[lineE+i];
	   fileop->lines[lineB+i] = fileop->lines[lineE+i];
	   mlftit[lineB+i] = mlftit[lineE+i];
	}
	fileop->nlines = fileop->nlines - M;
	fileop->nfiles = fileop->nfiles - 1;
     }

  } else if (fileop->opt && !fileop->list) {

	ntits          = ntits-1;
	COO[istruct]->ntits = ntits;

/* M number of lines delete */
/* m number of characters deleted */

        if (*idel == fileop->nfiles -1) {
	   M = fileop->nlines - mfdata->mollin[*idel];
	   m = fileop->size - fileop->fpos[*idel];
	} else {
	   M = mfdata->mollin[(*idel)+1] - mfdata->mollin[*idel];
	   m = fileop->fpos[(*idel)+1] - fileop->fpos[*idel];
	}

	for (i=*idel; i < mfdata->nmols-1; i++) {
	   mfdata->mollin[i] = mfdata->mollin[i+1] - M;
	}
	mfdata->nmols = mfdata->nmols - 1;

	for (i=mfdata->mollin[*idel]; i < fileop->nlines-M; i++) {
	   fileop->line_index[i] = fileop->line_index[i+M] - m;
	}

	fileop->nlines = fileop->nlines - M;
  }

  if (fileop->opt) {

     if (fileop->nfiles > 1) {
	if ((*idel)+1 == fileop->nfiles) {
	   m = fileop->size - fileop->fpos[*idel];
	   n = 0;
        } else {
	   m = fileop->fpos[(*idel)+1] - fileop->fpos[*idel];
	   n = fileop->size - fileop->fpos[(*idel)+1];
	}

        if (n == 0) {
	   fileop->str[fileop->fpos[*idel]] = '\0';
        } else if (n > 0) {
	   strncpy(&fileop->str[fileop->fpos[*idel]],
	     &fileop->str[fileop->fpos[(*idel)+1]],n);
	}
	fileop->size = fileop->size - m;

	for (i=*idel; i < fileop->nfiles-1; i++) {
	   fileop->fpos[i] = fileop->fpos[i+1] - m;
	   if (COO[istruct]->svgs != NULL) 
		COO[istruct]->svgs[i] = COO[istruct]->svgs[i+1];
	}

        Delete_Field(*idel,fileop);
        fileop->nfiles = fileop->nfiles - 1;
     }
  
  }

  Activate_Structure(idel);
}

void filmem(int iopt,int list,char *strn,FILEOP *fileop)
{
   FILE *f;
   struct stat buf;
   int i,n,fd,size,nlines,nfiles,ifiles,ilin;
   int ic = 0;
   size_t nl;
   int *linidx;
   int *fpos;
   char *string, *tstr, *tstrb;
   char maxlin[MAXCMD] = " ";

   fileop->list = list;
   fileop->opt = iopt;

   f = fopen(strn, "r");

   if (f != NULL) {

	rewind(f);
	fd = fileno(f);
	fstat(fd, &buf);
	size = buf.st_size;

	string = malloc(sizeof(char)*size+1);
	nl = fread(string, sizeof(char), size, f);
	if (nl == 0) {
	   fprintf(stderr,"Error reading file: %s\n", strn);
	} else {
	   string[nl] = '\0';
	}
	fclose(f);

	fileop->str = string;
	fileop->size = nl;
   } else {
	fileop->str = NULL;
	fileop->size = 0;
	string = NULL;
   }

   if (!list) COO[istruct]->ihasmf = 1;

   tstr = string;
   
   nlines = 0;
   if (tstr != NULL) {
	while (*tstr != '\0') {
	   if (*tstr == '\n')  nlines++;
	   tstr++;
	}
   }

   fileop->nlines = nlines;

   fileop->fpos = NULL;

   if (iopt) {

	tstr = string;
	tstrb = tstr;
	nfiles = 0;

	while (!(*tstr == '\0' || ic == nl)) {
	   if (*tstr == '\n') {
		ic++;
        	n = (int) (tstr - tstrb);
		strncpy(maxlin,tstrb,n);
		tstrb = tstr;
		tstr++;
		if (strstr(maxlin,"$$$$") != NULL) nfiles++;
		if (strstr(maxlin,"<TRIPOS>MOLECULE") != NULL) nfiles++;
	   } else {
		tstr++;ic++;
	   }
	}

	fileop->nfiles = nfiles;

	fileop->fpos = malloc(sizeof(int)*(nfiles+2));

	if (fileop->fpos != NULL) {
	   fileop->fpos[0] = 0;
	   tstr = string;
	   tstrb = tstr;
	   if (strstr(strn,".sdf")) {
	      ifiles = 0;
	   } else if (strstr(strn,".mol2")) {
	      ifiles = -1;
	   }

	   while (*tstr != '\0') {
		if (*tstr == '\n') {
        	   n = (int) (tstr - tstrb);
		   strncpy(maxlin,tstrb,n);
		   tstr++;
		   if (strstr(maxlin,"$$$$") != NULL) {
			ifiles++;
			fileop->fpos[ifiles] = (int) (tstr - string);
		   }
		   if (strstr(maxlin,"<TRIPOS>MOLECULE") != NULL) {
			ifiles++;
			if (ifiles == 0) {
			   fileop->fpos[0] = 0;
			} else {
			   fileop->fpos[ifiles] = (int) (tstrb - string);
			}
		   }
		   tstrb = tstr;
	   	} else {
		   tstr++;
	   	}
	   }
	}

	if (nfiles > mfdata->maxmol) {
	   if (mfdata->mollin != NULL) free(mfdata->mollin);
	   mfdata->mollin = (int *) malloc(sizeof(int)*(nfiles+2));
	   mfdata->mollin[0] = 0;
	   mfdata->maxmol = nfiles;
	   if (mlftit != NULL) free(mlftit);
	   mlftit = (char **) malloc(sizeof(char *)*(nfiles+2));
	   mxtits = nfiles;
	}
   }

   linidx = malloc(sizeof(int)*(nlines+1));
   fileop->line_index = linidx;

   if (list) {
	fileop->lines = malloc(sizeof(char *)*(nlines+1));
   }

   ilin = 1;
   tstr = string;
   linidx[0] = 0;
   if (tstr != NULL) {
     while (*tstr != '\0') {
	int i1,i2,n;
	if (*tstr == '\n') {
	   linidx[ilin] = (int) (tstr - string + 1);
	   if (list) {
		i2 = linidx[ilin];
		if (ilin == 1) {
		   i1 = 0;
		} else {
		   i1 = linidx[ilin-1];
		}
	   	n  = i2 - i1 - 1;
		fileop->lines[ilin-1] = malloc(sizeof(char)*(n+1));
		strncpy(fileop->lines[ilin-1],&string[i1],n);
		fileop->lines[ilin-1][n] = '\0';
	   }
	   ilin++;
	}
	tstr++; 
     }
   }

   if (!list) COO[istruct]->memfil = *fileop;
}

#if defined(VMS) || defined(UNDERSC)
void prsogl()
#else
#ifdef CRAY
void PRSOGL()
#else
void prsogl_()
#endif
#endif
{
    selfil = 0;

    if (fsel.files[selfil][0] != '/') {
	strcpy(strname,fsel.lastdir);
#ifndef VMS
	if (strname[strlen(strname)-1] != '/') strcat(strname,"/");
#endif
	strcat(strname,fsel.files[selfil]);
    } else strcpy(strname,fsel.files[selfil]);

    ParseFile(strname,fsel.files[selfil]);
}

int ParseFile(strname,shortname)
char *strname;
char *shortname;
{
   int i,naat;

#ifdef VMS
   for (i=0; i<strlen(strname); i++)
	Sstr->dsc$a_pointer[i] = strname[i];
#else
#ifdef CRAY
   strncpy(_fcdtocp(Sstr),strname,strlen(strname));
#else
   if (Sstr != NULL) strcpy(Sstr,strname);
#endif
#endif

   *Snstr = strlen(strname);
   *Sinct = qboxes[QREADF].qbinct;
   *Sincp = addfile;
/*   if (addfile) *Sinct = 481;*/

   doalign = 0;
   *irtcel = 0;
   if (!addfile) poszset = 0;
   *zmptrp->ihaszm = 0;
   WinName(win,shortname);

   if (qbres) {
	TogUp(&cbut[BFORC]);
	qbres = 0;
	XUnmapWindow(display,RESwin);
   }

   if (frfor && FRup) {
	TogUp(&cbut[BFORC]);
	XDestroyWindow(display,FrBox);
	DoFreq = 0;
	FRup = 0;
        *normc = 0;
   }

   if (frfor && specup) {
	XDestroyWindow(display,winspec);
	specup = 0;
   }

   if (geoup) {
	TogUp(&cbut[BGEOM]);
	XDestroyWindow(display,wingeo);
	geoup = 0;
   }

   if (cnvup) {
	XDestroyWindow(display,wincnv);
	cnvup = 0;
   }

   if (specup) {
	XDestroyWindow(display,winspec);
	specup = 0;
   }

   if (scoup) {
	XDestroyWindow(display,winsco);
	scoup = 0;
   }

   if (pmfup) {
	XDestroyWindow(display,winpmf);
	pmfup = 0;
   }

   if (MLTup) {
	XDestroyWindow(display,MLTwin);
	MLTup = 0;
   }

   ZMEswitch[0].toggle = 1; ZMEAA = 0; EXPbox[0].fake = 1; 
   RedrawZME(); XSync(display,False);
   pdb = 0; oqlen = 0; oqpos = 0;

   DowinC = 1; DoactC = 1; DoactMC = 1;
   TogUp(&cbut[BHYD]);
   XFlush(display);
   aflag = 0; bflag = 0; cflag = 0; dflag = 0;
   LastAmino = -1;
   CurAmino = -1;
   do3dx = 0; *do3d = 1;
   FRQ->ihasi = 0;
   HETLABSTRU hetlab = {.NHetLab = 0};

   if (!addfile && *multstruct) {

	if (nstruct == MAXSTRUCT) {

	    if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Reached maximum number supported structures",0)) {}

	} else {

	    if (nstruct == 0 && nfilesstart != 0) {
		SaveFirstStruct();
		nstruct++;
	    }

	    AllocateStructure(&COO[nstruct]);

	    if (nstruct != 0) SaveActiveStruct();

	    if (COO[nstruct] == NULL) {
		   if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
			     "Failed to allocate memory for structure",0)) {}
	    } else {
		   naat = PDBFile(strname);
		   if (naat > 0) {
			AllocateSubStructures(shortname,naat);
			*ipdbon = 1;
			filmem(0,0,strname,&fileop);
		   } else {
			AllocateSubStructures(shortname,0);
		   }
		   if (strstr(strname,".sdf")) {
			if (bcksvg.UpSVG) {
			   killob();
			   bcksvg.UpSVG = 0;
			}
			*iftyp = 13;
			filmem(1,0,strname,&fileop);
		   }
		   if (strstr(strname,".mol2")) {
			if (bcksvg.UpSVG) {
			   killob();
			   bcksvg.UpSVG = 0;
			}
			*iftyp = 16;
		//	ntits = 0;
			filmem(1,0,strname,&fileop);
		   }
		   if (strstr(strname,".arc")) {
			FILE *f;
			char cmdfil[MAXCMD];

			f = fopen(strname,"r");
			fgets(cmdfil,MAXCMD,f);
			fclose(f);
		        if (strstr(cmdfil,"[AMBFOR]")) {
			   *iftyp = 12;
			   filmem(0,0,strname,&fileop);
			}
		   }
	    }
	}

        ntits = 0;

   } else {

/* The addfile == 1 part */

	if (nstruct == MAXSTRUCT) {

	    if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Reached maximum number supported structures",0)) {}

	} else {

	    if (nstruct == 0 && nfilesstart != 0) {
		SaveFirstStruct();
	    }
	    if (strstr(strname,".sdf")) {
	    	if (*ipdbon == 1) {
                    int nato1,mx;

		    mx = NAtMax(strname);
/* 
   determine how much atoms have to be moved
*/
		    mvhlpat(mx,&nato1);
		    *xyzp->iatoms = *xyzp->iatoms + mx;
		    *iscst = nato1;
	    	}
		*iftyp = 13;
		filmem(1,0,strname,&fileop);
	    }
	    if (strstr(strname,".mol2")) {
//		ntits = 0;
		*iftyp = 16;
		filmem(1,0,strname,&fileop);
	    }
	}
   }


   if (!addfile) {
	*backb = 0;
	empty_model(istruct,1);
   }

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   if (strstr(strname,".ogl")) {
	if (has_opengl) {
	   if (rdoglfile(strname)) return(0);
	}
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
	*Sinct = 0;
        return(0);

   } else {

  	update_sel = 1;
  	update_model = 1;
	RedrawFwin(&fsel);
        return(1);
   }

}

void ULineString(hwin,str,x,y)
Window hwin;
char *str;
int x,y;
{
  if (str != NULL) {
     XDrawString(display, hwin, gc, x, y, str, strlen(str));
     XDrawLine(display, hwin, gc, x, y+DESCENT-1,
            x+StringWidth(str), y+DESCENT-1);
  }
}

void LineString(hwin,str,x,y)
Window hwin;
char *str;
int x,y;
{
  if (str != NULL) {
	XDrawString(display, hwin, gc, x, y, str, strlen(str));
  }
}


void createauthor()
{
      winau = CreateWindow("Author",DEFAUTHGEOM,
              gijsface_width,gijsface_height, infofg, infobg,(Window)0);
      XSelectInput(display, winau, ExposureMask | 
              ButtonPressMask | KeyPressMask);
      gijs  = XCreateBitmapFromData(display, winau,
              gijsface_bits, gijsface_width, gijsface_height);
      XMapWindow(display, winau);

      WinObj[2].win = &winau;
      WinObj[2].subwin = NULL;
      WinObj[2].butarr = NULL;
      WinObj[2].numbut = -1;
      WinObj[2].winup = &gijsup;
      WinObj[2].redraw = NULL;
}

void DrawTriangle(x,y,xt,yt,r,icol,ifill,iconv)
double x;
double y;
int xt;
int yt;
int r;
int icol;
int ifill;
int iconv;
{
   int r2,r3,r6;
   XPoint box_Xpoint[5];

   r2 = 0.5 * r;
   r6 = 0.25*sqrt(6.0)*r;
   r3 = sqrt(3.0)*r/3.0;

   if (iconv) {
	glpnt(rwi,rhi,x,y,&xt,&yt,0);
   }

   box_Xpoint[0].x = xt;
   box_Xpoint[0].y = yt+r3;
   
   box_Xpoint[1].x = xt+r2;
   box_Xpoint[1].y = yt-r6;
   
   box_Xpoint[2].x = xt-r2;
   box_Xpoint[2].y = yt-r6;
   
   box_Xpoint[3].x = box_Xpoint[0].x;
   box_Xpoint[3].y = box_Xpoint[0].y;
   
   XSetForeground(display, gc, colors[icol]);
   if (ifill) {
	XFillPolygon(display,winrama,gc,box_Xpoint,3,
		Nonconvex,CoordModeOrigin);
   } else {
	XDrawLines(display,winrama,gc,box_Xpoint,4,CoordModeOrigin);
   }
}

void DrawBox(x,y,xt,yt,r,icol,ifill,iconv)
double x;
double y;
int xt;
int yt;
int r;
int icol;
int ifill;
int iconv;
{
   int r2;
   XPoint box_Xpoint[5];

   r2 = 0.5 * r;

   if (iconv) glpnt(rwi,rhi,x,y,&xt,&yt,0);

   box_Xpoint[0].x = xt-r2;
   box_Xpoint[0].y = yt-r2;
   
   box_Xpoint[1].x = xt-r2;
   box_Xpoint[1].y = yt+r2;
   
   box_Xpoint[2].x = xt+r2;
   box_Xpoint[2].y = yt+r2;
   
   box_Xpoint[3].x = xt+r2;
   box_Xpoint[3].y = yt-r2;
   
   box_Xpoint[4].x = box_Xpoint[0].x;
   box_Xpoint[4].y = box_Xpoint[0].y;
   
   XSetForeground(display, gc, colors[icol]);
   if (ifill) {
	XFillPolygon(display,winrama,gc,box_Xpoint,5,
		Nonconvex,CoordModeOrigin);
   } else {
	XDrawLines(display,winrama,gc,box_Xpoint,5,CoordModeOrigin);
   }
}

void createDock()
{
      if (!*ipdbon) {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"You can only dock info a PDB file !",0);
	return;
      } 

      DCKINVOKE = 1;
      rwi = 500; rhi = 450;
      windock = CreateWindow("Docking Start",DEFCNV2GEOM,
              rwi,rhi, infobg, infofg,(Window)0);
      XSelectInput(display, windock, ExposureMask | EnterWindowMask |
              ButtonPressMask | PointerMotionMask | StructureNotifyMask |
 	      KeyPressMask);
      XMapWindow(display, windock);

      qboxstr(&qboxes[QDCKFI],&windock,0,0,190,35,40,400,40,2,
          "Ambfor XYZ File name: ",NULL,MAXPATHLEN,QSTRING,2000,0,dummyproc);
      strcpy(qboxes[QDCKFI].str,"dock.xyz");

      qboxstr(&qboxes[QDCKOUT],&windock,0,0,190,35,70,400,40,2,
          "MOL2 output file    : ",NULL,MAXPATHLEN,QSTRING,2000,0,dummyproc);
      strcpy(qboxes[QDCKOUT].str,"dock.mol2");

      qboxstr(&qboxes[QDCKSL],&windock,0,0,190,35,100,200,40,2,
          "Number of solutions : ",NULL,2,QPOSINT,2000,0,dummyproc);
      strcpy(qboxes[QDCKSL].str,"20");

      DefBut(&dockbut[0], windock, 35, 395, 60, 30,
	"Dock !", infobg, -15);

      DefBut(&dockbut[1], windock, 440, 38, 32, 25,
	"File !", infobg, -15);

      DefBut(&dockbut[2], windock, 375, 395, 60, 30,
	"Close", infobg, -15);

      DefBut(&dockbut[3], windock, 35, 140, 15, 15,
	"", infobg, -15);

      dockbut[1].pix = mapPix;
      dockbut[1].pw  = map_width;
      dockbut[1].ph  = map_height;

      if (debugdck) {
	TogDown(&dockbut[3]);
      } else {
	TogUp(&dockbut[3]);
      }
      DrwBut(&dockbut[3]);

      WinObj[45].win = &windock;
      WinObj[45].subwin = NULL;
      WinObj[45].butarr = NULL;
      WinObj[45].numbut = -1;
      WinObj[45].winup = &dockup;
      WinObj[45].redraw = NULL;
}

void drwdock()
{
  int i;

  rwi = 600; rhi = 450;

  butje(windock,0,0,rwi,rhi,4,0,0,1,None,0,0,0,0);

  for (i=0; i<NBUTDCK; i++) DrwBut(&dockbut[i]);

  PromptBox(&qboxes[QDCKFI]);
  PromptBox(&qboxes[QDCKSL]);
  PromptBox(&qboxes[QDCKOUT]);

  if (DCKSVG) {
 	XSetForeground(display, gc, infofg);
        XFillRectangle(display, windock, gc, 35, 165, 400, 200);

	DrawSVG(35, 165, 400 , 200,*DCKsvg,windock);
  }

  ULineString(windock, ": Add debug information", 60, 150);
}

int ButtonsDCK(k)
int k;
{
  int ret=0;
  int i,j;

  switch (k) {
  case 0:
	   strcpy(dcklig,qboxes[QDCKFI].str);
	   strcpy(dckout,qboxes[QDCKOUT].str);
	   dcksol = atoi(qboxes[QDCKSL].str);
	   if (access(dcklig,F_OK) != 0) {
	      DoCan(event.xbutton.x_root, event.xbutton.y_root,
			"Non existent ambfor .xyz file !\n",0);
	   } else {
	      XDestroyWindow(display,windock);
	      ProcLig(1);
	      dockup = 0;
	   }
           break;
  case 1:
	   dsel.qbrfile = 1;
	   dsel.subopt = 0;
	   dsel.parse = 0;
	   dsel.flist.select = -1;
	   dsel.Callwin = windock;
	   strcpy(dsel.pntr," ");
	   strcpy(dsel.substr,"xyz");
	   getfiles(&dsel,dsel.lastdir);
	   FileSelectList(&dsel);
           break;
  case 2:
	   XDestroyWindow(display,windock);
	   dockup = 0;
           break;
  case 3:
	   if (TogBut(&dockbut[3])) {
		debugdck = 0;
	   } else {
		debugdck = 1;
	   }
           break;
  default: break;
  }


}

void createRama()
{
      rwi = 600; rhi = 600;
      winrama = CreateWindow("Ramachandran Plot",DEFCNV2GEOM,
              rwi,rhi, infobg, infofg,(Window)0);
      XSelectInput(display, winrama, ExposureMask | EnterWindowMask |
              ButtonPressMask | PointerMotionMask | StructureNotifyMask);
      XMapWindow(display, winrama);
      RamaStru.current = -1;

      WinObj[8].win = &winrama;
      WinObj[8].subwin = NULL;
      WinObj[8].butarr = NULL;
      WinObj[8].numbut = -1;
      WinObj[8].winup = &ramaup;
      WinObj[8].redraw = NULL;
}

void DrawRama()
{
      char *tmpptr;
      int xt,yt,qlen;
      int dum0,i,n,x1t,y1t,ioff;
      double scx,scy,x1,y1,x2,y2;
      XPoint rama_Xpoint1[150];

      n = calfptr->ncalf;

      if (RamaStru.npts < n && RamaStru.x != NULL) {
	free(RamaStru.x);
	free(RamaStru.y);
	free(RamaStru.index);
      }
      
      if (RamaStru.x == NULL || RamaStru.npts < n) {
	RamaStru.x = (int *) malloc((sizeof i)*n);
	RamaStru.y = (int *) malloc((sizeof i)*n);
	RamaStru.index =  (int *) malloc((sizeof i)*n);
      }
      RamaStru.npts = n;

	 butje(winrama,0,0, rwi,rhi,3,0,0,0,None,0,0,0,0);

         XSetForeground(display, gc, BlackPixel(display,screen));


         XDrawString(display,winrama,gc,rwi/2-13,rhi-10,
		"PHI (degrees)",13);

         XDrawString(display,winrama,gc,10,rhi/2,   "P",1);
         XDrawString(display,winrama,gc,10,rhi/2+10,"S",1);
         XDrawString(display,winrama,gc,10,rhi/2+20,"I",1);

	 glpnt(rwi,rhi,0.0,0.0,&xt,&yt,0);
	 rama_Xpoint1[0].x = xt;
	 rama_Xpoint1[0].y = yt;
	 glpnt(rwi,rhi,0.0,1.0,&xt,&yt,0);
	 rama_Xpoint1[1].x = xt;
	 rama_Xpoint1[1].y = yt;
	 glpnt(rwi,rhi,1.0,1.0,&xt,&yt,0);
	 rama_Xpoint1[2].x = xt;
	 rama_Xpoint1[2].y = yt;
	 glpnt(rwi,rhi,1.0,0.0,&xt,&yt,0);
	 rama_Xpoint1[3].x = xt;
	 rama_Xpoint1[3].y = yt;
	 glpnt(rwi,rhi,0.0,0.0,&xt,&yt,0);
	 rama_Xpoint1[4].x = xt;
	 rama_Xpoint1[4].y = yt;

	 XSetForeground(display, gc, colors[15]);
	 XFillPolygon(display,winrama,gc,rama_Xpoint1,5,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<108; i++) {
		x1 = (rama_area4[i][0]/360.0 + 0.5);
		y1 = (rama_area4[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }
	 rama_Xpoint1[108].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[108].y = rama_Xpoint1[0].y;

	 XSetForeground(display, gc, colors[2]);
	 XFillPolygon(display,winrama,gc,rama_Xpoint1,108,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<67; i++) {
		x1 = (rama_area5[i][0]/360.0 + 0.5);
		y1 = (rama_area5[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }

	 rama_Xpoint1[67].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[67].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,67,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<10; i++) {
		x1 = (rama_area6[i][0]/360.0 + 0.5);
		y1 = (rama_area6[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }

	 rama_Xpoint1[10].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[10].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,10,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<28; i++) {
		x1 = (rama_area7[i][0]/360.0 + 0.5);
		y1 = (rama_area7[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }

	 rama_Xpoint1[28].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[28].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,28,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<10; i++) {
		x1 = (rama_area8[i][0]/360.0 + 0.5);
		y1 = (rama_area8[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }

	 rama_Xpoint1[10].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[10].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,10,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<10; i++) {
		x1 = (rama_area9[i][0]/360.0 + 0.5);
		y1 = (rama_area9[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }

	 rama_Xpoint1[10].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[10].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,10,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<16; i++) {
		x1 = (rama_area1[i][0]/360.0 + 0.5);
		y1 = (rama_area1[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }
	 rama_Xpoint1[16].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[16].y = rama_Xpoint1[0].y;

	 XSetForeground(display, gc, colors[1]);
	 XFillPolygon(display,winrama,gc,rama_Xpoint1,17,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<25; i++) {
		x1 = (rama_area2[i][0]/360.0 + 0.5);
		y1 = (rama_area2[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }
	 rama_Xpoint1[25].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[25].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,25,
		Nonconvex,CoordModeOrigin);

	 for (i=0; i<108; i++) {
		x1 = (rama_area3[i][0]/360.0 + 0.5);
		y1 = (rama_area3[i][1]/360.0 + 0.5);
		glpnt(rwi,rhi,x1,y1,&x1t,&y1t,0);
		rama_Xpoint1[i].x = x1t;
		rama_Xpoint1[i].y = y1t;
	 }
	 rama_Xpoint1[108].x = rama_Xpoint1[0].x;
	 rama_Xpoint1[108].y = rama_Xpoint1[0].y;

	 XFillPolygon(display,winrama,gc,rama_Xpoint1,108,
		Nonconvex,CoordModeOrigin);

         XSetForeground(display, gc, BlackPixel(display,screen));
	 dum0 = 0;
         drwgl(winrama,rwi,rhi,0.0,0.0,1.0,0.0,dum0,dum0,0,0);
         drwgl(winrama,rwi,rhi,0.0,0.0,0.0,1.0,dum0,dum0,0,0);
         drwgl(winrama,rwi,rhi,0.0,1.0,1.0,1.0,dum0,dum0,0,0);
         drwgl(winrama,rwi,rhi,1.0,1.0,1.0,0.0,dum0,dum0,0,0);
         drwgl(winrama,rwi,rhi,0.0,0.5,1.0,0.5,dum0,dum0,0,0);
         drwgl(winrama,rwi,rhi,0.5,0.0,0.5,1.0,dum0,dum0,0,0);

	 scx = 12.0;
	 for (i=0; i<13; i++) {
		  x1 = ((double) i)/scx;
		  y1 = 0.0;
		  y2 = -0.02;
		  drwgl(winrama,rwi,rhi,x1,y1,x1,y2,dum0,dum0,0,0);
		  drwgl(winrama,rwi,rhi,y1,x1,y2,x1,dum0,dum0,0,0);
	 }

	 ioff = CHIGH/2;

	 glpnt(rwi,rhi,0.0,-0.04,&xt,&yt,0);
	 sprintf(stemp,"%d",-180);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt,stemp,strlen(stemp));

	 glpnt(rwi,rhi,0.25,-0.04,&xt,&yt,0);
	 sprintf(stemp,"%d",-90);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt,stemp,strlen(stemp));

	 glpnt(rwi,rhi,0.5,-0.04,&xt,&yt,0);
	 sprintf(stemp,"%d",0);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt,stemp,strlen(stemp));

	 glpnt(rwi,rhi,0.75,-0.04,&xt,&yt,0);
	 sprintf(stemp,"%d",90);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt,stemp,strlen(stemp));

	 glpnt(rwi,rhi,1.0,-0.04,&xt,&yt,0);
	 sprintf(stemp,"%d",180);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt,stemp,strlen(stemp));

	 glpnt(rwi,rhi,-0.04,0.0,&xt,&yt,0);
	 sprintf(stemp,"%d",-180);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt+ioff,stemp,strlen(stemp));

	 glpnt(rwi,rhi,-0.04,0.25,&xt,&yt,0);
	 sprintf(stemp,"%d",-90);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt+ioff,stemp,strlen(stemp));

	 glpnt(rwi,rhi,-0.04,0.5,&xt,&yt,0);
	 sprintf(stemp,"%d",0);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt+ioff,stemp,strlen(stemp));

	 glpnt(rwi,rhi,-0.04,0.75,&xt,&yt,0);
	 sprintf(stemp,"%d",90);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt+ioff,stemp,strlen(stemp));

	 glpnt(rwi,rhi,-0.04,1.0,&xt,&yt,0);
	 sprintf(stemp,"%d",180);
	 qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
	 XDrawString(display,winrama,gc,xt-qlen/2,yt+ioff,stemp,strlen(stemp));

	 for (i=0; i<calfptr->ncalf; i++) {
	   x1 = calfptr->rphi[i]/360.0 + 0.5;
	   y1 = calfptr->rpsi[i]/360.0 + 0.5;
           if (calfptr->iamino[i] == 1) {
		DrawTriangle(x1,y1,0,0,6,3,1,1);
	   } else if (calfptr->iamino[i] == 15) {
		DrawTriangle(x1,y1,0,0,6,4,1,1);
	   } else {
		DrawBox(x1,y1,0,0,6,3,1,1);
	   }
	   glpnt(rwi,rhi,x1,y1,&xt,&yt,0);
	   RamaStru.x[i] = xt;
	   RamaStru.y[i] = yt;
	   RamaStru.index[i] = i;
	 }

	 if (RamaStru.current != -1) {
	   i = RamaStru.current;
	   if (calfptr->iamino[i] == 1) {
		DrawTriangle(0.0,0.0,
			RamaStru.x[i],RamaStru.y[i],
			6,0,0,0);
	   } else if (calfptr->iamino[i] == 15) {
		DrawTriangle(0.0,0.0,
			RamaStru.x[i],RamaStru.y[i],
			6,0,0,0);
	   } else {
		DrawBox(0.0,0.0,
			RamaStru.x[i],RamaStru.y[i],
			6,0,0,0);
	   }
	 }
}

void createconv()
{
      wincnv = CreateWindow("SCF Convergence",DEFCNVGEOM,
              CNVWIDE,CNVHIGH, infobg, infofg,(Window)0);
      XSelectInput(display, wincnv, ExposureMask | EnterWindowMask |
              ButtonPressMask | PointerMotionMask);
      XMapWindow(display, wincnv);

      WinObj[3].win = &wincnv;
      WinObj[3].subwin = NULL;
      WinObj[3].butarr = NULL;
      WinObj[3].numbut = -1;
      WinObj[3].winup = &cnvup;
      WinObj[3].redraw = drwcnv;
}

void createfr(dowin)
int dowin;
{

   if (dowin) {
	FrBox = CreateWindow("Molden Frequency Select","-80-80",QBOXWIDE,310,
	   infobg,infofg,(Window)0);
	XSelectInput(display, FrBox, ExposureMask | KeyPressMask | 
	   ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | 
	   LeaveWindowMask | EnterWindowMask);
   }

   WinObj[17].win = &FrBox;
   WinObj[17].subwin = NULL;
   WinObj[17].butarr = NULL;
   WinObj[17].numbut = -1;
   WinObj[17].winup = &FRup;
   WinObj[17].redraw = NULL;

   if (FRQ->ihasi < 0) {
	if (*ihasex) {
	   DefList(&frlist,FrBox,DIRX,DIRY,DIRW,DIRH,
	   "  Nr.     Excitation (nm)   Int.  Mult-Irrep.",
	   NFLS,frsym,FRQ->freq,FRQ->frint,NULL,&FRQ->nfreq,NULL);
	} else {
	   DefList(&frlist,FrBox,DIRX,DIRY,DIRW,DIRH,
	   "  Nr.     Frequency (cm-1)  Int.  Irrep.",
	   NFLS,frsym,FRQ->freq,FRQ->frint,NULL,&FRQ->nfreq,NULL);
	}
   } else {
      	DefList(&frlist,FrBox,DIRX,DIRY,DIRW,DIRH,"  Nr.     Frequency    (cm-1)",
	NFLS,NULL,FRQ->freq,NULL,NULL,&FRQ->nfreq,NULL);
   }

   qboxstr(&qboxes[QNSCAL],&FrBox,1,0,-1,DEFQX,270, 170,QBOXHIGH,0,
	"Scale Factor ? ","1.0", 0,3, 2000,-1,dummyproc);

   qboxes[QNSCAL].qflt = frmul;
   sprintf(qboxes[QNSCAL].str,"%f", *frmul);
   qboxes[QNSCAL].curpos = strlen(qboxes[QNSCAL].str);
   qboxes[QNSCAL].explstr = "Scale amplitude atomic movements";
   if (dowin) XMapWindow(display,FrBox);
}

void INTextr() {
      int i;

      spec_mx = spec_mn = out_spec[0];
      for (i=1; i < n_freqs; i++) {
        if (out_spec[i] > spec_mx) {
    	   spec_mx = out_spec[i];
        }
        if (out_spec[i] < spec_mn) {
    	   spec_mn = out_spec[i];
        }
      }
}

void init_spec()
{
  int i,frtmp;
      if (FRQ->ihasi) {

	spint = FRQ->frint;
	spfrq = FRQ->freq;
	spnfrq = &FRQ->nfreq;
	min_freq = 0;
	max_freq = 0;
	for (i=0; i < FRQ->nfreq; i++) {
	   frtmp = (int) (spfrq[i]*freq_scale);
	   if (frtmp > max_freq) max_freq = frtmp;
	}
	i = max_freq / 500;
	max_freq = (i+1)*500;
	freq_step = 1.0;
	hwhm = 20.0;
	if (*ihasex) {
	   splab = uvlab;
        } else {
	   splab = forlab;
	}
	nspqbox = 5;
	nsbutts = 5;

      } else if (nmrptr->ihsnmr) {

	prep_nmr();
	spint = inten;
	spfrq = peaks;
	spnfrq = &npks;
	FRQextr();
	if (spmode) {
	   freq_step = nmr13Cstep;
	} else {
	   freq_step = nmr1Hstep;
	}
	hwhm = 0.01;
	splab = nmrlab;
	nspqbox = 7;
	nsbutts = 7;
      }
}

#if defined(VMS) || defined(UNDERSC)
void gtfcor(int *ifrq,int *x1,int *y1,int *x2,int *y2)
#else
#ifdef CRAY
void GTFCOR(int *ifrq,int *x1,int *y1,int *x2,int *y2)
#else
void gtfcor_(int *ifrq,int *x1,int *y1,int *x2,int *y2)
#endif
#endif
{
  int lb,rb,frqrng,iw,x,imagx,imagy;
  double p;

  lb = 34; rb = 57; iw = 4;
  imagx = 1000; imagy = 500;
 
  frqrng = (max_freq - min_freq);

  p = (double) (imagx-lb-rb) / (double) frqrng;

  x =  lb + (int) (p*FRQ->freq[*ifrq-1]);
  *x1 = x - iw; *x2 = x + iw;
  *y1 = 0; *y2 = imagy;
  
}

#if defined(VMS) || defined(UNDERSC)
void pltspec(int *opt)
#else
#ifdef CRAY
void PLTSPEC(int *opt)
#else
void pltspec_(int *opt)
#endif
#endif
{
   init_spec();
   if (nmrptr->ihsnmr) {
	avch3();
	prep_nmr();
   }
   calc_spectrum(0);
   write_spectrum("spec.ps",0,*opt);
   
}

void createspec(dowin)
int dowin;
{
      int i;

      if (!FRQ->ihasi && !nmrptr->ihsnmr) return;

      if (dowin) {
	winspec = CreateWindow("Spectrum",DEFCNVGEOM,
              SPECWIDE,SPECHIGH+SPBHIGH, infobg, infofg,(Window)0);
	XSelectInput(display, winspec, SubstructureNotifyMask | ExposureMask | 
		ButtonPressMask | ButtonReleaseMask | PointerMotionMask | 
		StructureNotifyMask | KeyPressMask | 
		EnterWindowMask | LeaveWindowMask); 
	subSPEC = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],winspec);
	XMapWindow(display, winspec);
      }

      init_spec();

      calc_spectrum(0);

      DefBut(&spbut[0], winspec, 80, SPECHIGH + BUTTN, 100, 23, "Lorentzian", 
	infobg, ZMBCOL);
      spbut[0].str = pktyp[lorentzian];
      spbut[0].explstr = "Peak enveloppe: Lorentzian, Gaussian";

      DefBut(&spbut[1], winspec, 80, SPECHIGH, 100, 23, "Infra Red", 
	infobg, ZMBCOL);
      if (FRQ->ihasi) {
	  if (*ihasex) {
             spbut[1].str = *uvsptyp;
	     spbut[1].explstr = "UV spectrum";
	  } else {
             spbut[1].str = sptyp[spmode];
	     spbut[1].explstr = "Type of spectrum: Infrared, Raman\nSome QM programs calculate both intensities";
	  }
      } else if (nmrptr->ihsnmr) {
          spbut[1].str = nmrsptyp[spmode];
	  spbut[1].explstr = "Type of NMR spectrum: 1H, 13C";
	  if (spmode) {
		nmrref  = &nmr13Cref;
	  } else {
		nmrref  = &nmr1Href;
	  }
      }


      DefBut(&spbut[2], winspec, SPECWIDE-85, SPECHIGH+15 + 2*BUTTN, 75, 23, 
	"Close", infobg, ZMBCOL);
      spbut[2].explstr = "Close window";

      DefBut(&spbut[3], winspec, SPECWIDE-85, SPECHIGH+15, 75, 23, 
	"Postscript", infobg, ZMBCOL);
      spbut[3].explstr = "Export spectrum as Postscript file";

      DefBut(&spbut[4], winspec, SPECWIDE-85, SPECHIGH+15 + BUTTN,35, 23, 
	"Xmgr", infobg, ZMBCOL);
      spbut[4].explstr = "Export spectrum as input file for Xmgr";

      DefBut(&spbut[5], winspec, SPECWIDE-40, SPECHIGH+15 + BUTTN,30, 23,
        "jdx", infobg, ZMBCOL);
      spbut[5].explstr = "Export spectrum as jdx file";

      DefBut(&spbut[6], winspec, SPECWIDE-85, SPECHIGH+15 - BUTTN,75, 23, 
	"Aver. CH3", infobg, ZMBCOL);
      spbut[6].explstr = "Average shielding and J-coupling\nof rotational equivalent Hydrogens on CH3";

      qboxstr(&qboxes[QHW],&winspec,1,0,190,200,SPECHIGH,
	150,QBOXHIGH-5,2,"Half-Width"," ",10,QREAL,2000,-1,updcallb);
      if (FRQ->ihasi) {
	sprintf(qboxes[QHW].str,"%-4.1f",hwhm);
      } else if (nmrptr->ihsnmr) {
	sprintf(qboxes[QHW].str,"%-8.4f",hwhm);
      }
      qboxes[QHW].curpos = strlen(qboxes[QHW].str);
      qboxes[QHW].dflt = &hwhm;
      qboxes[QHW].explstr = "Half-Width of peak\nInfluences peak width";

      qboxstr(&qboxes[QSSCAL],&winspec,0,0,190,200,SPECHIGH+10+BUTTN,
	150,QBOXHIGH-5,2,"Scale Fac."," ",10,QREAL,2000,-1,updcallb);
      sprintf(qboxes[QSSCAL].str,"%-4.2f",freq_scale);
      qboxes[QSSCAL].curpos = strlen(qboxes[QSSCAL].str);
      qboxes[QSSCAL].dflt = &freq_scale;
      qboxes[QSSCAL].explstr = "Apply frequency scale factor";

      qboxstr(&qboxes[QMINF],&winspec,0,0,190,350,SPECHIGH,
	150,QBOXHIGH-5,2,"Min. Freq."," ",10,QREAL,2000,-1,updcallb);
      sprintf(qboxes[QMINF].str,"%d",min_freq);
      qboxes[QMINF].curpos = strlen(qboxes[QMINF].str);
      qboxes[QMINF].iflt = &min_freq;
      qboxes[QMINF].explstr = "Lowest frequency displayed\nSpecify displayed frequency range";

      qboxstr(&qboxes[QMAXF],&winspec,0,0,190,350,SPECHIGH+10+BUTTN,
	150,QBOXHIGH-5,2,"Max. Freq."," ",10,QREAL,2000,-1,updcallb);
      sprintf(qboxes[QMAXF].str,"%d",max_freq);
      qboxes[QMAXF].curpos = strlen(qboxes[QMAXF].str);
      qboxes[QMAXF].iflt = &max_freq;
      qboxes[QMAXF].explstr = "Highest frequency displayed\nSpecify displayed frequency range";

      qboxstr(&qboxes[QIMAX],&winspec,0,0,190,350,SPECHIGH+15+2*BUTTN,
	150,QBOXHIGH-5,2,"Max. Ints."," ",10,QREAL,2000,-1,updcallb);
      sprintf(qboxes[QIMAX].str,"%-4.2f",spec_mx);
      qboxes[QIMAX].curpos = strlen(qboxes[QIMAX].str);
      qboxes[QIMAX].dflt = &spec_mx;
      qboxes[QIMAX].explstr = "Apply intensity scale factor\nInstrumental in comparing spectra";

      if (nmrptr->ihsnmr) {

	qboxstr(&qboxes[QTMS],&winspec,0,0,190,200,SPECHIGH+15+2*BUTTN,
	150,QBOXHIGH-5,2,"TMS ref.  "," ",10,QREAL,2000,-1,updcallb);
	sprintf(qboxes[QTMS].str,"%6.2f",*nmrref);
        qboxes[QTMS].curpos = strlen(qboxes[QTMS].str);
	qboxes[QTMS].qflt = nmrref;
	qboxes[QTMS].explstr = "The TMS reference.\nIsotropic Magnetic shielding (ppm)";

	qboxstr(&qboxes[QFREQ],&winspec,0,0,190,10,SPECHIGH+15+2*BUTTN,
	170,QBOXHIGH-5,2,"Carrier Freq. (MHz)"," ",10,QREAL,2000,-1,updcallb);
	sprintf(qboxes[QFREQ].str,"%5.1f",NMRbas);
        qboxes[QFREQ].curpos = strlen(qboxes[QFREQ].str);
	qboxes[QFREQ].qflt = &NMRbas;
	qboxes[QFREQ].explstr = "Carrier frequency\nInfluences the size of the peak splitting";
      }

      specup = 1;

      WinObj[5].win = &winspec;
      WinObj[5].subwin = &subSPEC;
      WinObj[5].butarr = spbut;
      WinObj[5].numbut = NSBUTTS;
      WinObj[5].winup = &specup;
      WinObj[5].redraw = drwspec;
}

void creategeom()
{

      gwi = CNVWIDE*2; ghi = CNVHIGH*2;
      if (!geo1ptr->idmxav && !geo1ptr->idrmav) gwi = CNVWIDE;
      if (!geo1ptr->ifmxav && !geo1ptr->ifrmav) ghi = CNVHIGH;

      wingeo = CreateWindow("Geom. Convergence",DEFCNV2GEOM,
              gwi,ghi, infobg, infofg,(Window)0);
      XSelectInput(display, wingeo, ExposureMask | EnterWindowMask |
              ButtonPressMask | PointerMotionMask | StructureNotifyMask);
      XMapWindow(display, wingeo);

      WinObj[4].win = &wingeo;
      WinObj[4].subwin = NULL;
      WinObj[4].butarr = NULL;
      WinObj[4].numbut = -1;
      WinObj[4].winup = &geoup;
      WinObj[4].redraw = NULL;
}

void createscore()
{
      winsco = CreateWindow("Docking Score",DEFCNVGEOM,
              CNVWIDE,CNVHIGH+140, infobg, infofg,(Window)0);
      XSelectInput(display, winsco, ExposureMask | EnterWindowMask |
              ButtonPressMask | PointerMotionMask);
      XMapWindow(display, winsco);
      scoup = 1;

      DefBut(&scbut[0], winsco, 10, CNVHIGH + 10, 75, 23, 
	"Save Pose", infobg, ZMBCOL);

      DefBut(&scbut[1], winsco, 90, CNVHIGH + 10, 75, 23, 
	"Write Poses", infobg, ZMBCOL);

      DefBut(&scbut[2], winsco, 170, CNVHIGH + 10, 50, 23, 
	"AtomInf", infobg, ZMBCOL);

      DefBut(&scbut[3], winsco, CNVWIDE-60, CNVHIGH + 10, 50, 23, 
	"Close", infobg, ZMBCOL);

      DefBut(&scbut[4], winsco, 10, CNVHIGH + 40, 15, 15, 
	" ", infobg, ZMBCOL);

      DefBut(&scbut[5], winsco, 10, CNVHIGH + 60, 15, 15, 
	" ", infobg, ZMBCOL);

      if (*ipmfm) {
	  TogDown(&scbut[4]);
      } else {
	  TogUp(&scbut[4]);
      }

      if (*ipmfh) {
	  TogDown(&scbut[5]);
      } else {
	  TogUp(&scbut[5]);
      }

      WinObj[6].win = &winsco;
      WinObj[6].subwin = NULL;
      WinObj[6].butarr = scbut;
      WinObj[6].numbut = NSCBUTTS;
      WinObj[6].winup = &scoup;
      WinObj[6].redraw = drwsco;
}

void createpmf()
{
      winpmf = CreateWindow("PMF Score",DEFPMFGEOM,
              325,CNVHIGH+40, infobg, infofg,(Window)0);
      XSelectInput(display, winpmf, ExposureMask | EnterWindowMask |
              ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | 
		LeaveWindowMask);
      XMapWindow(display, winpmf);
      pmfup = 1;

      DefBut(&pbut[0], winpmf, 10, CNVHIGH + 10, 75, 23, 
	"Close", infobg, ZMBCOL);
/*
      DefList(&pmflistmn,winpmf,DIRX,DIRY,DIRW,80,
	"Top Negative Interactions",5,NULL,NULL,NULL,pmfmn,npmfmx,NULL);

      DefList(&pmflistmx,winpmf,DIRX,160,DIRW,80,
	"Top Positive Interactions",5,NULL,NULL,NULL,pmfmx,npmfmx,NULL);
*/
      DefList(&pmflistmn,winpmf,DIRX,DIRY,DIRW,80,
	NULL,5,NULL,NULL,pmfmn,NULL,npmfmx,NULL);

      DefList(&pmflistmx,winpmf,DIRX,160,DIRW,80,
	NULL,5,NULL,NULL,pmfmx,NULL,npmfmx,NULL);

      WinObj[7].win = &winpmf;
      WinObj[7].subwin = NULL;
      WinObj[7].butarr = pbut;
      WinObj[7].numbut = NPBUTTS;
      WinObj[7].winup = &pmfup;
      WinObj[7].redraw = drwpmf;
}

#if defined(VMS) || defined(UNDERSC)
void crsco()
#else
#ifdef CRAY
void CRSCO()
#else
void crsco_()
#endif
#endif
{
   if (!scoup) createscore();
   if (ZMEup) UnMapZME();
}

#if defined(VMS) || defined(UNDERSC)
void cpmf()
#else
#ifdef CRAY
void CPMF()
#else
void cpmf_()
#endif
#endif
{
   if (pmfup) drwpmf();
   else createpmf();
}

#if defined(VMS) || defined(UNDERSC)
void upsco()
#else
#ifdef CRAY
void UPSCO()
#else
void upsco_()
#endif
#endif
{

   if (scoup) {
	drwsco();
   } else {
	createscore();
   }

}

#if defined(VMS) || defined(UNDERSC)
void molstr(str, nstr, iwin)
#else
#ifdef CRAY
void MOLSTR(str, nstr, iwin)
#else
void molstr_(str, nstr, iwin)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
int *iwin;
{
int i;
int ns;
int dobell;

       if(DEBUG)fprintf(stderr,"molstr in%d\n",*iwin);

       dobell = 0;

       ns = *nstr;
       if (*nstr > MAXSTRLMW ) ns = MAXSTRLMW;
       for (i=0; i<MAXSTRLMW; i++)
            {if (! *iwin) molwstr[i] = ' ';
             else densstr[i] = ' ';}
       if (! *iwin) strcp(str,molwstr,ns);
       else strcp(str,densstr,ns);

       if(DEBUG && *iwin)fprintf(stderr,"molstr in %d %s\n",*iwin,densstr);
       if(DEBUG && !*iwin)fprintf(stderr,"molstr in %d %s\n",*iwin,molwstr);
       for (i=0; i<ns; i++)
       {
           if (! *iwin && molwstr[i] == '!') dobell = 1;
           if ( *iwin && densstr[i] == '!') dobell = 1;
       }

       StatusStr(*iwin,dobell);

       if(DEBUG)fprintf(stderr,"molstr out\n");
}

void StatusStr(iwin,dobell)
int iwin;
int dobell;
{

       if (dobell && *ibell) XBell(display,0);

       if (! iwin && !DowinMC) {
          XSetForeground(display, gc, infofg);
          XFillRectangle(display, winMC, gc, SOFFX, SOFFY+7,240 ,20);
          XSetForeground(display, gc, infobg);
          XDrawRectangle(display, winMC, gc, SOFFX, SOFFY+7,240 ,20);
          XDrawString(display,winMC,gc,SOFFX+5,SOFFY+20,molwstr,MINI(MAXSTRLMW,strlen(molwstr))); 
       }

       if ( iwin && !DowinC) {
          XSetForeground(display, gc, infofg);
          XFillRectangle(display, winC, gc, S2OFFX, S2OFFY+7,240 ,20);
          XSetForeground(display, gc, infobg);
          XDrawRectangle(display, winC, gc, S2OFFX, S2OFFY+7,240 ,20);
          XDrawString(display,winC,gc,S2OFFX+5,S2OFFY+20,densstr,MINI(MAXSTRLMW,strlen(densstr))); 
       }
       XFlush(display);
}

#if defined(VMS) || defined(UNDERSC)
void errzme(str, nstr, icard, ivar)
#else
#ifdef CRAY
void ERRZME(str, nstr, icard, ivar)
#else
void errzme_(str, nstr, icard, ivar)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
int *icard;
int *ivar;
{
int i;
int ns;

	if (DEBUG) fprintf(stderr,"errzme in\n");

	if (!ZMEup) return;

	ns = *nstr;
	if (*nstr > MAXZMEERR ) ns = MAXZMEERR;
	for (i=0; i<MAXZMEERR; i++) ZMEerr[i] = ' ';
	strcp(str,ZMEerr,ns);

	for (i=0; i<ns; i++) if (ZMEerr[i] == '!') 
	   if (*ibell) XBell(display,0);

	XFlush(display);
	for (i=0; i<*xyzp->iatoms; i++) xyzp->iaton[i] = 1;
	DeActZME();
	xyzp->iaton[zmptrp->imap[*icard-1]-1] = 3;
	update_sel = 1;
	if (ABS(*ivar) > 0) {
		if (*ivar < 0) ActOnErr(*icard-1,4+ABS(*ivar)-1,ZMEerr);
		else ActOnErr(*icard-1,*ivar,ZMEerr);
	}
	else ActOnErr(*icard-1,0,ZMEerr);

	if (DEBUG) fprintf(stderr,"errzme out\n");

	return;

}

#if defined(VMS) || defined(UNDERSC)
void drwstr(xvl,yvl,strvl,sl,ind)
#else
#ifdef CRAY
void DRWSTR(xvl,yvl,strvl,sl,ind)
#else
void drwstr_(xvl,yvl,strvl,sl,ind)
#endif
#endif

int *xvl;
int *yvl;
int *sl;
int *ind;
#ifdef VMS
struct dsc$descriptor_s *strvl;
#else
#ifdef CRAY
_fcd strvl;
#else
char *strvl;
#endif
#endif
{
  if (monoscr) XSetBackground(display, gc, BlackPixel(display,screen));
#ifdef VMS
  if (monoscr) XDrawImageString(display, molcur, gc, *yvl, *xvl, strvl->dsc$a_pointer, *sl);
  else {
#ifdef DOGL
     if (has_opengl && (*fancy || *fullgl)) {
	if (StarNetOld) {
	   XDrawString(display, win, gc, *yvl, *xvl, strvl->dsc$a_pointer, *sl);
	} else {
	   if (strvl[*sl]  != '\0') strvl[*sl] = '\0';
	   printString(*yvl,*xvl,0,strvl->dsc$a_pointer);
	}
     } else
#endif
        XDrawString(display, molcur, gc, *yvl, *xvl, strvl->dsc$a_pointer, *sl);
  }
#else
#ifdef CRAY
  if (monoscr) XDrawImageString(display, molcur, gc, *yvl, *xvl, _fcdtocp(strvl), *sl);
  else {
#ifdef DOGL
     if (has_opengl && (*fancy || *fullgl)) {
	if (StarNetOld) {
	   XDrawString(display, win, gc, *yvl, *xvl, _fcdtocp(strvl), *sl);
	} else {
	   if (strvl[*sl]  != '\0') strvl[*sl] = '\0';
	   printString(*yvl,*xvl,0,_fcdtocp(strvl));
	}
     } else
#endif
	XDrawString(display, molcur, gc, *yvl, *xvl, _fcdtocp(strvl), *sl);
  }
#else
  if (monoscr) XDrawImageString(display, molcur, gc, *yvl, *xvl, strvl, *sl);
  else {
#ifdef DOGL
     if (has_opengl && (*fancy || *fullgl) ) {
	if (StarNetOld) {
	   XDrawString(display, win, gc, *yvl, *xvl, strvl, *sl);
	} else {
	   if (strvl[*sl]  != '\0') strvl[*sl] = '\0';
	   printString(*yvl,*xvl,0,strvl);
	}
     } else
#endif
	XDrawString(display, molcur, gc, *yvl, *xvl, strvl, *sl);
  }
#endif
#endif

}


#if defined(VMS) || defined(UNDERSC)
void drwqstr(xvl,yvl,ian,q,ind)
#else
#ifdef CRAY
void DRWQSTR(xvl,yvl,ian,q,ind)
#else
void drwqstr_(xvl,yvl,ian,q,ind)
#endif
#endif

int *xvl;
int *yvl;
int *ian;
double *q;
int *ind;
{
  sprintf(pchgtmp,"%s %7.4f  ",elements[*ian],*q);
  if (monoscr) XSetBackground(display, gc, BlackPixel(display,screen));
  if (monoscr) XDrawImageString(display, molcur, gc, *yvl, *xvl, pchgtmp, 10);
  else {
#ifdef DOGL
     if (has_opengl && (*fancy || *fullgl)) {
	if (StarNetOld) {
	   XDrawString(display, win, gc, *yvl, *xvl, pchgtmp, 10);
	} else {
	   pchgtmp[10] = '\0';
	   printString(*yvl,*xvl,0,pchgtmp);
	}
     } else
#endif
	XDrawString(display, molcur, gc, *yvl, *xvl, pchgtmp, 10);
  }

}

#ifndef VMS   
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <dirent.h>
#else
#include <stat.h>
#include <ctype.h>
#include <errno.h>
#include <rmsdef.h>

struct dirent {
    char	d_name[100];		/* File name		*/
    int         d_namlen;
    int		vms_verscount;		/* Number of versions	*/
    int		vms_versions[20];	/* Version numbers	*/
};

typedef struct _dirdesc {
    long			context;
    int				vms_wantversions;
    char			*pattern;
    struct dirent		entry;
    struct dsc$descriptor_s	pat;
} DIR;


extern DIR		*opendir();
extern struct dirent	*readdir();
extern void             closedir();
#endif


#if defined(__convex__) && defined (__STDC__)
#define S_IFMT  _S_IFMT
#define S_IFDIR _S_IFDIR
#endif



static int dosort(s1,s2)
char **s1, **s2;
{
    return (strcmp((*s1), (*s2)));
}

static int dsort(f1,f2)
float f1, f2;
{
    int iret;

    iret = -1;
    if (f1 == f2) iret = 0;
    if (f1 > f2) iret = 1;
    return (iret);
}

int isdir(dirname)
char* dirname;
{
  struct stat st;
  int i,j, ftype;

  st.st_mode = 0;
  stat(dirname, &st);
  ftype = st.st_mode & S_IFMT;  
  if ((st.st_mode & S_IFMT) == S_IFDIR) {
     return(1);
  } else {
     return(0);
  }
}

void getfiles(fs,dirname)
FSELSTRU *fs;
char* dirname;
{
  DIR           *dir;
  int            i,j, ftype;
  int            idstat,ifstat;
  struct stat    st;
  struct dirent *dp;
  char tmpfname[MAXFILELEN];

  if (dirname[strlen(dirname)-1] != '/') strcat(dirname,"/");
  if (fs->lastdir != dirname) strcpy(fs->lastdir,dirname);
  if (fs->parse) if (qboxes[QSUBSTR].str != NULL)
	strcpy(fs->substr,qboxes[QSUBSTR].str);

  for (i=0; i<fs->nfiles; i++) free(fs->files[i]);
  fs->nfiles = 0;
  lpnt = 0;

  for (i=0; i<fs->ndirs; i++) free(fs->dirs[i]);
  fs->ndirs = 0;

  dir = opendir(dirname);
  if (!dir) {
    fs->ndirs = 1;
    fs->dirs[0] = (char *) malloc(6);
    strcpy(fs->dirs[0], "..");
    return;
  }

  idstat=0; ifstat=0;
  i=0; j=0;
  while ( (dp = readdir(dir)) != NULL) {

	strcpy(tmpfname,dirname);
	strcat(tmpfname,dp->d_name);
        st.st_mode = 0;
        stat(tmpfname, &st);
	ftype = st.st_mode & S_IFMT;  
        if (ftype == S_IFDIR) {
	   if (j >= MAXDIRS) {
		idstat = 1;
	   } else {
		fs->dirs[j] = (char *) malloc(strlen(dp->d_name) + 3);
		if (!fs->dirs[j]) fprintf(stderr,"getfiles: malloc error\n");
		strcpy(fs->dirs[j], dp->d_name); j++;
	   }
	} else {
	   if (i >= MAXNAMES) {
		ifstat = 1;
	   } else {
		if (strstr(dp->d_name,fs->substr)) {
		   fs->files[i] = (char *) malloc(strlen(dp->d_name) + 3);
		   if (!fs->files[i]) 
			fprintf(stderr,"getfiles: malloc error\n");
		   strcpy(fs->files[i], dp->d_name); i++;
		}
	   }
	}

  }

  closedir(dir);

  if (idstat) {
      fprintf(stderr,
	"too many directories in directory only showing first %d.\n",MAXDIRS);
  }

  if (ifstat) {
      fprintf(stderr,
	"too many files in directory only showing first %d.\n",MAXNAMES);
  }

  fs->nfiles = i;
  fs->flist.lpnt = 0;
  fs->flist.select = 0;

  qsort((char *) fs->files, fs->nfiles, sizeof(char *), dosort);

  fs->ndirs = j;
  fs->dirlist.lpnt = 0;
  fs->dirlist.select = 0;

  if (fs->ndirs == 0) {
    fs->ndirs = 1;
    fs->dirs[j] = (char *) malloc(6);
    strcpy(fs->dirs[j], "..");
  } else {
    qsort((char *) fs->dirs, fs->ndirs, sizeof(char *), dosort);
  }

}

                                                                                
#ifdef VMS


DIR *
opendir(name)
    char	*name;
{
    DIR		*dd;

    /* Get memory for the handle, and the pattern. */
    if ((dd = (DIR *)malloc(sizeof *dd)) == NULL) {
	errno = ENOMEM;
	return NULL;
    }
    
    if (strcmp(".",name) == 0) name = "";
    
    dd->pattern = malloc((unsigned int)(strlen(name) + sizeof "*.*" + 1));
    if (dd->pattern == NULL) {
	free((char *)dd);
	errno = ENOMEM;
	return NULL;
    }

    /* Fill in the fields; mainly playing with the descriptor. */
    (void)sprintf(dd->pattern, "%s*.*", name);
    dd->context = 0;
    dd->vms_wantversions = 0;
    dd->pat.dsc$a_pointer = dd->pattern;
    dd->pat.dsc$w_length = strlen(dd->pattern);
    dd->pat.dsc$b_dtype = DSC$K_DTYPE_T;
    dd->pat.dsc$b_class = DSC$K_CLASS_S;

    return dd;
}


struct dirent *
readdir(dd)
    DIR				*dd;
{
    struct dsc$descriptor_s	res;
    char			*p;
    char			buff[sizeof dd->entry.d_name];
    int				i;

    /* Set up result descriptor, and get next file. */
    res.dsc$a_pointer = buff;
    res.dsc$w_length = sizeof buff - 2;
    res.dsc$b_dtype = DSC$K_DTYPE_T;
    res.dsc$b_class = DSC$K_CLASS_S;
    if (lib$find_file(&dd->pat, &res, &dd->context) == RMS$_NMF
     || dd->context == 0L)
	/* None left... */
	return NULL;

    /* Force the buffer to end with a NUL. */
    buff[sizeof buff - 1] = '\0';
    for (p = buff; !isspace(*p); p++)
	;
    *p = '\0';

    /* Skip any directory component and just copy the name. */
    if (p = strchr(buff, ']'))
	(void)strcpy(dd->entry.d_name, p + 1);
    else
	(void)strcpy(dd->entry.d_name, buff);

    /* Clobber the version. */
    if (p = strchr(dd->entry.d_name, ';'))
	*p = '\0';

    dd->entry.d_namlen = strlen(dd->entry.d_name);

    dd->entry.vms_verscount = 0;
    return &dd->entry;
}

void
closedir(dd)
    DIR         *dd;
{
    free(dd->pattern);
    free((char *)dd);
}
#endif /* end VMS */

void actde(inactid,inactf,iwin)

int iwin;
int inactid;
int inactf;
{
     int i;
     int inact;
     int inaf;

     if (DEBUG) fprintf(stderr,"actde in\n");


     inact = inactid;
     inaf  = inactf;

     if ( iwin == 1 ) {
	 denmode = 1;
         for ( i = 0; i < NBUTTS; i++ ) ActBut(&dbut[i],1);
         if ( inact == 1 ) {
               ActBut(&dbut[BELPOT],0);
               ActBut(&dbut[BORI],0);
               ActBut(&dbut[BATOM],0);
               ActBut(&dbut[BOVRLP],0);
         }

     }
     else {
	 inactMC = inact; inafMC = inaf;
	 denmode = 0;
         pdb = 0;
	 frfor = 0;
	 ZMEAA = 0;
         if (inaf >= 10) {pdb = 1;inaf = inaf - 10;linmax = 3;}
	 if (inaf == 2) {
	    frfor = 1;
	    if (FRup) RedrawList(&frlist);
            if (FRQ->ihasi) {
	        if (specup) drwspec();
	    } else {
	        if (specup) {
		   XDestroyWindow(display,winspec);
		   specup = 0;
		}
	    }
	    if (FRQ->ihasi && specup) drwspec();
	 } else {
	    if (FRup) {
		RedrawList(&frlist);
		XDestroyWindow(display,FrBox);
		FRup = 0;
	    }
	    if (specup) {
		XDestroyWindow(display,winspec);
		specup = 0;
	    }
	 }
         if (pdb == 1) {
            if (!addfile) {
		*backb = 0;
                hbon = 0;
	    }
            DefBut(&cbut[BFORC],  winMC, FOFFX+10, FOFFY+24, 80, BUTTH,
                     "Res.Comm.", infobg, CNTCOL);
	    cbut[BFORC].explstr = "Residue command window (protein only)\nIn combination with backbone display\nSwitch on/off residues";

            DefBut(&cbut[BINCRF], winMC, FOFFX+10, FOFFY+24+BUTTN*1, 80, BUTTH,
                     "Residue", infobg, CNTCOL);
	    cbut[BINCRF].explstr = "Switch on/off residues, by\nclicking on the backbone";

            DefBut(&cbut[BDECRF], winMC, FOFFX+10, FOFFY+24+BUTTN*2, 80, BUTTH,
                     "HetAtm", infobg, CNTCOL);
	    cbut[BDECRF].explstr = "Switch on/off NON amino acids:\nHETATM records in the PDB\nSwitch on/off secundary structure\ncartoons";

            DefBut(&cbut[BUNSC],  winMC, FOFFX+10, FOFFY+24+BUTTN*3, 
		TOGGWH, TOGGWH, " ", infobg, CNTCOL);
	    cbut[BUNSC].explstr = "Toggle display cysteine bridges";

            DefBut(&cbut[BHBOND], winMC, FOFFX+10, FOFFY+24+BUTTN*4, TOGGWH, TOGGWH,
                     " ", infobg, CNTCOL);
	    cbut[BHBOND].explstr = "Toggle display hydrogen bonds\n of secundary structure";

            if (!addfile) {
		TogUp(&cbut[BBACKB]);
		TogUp(&cbut[BATCOL]);
		TogUp(&cbut[BFORC]);
		TogUp(&cbut[BUNSC]);
		TogUp(&cbut[BHBOND]);
	    }
         }
         else {
	    DefBut(&cbut[BFORC],  winMC, FOFFX+10, FOFFY+24,
			TOGGWH, TOGGWH, " ", infobg, CNTCOL);
	    cbut[BFORC].explstr = "Switch on/off display of forces\nGaussian/Games/Molf only";
	    if (frfor) cbut[BFORC].explstr = 
		"Normal Mode/Frequency analysis";

            DefBut(&cbut[BINCRF], winMC, FOFFX+10, FOFFY+24+BUTTN*1, 80, BUTTH,
                     "Incr. Scale", infobg, CNTCOL);
	    cbut[BINCRF].explstr = "Increase scale of forces";

            DefBut(&cbut[BDECRF], winMC, FOFFX+10, FOFFY+24+BUTTN*2, 80, BUTTH,
                     "Decr. Scale", infobg, CNTCOL);
	    cbut[BDECRF].explstr = "Decrease scale of forces";

            DefBut(&cbut[BUNSC],  winMC, FOFFX+10, FOFFY+24+BUTTN*3, 80, BUTTH,
                     "Unscale", infobg, CNTCOL);
	    cbut[BUNSC].explstr = "no scaling of forces";

            DefBut(&cbut[BHBOND], winMC, FOFFX+10, FOFFY+24+BUTTN*4, 80, BUTTH,
                     "", infobg, CNTCOL);
         }
         for ( i = 0; i < NBUTTS2; i++ ) ActBut(&cbut[i],1);


         if (pdb) {
            if (!addfile) {
		ActBut(&cbut[BFORC],0);
		ActBut(&cbut[BINCRF],0);
		ActBut(&cbut[BDECRF],0);
		ActBut(&cbut[BUNSC],0);
		ActBut(&cbut[BHBOND],0);
	    }
         }
         if ( inact >= 4 ) {
            ActBut(&cbut[BDENMOD],0);
            denm = 0;
            inact = inact - 4;
         }
         else denm = 1;

         if ( inact >= 2 ) {
            ActBut(&cbut[BCONV],0);
            inact = inact - 2;
         }
         if ( inact == 1 ) {
            ActBut(&cbut[BFIRST],0);
            ActBut(&cbut[BNEXT],0);
            ActBut(&cbut[BPREV],0);
            ActBut(&cbut[BMOVIE],0);
            ActBut(&cbut[BGEOM],0);
         }
         if ( inaf >= 1 && !pdb ) {
            ActBut(&cbut[BFORC],0);
            ActBut(&cbut[BINCRF],0);
            ActBut(&cbut[BDECRF],0);
            ActBut(&cbut[BUNSC],0);
            ActBut(&cbut[BHBOND],0);
         }
         if ( inaf == 2 && !pdb ) {
		ActBut(&cbut[BFORC],1);
		TogUp(&cbut[BFORC]);
	 }
         if (!pdb) ActBut(&cbut[BBACKB],0);
         if (!mfdata->imol) {
            ActBut(&cbut[BMOLF],-1);
	 } else {
            ActBut(&cbut[BMOLF],1);
	 }

	 if (*fullgl) {
	    *persp = 1;
	    TogDown(&cbut[BPERSP]); 
	 }
    
     }

     if (iwin) RedrawwinC(0,0,WINCWIDE,WINCHIGH);
     else      RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
     ATMsel = 0;
     ATMselp = ATMsel + 1;
     if (ATMup) {
	UpdateATM();
	RedrawATM();
     }
     if (CPup) {
	UpdateCP();
	RedrawCP();
     }
     if (CTup) {
	RedrawCT();
     }
     if (STRCup) {
	UpdateSTRC();
	RedrawSTRC();
     }


     if (pdb && ZMEup) {
	if (DoPDB(1)) i = 1;
     }
     if (DEBUG) fprintf(stderr,"actde out\n");
}

void CentLig()
{
      int i,l,m;
      double CoorLig[3][MXHETA]= {0.0};
      double dmn[MXHETA]= {0.0};
      double d2,dx;
      int NligAt[MXHETA] = {0};

      if (*ipdbon && !clfstrptr->ilcset) {

	for (l=0; l < *xyzp->iatoms; l++) {

	  if (xyzp->iresid[l] < -3) {

	   m = ABS(xyzp->iresid[l]);
	   
	   if (m < MXHETA) {
		for (i=0; i<3; i++) 
		   CoorLig[i][m] = CoorLig[i][m] + xyzp->coo[l*3+i];
		NligAt[m]++;
	   }

	  }
	}

	for (l=0; l < MXHETA; l++) {
	   if (NligAt[l] > 0) {
		for (i=0; i<3; i++) 
			CoorLig[i][l] = CoorLig[i][l] / (NligAt[l]);
	   }
	   dmn[l] = 1.0e08;
	}

	for (l=0; l < *xyzp->iatoms; l++) {

	  if (xyzp->iresid[l] < -3) {

	   m = ABS(xyzp->iresid[l]);
	   

	   if (m < MXHETA) {
	      d2 = 0.0;
	      for (i = 0; i < 3; i++) {
		dx = CoorLig[i][m] - xyzp->coo[l*3+i];
		d2 = d2 + dx*dx;
	      }

	      if (d2 < dmn[m])  {
		dmn[m] = d2;
		clfstrptr->ligcat[m] = l;
	      }
	   }

	  }
	}
	clfstrptr->ilcset = 1;

      }


}


#if defined(VMS) || defined(UNDERSC)
void hetnum(idum)
#else
#ifdef CRAY
void HETNUM(idum)
#else
void hetnum_(idum)
#endif
#endif
int *idum;
{
   *idum =  hetptr.NHetAtm;
}

#if defined(VMS) || defined(UNDERSC)
void chkmol2(iok)
#else
#ifdef CRAY
void CHKMOL2(iok)
#else
void chkmol2_(iok)
#endif
#endif
int *iok;
{
#if defined(VMS) || defined(UNDERSC)
   chkmld(iok,
#else
#ifdef CRAY
   CHKMLD(iok,
#else
   chkmld_(iok,
#endif
#endif
	xyzp->ianz,xyzp->ityp);

}

#if defined(VMS) || defined(UNDERSC)
void prslab(str, nstr, iopt)
#else
#ifdef CRAY
void PRSLAB(str, nstr, iopt)
#else
void prslab_(str, nstr, iopt)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
int *iopt;
{

       if (hetlab.NHetLab >= MXHETLAB) return;
       
       hetlab.iat[hetlab.NHetLab]    = *iopt;

       hetlab.HetLab[hetlab.NHetLab] = (char *) malloc(*nstr+1);
       if (!hetlab.HetLab[hetlab.NHetLab]) 
		fprintf(stderr,"prslab: malloc error\n");

       strcp(str,hetlab.HetLab[hetlab.NHetLab],*nstr);

#ifndef CRAY
       hetlab.HetLab[hetlab.NHetLab][*nstr] = '\0';
#endif
       hetlab.NHetLab++;

}

#if defined(VMS) || defined(UNDERSC)
void sftlab(iopt)
#else
#ifdef CRAY
void SFTLAB(iopt)
#else
void sftlab_(iopt)
#endif
#endif
int *iopt;
{
   int i;

   for (i=0; i<hetlab.NHetLab; i++)
	if (hetlab.iat[i] == *iopt) hetlab.iat[i] = *iopt + 1;
}

#if defined(VMS) || defined(UNDERSC)
void parsfn(str, nstr, iopt)
#else
#ifdef CRAY
void PARSFN(str, nstr, iopt)
#else
void parsfn_(str, nstr, iopt)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
int *iopt;
{
       int j;
       char **strarr;
       int *nstrings;
       int room;

       switch(*iopt) {
       case 0: 
	  strarr = fsel.files;
	  nstrings = &fsel.nfiles;
	  room = *nstr + 3;
	  break;
       case 1: 
	  strarr = hetptr.HetAtm;
	  nstrings = &hetptr.NHetAtm;
	  if (hetptr.NHetAtm >= MXHETA) return;
	  hetptr.Allocated[*nstrings] = 1;
	  room = *nstr + 1;
	  break;
       case 2: 
	  strarr = &VRMLFname;
          j = 0;
	  nstrings = &j;
	  room = *nstr + 1;
	  break;
       case 3: 
	  strarr = ColNam;
	  nstrings = &NColNam;
	  room = *nstr + 1;
	  break;
       case 4: 
	  strarr = mm3;
	  nstrings = &Nmm3;
	  room = *nstr + 1;
	  break;
       case 5: 
	  strarr = chmtnk;
	  nstrings = &Nchmtnk;
	  room = *nstr + 1;
	  break;
       case 6: 
	  strarr = mol2;
	  nstrings = &Nmol2;
	  room = *nstr + 1;
	  break;
       case 7: 
	  strarr = chmsf;
	  nstrings = &Nchmsf;
	  room = *nstr + 1;
	  break;
       case 8: 
	  strarr = ambstr;
	  nstrings = &Nambstr;
	  room = *nstr + 1;
	  break;
       case 9: 
	  strarr = &GEOMstr;
          j = 0;
	  nstrings = &j;
	  room = *nstr + 1;
	  GEOMset = 1;
	  break;
       case 10: 
	  strarr = spacegr;
	  nstrings = &Nspgr;
	  room = *nstr + 1;
	  break;
       case 11: 
	  strarr = achain;
	  nstrings = &ncal;
	  room = *nstr + 1;
	  break;
       case 12: 
	  strarr = frsym;
	  nstrings = &nfr;
	  room = *nstr + 1;
	  break;
       case 13: 
	  strarr = mlftit;
	  nstrings = &ntits;
	  room = *nstr + 1;
	  if (ntits >= mxtits) return;
	  break;
       case 14: 
	  strarr = gmx;
	  nstrings = &Ngmx;
	  room = *nstr + 1;
	  break;
       case 15: 
	  strarr = gmx2;
	  nstrings = &Ngmx2;
	  room = *nstr + 1;
	  break;
       case 16: 
	  strarr = g43;
	  nstrings = &Ng43;
	  room = *nstr + 1;
	  break;
       case 17: 
	  strarr = amostr;
	  nstrings = &Namostr;
	  room = *nstr + 1;
	  break;
       case 18: 
	  strarr = grostr;
	  nstrings = &Ngrostr;
	  room = *nstr + 1;
	  break;
       case 19: 
	  strarr = gffext;
	  nstrings = &Ngffext;
	  room = *nstr + 1;
	  break;
       case 20: 
	  strarr = exepath;
	  nstrings = &Nexepath;
	  room = *nstr + 1;
	  break;
       }

       strarr[*nstrings] = (char *) malloc(room);
       if (!strarr[*nstrings]) fprintf(stderr,"getfiles: malloc error\n");
       strcp(str,strarr[*nstrings],*nstr);
#ifndef CRAY
       strarr[*nstrings][*nstr] = '\0';
#endif
       (*nstrings)++;

/* postprocess some strings */

       if (*iopt == 20) {
	  char *p;
	  
	  if ((p = strrchr(exepath[0], '/'))) {
		p++; *p = '\0';
	  } else {
		p = exepath[0];
		*p = '\0';
	  }
       }
}

#if defined(VMS) || defined(UNDERSC)
void parstr(str, iopt)
#else
#ifdef CRAY
void PARSTR(str, iopt)
#else
void parstr_(str, iopt)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *iopt;
{
       int n;

       switch(*iopt) {
       case 0: 
	  glin1 = str;
	  break;
       case 1: 
	  glin2 = str;
	  break;
       case 2: 
	  gtitl = str;
	  break;
       case 3: 
	  jname = str;
	  break;
       case 4: 
	  qname = str;
	  break;
       case 5: 
	  ename = str;
	  break;
       case 6: 
	  tnkjn = str;
	  break;
       case 7: 
	  vfile = str;
	  break;
       case 8: 
	  mfile = str;
	  break;
       case 9: 
	  oglfile = str;
	  break;
       case 10: 
	  povfile = str;
	  break;
       case 11: 
	  n = strlen(str);
	  if (pdbcode != NULL && pdbcode == pdbcbck) free(pdbcode);
	  pdbcode = (char *) malloc(n+1);
	  pdbcbck = pdbcode;
	  strncpy(pdbcode,str,n);
	  pdbcode[4] = '\0';
	  break;
       case 12: 
	  gfile = str;
	  break;
       case 13: 
	  tmpfil = str;
	  break;
       }
}

void cpstr(ostr,str,nlen)
char *ostr;
#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int nlen;
{
/* ostr (C) -> str (Fortran) */
  int i;
  int n;

  if (nlen) {
	n = MINI(strlen(ostr),nlen);
  } else {
	n = strlen(ostr);
  }

#ifdef VMS
                for (i=0; i<n; i++)
                      {str->dsc$a_pointer[i] = ostr[i];}
#else
#ifdef CRAY
                strncpy(_fcdtocp(str),ostr,n);
#else
                for (i=0; i<nlen; i++) str[i] = '\0';
                strncpy(str,ostr,n);
#endif
#endif
}

void strcp(str,ostr,nlen)
#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
char *ostr;
int nlen;
{
/* str (fortran) -> ostr (C) */
  int i;

#ifdef VMS
                for (i=0; i<nlen; i++)
                      ostr[i] = str->dsc$a_pointer[i];
#else
#ifdef CRAY
                strncpy(ostr,_fcdtocp(str),nlen);
#else
                for (i=0; i<nlen; i++) ostr[i] = '\0';
                strncpy(ostr,str,nlen);
#endif
#endif
}

#if defined(VMS) || defined(UNDERSC)
void gtht(charr,ires)
#else
#ifdef CRAY
void GTHT(charr,ires)
#else
void gtht_(charr,ires)
#endif
#endif
int *charr;
int *ires;
{
   int i;
   
   if (*ires-1 < hetptr.NHetAtm) {
	if (hetptr.HetAtm[*ires-1] == NULL) {
	   charr[0] = 'R';
	   charr[1] = 'E';
	   charr[2] = 'S';
	} else {
	   for(i=0; i<3; i++) {
		charr[i] = hetptr.HetAtm[*ires-1][i];
	   }
	}
   } else {
	charr[0] = 'H';
	charr[1] = 'O';
	charr[2] = 'H';
   }
}

void send_expose()
{
   XExposeEvent expe;

   expe.type = Expose;
   expe.send_event = True;
   expe.display = display;
   expe.window = win;
   expe.x = 0;
   expe.y = 0;
   expe.count = 0;
   expe.width = width; expe.height = height;
   XSendEvent(display, win, True, ExposureMask, (XEvent *) &expe);
   XFlush(display);
}

#if defined(VMS) || defined(UNDERSC)
void parfns(str, nstr)
#else
#ifdef CRAY
void PARFNS(str, nstr)
#else
void parfns_(str, nstr)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
{

   if (*nstr < MAXSTRLEN) {
       strcp(str,strname,*nstr);
#ifndef CRAY
       strname[*nstr] = '\0';
#endif
   }

}

volatile sig_atomic_t pdone;

static void handle_child()
{
/*  fprintf(stderr,"handle_child %d\n",tnkpid);*/
  sigprocmask(SIG_BLOCK,&base_mask,NULL);
  pdone = 1;
  fndfile = 1;
  tnkupf = 1;
  if (tnkloop) send_expose();
  sigprocmask(SIG_UNBLOCK,&base_mask,NULL);
}

static int tdone;

static void handle_alarm()
{
  tdone = 1;
}

static void handle_explalarm()
{
   XMapEvent expe;
   Window win;

   expe.type = MapNotify;
   expe.display = display;
   if (expldat.borq) {
	win = expldat.qarr[expldat.button].win;
   } else {
	win = expldat.barr[expldat.button].win;
   }
   expe.window = expldat.win;
   if (expldat.winup != NULL) if (! *expldat.winup) return;

   if (!expldat.active && !animptr.on && !*movie) {
	XFlush(display);
	XSendEvent(display, win, 
		False, SubstructureNotifyMask, (XEvent *) &expe);
	XFlush(display);
   }
}

static void DoSvgfile()
{
   Window win;
   char str[500];
   char str1[500];
   int i;

/*
fprintf(stderr,"DoSvgfile CurSVG %d uping %d\n",bcksvg.CurSVG,uping);
*/
   if (!bcksvg.UpSVG) return;

   if (uping) {
#ifdef HASTIMER
	Timer(100,3);
#else
	signal(SIGALRM,handle_svgfile);
	alarm(2);
#endif
	return;
   }

   uping = 1;
   signal(SIGALRM,SIG_IGN);

   if (!expldat.active && !animptr.on && !*movie && bcksvg.UpSVG) {
     for (i = 0; i < CHUNK; i++) {
	sprintf(str,"/tmp/b%d.svg",bcksvg.CurSVG+1);
	sprintf(str1,"/tmp/b%d.svg",bcksvg.CurSVG+2);
	if (access(str1,F_OK) == 0 || bcksvg.CurSVG+1 == bcksvg.NUpSVG) {
	   bcksvg.ReadSVG = 1;
	   rdsvg(&COO[bcksvg.istruct]->svgs[bcksvg.CurSVG],str,bcksvg.CurSVG);
	   bcksvg.CurSVG++;
	   if (bcksvg.CurSVG >= bcksvg.NUpSVG) {
		bcksvg.UpSVG = 0;
		bcksvg.NUpSVG = 0;
		bcksvg.CurSVG = 0;
	   	handle = 0;
	   	bcksvg.ReadSVG = 0;
		COO[bcksvg.istruct]->svgdone = 1;
		wrsvgs(COO[bcksvg.istruct]->fname);
		uping = 0;
		return;
	   }
	}
    }
#ifdef HASTIMER
	Timer(100,3);
#else
	signal(SIGALRM,handle_svgfile);
	alarm(2);
#endif
   }
   uping = 0;
}

static void SvgExpose()
{
   XExposeEvent expe;

   expe.type = Expose;
   expe.send_event = True;
   expe.display = display;
   expe.window = MLTwin;
/*   expe.count = 0;*/

   if (!expldat.active && !animptr.on && !*movie && bcksvg.UpSVG && !uping) {
	if (*WinObj[30].winup) {
	   XFlush(display);
	   XSendEvent(display, MLTwin, 
		False, ExposureMask, (XEvent *) &expe);
	   XFlush(display);
	} else {
	   initMLT();
	}
	
   }
   DoSVGExpose = 0;
}

static void handle_svgfile()
{
   if (uping)  return;

   sigprocmask(SIG_BLOCK,&base_mask,NULL);
   DoSVGExpose = 1;
   if (!expldat.active && !animptr.on && !*movie && bcksvg.UpSVG && !uping) {
	DoSVGExpose = 1;
   }
   sigprocmask(SIG_UNBLOCK,&base_mask,NULL);
}

static int escopt = 0;

static void handle_tnk()
{
   sigprocmask(SIG_BLOCK,&base_mask,NULL);
   tnkupf = 1;
   sigprocmask(SIG_UNBLOCK,&base_mask,NULL);
}

static void update_tnk()
{
   int phlp,iret,i;
   char cmdcyc[MAXCMD];
   struct stat st;
   struct timeval tv,tvn;
   long tvs,tvu, tottv;

   if (uping) return;
 
   uping = 1;
   nomemf = 1;
   if (opttim) gettimeofday(&tv,NULL);

   phlp = pdone;
   sprintf(cmdcyc,"%s.%03d",cmdstr,cycle);
/*fprintf(stderr,"TNKPNT %s\n",cmdcyc);*/
   fndfile = 1;
   st.st_mode = 0;
   if (!stat(cmdcyc, &st)) {
/*fprintf(stderr,"Found file %s\n",cmdcyc);*/
	signal(SIGALRM,SIG_IGN);
#if defined(VMS) || defined(UNDERSC)
       	tnkpnt(&cycle,&iret);
#else
#ifdef CRAY
       	TNKPNT(&cycle,&iret);
#else
       	tnkpnt_(&cycle,&iret);
#endif
#endif
	if (iret) {
	   tnkupd = 1;
	   if (tnkloop) send_expose();
           if (delcyclefile) unlink(cmdcyc);
	   cycle++;
	} else {
	   fprintf(stderr,"found file ERROR\n");
	}
	
   } else {
/*fprintf(stderr,"NOT Found file %s\n",cmdcyc);*/
	if (phlp == pdone) {
	   fndfile = 0;
	   if (tnkloop) send_expose();
	}
   }

   if (opttim) {
	gettimeofday(&tvn,NULL);
	tvs = tvn.tv_sec - tv.tv_sec;
	tvu = (tvn.tv_usec - tv.tv_usec) / 1000L;
	timo[icyco] = tvu;
	icyco++;
	if (icyco >= NCYCO) {
	   tottv = 0L;
	   for (i=0; i<NCYCO; i++)  {
		tottv = tottv + timo[i];
	   }
	   TIMi = 2*((int) tottv) / NCYCO;
	   if (TIMi < 5) TIMi = 5;
	   opttim = 0;
	}
   }

   uping = 0;
   nomemf = 0;
}

static void handle_tnkesc()
{
   tnkesc = 1;
}

static void esctnk()
{
   int ist,phlp,iret,cyclo;
   char cmdcyc[MAXCMD];
   char cmdtmp[MAXCMD];
   struct stat st;

   sprintf(cmdcyc,"%s.%03d",cmdstr,cycle);
   sprintf(cmdtmp,"%s.tmp",cmdstr);
   phlp = pdone;
   fndfile = 1;
   st.st_mode = 0;
   cyclo = cycle;
   while (!stat(cmdcyc, &st)) {
	/*fprintf(stderr,"esc Found file %s\n",cmdcyc);*/
	cyclo = cycle;
	if (delcyclefile) {
	   ist = rename(cmdcyc,cmdtmp);
	   if (rename(cmdcyc,cmdtmp)) {
	      unlink(cmdcyc);
	   }
	} else {
	   strcpy(cmdtmp,cmdcyc);
	}
	cycle++;
        sprintf(cmdcyc,"%s.%03d",cmdstr,cycle);
   }

   if ( (access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp)) ) {

	if (delcyclefile) cyclo = -1;
#if defined(VMS) || defined(UNDERSC)
	tnkpnt(&cyclo,&iret);
#else
#ifdef CRAY
	TNKPNT(&cyclo,&iret);
#else
	tnkpnt_(&cyclo,&iret);
#endif
#endif
        if (delcyclefile) unlink(cmdtmp);

	if (iret) {
	   tnkupd = 1;
	   if (tnkloop) send_expose();
	}

   } else {

	if (phlp == pdone) {
	   fndfile = 0;
	   if (tnkloop) send_expose();
	}
   }

   escopt = 0;

#ifdef HASTIMER
   Timer(100,1);
#endif

}

int escox()
{
   char cmdtmp[MAXCMD];
   struct stat st;

   sprintf(cmdtmp,"%s_opt.xyz",cmdstr);
   st.st_mode = 0;
   if (!stat(cmdtmp, &st)) {
	if (st.st_size) return(1);
   }
   return(0);
}

void spaesc(fname)
char *fname;
{
   char tmpf[MAXCMD], *p, *q;

   strcpy(tmpf,fname);

   while ((p = strchr(fname,' '))) {
      q = strchr(tmpf,' ');
      p[0] = '\\';
      p[1] = '\0';
      strcat(fname,q);
      p[1] = '\n';
      strcpy(tmpf,fname);
   }

   while ((p = strchr(fname,'\n'))) p[0] = ' ';
}

void setlck(i)
int *i;
{
        FILE *out;
        char lckfile[80];
	struct stat st;

        sprintf(lckfile,"%d.ambforw",*i);

	st.st_mode = 0;
	if (stat(lckfile, &st)) {
           out = fopen(lckfile,"w");
           fprintf(out,"lock\n");
           fclose(out);
	}
}

#if defined(VMS) || defined(UNDERSC)
int islck(i)
#else
#ifdef CRAY
int ISLCK(i)
#else
int islck_(i)
#endif
#endif
int *i;
{
        FILE *out;
        char lckfile[80];
	struct stat st;

        sprintf(lckfile,"%d.ambforw",*i);

	st.st_mode = 0;

	if (!stat(lckfile, &st)) {
	   return 1;
	} else {
	   return 0;
	}
}

int getexe(iprg,mpi,cmdfil)
int iprg;
int mpi;
char *cmdfil;
{

#ifdef __CYGWIN__
   sprintf(cmdfil,"%s%s.exe",exepath[0],AmbProgs[iprg]);
#else
   if (mpi) {
	sprintf(cmdfil,"%s%s.mpi",exepath[0],AmbProgs[iprg]);
   } else {
	sprintf(cmdfil,"%s%s",exepath[0],AmbProgs[iprg]);
   }
#endif

   if (! (access(cmdfil,F_OK) == 0 && !isdir(cmdfil))) {
#ifdef __CYGWIN__
	sprintf(cmdfil,"%sambfor/%s.exe",exepath[0],AmbProgs[iprg]);
#else
	if (mpi) {
	   sprintf(cmdfil,"%sambfor/%s.mpi",exepath[0],AmbProgs[iprg]);
	} else {
	   sprintf(cmdfil,"%sambfor/%s",exepath[0],AmbProgs[iprg]);
	}
#endif
	if (! (access(cmdfil,F_OK) == 0)) {
	   if (mpi) {
		sprintf(cmdfil,"%s.mpi",AmbProgs[iprg]);
	   } else {
		sprintf(cmdfil,"%s",AmbProgs[iprg]);
	   }
	} else {
	   return(1);
	}
   } else {
	return(1);
   }
   return(0);
}

void doamb(jobstr)
char *jobstr;
{
   char cmdfil[MAXCMD];
   char cmdopt[MAXCMD];
   char cmdtmp[MAXCMD] = "ambfor ";
   char **argv;
   char *p;
   char *ambfor = "ambfor";
   char *spntr;
   char gtolstr[20];
   char iterstr[20];
   int iprg;
   FILE *out;

   if (hasmpi && usempi) {
	domamb(jobstr);
	return;
   }

   iprg = *tnkprg;
   if (iprg == 2) iprg = 0;

   strcpy(cmdtmp,DOSpath(jobstr));
   strcat(cmdtmp,"_opt.xyz");
   if ( (access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp)) ) {
	strcpy(cmdopt,cmdtmp);
	strcat(cmdopt,".old");
	if (rename(cmdtmp,cmdopt)) {
	   fprintf(stderr,"error renaming existing file %s\n",cmdopt);
	}
   }

   strcpy(cmdtmp,DOSpath(jobstr));
   strcat(cmdtmp,".tmp");
   if ( (access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp)) ) {
	unlink(cmdtmp);
   }

   sprintf(gtolstr,"%f",*currgrd);
   sprintf(iterstr,"%d",*tnkit);

   getexe(iprg,0,cmdfil);

   strcpy(cmdtmp,cmdfil);
#ifdef __CYGWIN__
   spaesc(cmdtmp);
   if (p = strstr(cmdfil,".exe")) p[0] = '\0';
#endif
   strcat(cmdtmp," ");

   if (tnk_single) {
	strcat(cmdtmp,"-n -s ");
   } else {
	if (*tnkbg) {
	   strcat(cmdtmp,"-n ");
	} else {
	   strcat(cmdtmp,"-M ");
	}

	if (*arch) {
	   strcat(cmdtmp," -a ");
	}

	if (Box) {
	   strcat(cmdtmp," -b ");
	}

	if (Cutoff) {
	   strcat(cmdtmp," -N ");
	}

	strcat(cmdtmp,grdFlags[iprg]);
	strcat(cmdtmp," ");
	strcat(cmdtmp,gtolstr);

	strcat(cmdtmp," ");
	strcat(cmdtmp,iterFlags[iprg]);
	strcat(cmdtmp," ");
	strcat(cmdtmp,iterstr);

	strcat(cmdtmp," ");
   }

   strcat(cmdtmp,DOSpath(jobstr));

   if (tnk_single) {
	system(cmdtmp);
	strcpy(cmdtmp,DOSpath(jobstr));
	strcat(cmdtmp,".log");
	out = fopen(cmdtmp,"r");
	if (out != NULL) {
	   while (fgets(cmdfil,MAXCMD,out) != NULL) {
		if (strstr(cmdfil,"Estat") != NULL) {
		   spntr = cmdfil + 6;
		   sscanf(spntr,"%lf",&newen);
/*
		   fprintf(stderr,"newen %f\n",newen);
*/
		}
	   }
	   fclose(out);
	}
   } else {
     if (*tnkbg) {
	if (*arch) {
	   if (Box) {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-a","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-a","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-a","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-a",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }
	} else {

	   if (Box) {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-n","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-n",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }

	}
     } else {
	if (*arch) {
	   if (Box) {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-a","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-a","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-a","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-a",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }
	} else {
	   if (Box) {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(cmdfil,AmbProgs[iprg],"-M","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(cmdfil,AmbProgs[iprg],"-M",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }
	}
     }
   }
}

void domamb(jobstr)
char *jobstr;
{
   char cmdfil[MAXCMD];
   char cmdopt[MAXCMD];
   char cmdtmp[MAXCMD] = "ambfor ";
   char **argv;
   char *p;
   char *ambfor = "ambfor";
   char *spntr;
   char gtolstr[20];
   char iterstr[20];
   char procstr[20];
   int iprg;
   FILE *out;

   iprg = *tnkprg;
   if (iprg == 2) iprg = 0;

   strcpy(cmdtmp,DOSpath(jobstr));
   strcat(cmdtmp,"_opt.xyz");
   if ( (access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp)) ) {
	strcpy(cmdopt,cmdtmp);
	strcat(cmdopt,".old");
	if (rename(cmdtmp,cmdopt)) {
	   fprintf(stderr,"error renaming existing file %s\n",cmdopt);
	}
   }

   strcpy(cmdtmp,DOSpath(jobstr));
   strcat(cmdtmp,".tmp");
   if ( (access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp)) ) {
	unlink(cmdtmp);
   }

   sprintf(gtolstr,"%f",*currgrd);
   sprintf(iterstr,"%d",*tnkit);
   sprintf(procstr,"%d",useproc);

   getexe(iprg,1,cmdfil);

   strcpy(cmdtmp,mpicmd);
   strcat(cmdtmp," -np ");
   strcat(cmdtmp,procstr);
   strcat(cmdtmp," ");
   strcat(cmdtmp,cmdfil);

#ifdef __CYGWIN__
   spaesc(cmdtmp);
   if (p = strstr(cmdfil,".exe")) p[0] = '\0';
#endif

   strcat(cmdtmp," ");

   if (tnk_single) {
	strcat(cmdtmp,"-n -s ");
   } else {
	if (*tnkbg) {
	   strcat(cmdtmp,"-n ");
	} else {
	   strcat(cmdtmp,"-M ");
	}

	if (*arch) {
	   strcat(cmdtmp," -a ");
	}

	if (Box) {
	   strcat(cmdtmp," -b ");
	}

	if (Cutoff) {
	   strcat(cmdtmp," -N ");
	}

	strcat(cmdtmp,grdFlags[iprg]);
	strcat(cmdtmp," ");
	strcat(cmdtmp,gtolstr);

	strcat(cmdtmp," ");
	strcat(cmdtmp,iterFlags[iprg]);
	strcat(cmdtmp," ");
	strcat(cmdtmp,iterstr);

	strcat(cmdtmp," ");
   }

   strcat(cmdtmp,DOSpath(jobstr));

   if (tnk_single) {
	system(cmdtmp);
	strcpy(cmdtmp,DOSpath(jobstr));
	strcat(cmdtmp,".log");
	out = fopen(cmdtmp,"r");
	if (out != NULL) {
	   while (fgets(cmdfil,MAXCMD,out) != NULL) {
		if (strstr(cmdfil,"Estat") != NULL) {
		   spntr = cmdfil + 6;
		   sscanf(spntr,"%lf",&newen);
/*
		   fprintf(stderr,"newen %f\n",newen);
*/
		}
	   }
	   fclose(out);
	}
   } else {
     if (*tnkbg) {
	if (*arch) {
	   if (Box) {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-a","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-a","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-a","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-a",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }
	} else {

	   if (Box) {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-n",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }

	}
     } else {
	if (*arch) {
	   if (Box) {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-a","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-a","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-a","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-a",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr, 
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }
	} else {
	   if (Box) {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-b","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-b",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   } else {
	      if (Cutoff) {
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M","-N",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      } else {
/*yoyyoyo*/
		if (execlp(mpicmd,"mpirun",
		    "-np",procstr,
		    cmdfil,"-M",
		    grdFlags[iprg],gtolstr,
		    iterFlags[iprg],iterstr,
		    DOSpath(jobstr),NULL) == -1) {
		    system(cmdtmp);
		}
	      }
	   }
	}
     }
   }
}

void mloop(iopt)
int *iopt;
{
   int i;
   int ptmp,ctmp;

   sigprocmask(SIG_BLOCK,&base_mask,NULL);
   XFlush(display);

   tnkloop = 1;

   if (XPending(display)>0) {

	if (XCheckTypedWindowEvent(display, winMC, ButtonPress,&event)) {
	   event.xbutton.window = winMC;
	} else { 
	   if (XCheckTypedWindowEvent(display, win, ButtonPress,&event)) {
		event.xbutton.window = win;
	   } else {
		XNextEvent(display, &event);
	   }
	}
	tnkloop = 0;

	switch (event.type) {
	case KeyPress:
	{
	   XKeyEvent *key_event = (XKeyEvent *) &event;
	   char buf[10]; XComposeStatus status;
	   int stlen,istat;

	   stlen = XLookupString(key_event,buf,10,&ks,&status);
	   if (key_event->window == win || key_event->window == winMC) {
		if (ks==XK_Escape) {
		  if (!pdone) kill(-tnkpid,SIGINT);
		  escopt = 1; pdone = 1;
		  if (!escox()) *iopt = -1;
 		  Timer(TIMi,1);
		  /*fndfile = 0;*/
		  break;
		}
	   }

	}
	break;
	case ButtonPress:
		if (event.xbutton.window == win) {
		   if (event.xbutton.button == 3) OnTop();
		   else if (event.xbutton.button == 4) 
			ScrollWheel(&ctmp,&ptmp,1);
		   else if (event.xbutton.button == 5) 
			ScrollWheel(&ctmp,&ptmp,0);
		   else {
		      if (*ball) {
			gmoving = 1;
			moving = 1;
			tnkupd = 1;
			hold = 0;
			startx = event.xbutton.x;
			starty = event.xbutton.y;
			btype = 0;
			if (event.xbutton.state & ShiftMask) btype = 1;
			if (event.xbutton.state & ControlMask) btype = 2;
			if ((event.xbutton.state & ControlMask) 
					 && (event.xbutton.state & ShiftMask)) 
						btype = 3;
			if ((*fancy || *fullgl) && has_opengl) 
			    moused(event.xbutton.button,
					   event.xbutton.state, 
					   event.xbutton.x, 
					   event.xbutton.y);
		      } else {
			    rotat(event.xbutton.x,event.xbutton.y);
		      }
		   }

		} else if (event.xbutton.window == winMC) {

		   i = Clickwin(cbut,NBUTTS2,event.xbutton.x,event.xbutton.y,1);

		   switch (i) {
			case BQUITT:
				kill(-tnkpid,SIGINT);
				/*fndfile = 0;*/
				pdone = 1;
				escopt = 1;
				if (!escox()) *iopt = -1;
 		  		Timer(TIMi,1);
				break;

			case BZOOMIN:
				hold = 1; 
				holdt = 290; holdp = -1;
				break;

			case BZOOMOUT:
				hold = 1; 
				holdt = 290; holdp = 1;
				break;

			case BLEFT:    
				hold = 1; 
				holdt = 420; holdp = 0;
				break;

			case BRIGHT:    
				hold = 1; 
				holdt = 430; holdp = 0;
				break;

			case BUP:    
				hold = 1; 
				holdt = 440; holdp = 0;
				break;

			case BDOWN:    
				hold = 1; 
				holdt = 450; holdp = 0;
				break;

			case BSOLID:
				tnkupd = 1;
				TogBut(&cbut[BSOLID]);
				if (*fancy) {
				    *fancy = 0;
				    if (has_opengl) {
					if (*fullgl) {
					   *ifogl = 1;
					} else {
					   *ifogl = 0;
					}
				    } else {
					*ifogl = 0;
				    }
				} else {
				    *fancy = 1;
				    if (has_opengl) {
					*ifogl = 1;
				    } else {
					*ifogl = 0;
				    }
				}
				break;

			case BATCOL:
				tnkupd = 1;
				TogBut(&cbut[BATCOL]);
				if (*atcol) *atcol = 0;
				else *atcol = 1;
				break;

			case BSHADE:
				tnkupd = 1;
				TogBut(&cbut[BSHADE]);
				if (*shade) *shade = 0;
				else if (colcells >= 256) *shade = 1;
				break;

			case BPERSP:
				tnkupd = 1;
				TogBut(&cbut[BPERSP]);
				if (*persp) *persp = 0;
				else *persp = 1;
				break;
			default: 
				break;
		   }
		}
		break;

	case ButtonRelease:
		if (!((*fancy || *fullgl) && has_opengl) 
					&& event.xbutton.window == win) {
		   moving = 0;
		   gmoving = 0;
		   hold = 0;
		   holdt = 0; holdp = 0;
		}

		if (event.xbutton.window == win && 
			   (event.xbutton.button == 1 || 
			    event.xbutton.button == 2) && !ZoomSelection ) 
		   moving = 0;

		if (((*fancy || *fullgl) && has_opengl) && 
				event.xbutton.window == win) {
		   gmoving = 0;
		   moving = 0;
		   hold = 0;
		   holdt = 0; holdp = 0;
		   dispsf();
		}
		break;

	case MotionNotify:
		event.xmotion.window = win;
		motion_screen(&ctmp,&ptmp);
		break;

	case ConfigureNotify:
		if (event.xconfigure.window == win) {
		    width = event.xconfigure.width;
		    height = event.xconfigure.height;
		    if ((*fancy || *fullgl) && has_opengl) {
		    Reshape(0);
		    dispsf();
		    }
		}
		break;

	case Expose:
		if (event.xexpose.window == win) {
		   if ((*fancy || *fullgl) && has_opengl) {
			dispsf();
		   } else {
			if (molback == molcur) 
			   XCopyArea(display,molcur,win,gc,
					0,0,width,height,0,0);
		   }
		}
		if (event.xexpose.window == ZMEwin) RedrawZME();
		if (event.xexpose.window == SEQwin) RedrawSEQ();
              	if (event.xexpose.window == ATMwin) RedrawATM();
              	if (event.xexpose.window == MLTwin) RedrawList(&mltlist);
		if (event.xexpose.window == winMC)
				RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
		break;

	default: break;
	}
   }

   sigprocmask(SIG_UNBLOCK,&base_mask,NULL);
}

#if defined(VMS) || defined(UNDERSC)
void sysstr(str,nstr)
#else
#ifdef CRAY
void SYSSTR(str,nstr)
#else
void sysstr_(str,nstr)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;

{
	int i,ns;
	char cmdfil[MAXCMD];

        ns = *nstr;
        if (*nstr > MAXCMD ) ns = MAXCMD;
        for (i=0; i<MAXCMD; i++) cmdstr[i] = ' ';
	strcp(str,cmdstr,ns);
	cmdstr[ns] = '\0';

	system(cmdstr);
}

#if defined(VMS) || defined(UNDERSC)
void exstr(str,nstr,iopt)
#else
#ifdef CRAY
void EXSTR(str,nstr,iopt)
#else
void exstr_(str,nstr,iopt)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nstr;
int *iopt;

{
	int pid,i,ns;
        int ptmp,ctmp;
	char cmdfil[MAXCMD];
	char cmdfilh[MAXCMD];

	delcyclefile = 0;
        ns = *nstr;
        if (*nstr > MAXCMD ) ns = MAXCMD;
        for (i=0; i<MAXCMD; i++) cmdstr[i] = ' ';
	strcp(str,cmdstr,ns);
	cmdstr[ns] = '\0';

	switch(*iopt) {
	case 0:
	  system(cmdstr);
	  break;
	case 4:
	case 1:
#ifdef DARWIN
	  pid = fork();
#else
	  pid = vfork();
#endif
	  switch(pid) {
	  case -1:
		fprintf(stderr,"Couldnt Fork\n");
		break;
	  case 0:	/*child */
/* iopt is always 1 since this is case 1: so it will nver do doamb here ?*/
                if (*iopt == 1) {
		   execlp(cmdstr," ",(char *)0);
		} else {
		   doamb(cmdstr);
		}
		_exit(0);
		break;
	  default:	/*parent*/
		return;
		break;
	  }
	  break;

	case 5:
	case 3:
	case 2:

	  if (*iopt == 3 && ! *tnkbg) setlck(&ONE);

	  signal(SIGCHLD,handle_child);
#ifdef DARWIN
	  tnkpid = fork();
#else
	  tnkpid = vfork();
#endif
	  tnkfrk = 1;

	  switch(tnkpid) {
	  case -1:
		fprintf(stderr,"Couldnt Fork\n");
		break;
	  case 0:	/*child */
		tnkpid = getpid();
#ifndef VMS 
		setpgid(tnkpid,tnkpid);
#endif
	  	signal(SIGCHLD,SIG_DFL);
	  	signal(SIGALRM,SIG_DFL);

                if (*iopt == 2) {

		   sprintf(cmdfil,"./%s.run",cmdstr);
		   sprintf(cmdfilh,"%s.run",cmdstr);
		   execlp(cmdfil,cmdfilh,(char *) NULL);

		} else if (*iopt == 3) {

		   setenv("LD_LIBRARY_PATH",npth,1);
		   doamb(cmdstr);

		} else if (*iopt == 5) {
		   system(cmdstr);
		}
		_exit(0);
		break;
	  default:	/*parent*/
	  	pdone = 0;
	  	cycle = 1;
		fndfile = 1;
		escopt = 0;
		tnkesc = 0;
#ifdef HASTIMER
		hold = 0;
		holdt = 0; holdp = 0;
		update_model = 0;

		if (*iopt == 3) delcyclefile = 1;

		opttim = 1;
		icyco = 0;
	  	signal(SIGCHLD,handle_child);
		sigemptyset(&base_mask);
		sigaddset(&base_mask,SIGALRM);
		sigaddset(&base_mask,SIGCHLD);
   		Timer(TIMi,1);
	/*	delayt();*/
#endif

/* 
pdone = 1 means child is done or killed by users
fndfile = 1 means there is still a cycle file wich need to be read in
          and updated
The follwing while loop ends if pdone = 1 and fndfile = 0
*/

		while (!(pdone && !fndfile)) {
#ifdef HASTIMER
/* update the on screen structure  (just once)
   and the loop for holding a move direction
*/

		   if (hold || tnkupf || tnkupd || tnkesc) {
			 while (1){
			   XSync(display, False);
			   if (XCheckMaskEvent(display,
				ButtonReleaseMask, &event)) {
				hold = 0;
				holdt = 0; holdp = 0;
				moving = 0;
				gmoving = 0;
				break;
			   }

			   if (tnkesc) {
				esctnk();
			   } else {
				sigprocmask(SIG_BLOCK,&base_mask,NULL);
		   		if (tnkupf) {
				   update_tnk();
	/* set new alarm */
				   Timer(TIMi,1);
				   tnkupf = 0;
				   if ((*fancy || *fullgl) && has_opengl) 
					update_model = 1;
				}
				sigprocmask(SIG_UNBLOCK,&base_mask,NULL);
			   }

		   	   if (tnkupd || tnkesc) {
				if ((*fancy || *fullgl) && has_opengl) 
				update_model = 1;
				tnkupd = 0;
			   }

			   doclr();

#if defined(VMS) || defined(UNDERSC)
			   mktrn(&holdt,&holdp);
			   qupd();
#else
#ifdef CRAY
			   MKTRN(&holdt,&holdp);
			   QUPD();
#else
			   mktrn_(&holdt,&holdp);
			   qupd_();
#endif
#endif
			   update_model = 0;

			   if (!hold) break;

			   if (tnkesc) break;

			 }
		   }

		   if (tnkesc) break;

		   mloop(iopt);
#else
/* not hastimer */
                   handle_tnk();
#endif
		   if (tnkupd) {
		        update_model = 1;
			doclr();
#if defined(VMS) || defined(UNDERSC)
			mktrn(&holdt,&holdp);
			qupd();
#else
#ifdef CRAY
			MKTRN(&holdt,&holdp);
			QUPD();
#else
			mktrn_(&holdt,&holdp);
			qupd_();
#endif
#endif
		   }

		}
		/*fprintf(stderr,"End of process %d\n",tnkpid);*/
	  	signal(SIGCHLD,SIG_IGN);
	  	signal(SIGALRM,SIG_IGN);
		break;
	  }
	  break;
	}

	signal(SIGCHLD,SIG_DFL);
	signal(SIGALRM,SIG_IGN);

	esctnk();
	update_model = 1;
	doclr();

#if defined(VMS) || defined(UNDERSC)
	qupd();
#else
#ifdef CRAY
	QUPD();
#else
	qupd_();
#endif
#endif

	handle = 0;
	tnkfrk = 0;
}

#if defined(VMS) || defined(UNDERSC)
void tomap(imap,iambfor)
#else
#ifdef CRAY
void TOMAP(imap,iambfor)
#else
void tomap_(imap,iambfor)
#endif
#endif
int *imap;
int *iambfor;
{
  *imap = 1;
  *iambfor = 0;
  if (Progs == AmbProgs && *tnkprg == 1) *imap = 0;
  if (Progs == AmbProgs) *iambfor = 1;
}

int typchk(silent)
int silent;
{
   int i,j;

   j = 0;
   for ( i = 0; i < *xyzp->iatoms; i++ ) {
	   if (xyzp->ianz[i] < 99 &&  xyzp->ityp[i] == 0) {
		if (!silent) {
		   if (xyzp->iresid[i] > 0) {
			fprintf(stderr,"AtomNr. %d %s %s untyped\n",i+1,
			elements[xyzp->ianz[i]],
			AminoAcids[calfptr->iamino[xyzp->iresid[i]-1]-1]);
			fprintf(stderr,"Coordinates (Ang) %#9.3f,%#9.3f,%#9.3f\n",
			   xyzp->coo[i*3]*toangs,
			   xyzp->coo[i*3+1]*toangs,
			   xyzp->coo[i*3+2]*toangs);
		   } else if (xyzp->iresid[i] < -3) {
			fprintf(stderr,"AtomNr. %d %s %s untyped\n",i+1,
			elements[xyzp->ianz[i]],
			hetptr.HetAtm[ABS(xyzp->iresid[i])]);
			fprintf(stderr,"Coordinates (Ang) %#9.3f,%#9.3f,%#9.3f\n",
			   xyzp->coo[i*3]*toangs,
			   xyzp->coo[i*3+1]*toangs,
			   xyzp->coo[i*3+2]*toangs);
		   }
		}
		j++;
	   }

   }
   return(j);

}

int typit(ff,silent)
int ff;
int silent;
{
   int iretval,retype;
   char mess[64];

   iretval = 0;
   retype = 0; 

   if (*fftyp != ff) {
	*fftyp = ff;
	retype = 1;
   } else {
	if (typchk(silent)) retype = 1;
   }
   
   if (retype) {
#if defined(VMS) || defined(UNDERSC)
	dotyp(&cell->ichx);
#else
#ifdef CRAY
	DOTYP(&cell->ichx);
#else
	dotyp_(&cell->ichx);
#endif
#endif
	iretval = typchk(silent);

	if (ATMup) {
	   UpdateATM();
	   XMapRaised(display,ATMwin);
	   RedrawATM();
	}
	if (!silent) {
	   sprintf(mess,"(Re)typing %s",ForceFields[*fftyp]);
	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,mess,0)) {}
	}
   }
   return(iretval);
}

static int json = 0;

int WriteJSON(str)
char *str;
{
  FILE *f;
  int i;

  f = fopen(str,"w");

  if (f == NULL) {
	fprintf(stderr,"Error opening file %s\n",str);
 	return(0);
  }

  fprintf(f,"{\n");
  fprintf(f,"\t\"points\" :\n");
  fprintf(f,"\t[\n");

  for (i=0; i<pharm.NSelFeat; i++) {
	fprintf(f,"\t\t{\n");
	fprintf(f,"\t\t\t\"name\" : \"%s\",\n",
		FeatStr[pharm.array[pharm.index[i]].type]);
	fprintf(f,"\t\t\t\"radius\" : %f,\n",
		pharm.array[pharm.index[i]].rad*0.52917706);
	fprintf(f,"\t\t\t\"requirement\" : \"required\",\n");
	fprintf(f,"\t\t\t\"size\" : %d,\n",
		pharm.array[pharm.index[i]].size);
	fprintf(f,"\t\t\t\"vector_on\": 0,\n");
	fprintf(f,"\t\t\t\"vector\" :\n");
	fprintf(f,"\t\t\t[\n");
	if (pharm.array[pharm.index[i]].type <= 2) {
	   fprintf(f,"\t\t\t\t{\n");
	   fprintf(f,"\t\t\t\t\t\"x\" : %f,\n",
		pharm.array[pharm.index[i]].vec1[0]*0.52917706);
	   fprintf(f,"\t\t\t\t\t\"y\" : %f,\n",
		pharm.array[pharm.index[i]].vec1[1]*0.52917706);
	   fprintf(f,"\t\t\t\t\t\"z\" : %f\n",
		pharm.array[pharm.index[i]].vec1[2]*0.52917706);
	   fprintf(f,"\t\t\t\t}");
	   if (pharm.array[pharm.index[i]].type == 0) {	
		fprintf(f,",\n");
	   } else {
		fprintf(f,"\n");
	   }
	   
	   if (pharm.array[pharm.index[i]].type == 0) {	
		fprintf(f,"\t\t\t\t{\n");
		fprintf(f,"\t\t\t\t\t\"x\" : %f,\n",
		pharm.array[pharm.index[i]].vec2[0]*0.52917706);
		fprintf(f,"\t\t\t\t\t\"y\" : %f,\n",
		pharm.array[pharm.index[i]].vec2[1]*0.52917706);
		fprintf(f,"\t\t\t\t\t\"z\" : %f\n",
		pharm.array[pharm.index[i]].vec2[2]*0.52917706);
		fprintf(f,"\t\t\t\t}\n");
	   }
        }
	fprintf(f,"\t\t\t],\n");
	fprintf(f,"\t\t\t\"x\" : %f,\n",
		pharm.array[pharm.index[i]].cor[0]*0.52917706);
	fprintf(f,"\t\t\t\"y\" : %f,\n",
		pharm.array[pharm.index[i]].cor[1]*0.52917706);
	fprintf(f,"\t\t\t\"z\" : %f\n",
		pharm.array[pharm.index[i]].cor[2]*0.52917706);
	if (i == pharm.NSelFeat -1)  {
	   fprintf(f,"\t\t}\n");
	} else {
	   fprintf(f,"\t\t},\n");
	}
  }

  fprintf(f,"\t]\n");
  fprintf(f,"}\n");

  fclose(f);
}

int GetJson(str)
char *str;
{
  FILE *f;
  char strmax[1000];
  char *strtmp;
  int feat,i,next,isvec;

  if (json) return(0);

  json = 1;

  f = fopen(str,"r");
	
  if (f == NULL) {
	fprintf(stderr,"Error opening file %s\n",str);
 	return(0);
  }
  
  pharm.nfeat = 0;
  while (1) {
     if (fgets(strmax,1000,f) == NULL) break;
     if (strstr(strmax,"\"name\""))  pharm.nfeat++;
  }

  rewind(f);
  
  pharm.array = (PHARMSTRUC *) malloc(sizeof(PHARMSTRUC)*(pharm.nfeat));
  pharm.ixp   = (int *) malloc(sizeof(int)*(pharm.nfeat));
  pharm.iyp   = (int *) malloc(sizeof(int)*(pharm.nfeat));
  pharm.rzp   = (double *) malloc(sizeof(double)*(pharm.nfeat));
  pharm.index = (int *) malloc(sizeof(int)*(pharm.nfeat));
  pharm.str   = (char **) malloc(sizeof(char *)*(pharm.nfeat));
  pharm.NSelFeat = 0;

  feat = -1;

  for (i = 0; i < pharm.nfeat; i++) pharm.index[i] = -1;      

  while (1) {
     if (fgets(strmax,1000,f) == NULL) break;
     if (strstr(strmax,"\"name\"")) {
	feat++;
	
	pharm.array[feat].incl = 0;

	for (i = 0; i < 6; i++) {       
	   if (strstr(strmax,FeatStr[i])) {
		pharm.array[feat].type = i;
		break;
	   }
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"radius\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&pharm.array[feat].rad);
	   pharm.array[feat].rad = pharm.array[feat].rad / 0.52917706;
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"size\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%d",&pharm.array[feat].size);
	}

        next = 1;

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"vector\"")) {
	   isvec  = -1;
	   while (fgets(strmax,1000,f) != NULL) {
		if (strchr(strmax,']'))  break;
        	if (strstr(strmax,"\"x\"")) {
		   isvec++;
	   	   strtmp = strchr(strmax,':');
		   strtmp++;
		   if (isvec == 0) {
			sscanf(strtmp,"%f",&pharm.array[feat].vec1[0]);
			pharm.array[feat].vec1[0] = 
				pharm.array[feat].vec1[0] / 0.52917706;
		   } else {
			sscanf(strtmp,"%f",&pharm.array[feat].vec2[0]);
			pharm.array[feat].vec2[0] = 
				pharm.array[feat].vec2[0] / 0.52917706;
		   }
		}

        	if (strstr(strmax,"\"y\"")) {
	   	   strtmp = strchr(strmax,':');
		   strtmp++;
		   if (isvec == 0) {
			sscanf(strtmp,"%f",&pharm.array[feat].vec1[1]);
			pharm.array[feat].vec1[1] = 
				pharm.array[feat].vec1[1] / 0.52917706;
		   } else {
			sscanf(strtmp,"%f",&pharm.array[feat].vec2[1]);
			pharm.array[feat].vec2[1] = 
				pharm.array[feat].vec2[1] / 0.52917706;
		   }
		}

        	if (strstr(strmax,"\"z\"")) {
	   	   strtmp = strchr(strmax,':');
		   strtmp++;
		   if (isvec == 0) {
			sscanf(strtmp,"%f",&pharm.array[feat].vec1[2]);
			pharm.array[feat].vec1[2] = 
				pharm.array[feat].vec1[2] / 0.52917706;
		   } else {
			sscanf(strtmp,"%f",&pharm.array[feat].vec2[2]);
			pharm.array[feat].vec2[2] = 
				pharm.array[feat].vec2[2] / 0.52917706;
		   }
		}
	   }
	} else {
	   next = 0;
	}

        if (next ) {
	   if (fgets(strmax,1000,f) == NULL) break;
	}

        if (strstr(strmax,"\"x\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&pharm.array[feat].cor[0]);
	   pharm.array[feat].cor[0] = pharm.array[feat].cor[0] / 0.52917706 ;
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"y\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&pharm.array[feat].cor[1]);
	   pharm.array[feat].cor[1] = pharm.array[feat].cor[1] / 0.52917706 ;
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"z\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&pharm.array[feat].cor[2]);
	   pharm.array[feat].cor[2] = pharm.array[feat].cor[2] / 0.52917706 ;
	}
     }
  }

  fclose(f);

}

int GetJsonU(str)
char *str;
{
  FILE *f;
  char strmax[1000];
  char *strtmp;
  int feat,i,next,type;
  float x,y,z,rad,dx,dy,dz,tol;

  tol = 0.01;

  f = fopen(str,"r");
	
  if (f == NULL) {
	fprintf(stderr,"Error opening file %s\n",str);
 	return(0);
  }
  
  rewind(f);
  
  pharm.NSelFeat = 0;

  while (1) {
     if (fgets(strmax,1000,f) == NULL) break;
     if (strstr(strmax,"\"name\"")) {
	

	for (i = 0; i < 6; i++) {       
	   if (strstr(strmax,FeatStr[i])) {
		type = i;
		break;
	   }
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"radius\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&rad);
	   rad = rad / 0.52917706;
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"size\"")) {
	}

        next = 1;

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"vector_on\"")) {
	   if (fgets(strmax,1000,f) == NULL) break;
	}

        if (strstr(strmax,"\"vector\"")) {
	   while (fgets(strmax,1000,f) != NULL) {
		if (strchr(strmax,']'))  break;
	   }
	} else {
	   next = 0;
	}

        if (next ) {
	   if (fgets(strmax,1000,f) == NULL) break;
	}

        if (strstr(strmax,"\"x\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&x);
	   x = x / 0.52917706;
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"y\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&y);
	   y = y / 0.52917706;
	}

        if (fgets(strmax,1000,f) == NULL) break;
        if (strstr(strmax,"\"z\"")) {
	   strtmp = strchr(strmax,':');
	   strtmp++;
	   sscanf(strtmp,"%f",&z);
	   z = z / 0.52917706;
	}

	for (feat = 0; feat < pharm.nfeat; feat++) {       
	   dx = fabsf(x-pharm.array[feat].cor[0]);
	   dy = fabsf(y-pharm.array[feat].cor[1]);
	   dz = fabsf(z-pharm.array[feat].cor[2]);
	   if (dx < tol && dy < tol && dz < tol &&
	       pharm.array[feat].type == type) {

		pharm.NSelFeat++;
		pharm.index[pharm.NSelFeat-1] = feat;
		pharm.array[feat].incl = 1;
	        pharm.array[feat].rad = rad;

	        pharm.str[pharm.NSelFeat-1] = (char *) malloc(sizeof(char)*17);
	        strcpy(pharm.str[pharm.NSelFeat-1],FeatStr[type]);
	   }
	}

     }
  }

  fclose(f);

}

int getPharmer()
{
  char cmdfil[MAXSTRLEN];

  getob();

  strcpy(cmdfil,"/usr/local/bin/pharmer");
  if (access(cmdfil,X_OK) == 0 && !isdir(cmdfil)) {
	PHRMloc = 0;
	return(1);
  }

  sprintf(cmdfil,"%spharmer",exepath[0]);
  if (access(cmdfil,X_OK) == 0 && !isdir(cmdfil)) {
	return(1);
	PHRMloc = 1;
  }

  return(0);
}

char * mkjson()
{
  int n1,l;
  char *xstr1;
  char *last1;
  char *dot1;

  last1 = COO[istruct]->fname;
  l = strlen(last1);
  if (l > 512) return(NULL);
  xstr1 = (char *) malloc(sizeof(char)*(l+5));
  if (xstr1 == NULL) return(NULL);
  if (last1 != NULL) {
     dot1 = strrchr(last1,'.');
     if (dot1 != NULL) {
	n1 = (int) (dot1 - last1);
	strncpy(xstr1,last1,n1);
	xstr1[n1] = '\0';
	strcat(xstr1,".json");
     } else {
	return(NULL);
     }
  } else {
     return(NULL);
  }

  return(xstr1);
}

char * mkdb()
{
  int n1,l;
  char *xstr1;
  char *last1;
  char *dot1;

  l = strlen(qboxes[QSCSDF].str);
  if (l > 512) return(NULL);
  xstr1 = (char *) malloc(sizeof(char)*(l+5));
  if (xstr1 == NULL) return(NULL);
  strcpy(xstr1,qboxes[QSCSDF].str);
  last1 = xstr1;
  if (last1 != NULL) {
     dot1 = strrchr(last1,'.');
     if (dot1 != NULL) {
	n1 = (int) (dot1 - last1);
	xstr1[n1] = '\0';
	strcat(xstr1,".db");
     } else {
	return(NULL);
     }
  } else {
     return(NULL);
  }

  return(xstr1);
}

int FeatEditor()
{
  int n,n1,stat;
  char cmdfil[512];
  char cmdfil2[512];
  char xstr1[512];
  char fn[] = "/tmp/fileXXXXXX";
  char *last1;
  char *dot1;

  if (!has_opengl) {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"The pharmacophore editor is only available with gmolden.",0);
	return(0);
  }

  if (COO[istruct]->fname == NULL) {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"The pharmacophore editor is NOT available with \n files read from the commandline.",0);
	return(0);
  }

  if (getPharmer()) {
	strcpy(cmdfil,"/usr/local/lib/openbabel");
	strcpy(cmdfil2,"/usr/lib/openbabel");
	if ((!isdir(cmdfil) && !isdir(cmdfil2)) || OBloc == 1) {
	     if (getenv("BABEL_LIBDIR") == NULL) {
#if !defined(DARWIN)
		sprintf(cmdfil,"%s",exepath[0]);
		setenv("LD_LIBRARY_PATH",cmdfil,1);
		setenv("BABEL_LIBDIR",cmdfil,1);
		setenv("BABEL_DATADIR",cmdfil,1);
#else
		sprintf(cmdfil,"%s/data",exepath[0]);
		setenv("BABEL_DATADIR",cmdfil,1);
		sprintf(cmdfil,"%s/lib",exepath[0]);
		setenv("BABEL_LIBDIR",cmdfil,1);
#endif
	     }
	}


	stat = 1;
	last1 = rindex(COO[istruct]->fname,'/');
	sprintf(xstr1,"%s.json",mktemp(fn));

	if (stat) {
	   if (PHRMloc) {
		sprintf(cmdfil,
		"%spharmer pharma -in %s -out %s",exepath[0],
		COO[istruct]->fname,xstr1);
	   } else {
		sprintf(cmdfil,
		"/usr/local/bin/pharmer pharma -in %s -out %s",
		COO[istruct]->fname,xstr1);
	   }
	   n = strlen(cmdfil);
#if defined(VMS) || defined(UNDERSC)
	   exstr(cmdfil,&n,&ZERO);
#else
#ifdef CRAY
	   EXSTR(cmdfil,&n,&ZERO);
#else
	   exstr_(cmdfil,&n,&ZERO);
#endif
#endif
	   GetJson(xstr1);
	   return(1);

	} else {

	   return(0);
	}

  } else {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"Could NOT locate Pharmer.",0);
	return(0);
  }

}

void OpenPHRME()
{
    if (FeatEditor()) initPHRM();
}

int getob()
{
  char cmdfil[MAXSTRLEN];
  char cmdfil2[MAXSTRLEN];
  char resolved[MAXSTRLEN];
  char *ptr;

  realpath(exepath[0],resolved);
  sprintf(cmdfil,"%s/obabel",resolved);
  if (access(cmdfil,X_OK) == 0 && !isdir(cmdfil)) OBloc = 1;

  strcpy(cmdfil,"/usr/local/lib/openbabel");
  strcpy(cmdfil2,"/usr/lib/openbabel");
  if ((!isdir(cmdfil) && !isdir(cmdfil2)) || OBloc == 1) {
     if (getenv("BABEL_LIBDIR") == NULL) {
#if !defined(DARWIN)
	sprintf(cmdfil,"%s",exepath[0]);
	realpath(exepath[0],resolved);
	setenv("BABEL_LIBDIR",resolved,1);
	setenv("BABEL_DATADIR",resolved,1);
#else
	sprintf(cmdfil,"%s/data",exepath[0]);
	setenv("BABEL_DATADIR",cmdfil,1);
	sprintf(cmdfil,"%s/lib",exepath[0]);
	setenv("BABEL_LIBDIR",cmdfil,1);
#endif
     }
  }

  OBloc = -1;
  sprintf(cmdfil,"%sobabel",exepath[0]);
  if (access(cmdfil,X_OK) == 0 && !isdir(cmdfil)) {
	OBloc = 1;
	return(1);
  }

  strcpy(cmdfil,"/usr/local/bin/obabel");
  if (access(cmdfil,X_OK) == 0 && !isdir(cmdfil)) {
	OBloc = 0;
	return(1);
  }

  strcpy(cmdfil,"/usr/bin/obabel");
  if (access(cmdfil,X_OK) == 0 && !isdir(cmdfil)) {
	OBloc = 2;
	return(1);
  }

  fprintf(stderr,"Could NOT locate obabel executable !\n");

  return(0);
}

void killob()
{
  int n;
  char cmdfil[MAXSTRLEN];

  sprintf(cmdfil,"killall obabel");
  n = strlen(cmdfil);
  excmd(cmdfil,&n);
}

void obsrch(char *str)
{
  int n,nres;
  float tani;
  char cmdfil[MAXSTRLEN];
  char xstr1[MAXCMD];
  char *last1;
  char *dot1;
  int n1,stat;
  
  getob();

  tani = atof(qboxes[QNRES].str);

  stat = 1;
  last1 = COO[istruct]->fname;
  if (last1 != NULL) {
     dot1 = strrchr(last1,'.');
     if (dot1 != NULL) {
	n1 = (int) (dot1 - last1);
	strncpy(xstr1,last1,n1);
	xstr1[n1] = '\0';
	strcat(xstr1,".fs");
     } else {
	stat = 0;
     }
  } else {
     stat = 0;
  }


  if (stat) {
	if (OBloc == 1) {
	    sprintf(cmdfil,
		"%sobabel %s -O %s -s %s -at %f -xfFP3",exepath[0],
		xstr1,qboxes[QRESF].str,qboxes[QQUERY].str,tani);
	} else if (OBloc == 2) {
	    sprintf(cmdfil,
		"/usr/bin/obabel %s -O %s -s %s -at %f -xfFP3",
		xstr1,qboxes[QRESF].str,qboxes[QQUERY].str,tani);
	} else {
	    sprintf(cmdfil,
		"/usr/local/bin/obabel %s -O %s -s %s -at %f -xfFP3",
		xstr1,qboxes[QRESF].str,qboxes[QQUERY].str,tani);
	}
	n = strlen(cmdfil);
/*
fprintf(stderr,"obsrch: cmdfil %s\n",cmdfil);
*/
#if defined(VMS) || defined(UNDERSC)
	exstr(cmdfil,&n,&ZERO);
#else
#ifdef CRAY
	EXSTR(cmdfil,&n,&ZERO);
#else
	exstr_(cmdfil,&n,&ZERO);
#endif
#endif
  }
  return;
}

int obfp()
{
  int n;
  char cmdfil[MAXSTRLEN];

  getob();
  if (OBloc == 1) {
     sprintf(cmdfil,
	"%sobabel %s -ofs -xfFP3",exepath[0],COO[istruct]->fname);
  } else if (OBloc == 2) {
     sprintf(cmdfil,
	"/usr/bin/obabel %s -ofs -xfFP3",COO[istruct]->fname);
  } else {
     sprintf(cmdfil,
	"/usr/local/bin/obabel %s -ofs -xfFP3",COO[istruct]->fname);
  }
  n = strlen(cmdfil);
#if defined(VMS) || defined(UNDERSC)
  exstr(cmdfil,&n,&ZERO);
#else
#ifdef CRAY
  EXSTR(cmdfil,&n,&ZERO);
#else
  exstr_(cmdfil,&n,&ZERO);
#endif
#endif
  return(0);
}

#include <libgen.h>
void getstemp(char *stemp)
{
	char *last1;
	int n1;

	if (!FLDS.editted) {

		strcpy(stemp,basename(COO[istruct]->fname));
		last1 = strrchr(stemp,'.');

		if (last1 != NULL) {
		   n1 = last1 - stemp;
		   stemp[n1] = '\0';
		}
	} else {

		last1 = strstr(qboxes[QSDFO].str,"_logact");

		if (last1 == NULL) {
		   strcpy(stemp,qboxes[QSDFO].str);
		} else {
		   n1 = last1 - qboxes[QSDFO].str;
		   strncpy(stemp,qboxes[QSDFO].str,n1);
		   stemp[n1] = '\0';
		}
	}

}

void savsdf(char *str)
{
  
  ParseFields(&COO[istruct]->memfil);
  getstemp(stemp);

  strcat(stemp,".sdf");

  if (strstr(COO[istruct]->fname,".sdf")) {
	wrtfilmem(stemp,&COO[istruct]->memfil);
  } else if (strstr(COO[istruct]->fname,".mol2")) {
	WrtSDFs(stemp,&COO[istruct]->memfil);
  }
  wrsvgs(stemp);

  return;
}

void savmol2(char *str)
{
  
  ParseFields(&COO[istruct]->memfil);
  getstemp(stemp);

  strcat(stemp,".mol2");
  if (strstr(COO[istruct]->fname,".sdf")) {
	WrtMol2s(stemp,&COO[istruct]->memfil);
  } else if (strstr(COO[istruct]->fname,".mol2")) {
	wrtfilmem(stemp,&COO[istruct]->memfil);
  }
  wrsvgs(stemp);

  return;
}

#define NUMCOL 16

static int PopUpNum, PopUpEntryH, PopUpHeight, PopUpWidth, PopUpChunk, PopUpCLow;
static int PopUpMaxNum = 20;

int DoPopUp(ParentWin,x,y,List,iopt,icent)
Window ParentWin;
int *iopt;
LSSTRU *List;
int x,y,icent;
{
  int done, inew, iold, ifrst, i, wit, wi, xt, ioptt;

  ioptt = *iopt;

  if (List == NULL) {
	PopUpNum = NUMCOL;
	PopUpEntryH = 14;
	PopUpWidth = 100;
	PopUpChunk = -1;
  } else {
	PopUpChunk = -1;
	PopUpNum = List->nents;
	if (PopUpNum > PopUpMaxNum) {
	   PopUpChunk = 0;
	   PopUpCLow = PopUpChunk*PopUpMaxNum;
	   PopUpNum = PopUpMaxNum;
	   if ((PopUpChunk+1)*PopUpMaxNum > List->nents) 
		PopUpNum = List->nents - PopUpCLow;
	} else {
	   PopUpCLow = 0;
	}
	PopUpEntryH = LINEHIGH;
	wi = 0;
	for (i=0; i<PopUpNum; i++) {
	    if (List->list[i] != NULL) {
		wit = XTextWidth(mfinfo,List->list[i],strlen(List->list[i]));
	    } else {
		wit  = 0;
	    }
	    if (wit > wi) wi = wit;
	}
	PopUpWidth = wi + 2*SPACING;
  }

  PopUpHeight = PopUpNum*PopUpEntryH;
  if (PopUpChunk != -1) PopUpHeight = (PopUpNum+1)*PopUpEntryH;
  
  if (!PopUpHeight || !PopUpWidth) return 0;

  PopUp = CreateWindow("Molden Color Box",DEFQBOXGEOM,PopUpWidth,PopUpHeight,
                            colors[0],colors[190],ParentWin);

  XSelectInput(display, PopUp, 
  ( ExposureMask | ButtonPressMask | PointerMotionMask | VisibilityChangeMask));
  
  xt = x;
  if (icent) {
	xt = x - PopUpWidth/2;
	if (xt < 0) xt = 0;
  }
  XMoveResizeWindow(display, PopUp, xt, y, PopUpWidth, PopUpHeight);

  XSetFunction(display, gc, GXcopy);
  XSetPlaneMask(display, gc, colors[0] ^ colors[190]);
  XSetForeground(display, gc, colors[0]);
  XSetBackground(display, gc, colors[190]);

#ifdef DOGL
  if ( (*fancy || *fullgl) && has_opengl && !StarNetOld) {
	dispsf();
	glXWaitGL();
  }
#endif

  XMapRaised(display,PopUp);

  XWindowEvent(display, PopUp, VisibilityChangeMask, &event);

  XFlush(display);

  iold = -1;
  ifrst = 1;
  done = 0;
  while (!done) {

    if (XPending(display)>0) {
      XNextEvent(display, &event);
      
      switch (event.type) {
      case Expose: {

	if (event.xexpose.window == PopUp) {
            RedrawPopUp(List);
	}
      }
      break;

      case ButtonPress: {
        if (event.xbutton.window == PopUp) {
           *iopt = (event.xbutton.y*PopUpNum) / PopUpHeight;
	   if (PopUpChunk != -1) {
		*iopt = event.xbutton.y / PopUpEntryH;
		if (*iopt >= PopUpNum) {
		    PopUpChunk = PopUpChunk + 1;
		    if (PopUpChunk*PopUpMaxNum > List->nents) PopUpChunk = 0;
		    PopUpCLow = PopUpChunk*PopUpMaxNum;
		    PopUpNum = PopUpMaxNum;
		    if ((PopUpChunk+1)*PopUpMaxNum > List->nents) 
			PopUpNum = List->nents - PopUpCLow;
		    iold = -1;
		    RedrawPopUp(List);
		} else {
		    *iopt = *iopt + PopUpChunk*PopUpMaxNum;
		    if (List != NULL) if (*iopt >= List->nents) 
			*iopt = List->nents - 1;
		    done = 1;
		}
	   } else {
		done = 1;
	   }
        } else {
           done = 1;
           *iopt = ioptt;
	   XSetFunction(display, gc, GXcopy);
	   XSetPlaneMask(display, gc, (unsigned long) ~0L);
	   XDestroyWindow(display,PopUp);

	   return -1;
	}
      }
      break;

      case MotionNotify: {
        if (event.xmotion.window == PopUp) {
           inew = (event.xmotion.y*PopUpNum) / PopUpHeight;
	   if (PopUpChunk != -1) inew = 
		(event.xmotion.y*(PopUpNum+1)) / ((PopUpNum+1)*PopUpEntryH);
           if (inew != iold) {
		if (List == NULL) {
		    XSetForeground(display, gc, colors[1+iold]);
		    XDrawRectangle(display, PopUp, gc, 0,
		     (iold * PopUpHeight)/PopUpNum, PopUpWidth,PopUpEntryH);
		    XSetForeground(display, gc, colors[0]);
		    XDrawRectangle(display, PopUp, gc, 0,
		    (inew * PopUpHeight)/PopUpNum, PopUpWidth,PopUpEntryH);
		} else {
		    XSetFunction(display, gc, GXinvert);
		    XSetPlaneMask(display, gc, colors[190] ^ colors[0]);
		    if (!ifrst) {
		        XFillRectangle(display, PopUp, gc, 0,
		         iold * PopUpEntryH, PopUpWidth,PopUpEntryH);
		    } else ifrst = 0;
		    XFillRectangle(display, PopUp, gc, 0,
		     inew * PopUpEntryH, PopUpWidth,PopUpEntryH);
		    XSetFunction(display, gc, GXcopy);
		    XSetPlaneMask(display, gc, (unsigned long) ~0L);
		}
		iold = inew;
           }
        }
      }
      break;

      default: break;

      } /* end switch */
     }/* end if XPending*/
   } /*end while */

   XSetFunction(display, gc, GXcopy);
   XSetPlaneMask(display, gc, (unsigned long) ~0L);
   XDestroyWindow(display,PopUp);

#ifdef DOGL
   if ( (*fancy || *fullgl) && has_opengl && !StarNetOld) {
	dispsf();
	glXWaitGL();
   }
#endif

   return 0;
}

void RedrawPopUp(List)
LSSTRU *List;
{
      int i;

  if (List == NULL) {
      XSetFunction(display, gc, GXcopy);
      XSetPlaneMask(display, gc, (unsigned long) ~0L);
      for (i=0; i < PopUpNum; i++) {
          XSetForeground(display, gc, colors[i]);
          XFillRectangle(display, PopUp, gc, 0,
               (i * PopUpHeight)/PopUpNum, PopUpWidth,PopUpEntryH);
      }
  }
  else {
      XSetForeground(display, gc, colors[190]);
      XFillRectangle(display, PopUp, gc, 0,0,
		          PopUpWidth,PopUpHeight);
      XSetFunction(display, gc, GXcopy);
      XSetPlaneMask(display, gc, colors[0] ^ colors[190]);
      for (i=0; i < PopUpNum; i++) {
          XSetForeground(display, gc, colors[190]);
          XFillRectangle(display, PopUp, gc, 0,
		         i * PopUpEntryH, PopUpWidth,PopUpEntryH);
          XSetForeground(display, gc, colors[0]);
	  LineString(PopUp,List->list[i+PopUpCLow],SPACING,ASCENT + i*PopUpEntryH);
      }
      if (PopUpChunk != -1) {
          XSetForeground(display, gc, colors[190]);
          XFillRectangle(display, PopUp, gc, 0,
		         PopUpNum * PopUpEntryH, PopUpWidth,PopUpEntryH);
          XSetForeground(display, gc, colors[0]);
	  if (PopUpCLow+PopUpNum == List->nents) 
	    LineString(PopUp,"<- To top",SPACING,ASCENT + PopUpNum*PopUpEntryH);
	  else 
	    LineString(PopUp,"More ...",SPACING,ASCENT + PopUpNum*PopUpEntryH);
      }
  }
}

#define POPSPACE 8
int DoCan(x,y,strval,docan)
int x,y;
char *strval;
int docan;
{
  int done,wit,hit,bw,xp,retval,nb,nlines,wittmp,ql;
  char wgeom[64];
  char *p, *q;

  retval = 0;
  nb = 1;
  if (docan) nb = 2;

  nlines = 0;
  p = strval;
  q = strval;
  wit = 0;
  while ((p = strchr(q, '\n'))) {
     ql = (int) (p-q);
     wittmp = XTextWidth(mfinfo,q,ql) + 2*POPSPACE;
     if (wittmp > wit) wit = wittmp;
     p++;
     q = p;
     nlines++;
  }
  ql = strlen(q);
  wittmp = XTextWidth(mfinfo,q,ql) + 2*POPSPACE;
  if (wittmp > wit) wit = wittmp;
  nlines++;

  hit = POPSPACE + LINEHIGH*nlines + POPSPACE + BUTTH + POPSPACE;
  

  sprintf(wgeom,"+%d+%d",x-wit/2,y-hit/2);

  PopOk = CreateWindow("Molden OK Box",wgeom,wit,hit,
                            infobg,colors[190],(Window)0);

  XSelectInput(display, PopOk, 
  ( ExposureMask | ButtonPressMask | VisibilityChangeMask ));
  
  XMoveResizeWindow(display, PopOk, x-wit/2, y-hit/2, wit, hit);

  XMapRaised(display,PopOk);

  XWindowEvent(display, PopOk, VisibilityChangeMask, &event);

  XFlush(display);

  if (docan) {
	bw = (wit - 4*POPSPACE) / 2;
	DefBut(&obut[0],  PopOk, POPSPACE, nlines*LINEHIGH + 2*POPSPACE, 
		bw, BUTTH, "OK", infobg, 0);
	DefBut(&obut[1],  PopOk, bw + 3*POPSPACE, nlines*LINEHIGH + 2*POPSPACE, 
		bw, BUTTH, "Cancel", infobg, 0);
  } else {
	bw = 40;
	xp = wit / 2 - bw / 2;
	DefBut(&obut[0],  PopOk, xp, nlines*LINEHIGH + 2*POPSPACE, 
		bw, BUTTH, "OK", infobg, 0);
  }

  done = 0;
  while (!done) {

    if (XPending(display)>0) {
      XNextEvent(display, &event);
      
      switch (event.type) {
      case Expose: {

	if (event.xexpose.window == PopOk) {
	   nlines = 0;
	   p = strval;
	   q = strval;
	   while ((p = strchr(q, '\n'))) {
		ql = (int) (p-q);
	        XDrawString(display, PopOk, gc, 
			POPSPACE, CHIGH+nlines*LINEHIGH+POPSPACE, q, ql);
		p++;
		q = p;
		nlines++;
	   }
	   ql = strlen(q);
	   XDrawString(display, PopOk, gc, 
			POPSPACE, CHIGH+nlines*LINEHIGH+POPSPACE, q, ql);
	   DrwBut(&obut[0]);
	   if (docan) DrwBut(&obut[1]);
	}
	if (event.xexpose.window == STRwin && STRup) RedrawSTR();
	if (event.xexpose.window == win) {
#ifndef DOGL
	   if (molback == molcur)
                    XCopyArea(display,molcur,win,gc,0,0,width,height,0,0);
#endif
	}
      }
      break;

      case ButtonPress: {
        if (event.xbutton.window == PopOk) {
	   if (Clickwin(obut,nb,event.xbutton.x, event.xbutton.y,1) == 1) 
		retval = 1;
           done = 1;
	} else {
	   DirBox(PopOk,1);
        }
      }
      break;

      default: break;

      } /* end switch */
     }/* end if XPending*/
   } /*end while */

   XDestroyWindow(display,PopOk);
   XSync(display, False);
   return(retval);
}

#if defined(VMS) || defined(UNDERSC)
void confrm(iop,istat)
#else
#ifdef CRAY
void CONFRM(iop,istat)
#else
void confrm_(iop,istat)
#endif
#endif

int *iop;
int *istat;
{
   char statstr[200];

   if (!xison) return;

   switch (*iop) {
	case 0: 
		strcpy(statstr,"Setup completed, click OK to optimise. \n\n Hit esc to abort calculation.");
		break;
	case 1: 
		strcpy(statstr,"Found mutiple structure XDATCAR file, \n click OK to use this in conjuction with POSCAR/CONTCAR file");
		break;
   }

   *istat = 1;
   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
	statstr,1)) {
	*istat = 0;
   }
   if (*iop == 0) RedrawZME();
}

#if defined(VMS) || defined(UNDERSC)
void plsph3(xori,yori,diameter,ia,ioffs,icfac)
#else
#ifdef CRAY
void PLSPH3(xori,yori,diameter,ia,ioffs,icfac)
#else
void plsph3_(xori,yori,diameter,ia,ioffs,icfac)
#endif
#endif

int *xori;
int *yori;
int *diameter;
int *ia;
int *ioffs;
int *icfac;
{
  int xc,yc,xce,yce;
  int thetad,coli,oldcol;
  double tcos,tsin;
  unsigned int wi,hi,wold,wtmp,whlf;

/*
   xori,yori = x,y of center of sphere
   diameter  = diameter of sphere
   ia        = flag for green circle around sphere (z-mat)
   ioffs     = offset in color array for atom color
   icfac     = range of shades possible
*/

  xc = *xori - *diameter/2;
  yc = *yori - *diameter/2;
  xce = *xori + *diameter/2;
  yce = *yori + *diameter/2;

  if (xce < 0 && yce < 0) return;
  if (xc > (int) width && yc > (int) height) return;

  oldcol = -1; wold = 30000;
  for ( thetad=90; thetad > 0; thetad-- ) {
     tcos = Tcos[thetad];  tsin = Tsin[thetad];
     wi = (unsigned int) (*diameter * tsin + 0.5);
     coli = (int)( *ioffs + tcos * (*icfac) + 0.5);
     if (coli != oldcol) {

        if (wold < 30000) {
           whlf = (wold + wi) / 2;
           XSetForeground(display, gc, colors[coli]);
           XSetBackground(display, gc, colors[oldcol]);
           XSetFillStyle(display,gc,FillOpaqueStippled);

           wtmp = (wold + whlf) / 2;
           xc = *xori - wtmp / 2;
           yc = *yori - wtmp / 2;
           XSetStipple(display,gc,qwgrey);
           XFillArc(display, molcur, gc, xc,yc, wtmp, wtmp, 0,360*64);

           xc = *xori - whlf / 2;
           yc = *yori - whlf / 2;
           XSetStipple(display,gc,stipple);
           XFillArc(display, molcur, gc, xc,yc, whlf, whlf, 0,360*64);

           wtmp = (wi + whlf) / 2;
           xc = *xori - wtmp / 2;
           yc = *yori - wtmp / 2;
           XSetStipple(display,gc,tqwgrey);
           XFillArc(display, molcur, gc, xc,yc, wtmp, wtmp, 0,360*64);

           XSetFillStyle(display,gc,FillSolid);
        }

        xc = *xori - wi / 2;
        yc = *yori - wi / 2;
        XSetBackground(display, gc, BlackPixel(display,screen));
        XSetForeground(display, gc, colors[coli]);
        XFillArc(display, molcur, gc, xc,yc, wi, wi, 0,360*64);

        oldcol = coli; wold = wi;
     }
  }

/* if atoms select for Z-matrix, draw green circle around it */

  xc = *xori - *diameter / 2;
  yc = *yori - *diameter / 2;
  
  if (*ia >= 2 && (ZMEup || ATMup) ) {
     wi = (unsigned int) *diameter;
     hi = wi;
     XSetForeground(display, gc, colors[rimcols[*ia]]);
     XDrawArc(display, molcur, gc, xc,yc, wi, hi, 0,360*64);
  }
}

void plrod(int xori,int yori,int rada,int radb,int radc,int rodl,float cosa,float sina);

#if defined(VMS) || defined(UNDERSC)
void plrod3(xori,yori,diameter1,diameter2,diameter3,rodlen,ioffs,icfac,cosa,sina)
#else
#ifdef CRAY
void PLROD3(xori,yori,diameter1,diameter2,diameter3,rodlen,ioffs,icfac,cosa,sina)
#else
void plrod3_(xori,yori,diameter1,diameter2,diameter3,rodlen,ioffs,icfac,cosa,sina)
#endif
#endif

int *xori;
int *yori;
int *diameter1;
int *diameter2;
int *diameter3;
int *rodlen;
int *icfac;
int *ioffs;
float *cosa;
float *sina;
{
  int xc,yc;
  int thetad,coli,oldcol;
  double x,y,x1,y1,x2,y2,x3,y3;
  double tcos,tsin;
  unsigned int wi1,wi2,wi3,wold1,wtmp1,whlf1,wold3,wtmp3,whlf3;
  float Cosa,Sina;
  int rodl;
  int is;

/*
   xori,yori = x,y of center of sphere
   diameter  = diameter of sphere
   ia        = flag for green circle around sphere (z-mat)
   ioffs     = offset in color array for atom color
   icfac     = range of shades possible
*/

  is = 0;
  x1 = (double) *xori; y1 = (double) *yori;
  x = (double) 0; y = (double) -*rodlen;
  x2 = *xori + (*cosa*x - *sina*y);
  y2 = *yori + (*sina*x + *cosa*y);
  x3 = (x1 + x2) / 2.0;
  y3 = (y1 + y2) / 2.0;

  if ((x1 >= 0 && x1 <= (double) width) && 
	(y1 >= 0 && y1 <= (double) height)) is++;
  if ((x2 >= 0 && x2 <= (double) width) && 
	(y2 >= 0 && y2 <= (double) height)) is++;
  if ((x3 >= 0 && x3 <= (double) width) && 
	(y3 >= 0 && y3 <= (double) height)) is++;

  if (!is) return;

  Cosa = *cosa; Sina = *sina ; rodl = *rodlen;
  xc = *xori; yc = *yori;
  oldcol = -1; wold1 = 30000;
  for ( thetad=90; thetad > 0; thetad-- ) {
     tcos = Tcos[thetad];  tsin = Tsin[thetad];
     wi1 = (unsigned int) (*diameter1 * tsin + 0.5);
     wi2 = (unsigned int) (*diameter2 + 0.5);
     wi3 = (unsigned int) (*diameter3 * tsin + 0.5);
     coli = (int)( *ioffs + tcos * (*icfac) + 0.5);
     if (coli != oldcol) {

        if (wold1 < 30000) {
           whlf1 = (wold1 + wi1) / 2;
           whlf3 = (wold3 + wi3) / 2;
           XSetForeground(display, gc, colors[coli]);
           XSetBackground(display, gc, colors[oldcol]);
           XSetFillStyle(display,gc,FillOpaqueStippled);

           wtmp1 = (wold1 + whlf1) / 2;
           wtmp3 = (wold3 + whlf3) / 2;
           XSetStipple(display,gc,qwgrey);
	   plrod(xc,yc,wtmp1,wi2,wtmp3,rodl,Cosa,Sina);

           XSetStipple(display,gc,stipple);
	   plrod(xc,yc,whlf1,wi2,whlf3,rodl,Cosa,Sina);

           wtmp1 = (wi1 + whlf1) / 2;
           wtmp3 = (wi3 + whlf3) / 2;
           XSetStipple(display,gc,tqwgrey);
	   plrod(xc,yc,wtmp1,wi2,wtmp3,rodl,Cosa,Sina);

           XSetFillStyle(display,gc,FillSolid);
        }

        XSetBackground(display, gc, BlackPixel(display,screen));
        XSetForeground(display, gc, colors[coli]);
	plrod(xc,yc,wi1,wi2,wi3,rodl,Cosa,Sina);

        oldcol = coli; wold1 = wi1; wold3 = wi3; 
     }
  }
}


void plellps(xori,yori,rada,radb,alpha)
int xori;
int yori; 
int rada; 
int radb; 
float alpha; 
{
	int beta;
	double x,y;
	XPoint points[400];
	int npoints;
	double C,S;
/*
   xori,yori = x,y of center of ellips
   rada      = first axis radius
   radb      = second axis radius
   alpha     = rotation angle of ellips

   Let beta run from 0 to 360 degrees:

   x = rada*cos(beta)
   y = radb*sin(beta)

   Then rotation over alpha degrees and translation

   X = xori + (cos(alpha)*x - sin(alpha)*y)
   Y = yori + (sin(alpha)*x + cos(alpha)*y)
*/
	C = cos(alpha);
	S = sin(alpha);
	for (beta=0; beta <= 360; beta++)
	{
		x = rada*Tcos[beta];
		y = radb*Tsin[beta];
		points[beta].x = xori + (C*x - S*y);
		points[beta].y = yori + (S*x + C*y);
	}
	npoints = 361;
	XFillPolygon(display,molcur,gc,points,npoints,Convex,CoordModeOrigin);
}

void plrod(int xori,int yori,int rada,int radb,int radc,int rodl,
		float cosa,float sina)
{
	int beta;
	double x,y;
	XPoint points[400];
	int npoints;
	int binc;
/*
   xori,yori = x,y of center of ellips on top of rod
   rada      = first axis radius
   radb      = second axis up radius
   radc      = second axis down radius
   rodl      = rod length
   alpha     = rotation angle of rod

   Let beta run from 0 to 360 degrees:

   x = rada*cos(beta)
   y = radb*sin(beta)

   Then rotation over alpha degrees and translation

   X = xori + (cos(alpha)*x - sin(alpha)*y)
   Y = yori + (sin(alpha)*x + cos(alpha)*y)
*/
	npoints = 0;

	if (rada) {
		binc = 180/rada; if (!binc) binc = 1;
	}
	else binc = 1;
	x = radc; y = -rodl;
	points[0].x = xori + (cosa*x - sina*y);
	points[0].y = yori + (sina*x + cosa*y);
	for (beta=0; beta <= 180; beta = beta + binc)
	{
		npoints++;
		x = rada*Tcos[beta];
		y = radb*Tsin[beta];
		points[npoints].x = xori + (cosa*x - sina*y);
		points[npoints].y = yori + (sina*x + cosa*y);
	}
	npoints++;
	x = -radc; y = -rodl;
	points[npoints].x = xori + (cosa*x - sina*y);
	points[npoints].y = yori + (sina*x + cosa*y);
	npoints++;
	XFillPolygon(display,molcur,gc,points,npoints,Convex,CoordModeOrigin);
}

#if defined(VMS) || defined(UNDERSC)
void plrodx(xori,yori,rada,radb,radc,rodlen,ioffs,cosa,sina)
#else
#ifdef CRAY
void PLRODX(xori,yori,rada,radb,radc,rodlen,ioffs,cosa,sina)
#else
void plrodx_(xori,yori,rada,radb,radc,rodlen,ioffs,cosa,sina)
#endif
#endif

int *xori;
int *yori;
int *rada;
int *radb;
int *radc;
int *rodlen;
int *ioffs;
float *cosa;
float *sina;
{
  int rodl;
  int beta;
  int is;
  double x,y,x1,y1,x2,y2,x3,y3;
  XPoint points[400];
  int npoints;
  int binc;

/*
   xori,yori = x,y of center of sphere
   diameter  = diameter of sphere
   ia        = flag for green circle around sphere (z-mat)
   ioffs     = offset in color array for atom color
*/

  rodl = *rodlen;

  XSetForeground(display, gc, colors[*ioffs]);

  npoints = 0;

  if (*rada) {
	binc = 180/(*rada); if (!binc) binc = 1;
  }
  else binc = 1;

  is = 0;
  x1 = (double) *xori; y1 = (double) *yori;
  x = (double) 0; y = (double) -rodl;
  x2 = *xori + (*cosa*x - *sina*y);
  y2 = *yori + (*sina*x + *cosa*y);
  x3 = (x1 + x2) / 2.0;
  y3 = (y1 + y2) / 2.0;

  if ((x1 >= 0 && x1 <= (double) width) && 
	(y1 >= 0 && y1 <= (double) height)) is++;
  if ((x2 >= 0 && x2 <= (double) width) && 
	(y2 >= 0 && y2 <= (double) height)) is++;
  if ((x3 >= 0 && x3 <= (double) width) && 
	(y3 >= 0 && y3 <= (double) height)) is++;

  if (!is) return;

  x = *radc; y = -rodl;
  points[0].x = *xori + (*cosa*x - *sina*y);
  points[0].y = *yori + (*sina*x + *cosa*y);
  for (beta=0; beta <= 180; beta = beta + binc)
  {
	npoints++;
	x = *rada*Tcos[beta];
	y = *radb*Tsin[beta];
	points[npoints].x = *xori + (*cosa*x - *sina*y);
	points[npoints].y = *yori + (*sina*x + *cosa*y);
  }
  npoints++;
  x = -(*radc); y = -rodl;
  points[npoints].x = *xori + (*cosa*x - *sina*y);
  points[npoints].y = *yori + (*sina*x + *cosa*y);
  npoints++;
  XFillPolygon(display,molcur,gc,points,npoints,Convex,CoordModeOrigin);

  XSetBackground(display, gc, BlackPixel(display,screen));
  XSetFillStyle(display,gc,FillOpaqueStippled);
  XSetStipple(display,gc,stipple);

  npoints = 0;
  if (*cosa < 0) { 
    x = *radc; y = -rodl;
    points[0].x = *xori + (*cosa*x - *sina*y);
    points[0].y = *yori + (*sina*x + *cosa*y);
    for (beta=0; beta <= 90; beta = beta + binc)
    {
	   npoints++;
	   x = *rada*Tcos[beta];
	   y = *radb*Tsin[beta];
	   points[npoints].x = *xori + (*cosa*x - *sina*y);
	   points[npoints].y = *yori + (*sina*x + *cosa*y);
    }
    npoints++;
    x = 0; y = -rodl;
    points[npoints].x = *xori + (*cosa*x - *sina*y);
    points[npoints].y = *yori + (*sina*x + *cosa*y);
    npoints++;
    XFillPolygon(display,molcur,gc,points,npoints,Convex,CoordModeOrigin);
  }
  else {
    x = -(*radc); y = -rodl;
    points[0].x = *xori + (*cosa*x - *sina*y);
    points[0].y = *yori + (*sina*x + *cosa*y);
    for (beta=180; beta >= 90; beta = beta - binc)
    {
	   npoints++;
	   x = *rada*Tcos[beta];
	   y = *radb*Tsin[beta];
	   points[npoints].x = *xori + (*cosa*x - *sina*y);
	   points[npoints].y = *yori + (*sina*x + *cosa*y);
    }
    npoints++;
    x = 0; y = -rodl;
    points[npoints].x = *xori + (*cosa*x - *sina*y);
    points[npoints].y = *yori + (*sina*x + *cosa*y);
    npoints++;
    XFillPolygon(display,molcur,gc,points,npoints,Convex,CoordModeOrigin);
  }
  XSetFillStyle(display,gc,FillSolid);

  npoints = 0;
  x = (*radc)/2; y = -rodl;
  points[0].x = *xori + (*cosa*x - *sina*y);
  points[0].y = *yori + (*sina*x + *cosa*y);
  for (beta=0; beta <= 180; beta = beta + binc)
  {
	npoints++;
	x = (*rada)*Tcos[beta]/2;
	y = *radb*Tsin[beta];
	points[npoints].x = *xori + (*cosa*x - *sina*y);
	points[npoints].y = *yori + (*sina*x + *cosa*y);
  }
  npoints++;
  x = -(*radc)/2; y = -rodl;
  points[npoints].x = *xori + (*cosa*x - *sina*y);
  points[npoints].y = *yori + (*sina*x + *cosa*y);
  npoints++;
  XFillPolygon(display,molcur,gc,points,npoints,Convex,CoordModeOrigin);
}

#ifdef HASTIMER


void Timer(msec,timopt)   /* waits for 'n' milliseconds */
 int  msec;
 int timopt;
{
#ifdef VMS
  float ftime;
  ftime = msec / 1000.0;
  lib$wait(&ftime);

#else

  long usec;

  if (handle == 1 && (timopt == 0 || timopt == 2 || timopt == 3)) return;
  if (bcksvg.UpSVG && (timopt == 0 || timopt == 2)) return;
  if (msec <= 0) return;
  usec = (long) msec * 1000;

  it[timopt].it_value.tv_sec = 0L;
  it[timopt].it_value.tv_usec = 0L;
  it[timopt].it_interval.tv_sec = 0L;
  it[timopt].it_interval.tv_usec = 0L;

  if (usec>=1000000L) {  
    it[timopt].it_value.tv_sec = usec / 1000000L;
    usec %= 1000000L;
  }

  it[timopt].it_value.tv_usec = usec;
  tdone = 0;
  handle = timopt;
  if (timopt == 3) {
     signal(SIGALRM,handle_svgfile);
  } else if (timopt == 2) {
     signal(SIGALRM,handle_explalarm);
  } else if (timopt == 1) {
     if (!escopt) {
	signal(SIGALRM,handle_tnk);
     } else {
	signal(SIGALRM,handle_tnkesc);
     }
  } else signal(SIGALRM,handle_alarm);
  setitimer(ITIMER_REAL, &it[timopt], NULL);
  if (!timopt) pause();
#endif 
}
#endif

#if defined(VMS) || defined(UNDERSC)
void parpoi(
#else
#ifdef CRAY
void PARPOI(
#else
void parpoi_(
#endif
#endif
	nzm,nso,nio,nzo,ioropt,ifor,ixyz98,iopr,isymm,irc,
	imp2,icntp,msucc,ioni,mopopt,isbin,irtype,
	ipdbgro,ifav,ioxyz,iconv,ircus,nscnd,iscst,ialtyp)

int *nzm;
int *nso;
int *nio;
int *nzo;
int *ioropt;
int *ifor;
int *ixyz98;
int *iopr;
int *isymm;
int *irc;
int *imp2;
int *icntp;
int *msucc;
int *ioni;
int *mopopt;
int *isbin;
int *irtype;
int *ipdbgro;
int *ifav;
int *ioxyz;
int *iconv;
int *ircus;
int *nscnd;
int *iscst;
int *ialtyp;
{
   
 poi.nzm = *nzm;
 poi.nso = *nso;
 poi.nio = *nio;
 poi.nzo = *nzo;
 poi.ioropt = *ioropt;
 poi.ifor = *ifor;
 poi.ixyz98 = *ixyz98;
 poi.iopr = *iopr;
 poi.isymm = *isymm;
 poi.irc = *irc;
 poi.imp2 = *imp2;
 poi.icntp = *icntp;
 poi.msucc = *msucc;
 poi.ioni = *ioni;
 poi.mopopt = *mopopt;
 poi.isbin = *isbin;
 poi.irtype = *irtype;
 poi.ipdbgro = *ipdbgro;
 poi.ifav = *ifav;
 poi.ioxyz = *ioxyz;
 poi.iconv = *iconv;
 poi.ircus = *ircus;
 poi.nscnd = *nscnd;
 poi.iscst = *iscst;
 poi.ialtyp = *ialtyp;

 ptrpoi.nzm = nzm;
 ptrpoi.nso = nso;
 ptrpoi.nio = nio;
 ptrpoi.nzo = nzo;
 ptrpoi.ioropt = ioropt;
 ptrpoi.ifor = ifor;
 ptrpoi.ixyz98 = ixyz98;
 ptrpoi.iopr = iopr;
 ptrpoi.isymm = isymm;
 ptrpoi.irc = irc;
 ptrpoi.imp2 = imp2;
 ptrpoi.icntp = icntp;
 ptrpoi.msucc = msucc;
 ptrpoi.ioni = ioni;
 ptrpoi.mopopt = mopopt;
 ptrpoi.isbin = isbin;
 ptrpoi.irtype = irtype;
 ptrpoi.ipdbgro = ipdbgro;
 ptrpoi.ifav = ifav;
 ptrpoi.ioxyz = ioxyz;
 ptrpoi.iconv = iconv;
 ptrpoi.ircus = ircus;
 ptrpoi.nscnd = nscnd;
 ptrpoi.iscst = iscst;
 ptrpoi.ialtyp = ialtyp;
}

void bckpoi(istruct)
int istruct;
{

 poi = COO[istruct]->poi;

 *ptrpoi.nzm     = poi.nzm;
 *ptrpoi.nso     = poi.nso;
 *ptrpoi.nio     = poi.nio;
 *ptrpoi.nzo     = poi.nzo;
 *ptrpoi.ioropt  = poi.ioropt;
 *ptrpoi.ifor    = poi.ifor;
 *ptrpoi.ixyz98  = poi.ixyz98;
 *ptrpoi.iopr    = poi.iopr;
 *ptrpoi.isymm   = poi.isymm;
 *ptrpoi.irc     = poi.irc;
 *ptrpoi.imp2    = poi.imp2;
 *ptrpoi.icntp   = poi.icntp;
 *ptrpoi.msucc   = poi.msucc;
 *ptrpoi.ioni    = poi.ioni;
 *ptrpoi.mopopt  = poi.mopopt;
 *ptrpoi.isbin   = poi.isbin;
 *ptrpoi.irtype  = poi.irtype;
 *ptrpoi.ipdbgro = poi.ipdbgro;
 *ptrpoi.ifav    = poi.ifav;
 *ptrpoi.ioxyz   = poi.ioxyz;
 *ptrpoi.iconv   = poi.iconv;
 *ptrpoi.ircus   = poi.ircus;
 *ptrpoi.nscnd   = poi.nscnd;
 *ptrpoi.iscst   = poi.iscst;
 *ptrpoi.ialtyp  = poi.ialtyp;

}

#if defined(VMS) || defined(UNDERSC)
void parptr(nptr, fptr, ffptr, nitem)
#else
#ifdef CRAY
void PARPTR(nptr, fptr, ffptr, nitem)
#else
void parptr_(nptr, fptr, ffptr, nitem)
#endif
#endif

int *nptr;
float *fptr;
float *ffptr;
int *nitem;
{

    switch(*nptr) {
    case 1: FRQ = (FRQSTRU *) fptr; break;
    case 2: dorb.eiga = fptr; dorb.focc = (double *) ffptr; dorb.ncols = nitem;
	    dorb.mxorg = 0;
	    break;
    case 3: geo1ptr = (GEO1STRU *) fptr; 
	    geopntr.mxorg = 0;
	    break;
    case 151: geo2ptr = (GEO2STRU *) fptr; 
	    geopntr.formax = geo2ptr->formax;
	    geopntr.forrms = geo2ptr->forrms;
	    geopntr.dismax = geo2ptr->dismax;
	    geopntr.disrms = geo2ptr->disrms;
	    geopntr.epoints = geo2ptr->epoints;
	    geopntr.isav = geo2ptr->isav;
	    break;
    case 4: cnvptr = (CNVSTRU *) fptr; break;
    case 5: pnt = (PNTSTRU *) nitem; break;
    case 6: zmatptr = (ZMATSTRU *) fptr; 
	    zmptr.bl = zmatptr->bl;
	    zmptr.ibl = zmatptr->ibl;
	    zmptr.alph = zmatptr->alph;
	    zmptr.ialph = zmatptr->ialph;
	    zmptr.bet = zmatptr->bet;
	    zmptr.ibet = zmatptr->ibet;
	    zmptr.imap = zmatptr->imap;
	    zmptr.ianz = zmatptr->ianz;
	    zmptr.iz = (int *) zmatptr->iz;
	    break;
    case 7: atomptr = (ATOMSTRU *) fptr; 
	    xyz.coo = (double *) atomptr->coo;
	    xyz.rzp = (double *) atomptr->rzp;
	    xyz.ianz = (int *) atomptr->ianz;
	    xyz.iaton = (int *) atomptr->iaton;
	    xyz.iatclr = (int *) atomptr->iatclr;
	    xyz.iresid = (int *) atomptr->iresid;
	    xyz.ixp = (int *) atomptr->ixp;
	    xyz.iyp = (int *) atomptr->iyp;
	    xyz.iconn = (int *) atomptr->iconn;
	    break;
    case 8: elmptr = (ELMSTRU *) fptr; break;
    case 9: zmptr.nz = nitem;
	    zmptr.mxzorg = 0;
	    break;
    case 10: dorb.eigb = fptr; dorb.focb = (double *) ffptr; dorb.ncolb = nitem;
	     break;
    case 11: iuhf = nitem; break;
    case 12: xyz.icont = nitem; break;
    case 13: xyz.ncont = nitem; break;
    case 14: igffrm = nitem; break;
    case 15: xyz.iatoms = nitem;
	     xyz.mxorg = 0;
	     break;
    case 16: DoFreq = 0; break;
    case 129: DoFreq = 1; break;
    case 17: iftyp = nitem; break;
    case 18: esp = (double *) fptr; break;
    case 19: doesp = nitem; break;
    case 20: potcom = (POTSTRU *) fptr; break;
    case 21: irtval = nitem; break;
    case 22: ifntcl = nitem; break;
    case 24: icolps = nitem; break;
    case 25: ivtwo = nitem; break;
    case 26: ixyz = nitem; break;
    case 27: iixyz = nitem; break;
    case 28: iwropt = nitem; break;
    case 29: jobcom = (JOBSTRU *) nitem; break;
    case 37: espvdw = (double *) fptr; break;
    case 38: ispd = nitem; break;
    case 39: ibgcol = nitem; break;
    case 40: cell= (CELLSTRU *) nitem; break;
    case 41: jring = nitem; break;
    case 42: isimpl = nitem; break;
    case 43: surface = (SRFSTRU *) fptr; break;
    case 44: ivdwpl = nitem;break;
    case 45: NAT = (NATSTRU *) nitem; break;
    case 46: dospa = nitem; break;
    case 47: xyz.qat = (double *) fptr; 
	     break;
    case 48: fftyp = nitem; break;
    case 49: xyz.ityp = (short int *) nitem; 
	     break;
    case 50: xyz.ipdbt = (short int *) nitem; 
	     break;
    case 51: calfptr = (CALFSTRU *) fptr; break;
    case 52: istaro = nitem; break;
    case 53: fancy = nitem; break;
    case 54: atcol = nitem; break;
    case 55: shade = nitem; break;
    case 56: persp = nitem; break;
    case 57: tnkprg = nitem; break;
    case 58: currgrd = (double *) fptr; break;
    case 59: tnkbg = nitem; break;
    case 60: arch = nitem; break;
    case 61: archfrq = nitem; break;
    case 62: tnkit = nitem; break;
    case 63: iqopt = nitem; break;
    case 64: icalc = nitem; break;
    case 65: ipdbon = nitem; break;
    case 66: cubetyp = nitem; break;
    case 67: normc = nitem; break;
    case 68: frmul = fptr; break;
    case 69: ibell = nitem; break;
    case 70: natorg = nitem; break;
    case 71: zmptr.ihaszm = nitem; break;
    case 72: zmptr.mxzat = nitem; break;
    case 73: tstoc = (TSTOCSTRU *) fptr;
	     stoc.cstoc = (double *) tstoc->cstoc;
	     stoc.czstoc = (double *) tstoc->czstoc;
	     stoc.astoc = tstoc->astoc;
	     stoc.bstoc = tstoc->bstoc;
	     stoc.ianstc = tstoc->ianstc;
	     break; 
    case 74: torb = (TORBSTRU *) fptr;
	     orb.qd = (double *) torb->qd;
	     orb.pd = torb->pd;
	     orb.gd = (double *) torb->gd;
	     orb.hd = (double *) torb->hd;
	     break; 
    case 75: dorb.vectrs = (double *) fptr; dorb.vectrb = (double *) ffptr;
	     break; 
    case 76: dorb.nocc = nitem; break;
    case 77: dorb.nocb = nitem; break;
    case 78: dorb.p = (double *) fptr; dorb.paa = (double *) ffptr;
	     break; 
    case 79: dorb.istos = nitem; break;
    case 80: dorb.stoalfa = fptr; dorb.stobnorm = ffptr;
	     dorb.naorbs = nitem; break;
    case 81: dorb.averag = (double *) fptr; break;
    case 82: dorb.mxorb = nitem; break;
    case 83: sgrd.denn = (double *) fptr; 
	     sgrd.pmnn = (double *) ffptr;
	     sgrd.mx3d = nitem;
	     break;
    case 84: sgrd.dens = (double *) fptr; 
	     sgrd.denst = (double *) ffptr;
	     sgrd.mx3d2 = nitem;
	     break;
    case 85: sgrd.edx = (double *) fptr; 
	     sgrd.edy = (double *) ffptr;
	     sgrd.iedlog = nitem;
	     break;
    case 86: sgrd.rz = (double *) fptr; 
	     sgrd.bucket = (double *) ffptr;
	     sgrd.ix = nitem;
	     break;
    case 87: sgrd.iy = nitem; break;
    case 88: sgrd.mx3d = nitem; sgrd.mxorg = 0; break;
    case 89: sgrd.mx3d2 = nitem; break;
    case 90: irtcel = nitem; break;
    case 91: idelx = nitem; break;
    case 92: uscl = (double *) fptr; break;
    case 93: ball = nitem; break;
    case 94: picmax = nitem; break;
    case 95: cellpnt = (CELLSTRUC *) nitem; break;
    case 96: igztyp = nitem; break;
    case 97: igtfil = nitem; break;
    case 98: mgrd.fmap = (double *) fptr; 
	     mgrd.mx3d = nitem; mgrd.mxorg = 0;
	     break;
    case 99: mapit = nitem; break;
    case 100: ipsi = nitem; break;
    case 101: mapval = (double *) fptr; break;
    case 102: imapopt = nitem; break;
    case 110: ipdbwh = nitem; break;
    case 113: ideltm = nitem; break;
    case 115: ewin = (double *) fptr; break;
    case 116: npmfs = nitem; break;
    case 117: pmfmn = (double *) fptr; pmfmx = (double *) ffptr; 
		npmfmx = nitem; break;
    case 118: ipmfmn = nitem; break;
    case 119: ipmfmx = nitem; break;
    case 120: pmflga = (double *) fptr; break;
    case 121: ialtyp = nitem; break;
    case 122: iscst = nitem; break;
    case 123: ipmfm = nitem; break;
    case 124: levcol = nitem; break;
    case 125: ipmfh = nitem; break;
    case 126: zmpart = (ZMPARTSTRU *) nitem; break;
    case 130: rotptr = (ROTSTRU *) fptr; break;
    case 131: posptr = (POSSTRU *) fptr; break;
    case 132: logo = nitem; break;
    case 133: nscnd = nitem; break;
    case 134: dolabs = nitem; break;
    case 135: fcptr = (FCSTRU *) fptr; break;
    case 136: forces_yes_no = nitem; break;
    case 137: ifogl = nitem; break;
    case 138: hlpsrf = (HSRFSTRU *) nitem; break;
    case 139: backb = nitem; break;
    case 142: XYZ = (XYZSTRU *) fptr; break;
    case 143: BAS = (BASSTRU *) fptr; 
	      slagau = (GAUSTRU *) nitem;
	      break;
    case 144: comsrfptr = (COMSRFSTRU *) fptr; break;
    case 145: scle = (double *) fptr; break;
    case 146: ipsa = nitem; break;
    case 148: ifdogl = nitem; break;
    case 149: xyz.isurf = nitem; 
	      break;
    case 150: mapcol = (RGB *) fptr; valcol = (double *) ffptr; break;
/* already declared above
    case 151: (GEO2STRU *) fptr; break;
*/
    case 153: pmfrot = (PMFROTSTRU *) fptr; break;
    case 154: adjuss = (double *) fptr; break;
    case 156: iocnt = nitem; break;
    case 157: monptr = (MONSTRU *) fptr; break;
    case 158: xyz.mxnat = nitem; break;
    case 159: xyz.lwrit = nitem; break;
    case 160: xyz.lring = nitem; break;
    case 161: xyz.inat = nitem; break;
    case 162: ibgclo = nitem; break;
    case 163: qdpptr = (CHGDIP *) fptr; break;
    case 164: ibgmod = nitem; break;
    case 165: rng1 = (double *) fptr; rng2 = (double *) ffptr; break;
    case 166: vlcnt = (double *) fptr; vlcnt2 = (double *) ffptr; break;
    case 167: scalptr = (SCALSTRU *) fptr; break;
    case 168: clfhptr = (CLFHSTR *) nitem; break;
    case 170: idoh = nitem; break;
    case 171: hbpars = (HBSTRU *) fptr; break;
    case 172: itot = nitem; break;
    case 173: do3d = nitem; break;
    case 174: ambchg = nitem; break;
    case 175: MOP = (MOPSTRU *) nitem; break;
    case 176: PSEUD = (PSEUDSTRU *) nitem; break;
    case 177: plane = (PLANESTRU *) fptr; break;
    case 178: eul = (EULSTRU *) fptr; break;
    case 179: proj = (PROJSTRU *) fptr; break;
    case 180: multstruct = nitem; break;
    case 181: mfdata = (MFSTRU *) nitem; 
	      mfdata->mollin = (int *) malloc(sizeof(int)*MXMFMOL);
	      mfdata->mollin[0] = 0;
	      mfdata->maxmol = MXMFMOL;
	      mlftit = (char **) malloc(sizeof(char *)*MXMFMOL);
	      mxtits = MXMFMOL;
              break;
    case 182: pol = (double *) fptr; break;
    case 183: pol2 = (double *) fptr; break;
    case 184: icpsa = (int *) nitem; break;
    case 185: idtpsa = (int *) nitem; break;
    case 186: movie = (int *) nitem; break;
    case 187: fullgl = (int *) nitem; break;
    case 188: icst = (int *) nitem; break;
    case 189: ibox = (int *) nitem; break;
    case 190: igfmap = (int *) nitem; break;
    case 191: clfstrptr = (CLFSTRU *) nitem; break;
    case 192: nmrptr = (NMRSTRU *) fptr; break;
    case 193: iresrd = (int *) nitem; break;
    case 194: alnptr = (ALNSTRU *) nitem; break;
    case 195: pbc = (PBCSTRUC *) fptr; break;
    case 196: doshad = (int *) nitem; break;
    case 197: ihasex = (int *) nitem; break;
    case 198: noshad = (int *) nitem; break;
    case 199: dorb.phi = (double *) fptr; break; 
    case 200: dorb.dxpsi = (double *) fptr; break; 
    case 201: dorb.dypsi = (double *) fptr; break; 
    case 202: dorb.dzpsi = (double *) fptr; break; 
    case 203: dorb.dphi = (double *) fptr; break; 
    case 204: valcnt = (double *) fptr; break; 
    case 205: incompl = (INCOMPLSTRU *) nitem; break;
    case 206: ionoff = (int *) nitem; break;
    case 207: icommf = (int *) nitem; break;
    case 208: mets = (METSTRU *) fptr; break;
    case 209: eneptr = (ENERSTRU *) nitem; break;
    case 210: chgvdwptr = (CHGVDWSTRU *) fptr; break;
    case 211: zmatcptr = (ZMATSTRU *) fptr; 
	    zmcptr.bl = zmatcptr->bl;
	    zmcptr.ibl = zmatcptr->ibl;
	    zmcptr.alph = zmatcptr->alph;
	    zmcptr.ialph = zmatcptr->ialph;
	    zmcptr.bet = zmatcptr->bet;
	    zmcptr.ibet = zmatcptr->ibet;
	    zmcptr.imap = zmatcptr->imap;
	    zmcptr.ianz = zmatcptr->ianz;
	    zmcptr.iz = (int *) zmatcptr->iz;
	    break;
    }
}

void drwcnv()
{
      int nents;

      if (cnvptr->icvav2) 
	  nents = MAXI(cnvptr->jend1,cnvptr->jend2);
      else nents = cnvptr->jend1;

      if (cnvptr->icvav1) 
      drwgra(&scfEfirst,-5,wincnv,CNVWIDE,CNVHIGH,NULL,cnvptr->convg1,cnvptr->jstrt1,cnvptr->jend1,nents,cnvptr->cnvmax,cnvptr->cnvmin,0.0e0,5,1,"Iterations","Energy","First Point",0,1,0,0);
      if (cnvptr->icvav2) 
      drwgra(&scfElast,10,wincnv,CNVWIDE,CNVHIGH,NULL,cnvptr->convg2,cnvptr->jstrt2,cnvptr->jend2,nents,cnvptr->cnvmax,cnvptr->cnvmin,0.0e0,6,1,"Iterations","Energy","Last Point",1,0,0,0);
      XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
}

void drwspec()
{
      int i,j,ifr;
      double intensity, frq, center, rel_offset;
      double (*lineshape)(double);
      double fminus,scx,scy,x1,y1;


      if (out_spec == NULL) return;

      drwgra(&spect,-5,winspec,SPECWIDE,SPECHIGH,NULL,out_spec,1,n_freqs,n_freqs,spec_mx,spec_mn,0.0e0,5,1,splab,"Intensity","",0,1,0,1);

      if (!specps) {
	XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
      }

      if (lorentzian) {
	lineshape = lorentz;
      } else {
	lineshape = gauss;
      }

      spect.npts = 0;
      scx = 1.0*n_freqs;
      scy = spec_mx - spec_mn;
      fminus = spec_mn - 0.05*scy;
      scy = 1.05*scy;
      ifr = 1;

      for (i=0; i < *spnfrq; i++) {
	intensity = 0.0;
	frq = ((double) spfrq[i])*freq_scale;
	for (j=0; j < *spnfrq; j++) {
	   center = ((double) spfrq[j])*freq_scale ;
	   rel_offset = (frq - center) / hwhm;
	   intensity += spint[j] * lineshape(rel_offset);
	}
        
	x1 = ((((double) spfrq[i])*freq_scale - min_freq)/freq_step)/scx;
 	y1 = (intensity-fminus)/scy;
	if (spect.npts < MAXFRPNT) {
		glpnt(SPECWIDE,SPECHIGH,x1,y1,
		&spect.x[spect.npts],&spect.y[spect.npts],ifr);
		spect.index[spect.npts] = i;
	}
	spect.npts++;

      }

      spect.fpts = (double *) spfrq;

      if (!specps) {
	for (i=0; i<nsbutts; i++) DrwBut(&spbut[i]);
	for (i=0; i<nspqbox; i++) {
	   PromptBox(&qboxes[QHW+i]);
	}

	ULineString(winspec,"Spectrum:",CNVBORD, SPECHIGH+15);
	ULineString(winspec,"Lineshape:",CNVBORD, SPECHIGH+BUTTN+15);
      }

}

void drwsco()
{
   int i;
   int PEH,PH,PW,NE,MW,jx,jy;

   scomin = 1.e10;
   scomax = -1.e10;

   for (i=0; i<*npmfs; i++) {
	if (ewin[i] > scomax) scomax = ewin[i];
	if (ewin[i] < scomin) scomin = ewin[i];
   }
   scomax = 1.2e0*(scomax - scomin) + scomin;

   if (*npmfs && ! (scomax == scomin)) {
      drwgra(&docksco,-5,winsco,CNVWIDE,CNVHIGH,NULL,ewin,1,*npmfs,*npmfs,scomax,scomin,0.0e0,5,1,"Orientations","Score",NULL,0,1,0,0);
      XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
   }
   for (i=0; i<NSCBUTTS; i++) DrwBut(&scbut[i]);

   LineString(winsco, "Ligand Color Mode", 30, CNVHIGH+54);
   LineString(winsco, "Include Hydrogens", 30, CNVHIGH+74);

   NE = 4;
   PEH = 20;
   PW = 70;
   PH = NE*PEH;
   MW = 10;

   jx = CNVWIDE-PW-10;
   jy = CNVHIGH+45;

   if (! *ipmfm) {
	XSetForeground(display, gc, White);
	XFillRectangle(display, winsco, gc, jx-10,jy-10, PW+20,4*PEH+20);
	XSetForeground(display, gc, Black);
	return;
   }

   for (i=0; i < NE; i++) {
	XSetForeground(display, gc, colors[levcol[i]]);
	XFillRectangle(display, winsco, gc, jx,jy+(i * PH)/NE, PW,PEH);
   }

   XSetForeground(display, gc, Black);

   sprintf(stemp, "PMFmax");
   XDrawString(display,winsco,gc,jx+15,jy+4,
           stemp,strlen(stemp));
   sprintf(stemp, "PMFavg");
   XDrawString(display,winsco,gc,jx+15,jy+4+(2*PH)/NE,
           stemp,strlen(stemp));
   sprintf(stemp, "PMFmin");
   XDrawString(display,winsco,gc,jx+15,jy+4+(4*PH)/NE,
           stemp,strlen(stemp));

}

int ButtonsSCO(i)
int i;
{
   double tpmf;

   switch(i) {
   case 0:
#if defined(VMS) || defined(UNDERSC)
	alnsav();
#else
#ifdef CRAY
	ALNSAV();
#else
	alnsav_();
#endif
#endif
	break;
   case 1:
#if defined(VMS) || defined(UNDERSC)
	alnwrt();
#else
#ifdef CRAY
	ALNWRT();
#else
	alnwrt_();
#endif
#endif
	break;
   case 2:
	bflag = 1; bretval = 561;
	strcpy(molwstr,"Click on atom to analyze score !");
	StatusStr(0,1);
	XDefineCursor(display,win,AtomCursor);
	break;
   case 3:
	XDestroyWindow(display,winsco);scoup = 0;
	break;
   case 4:
	if (*ipmfm) {
	   *ipmfm = 0;
	} else {
	   *ipmfm = 1;
	}
	TogBut(&scbut[4]);
#if defined(VMS) || defined(UNDERSC)
	totpmf(&tpmf);
	qupd();
#else
#ifdef CRAY
	TOTPMF(&tpmf);
	QUPD();
#else
	totpmf_(&tpmf);
	qupd_();
#endif
#endif
	drwsco();

	break;
   case 5:
	if (*ipmfh) {
	   *ipmfh = 0;
	} else {
	   *ipmfh = 1;
	}
	TogBut(&scbut[5]);
#if defined(VMS) || defined(UNDERSC)
	totpmf(&tpmf);
	qupd();
#else
#ifdef CRAY
	TOTPMF(&tpmf);
	QUPD();
#else
	totpmf_(&tpmf);
	qupd_();
#endif
#endif
	drwsco();

	break;
   }
   return(0);
}

void drwpmf()
{
   int i;

   butje(winpmf,0,0,325,CNVHIGH+40,2,0,2,1,None,0,0,0,0);
   for (i=0; i<NPBUTTS; i++) DrwBut(&pbut[i]);
   RedrawList(&pmflistmx);
   RedrawList(&pmflistmn);
   ULineString(winpmf, "Top Negative Interactions", SBOXOFFX, 25);
   ULineString(winpmf, "Top Positive Interactions", SBOXOFFX, 25+120);
   sprintf(stemp, "Total Score Atom  : %8.3f",*pmflga);
   LineString(winpmf, stemp, SBOXOFFX, 25+120+120);
   sprintf(stemp, "Total Score Ligand: %8.3f",ewin[*npmfs-1]);
   LineString(winpmf, stemp, SBOXOFFX, 25+120+140);

}

int ButtonsPMF(i)
int i;
{

   switch(i) {
   case 0:
	XDestroyWindow(display,winpmf);pmfup = 0;
	break;
   }
   return(0);
}

#if defined(VMS) || defined(UNDERSC)
void drwgeo()
#else
#ifdef CRAY
void DRWGEO()
#else
void drwgeo_()
#endif
#endif
{
      int nitems;

      if (!geo1ptr->gcvav || !geoup) return;

      nhframes = 1;
      if (geo1ptr->ifmxav || geo1ptr->ifrmav) nhframes = 2;
      nwframes = 1;
      if (geo1ptr->idmxav || geo1ptr->idrmav) nwframes = 2;

      if (geo1ptr->ieav) {
	   nitems = geo1ptr->nepnts;
	   if (nitems > geo1ptr->mxpnt) nitems = geo1ptr->mxpnt;
	   drwgra(&geoE,-5,wingeo,CNVWIDE,CNVHIGH,geop->isav,
	   geop->epoints,0,0,nitems,geo1ptr->enmax,geo1ptr->enmin,
	   0.0e0,9,1,"Point","Energy",NULL,0,1,1,0);
      }

      nitems = geo1ptr->ngeoms;
      if (nitems > geo1ptr->mxpnt) nitems = geo1ptr->mxpnt;

      if (geo1ptr->ifmxav)
	   drwgra(&geoFmax,-5,wingeo,CNVWIDE,CNVHIGH,geop->isav,
	   geop->formax,0,0,nitems,geo1ptr->fgmax,geo1ptr->fgmin,
	   geo1ptr->fmaxt,5,2,"Point","Force","Max. Force",0,1,0,0);

      if (geo1ptr->ifrmav) 
	   drwgra(&geoFrms,10,wingeo,CNVWIDE,CNVHIGH,geop->isav,
	   geop->forrms,0,0,nitems,geo1ptr->fgmax,geo1ptr->fgmin,
	   geo1ptr->frmst,6,2,"Point","Force","Aver. Force",1,0,0,0);

      if (geo1ptr->idmxav)
	   drwgra(&geoSmax,-5,wingeo,CNVWIDE,CNVHIGH,geop->isav,
	   geop->dismax,0,0,nitems,geo1ptr->dgmax,geo1ptr->dgmin,
	   geo1ptr->dmaxt,1,3,"Point","Step","Max. Step",0,1,0,0);

      if (geo1ptr->idrmav)
	   drwgra(&geoSrms,10,wingeo,CNVWIDE,CNVHIGH,geop->isav,
           geop->disrms,0,0,nitems,geo1ptr->dgmax,geo1ptr->dgmin,
	   geo1ptr->drmst,11,3,"Point","Step","Aver. Step",1,0,0,0);

      XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);


}

void drwgra(tabptr,yelev,gwin,wide,high,isav,fpts,jbeg,jend,nents,fmax,fmin,flim,icol,ifr,xstr,ystr,labstr,isdash,init,notsav,ityp)
FRSTRU *tabptr;
int yelev;
Window gwin;
int wide,high;
int *isav;
double *fpts;
int jbeg,jend;
int nents;
double fmax,fmin,flim;
int icol;
int ifr;
char *xstr;
char *ystr;
char *labstr;
int isdash;
int init;
int notsav;
int ityp;
{
      int i,j,xt,yt,qlen,xoff;
      int ifrx,ifry;
      int dum0,dum1,itel,tick;
      double frq,fminus,scx,scy,x1,y1,x2,y2;
      char *tmpptr;

      tabptr->current = -1;
      tabptr->win = gwin;
      tabptr->fpts = fpts;
      tabptr->npts = 0;
      tabptr->yelev = yelev;
      tabptr->color = icol;
      tabptr->wide = wide;
      tabptr->high = high;

      if (tabptr->npts < nents && tabptr->x != NULL) {
	free(tabptr->x);
	free(tabptr->y);
	free(tabptr->index);
      }
      
      if (tabptr->x == NULL || tabptr->npts < nents) {
	tabptr->x = (int *) malloc((sizeof i)*nents);
	tabptr->y = (int *) malloc((sizeof i)*nents);
	tabptr->index =  (int *) malloc((sizeof i)*nents);
      }

      dum0 = 0;
      dum1 = 1;

      tmpptr = ystr;

      ifrx = 0;
      ifry = 0;
      if (ifr == 3 || ifr == 4) ifrx = 1;
      if (ifr == 2 || ifr == 4) ifry = 1;

      scx = 1.0*nents;
      scy = fmax - fmin;
      fminus = fmin - 0.05*scy;
      scy = 1.05*scy;

      if (init) {

       if (!specps) {
         XSetLineAttributes(display,gc,2,LineSolid,CapButt,JoinMiter);
	 butje(gwin,CNVBORD+tabptr->wide*ifrx,CNVBORD+tabptr->high*ifry,
	   tabptr->wide-2*CNVBORD,tabptr->high-2*CNVBORD,3,0,0,0,None,0,0,0,0);
         XSetForeground(display, gc, BlackPixel(display,screen));
	 xoff = strlen(xstr)*10;
         XDrawString(display,gwin,gc,(tabptr->wide-CNVBORD-xoff)+tabptr->wide*ifrx,(tabptr->high-CNVBORD-10)+tabptr->high*ifry,xstr,strlen(xstr));
         for (i=0; i < strlen(ystr); i++,tmpptr++)
             XDrawString(display,gwin,gc,CNVBORD+13+tabptr->wide*ifrx,CNVBORD+40+tabptr->high*ifry+i*10,tmpptr,1);

         XSetForeground(display, gc, BlackPixel(display,screen));
       
	} else {
	   glpnt(tabptr->wide,tabptr->high,0.85,-0.10,&xt,&yt,ifr);
	   qlen = strlen(xstr);
	   fprintf(spout,"%d %d m 4 0 (%s) ashow\n",
		600*(xt-qlen/2)/SPECWIDE,-300*yt/SPECHIGH,xstr);
	   qlen = strlen(ystr);
	   for (i=0; i < strlen(ystr); i++,tmpptr++) {
		glpnt(tabptr->wide,tabptr->high,-0.02,1.0-i*0.05,&xt,&yt,ifr);
		fprintf(spout,"%d %d m 4 0 (%c) ashow\n",
		600*(xt)/SPECWIDE,-300*yt/SPECHIGH,ystr[i]);
	   }
        }

         x1 = 0.0;
         y1 = 0.0;
         x2 = 1.0;
         y2 = 0.0;
         drwgl(gwin,tabptr->wide,tabptr->high,x1,y1,x2,y2,dum0,dum0,ifr,isdash);
         x2 = 0.0;
         y2 = 1.0;
         drwgl(gwin,tabptr->wide,tabptr->high,x1,y1,x2,y2,dum0,dum0,ifr,isdash);

	 if (freq_step == 1.0) {
		tick = 5;
		if (nents > 50) tick = 10;
		if (nents > 500) tick = 100;
		if (nents > 1000) tick = 500;
		if (nents > 10000) tick = 1000;
		if (nents > 100000) tick = 10000;
	 } else if (freq_step == nmr1Hstep) {
		tick = 1;
	 } else if (freq_step == nmr13Cstep) {
		tick = 10;
	 }

	 if (ityp) {
	    i = min_freq / tick;
	    if (i < 0) i = 0;
	    for (frq=tick*i; frq <= max_freq; frq = frq + tick) {
               if (frq >= 0 && frq <= nents) {
		  x1 = ((frq - min_freq)/freq_step)/scx;
		  y1 = 0.0;
		  x2 = x1;
		  y2 = -0.02;
		  drwgl(gwin,tabptr->wide,tabptr->high,x1,y1,x2,y2,dum0,dum0,
		    ifr,isdash);
		  glpnt(tabptr->wide,tabptr->high,x1,-0.05,&xt,&yt,ifr);
		  sprintf(stemp,"%d",(int) frq);

		  if (specps) {
			qlen = strlen(stemp);
			fprintf(spout,"%d %d m 4 0 (%s) ashow\n",
			  600*(xt-qlen/2)/SPECWIDE,-300*yt/SPECHIGH,stemp);
		  } else {
			qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
			XDrawString(display,gwin,gc,xt-qlen/2,yt,stemp,
			  strlen(stemp));
		  }
               }
	    }
	 } else {
	    for (i=0; i<=nents; i = i + tick) {
               if (i >= 0 && i <= nents) {
		  x1 = i/scx;
		  y1 = 0.0;
		  x2 = i/scx;
		  y2 = -0.02;
		  drwgl(gwin,tabptr->wide,tabptr->high,x1,y1,x2,y2,dum0,dum0,
		    ifr,isdash);
		  glpnt(tabptr->wide,tabptr->high,x1,-0.05,&xt,&yt,ifr);
		  sprintf(stemp,"%d",i);
		  qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
		  XDrawString(display,gwin,gc,xt-qlen/2,yt,stemp,strlen(stemp));
               }
	    }
	 }
      }

      if (labstr != NULL) {
	if (!specps) {

         if (! monoscr) XSetForeground(display, gc, colors[icol]);
         else { 
             XSetForeground(display, gc, BlackPixel(display,screen));
             if (isdash) 
                  XSetLineAttributes(display,gc,2,LineOnOffDash,CapButt,JoinMiter);
	     else XSetLineAttributes(display,gc,2,LineSolid,CapButt,JoinMiter);
             XDrawLine(display,gwin,gc,(tabptr->wide-CNVBORD-250)+tabptr->wide*ifrx,CNVBORD+40+isdash*20+tabptr->high*ifry,(tabptr->wide-CNVBORD-250)+tabptr->wide*ifrx,CNVBORD+40+isdash*20+tabptr->high*ifry);
         }

         XSetLineAttributes(display,gc,2,LineSolid,CapButt,JoinMiter);
         XDrawString(display,gwin,gc,(tabptr->wide-CNVBORD-100)+tabptr->wide*ifrx,CNVBORD+40+isdash*20+tabptr->high*ifry,labstr,strlen(labstr));

	} else {
		qlen = strlen(labstr);
		xt = 0; yt = 0;
		fprintf(spout,"%d %d m 4 0 (%s) ashow\n",
		600*(xt-qlen/2)/SPECWIDE,-300*yt/SPECHIGH,labstr);
	}
      }

      if (scy == 0.0) return;

      if (isav != NULL) {
	 itel = -1;
         for (i=1; i <= nents-1; i++) {
            if (isav[i-1] == 1 || notsav) {
	       if (i == pnt->ipnt) itel = tabptr->npts;
               x1 = i/scx;
               y1 = (fpts[i-1]-fminus)/scy;
	       tabptr->index[tabptr->npts] = i-1;
	       glpnt(tabptr->wide,tabptr->high,x1,y1,
		 &tabptr->x[tabptr->npts],&tabptr->y[tabptr->npts],ifr);
	       tabptr->npts++;
               for (j=i+1; j <= nents; j++) {
                 if (isav[j-1] == 1 || notsav) {
                    x2 = j/scx;
                    y2 = (fpts[j-1]-fminus)/scy;
                    drwgl(gwin,tabptr->wide,tabptr->high,x1,y1,x2,y2,
			icol,dum1,ifr,isdash);
		    if (j == nents) {
	       		if (j == pnt->ipnt) itel = tabptr->npts;
			tabptr->index[tabptr->npts] = nents-1;
			glpnt(tabptr->wide,tabptr->high,x2,y2,
			 &tabptr->x[tabptr->npts],&tabptr->y[tabptr->npts],ifr);
			tabptr->npts++;
		    }
                    break;
                 }
               }
            }
         }
	 if (itel >= 0 && !specps) {
	    XSetForeground(display,gc,colors[15]);
	    XDrawArc(display, gwin, gc, tabptr->x[itel]-10,tabptr->y[itel]-10, 20, 20, 0,360*64);
	 }
      }
      else {
/*
   Leave out first Energy point because the jump is to big, all detail
   of the rest of the curve would be lost
*/

         for (i=jbeg; i <= jend; i++) {
               x1 = (i)/scx;
               y1 = (fpts[i-1]-fminus)/scy;
               x2 = (i+1)/scx;
               y2 = (fpts[i]-fminus)/scy;
	       if (ityp) {
		  if (i <= jend-1) drwgl(gwin,tabptr->wide,tabptr->high,
		                   x1,y1,x2,y2,icol,dum0,ifr,isdash);
	       } else {
		  if (i <= jend-1) drwgl(gwin,tabptr->wide,tabptr->high,
		                   x1,y1,x2,y2,icol,dum1,ifr,isdash);
	                           tabptr->index[tabptr->npts] = i-1;
		  glpnt(tabptr->wide,tabptr->high,x1,y1,
		    &tabptr->x[tabptr->npts],&tabptr->y[tabptr->npts],ifr);
		  tabptr->npts++;
	       }
         }
      }

      if (flim > 0.0) {
         x1 = 0.0;
         y1 = (flim-fminus)/scy;
         x2 = 0.2;
         y2 = y1;
         drwgl(gwin,tabptr->wide,tabptr->high,x1,y1,x2,y2,icol,dum0,ifr,isdash);
      }

}

void drwgl(gwin,wide,high,x1,y1,x2,y2,icol,icross,iframe,isdash)
Window gwin;
double x1;
double y1;
double x2;
double y2;
int wide,high;
int icol;
int icross;
int iframe;
int isdash;
{
  int x1t,x2t,y1t,y2t;

  glpnt(wide,high,x1,y1,&x1t,&y1t,iframe);
  glpnt(wide,high,x2,y2,&x2t,&y2t,iframe);

  if (!specps) {
	if (monoscr) XSetForeground(display, gc, colors[0]);
	else XSetForeground(display,gc,colors[icol]);
	if (monoscr && icol) {
	    if (isdash) XSetLineAttributes(display, gc, 2, LineOnOffDash, 
			CapButt, JoinMiter);
	}
	XDrawLine(display,gwin,gc,x1t,y1t,x2t,y2t);

	if (icross == 1) {
	     XDrawLine(display,gwin,gc,x1t-2,y1t-2,x1t+2,y1t+2);
	     XDrawLine(display,gwin,gc,x1t-2,y1t+2,x1t+2,y1t-2);
	     XDrawLine(display,gwin,gc,x2t-2,y2t-2,x2t+2,y2t+2);
	     XDrawLine(display,gwin,gc,x2t-2,y2t+2,x2t+2,y2t-2);
	}
	if (monoscr && icol) {
	   XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinMiter);
	}
  } else {
     fprintf(spout,"newpath\n");
     fprintf(spout,"%d %d m %d %d l\n",600*x1t/SPECWIDE,-300*y1t/SPECHIGH,
	600*x2t/SPECWIDE,-300*y2t/SPECHIGH);
     fprintf(spout,"stroke\n");
  }
}

void glpnt(wide,high,x,y,xr,yr,iframe)
int wide,high;
double x;
double y;
int *xr;
int *yr;
int iframe;
{
  int ifrx,ifry;

  ifrx = 0;
  ifry = 1;
  if (iframe == 3 || iframe == 4) ifrx = 1;
  if (iframe == 2 || iframe == 4) ifry = 2;

  *xr = x*(wide-2*CNVOFFX-2*CNVBORD) + CNVOFFX + CNVBORD + wide*ifrx;
  *yr = high*ifry - (y*(high-2*CNVOFFY-2*CNVBORD) + 1.4*CNVOFFY + CNVBORD);

}

void parse_motion(tabptr)
FRSTRU *tabptr;
{
  int qlen,nopnt = 1;

  if (tabptr->npts <= 0) return;

  XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinMiter);
  nopnt = FindSel(NULL,tabptr->x,tabptr->y,0,tabptr->npts,
	event.xmotion.x,event.xmotion.y,GLTOL);

  if (tabptr->current != nopnt) {
     if (tabptr->current != -1) {
        XSetForeground(display, gc, colors[190]);
        XSetFunction(display, gc, GXxor);
	if (tabptr->fpts == (double *) spfrq) {
	   sprintf(stemp,"%f",freq_scale*spfrq[tabptr->index[tabptr->current]]);
	} else {
	   sprintf(stemp,"%f",tabptr->fpts[tabptr->index[tabptr->current]]);
	}
        qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
        XDrawString(display,tabptr->win,gc,tabptr->x[tabptr->current]-qlen,
   	  tabptr->y[tabptr->current]+tabptr->yelev,stemp,strlen(stemp));
        XSetFunction(display, gc, GXcopy);
        XSetForeground(display, gc, colors[tabptr->color]);
        XDrawLine(display,tabptr->win,gc,tabptr->x[tabptr->current]-2,
   	  tabptr->y[tabptr->current]-2,tabptr->x[tabptr->current]+2,
   	  tabptr->y[tabptr->current]+2);
        XDrawLine(display,tabptr->win,gc,tabptr->x[tabptr->current]-2,
	  tabptr->y[tabptr->current]+2,tabptr->x[tabptr->current]+2,
	  tabptr->y[tabptr->current]-2);
     }
     if (nopnt != -1) {
        XSetForeground(display, gc, colors[190]);
        XSetFunction(display, gc, GXxor);
	if (tabptr->fpts == (double *) spfrq) {
           sprintf(stemp,"%f",freq_scale*spfrq[tabptr->index[nopnt]]);
	} else {
           sprintf(stemp,"%f",tabptr->fpts[tabptr->index[nopnt]]);
	}
        qlen = XTextWidth(mfinfo,stemp, strlen(stemp));
        XDrawString(display,tabptr->win,gc,tabptr->x[nopnt]-qlen,
   	  tabptr->y[nopnt]+tabptr->yelev,stemp,strlen(stemp));
        XSetFunction(display, gc, GXcopy);
        XSetForeground(display, gc, BlackPixel(display, screen));
        XDrawLine(display,tabptr->win,gc,tabptr->x[nopnt]-2,tabptr->y[nopnt]-2,
   	  tabptr->x[nopnt]+2,tabptr->y[nopnt]+2);
        XDrawLine(display,tabptr->win,gc,tabptr->x[nopnt]-2,tabptr->y[nopnt]+2,
	  tabptr->x[nopnt]+2,tabptr->y[nopnt]-2);
     }
  }
  tabptr->current = nopnt;
  XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);
}

void parse_label(Ca,l,ix,iy)
int Ca;
int l;
int *ix;
int *iy;
{
      int x,y;

/* only visible atoms have non-zero ixp and iyp values */

      if ((Ca >= 0 && Ca != rsold) || (Ca <= -4 && Ca != rsold) || 
		(Ca == RESUND && rsold != RESUND)) {

	 if ( !((*fancy || *fullgl) && has_opengl && !StarNetOld) ) {
           if (rsold != RESUND)
	       XCopyArea(display,bckwin,win,gc,0,0,BckW,BckH,bckx,bcky);
	 }

	 strcpy(atemp,"               ");

	 if ( ( (Ca >= 0 && Ca != rsold) || (Ca <= -4 && Ca != rsold) ) 
		&& Ca != RESUND) {

           
	   if (Ca >= 0) l = calfptr->icalf[Ca][0]-1;
	   x = iy[l];
	   y = ix[l];
	   lhoh = l;
           
	   if (Ca >= 0) {
		sprintf(atemp,"%3s %-6d ",AminoAcids[calfptr->iamino[Ca]-1],
					 calfptr->irsnr[Ca]);
		atemp[12] = '\0';
	   } else {
		int aca;
		
		aca = abs(Ca+1);
		if (calfptr->ishoh > 0 && Ca+1 < -1.0e0*calfptr->ishoh) {
		   if (Ca+1 <= calfptr->ision && calfptr->ision < 0) {
			sprintf(atemp,"ION     ");
		   } else {
			sprintf(atemp,"HOH     ");
		   }
		} else {
		   if (aca < MXHETA && abs(Ca) < MXHETA) {
			sprintf(atemp,"%3s     ",hetptr.HetAtm[abs(Ca)]);
			sprintf(atemp,"%3s     ",hetptr.HetAtm[abs(Ca+1)]);
		   }
		}
		atemp[9] = '\0';
	   }

	   if ((*fancy || *fullgl) && has_opengl && !StarNetOld) {
#ifdef DOGL
	      dispsf();
	      printString(x,y,1,atemp);
#endif
	   } else {
	      foreground_pixel = colors[15];
	      XSetForeground(display, gc, foreground_pixel);
	      XCopyArea(display,win,bckwin,gc,x,y-20,BckW,BckH,0,0);
	      XDrawString(display, win, gc, x, y, atemp, 8);
	   }


	   bckx = x; bcky = y-20;
	 } else if (Ca == RESUND && rsold != RESUND) {
#ifdef DOGL
	   if ((*fancy || *fullgl) && has_opengl && !StarNetOld) dispsf();
#endif
	 }
	 rsold = Ca;
      }
}

void parse_labelp(Ca,l,ix,iy)
int Ca;
int l;
int *ix;
int *iy;
{
      int x,y;

      if ( (Ca >= 0 && Ca != rsold && !( (*fancy || *fullgl) && has_opengl)) 
	|| (Ca <= -4 && Ca != rsold) || 
	   (Ca == RESUND && rsold != RESUND)) {

	 if ( !( (*fancy || *fullgl) && has_opengl && !StarNetOld) ) {
           if (rsold != RESUND)
	       XCopyArea(display,bckwin,win,gc,0,0,BckW,BckH,bckx,bcky);
	 }

	 strcpy(atemp,"        ");
	 if ( ( (Ca >= 0 && Ca != rsold) || (Ca <= -4 && Ca != rsold) ) 
		&& Ca != RESUND) {

	   if (Ca >= 0) {
            /*this gives a wrong position for res label */
		x = calfptr->icyp[Ca];
		y = calfptr->icxp[Ca];
	   } else {
		x = iy[l];
		y = ix[l]-20;
		lhoh = l;
	   }

	   if (Ca >= 0) {
		sprintf(atemp,"%3s %3d ",AminoAcids[calfptr->iamino[Ca]-1],
					 calfptr->irsnr[Ca]);
	   } else {
		int aca;
		
		aca = abs(Ca+1);
		if (calfptr->ishoh > 0 && Ca+1 < -1.0e0*calfptr->ishoh) {
		   if (Ca+1 <= calfptr->ision && calfptr->ision < 0) {
			sprintf(atemp,"ION     ");
		   } else {
			sprintf(atemp,"HOH     ");
		   }
		} else {
		   if (aca < MXHETA && abs(Ca) < MXHETA) {
			sprintf(atemp,"%3s     ",hetptr.HetAtm[abs(Ca)]);
			sprintf(atemp,"%3s     ",hetptr.HetAtm[abs(Ca+1)]);
		   }
		}
	   }

	   if ( (*fancy || *fullgl) && has_opengl && !StarNetOld) {
#ifdef DOGL
	      dispsf();
	      printString(x,y,1,atemp);
#endif
	   } else {
	      foreground_pixel = colors[15];
	      XSetForeground(display, gc, foreground_pixel);
	      XCopyArea(display,win,bckwin,gc,x,y-20,BckW,BckH,0,0);
	      XDrawString(display, win, gc, x, y, atemp, 8);
	   }


	   bckx = x; bcky = y-20;
	 } else if (Ca == RESUND && rsold != RESUND) {
#ifdef DOGL
	   if ( (*fancy || *fullgl) && has_opengl && !StarNetOld) dispsf();
#endif
	 }
	 rsold = Ca;
      }
}

int FindSel(onoff,x,y,ist,num_items,cursorx,cursory,mindiff)
int *onoff;
int *x;
int *y;
int ist;
int num_items;
int cursorx,cursory;
int mindiff;
{
    int i,irt,dx,dy,dsqr,dsq_min,found,oke;

    found = -1;
    dsq_min = mindiff*mindiff;
    for ( i = ist; i < ist+num_items; i++ ) {
      oke = 0;
      if (onoff == NULL) oke = 1;
      else if (onoff[i] >= 1) oke = 1;
      if (oke) {
	  dx = ABS(cursorx - x[i]);
	  dy = ABS(cursory - y[i]);
	  dsqr = dx*dx + dy*dy;
          if (dx < mindiff && dy < mindiff && dsqr < dsq_min ) {
		dsq_min = dsqr;
		found = i;
          }
      }
    }
/* below is to accomodate to find a Calfa, because when in the upper loop it
   find Calfa it is from the secondary structure visualsation because these
   always come last in the atom array, so actually not the real Calfa is found
   but the visualisation Calfa (ianz = 100)
*/
    if ((found == -1 || (found != -1 && xyzp->ianz[found] == 100 )) && *ipdbon && onoff != NULL) {
	irt = FindCa(onoff,x,y,cursorx,cursory,mindiff);
	if (irt != -1) irt = calfptr->icalf[irt][0]-1; 
	return(irt);
    } else return (found);
}

int FindCa(onoff,x,y,cursorx,cursory,mindiff)
int *onoff;
int *x;
int *y;
int cursorx,cursory;
int mindiff;
{
    int i,j,l,dx,dy,dsqr,dsq_min,dsq_minz,found,oke;
    double dz, dzmin;

    found = -1;
    dsq_min = mindiff*mindiff;
    dsq_minz = mindiff*mindiff;
    if (has_opengl && (*fancy || *fullgl)) {
	dzmin = 1000000;
    } else {
	dzmin = -1000000;
    }
    for ( i = 0; i < calfptr->ncalf; i++ ) {
     for ( j = 0; j < 4; j++ ) {
      l = calfptr->icalf[i][j]-1;
      if (l < 0 || l > *xyzp->mxnat) continue;
      oke = 0;
      if (onoff == NULL) oke = 1;
      else if (onoff[l] >= 1) oke = 1;
      if (1) {
	  dx = ABS(cursorx - x[l]);
	  dy = ABS(cursory - y[l]);
	  dz = xyzp->rzp[l];
	  dsqr = dx*dx + dy*dy;
          if (dx < mindiff && dy < mindiff && dsqr < dsq_min) {
	     if (has_opengl && (*fancy || *fullgl)) {
		if (dz < dzmin) {
	 	  dzmin = dz;
		  found = i;
		}
	     } else {
		if (dz > dzmin) {
	 	  dzmin = dz;
		  found = i;
		}
	     }
          }
      }
     }
    }
    return (found);
}

int FindCaP(cursorx,cursory,mindiff)
int cursorx,cursory;
int mindiff;
{
    int i,dx,dy,dsqr,dsq_min,found;

    found = -1;
    dsq_min = mindiff*mindiff;
    for ( i = 0; i < calfptr->ncalf; i++ ) {
	dx = ABS(cursorx - calfptr->icyp[i]);
	dy = ABS(cursory - calfptr->icxp[i]);
	dsqr = dx*dx + dy*dy;
        if (dx < mindiff && dy < mindiff && dsqr < dsq_min) {
	  found = i;
        }
    }
    return (found);
}

#if defined(VMS) || defined(UNDERSC)
void labnr(isup)
#else
#ifdef CRAY
void LABNR(isup)
#else
void labnr_(isup)
#endif
#endif

int *isup;
{
    if (ZMEup&&*zmptrp->ihaszm) *isup = 1;
    else *isup = 0;
}

void InitZME()
{
   int i;
   
   ZMEup = 1;

   ZME_window_pos = 0;
   ZMEmode = 0;
   ZMEsel = 0;

   ZMEanW  = XTextWidth(mfinfo,"  ",2)+3*QBOXFR+2*QBOXBORD;
   ZMEconW = XTextWidth(mfinfo,"   ",3)+3*QBOXFR+2*QBOXBORD;
   ZMEbutW = XTextWidth(mfinfo,"   ",3)+2*QBOXBORD+3;
   ZMEvarW = XTextWidth(mfinfo,"------------",11)+3*QBOXFR+2*QBOXBORD;
   ZMEvarWs = XTextWidth(mfinfo,"--------",8)+3*QBOXFR+2*QBOXBORD;
   ZMEiz4W = XTextWidth(mfinfo,"-",1)+3*QBOXFR+2*QBOXBORD;
   ZMEiz   = ZMEanW+ZMETab2+ZMEvarW+ZMETab3;
   ZMEizs  = ZMEvarWs;
   ZMEZWIDE = ZMEBord + ZMETab1 + 3*ZMEiz + ZMEiz4W + ZMEBord;

   XMapWindow(display,ZMEwin);


   DefBut(&ZMEbut[ZMECANC], ZMEwin, ZMEZOffx+ZMEZWIDE+ZMESCR-30, 5, 
	50, 23, "Close", infobg, ZMBCOL);
   ZMEbut[ZMECANC].explstr = "Close the Z-Matrix window";

   DefBut(&ZMEbut[ZMEARR1], ZMEwin, ZMEZOffx+ZMEZWIDE+ZMESCR, ZMEZOffy , 
	23, 23, " ", infobg, 0);
   DefBut(&ZMEbut[ZMEARR2], ZMEwin, ZMEZOffx+ZMEZWIDE+ZMESCR, 
	ZMEZOffy+ZME_window_high*ZMEQHIGH+ZMEBord-22, 23, 23, " ", infobg, 0);
 
   DefBut(&ZMEbut[ZMEAPPL], ZMEwin, ZMEZOffx, ZMEButOffy, 
	ZMEBW2, 23, "Apply Changes to current Z-Mat", infobg, ZMBCOL);
   ZMEbut[ZMEAPPL].explstr = "Update on screen structure by applying the current Z-matrix\nHitting Enter/Return in the variable fields has the same effect";

   DefBut(&ZMEbut[ZMECAN1], ZMEwin, ZMEZOffx, ZMEButOffy+ZMEBWIDE, 
	ZMEBW4, 23, "Cancel Changes", infobg, ZMBCOL);
   ZMEbut[ZMECAN1].explstr = "Cancel non-applied changes";

   DefBut(&ZMEbut[ZMEREVT], ZMEwin, 2*ZMEZOffx+ZMEBW4, ZMEButOffy+ZMEBWIDE, 
	ZMEBW4, 23, "Undo Changes", infobg, ZMBCOL);
   ZMEbut[ZMEREVT].explstr = "Revert to last Z-matrix\n";

   DefBut(&ZMEbut[ZMEDEL], ZMEwin, ZMEZOffx, ZMEButOffy+2*ZMEBWIDE, 
	ZMEBW4, 23, "Delete Line", infobg, ZMBCOL);
   ZMEbut[ZMEDEL].explstr = "Delete a line from Z-matrix ==\nDelete an atom/dummy from the structure:\nLines can ONLY be removed when no other lines\nuse it as reference.\nIf there are references, remove those first";

   DefBut(&ZMEbut[ZMEADD], ZMEwin, 2*ZMEZOffx+ZMEBW4, ZMEButOffy+2*ZMEBWIDE, 
	ZMEBW4, 23, "Add Line", infobg, ZMBCOL);
   ZMEbut[ZMEADD].explstr = "Add line to Z-matrix ==\nAdd an atom/dummy to your structure";

   DefBut(&ZMEbut[ZMEFRG], ZMEwin, ZMEZOffx, ZMEButOffy+3*ZMEBWIDE, 
	ZMEBW2, 23, "Substitute atom by Fragment", infobg, ZMBCOL);
   ZMEbut[ZMEFRG].explstr = "Substitute active atom/line\nby the fragment you select";
   ZMEbut[ZMEFRG].style = 1;

   DefBut(&ZMEbut[ZMENEW], ZMEwin, ZMEZOffx, ZMEButOffy+4*ZMEBWIDE, 
	ZMEBW4, 23, "New Z-mat", infobg, ZMBCOL);
   ZMEbut[ZMENEW].explstr = "Clear Z-Matrix.\nSame as start with empty structure";
   DefBut(&ZMEbut[ZMEMAP], ZMEwin, 2*ZMEZOffx+ZMEBW4, ZMEButOffy+4*ZMEBWIDE, 
	ZMEBW4, 23, "MapXYZ/Optimise", infobg, ZMBCOL);
   ZMEbut[ZMEMAP].explstr = "Convert a structure from file to the current Z-matrix.\nUseful if the optimised structure is only available as XYZ.\nBut you need it as Z-matrix\nAlso interfaces to external optimisers are available";
	
   DefBut(&ZMEbut[ZMECVAR], ZMEwin, ZMEZOffx+ZMEWINW/2, ZMEButOffy, 
	ZMEBW2, 23, "Set Status All Variables", infobg, ZMBCOL);
   ZMEbut[ZMECVAR].explstr = "Treat all bond distances, bond angles and dihedral angles\neither as variable or constant.\nIndividual variables can be set by cicking\nwith the second mouse button in the variable field";

   DefBut(&ZMEbut[ZMEORD],  ZMEwin, ZMEZOffx+ZMEWINW/2, ZMEButOffy+2*ZMEBWIDE,
	ZMEBW2, 23, "Reorder Z-matrix", infobg, ZMBCOL);
   ZMEbut[ZMEORD].explstr = "Reorder the Z-matrix by clicking on screen atoms\nin the order you want the Z-matrix to be\nYou can abort the specification after any number of clicked atoms\nMolden will supply the remaining ones";

   DefBut(&ZMEbut[ZMESEL], ZMEwin, ZMEZOffx+ZMEWINW/2, ZMEButOffy+3*ZMEBWIDE, 
	ZMEBW4, 23, "Select by pointer", infobg, ZMBCOL);
   ZMEbut[ZMESEL].explstr = "Select a substructure of on screen atoms of which a Z-matrix will be generated\nSelecting: click first mouse button,\ndrag while keeping the mouse button pressed.\nUse in combination with DeSelect and Apply Selection";

   DefBut(&ZMEbut[ZMEUSEL],ZMEwin, 2*ZMEZOffx+ZMEWINW/2+ZMEBW4, 
	ZMEButOffy+3*ZMEBWIDE, ZMEBW4, 23, "DeSelect", infobg,ZMBCOL);
   ZMEbut[ZMEUSEL].explstr = "Deselect on screen atoms of which a Z-matrix will be generated\nSelecting: click first mouse button,\ndrag while keeping the mouse button pressed.\nUse in combination with Select by pointer and Apply Selection";

   DefBut(&ZMEbut[ZMESELA],ZMEwin, ZMEZOffx+ZMEWINW/2, ZMEButOffy+4*ZMEBWIDE, 
	ZMEBW2, 23, "Apply Selection", infobg, ZMBCOL);
   ZMEbut[ZMESELA].explstr = "Generate Z-matrix of selected on screen atoms.\nUse in combination with Select by pointer and DeSelect";

   DefBut(&ZMEbut[ZMEGAM], ZMEwin, ZMEZOffx+75,ZMEWOffy+ZMEWBOFF , 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEbut[ZMEGAM].explstr = "In combination with the Write Z-Matrix button:\nWrite the Z-matrix in Gamess format.\nIn combination with the Submit Job button\nSubmit a Gamess job";

   DefBut(&ZMEbut[ZMEGAU], ZMEwin, ZMEZOffx+155,ZMEWOffy+ZMEWBOFF, 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEbut[ZMEGAU].explstr = "In combination with the Write Z-Matrix button:\nWrite the Z-matrix in Gaussian format.\nIn combination with the Submit Job button\nSubmit a Gaussian job";

   DefBut(&ZMEbut[ZMEMOP], ZMEwin, ZMEZOffx+245,ZMEWOffy+ZMEWBOFF, 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEbut[ZMEMOP].explstr = "In combination with the Write Z-Matrix button:\nWrite the Z-matrix in MOPAC format.\nIn combination with the Submit Job button\nSubmit a MOPAC job";

   DefBut(&ZMEbut[ZMENWC], ZMEwin, ZMEZOffx+315,ZMEWOffy+ZMEWBOFF, 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEbut[ZMENWC].explstr = "In combination with the Write Z-Matrix button:\nWrite the Z-matrix in NWCHEM format.\nIn combination with the Submit Job button\nSubmit a NWCHEM job";

   DefBut(&ZMEbut[ZMECAR], ZMEwin, ZMEZOffx+400,ZMEWOffy+ZMEWBOFF, 23, 23, 
        	   " ", infobg, ZMBCOL);
   DefBut(&ZMEbut[ZMEWRT], ZMEwin, ZMEZOffx,ZMEWOffy+10, ZMEBW2, 23, 
        	   "Write Z-Matrix", infobg, ZMBCOL);
   ZMEbut[ZMEWRT].explstr = "Write the current Z-Matrix\nIn combination with the format buttons";

   DefBut(&ZMEbut[ZMESUB], ZMEwin, ZMEZOffx+ZMEWINW/2,ZMEWOffy+10, 
		ZMEBW2, 23, "Submit Job", infobg, ZMBCOL);
   ZMEbut[ZMESUB].explstr = "Submit a Gaussian/Gamess/MOPAC job\nIn combination with the format buttons";

   DefBut(&ZMEBbut[ZMESIN], ZMEwin, ZMEZOffx+145,ZMEButOffy , 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEBbut[ZMESIN].explstr = "Select bond distance and bond angle for a single bond";

   DefBut(&ZMEBbut[ZMEDBL], ZMEwin, ZMEZOffx+145,ZMEButOffy+ZMEBWIDE, 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEBbut[ZMEDBL].explstr = "Select bond distance and bond angle for a double bond";

   DefBut(&ZMEBbut[ZMETRI], ZMEwin, ZMEZOffx+145,ZMEButOffy+2*ZMEBWIDE, 23, 23, 
        	   " ", infobg, ZMBCOL);
   ZMEBbut[ZMETRI].explstr = "Select bond distance and bond angle for a triple bond";

   DefBut(&ZMEswitch[0], ZMEwin, ZMEZOffx+ZMEZWIDE+ZMESCR-110,
	ZMEZOffy-ZMEFRBord+ZMEZHIGH-TOGGWH-1, TOGGWH, TOGGWH, " ", infobg, ZMBCOL);

   DefBut(&ZMEswitch[1], ZMEwin, ZMEZOffx+ZMEZWIDE+ZMESCR-55,
	5, 23, 23, " ", infobg, ZMBCOL);

   ZMEswitch[1].pix = BigPix;
   ZMEswitch[1].pw  = bigsmall_width;
   ZMEswitch[1].ph  = bigsmall_height;

   DefBut(&ZMEbut[ZMEUS], ZMEwin, ZMEZOffx+105,ZMEWOffy+ZMEWBOFF+18 , 15, 15, 
        	   " ", infobg, ZMBCOL);
   ZMEbut[ZMEUS].explstr = "Switch between Gamess-UK and Gamess-US format";

   ActBut(&ZMEbut[ZMEopt],-1);
   TogDown(&ZMEbut[ZMEopt]);
   ActBut(&ZMEBbut[ZMEmul],-1);
   TogDown(&ZMEBbut[ZMEmul]);
   if (ZMEAA) {
	TogUp(&ZMEswitch[0]);
   } else {
	TogDown(&ZMEswitch[0]);
   }
   if (ZMEbig) {
	TogUp(&ZMEswitch[1]);
   } else {
	TogDown(&ZMEswitch[1]);
   }
   if (SUBup) TogDown(&ZMEbut[ZMESUB]);
   ZMEbut[ZMEARR1].pix = upPix;
   ZMEbut[ZMEARR1].pw  = up_width;
   ZMEbut[ZMEARR1].ph  = up_height;
 
   ZMEbut[ZMEARR2].pix = downPix;
   ZMEbut[ZMEARR2].pw  = down_width;
   ZMEbut[ZMEARR2].ph  = down_height;

   qboxstr(&qboxes[QBZMAT],&ZMEwin,0,0,190,ZMEZOffx,ZMEWOffy+40,
      ZMEZWIDE,QBOXHIGH,2,"File name ? ",NULL,0,0,470,0,dummyproc);

   qboxstr(&EXPbox[0],&ZMEwin,0,0,190,ZMEZOffx+225,ZMEZOffy-ZMEFRBord+
	   ZMEZHIGH-TOGGWH,130,QBOXHIGH-9,2,"Expr.",NULL,10,0,2000,-1,dummyproc);
   if (ZMEAA) EXPbox[0].fake = 0;
   else EXPbox[0].fake = 1;

   for (i=0; i < TABBUTN; i++) {
	if (i==TABBUTN-1)
   	DefBut(&TabBut[i],ZMEwin, ZMEZOffx+ZMEBord+TabPos[i][1]*(ZMETABH+1), ZMEZOffy+ZMEBord+TabPos[i][0]*(ZMETABH+1), ZMETABH, ZMETABH, 
        	   elements[99], infobg, -elmptr->icol[98]);
	else
   	DefBut(&TabBut[i],ZMEwin, ZMEZOffx+ZMEBord+TabPos[i][1]*(ZMETABH+1), ZMEZOffy+ZMEBord+TabPos[i][0]*(ZMETABH+1), ZMETABH, ZMETABH, 
        	   elements[i+1], infobg, -elmptr->icol[i]);
   }

   SetQZME();

   DefScroll(&zscroll,ZMEwin,ZMEZOffx+ZMEZWIDE+ZMESCR,ZMEZOffy+22,22,
             ZME_window_high*ZMEQHIGH+ZMEBord-2*22,zmptrp->nz,
	    &ZME_window_pos,ZME_window_high,NULL);

   strcpy(ZMEerr,"Use Mouse Button 2 to change the status of a variable");

   if (ZMEAA) make_aa();
}

void UnMapZME()
{
	int nw;

	SwitchOffAnim();
	TogUp(&cbut[BZMAT]);
	ZMEup = 0;
	XUnmapWindow(display,ZMEwin);
	ZoomEnable = False; ZoomSelection = False;
	DeActZME(); 
	ActBut(&cbut[BDIST],1);
	ActBut(&cbut[BANGLE],1);
	ActBut(&cbut[BDIHED],1);
        if (*backb) {ActBut(&cbut[BDECRF],1); ActBut(&cbut[BUNSC],1);}
        ActBut(&cbut[BREADF],1);
        if (denm) ActBut(&cbut[BDENMOD],1);
#ifdef DOGL
	if ((*fancy || *fullgl) && has_opengl) ogunsel();
#endif

#if defined(VMS) || defined(UNDERSC)
        haswat(&nw);
#else
#ifdef CRAY
        HASWAT(&nw);
#else
        haswat_(&nw);
#endif
#endif
	if (nw != nwater[istruct])  {
	   reswat();
#ifdef DOGL
	   if (*fancy) {
	      oghet(0);
	   } else {
	      oglines();
	   }
#endif
	}
#ifdef DOGL
	dispsf();
#endif
}

void RedrawZME()
{
   int i,ZMEx,ZMEy;

   if (!ZMEup) return;

   ZMEy = 20;
   ZMEx = ZMEZOffx + ZMEBord + 5;
   XDrawString(display,ZMEwin,gc,ZMEx,ZMEy,"Atom",4);
   ZMEx = ZMEx + ZMETab1 + ZMEconW + ZMETab2;

   if (monoscr) {
       XSetFillStyle(display, gc, FillStippled);
       XSetStipple(display, gc, hlfgrey);
       XSetForeground(display, gc, infobg);
       XFillRectangle(display, ZMEwin, gc, 0, ZMEZOffy-ZMEFRBord, ZMEWINW, ZMEZHIGH+1);
       XSetFillStyle(display,gc,FillSolid);}
   else {
	butje(ZMEwin,0,0,ZMEWINW-1,ZMEZOffy-ZMEFRBord+1,1,0,0,1,None,0,0,0,0);
        XSetForeground(display, gc, infobg);
	butje(ZMEwin,0,ZMEZOffy-ZMEFRBord,ZMEWINW-1,ZMEZHIGH,1,0,0,1,None,0,0,0,0);
   }
   if (ZMEAA) {
	XDrawString(display,ZMEwin,gc,ZMEZOffx+ZMETab1+15+0*ZMEizs,45,"Phi",3);
	XDrawString(display,ZMEwin,gc,ZMEZOffx+ZMETab1+15+1*ZMEizs,45,"Psi",3);
	XDrawString(display,ZMEwin,gc,ZMEZOffx+ZMETab1+15+2*ZMEizs,45,"Chi1",4);
	XDrawString(display,ZMEwin,gc,ZMEZOffx+ZMETab1+15+3*ZMEizs,45,"Chi2",4);
	XDrawString(display,ZMEwin,gc,ZMEZOffx+ZMETab1+15+4*ZMEizs,45,"Chi3",4);
	XDrawString(display,ZMEwin,gc,ZMEZOffx+ZMETab1+15+5*ZMEizs,45,"Chi4",4);
   } else {
	XDrawString(display,ZMEwin,gc,ZMEx,ZMEy,"BondLength",10);
	XDrawString(display,ZMEwin,gc,ZMEx+ZMEiz,ZMEy,"BondAngle",9);
	XDrawString(display,ZMEwin,gc,ZMEx+2*ZMEiz,ZMEy,"DiHedral",8);
   }

   butje(ZMEwin,0,ZMEZOffy-ZMEFRBord+ZMEZHIGH-1,ZMEWINW/2+1,ZMEBHIGH,1,0,0,1,None,0,0,0,0);
   butje(ZMEwin,ZMEWINW/2,ZMEZOffy-ZMEFRBord+ZMEZHIGH-1,ZMEWINW/2,ZMEBHIGH,1,0,0,1,None,0,0,0,0);
   RedrawStatus();
   butje(ZMEwin,0,ZMEWOffy-3,ZMEWINW-1,ZMEWHIGH,1,0,0,1,None,0,0,0,0);

   butje(ZMEwin, ZMEZOffx+1, ZMEZOffy, ZMEZWIDE-1, ZME_window_high*ZMEQHIGH+ZMEBord+1,2,0,2,0,None,0,0,0,0);

   UpdateZME();

   if (ZMEsel || ZMEmode) {
   	for (i=0; i<3; i++) DrwBut(&ZMEBbut[i]);
	ULineString(ZMEwin, "Bond Length:", ZMEZOffx+3 ,ZMEButOffy+15);
	LineString(ZMEwin, "Single", ZMEZOffx+190  ,ZMEButOffy+15);
	LineString(ZMEwin, "Double", ZMEZOffx+190 ,ZMEButOffy+ZMEBWIDE+15);
	LineString(ZMEwin, "Triple", ZMEZOffx+190 ,ZMEButOffy+2*ZMEBWIDE+15);
	return;
   }

   if (pdb) LineString(ZMEwin, "Full Z-Mat", ZMEZOffx+ZMEZWIDE+ZMESCR-80,
	ZMEZOffy-ZMEFRBord+ZMEZHIGH-ZMETABA+16);

   RedrawScroll(&zscroll);
   for (i=0; i<ZMEBUTTS; i++) DrwBut(&ZMEbut[i]);
   if (pdb && ! *ialtyp) DrwBut(&ZMEswitch[0]);
   DrwBut(&ZMEswitch[1]);

   PromptBox(&qboxes[QBZMAT]);
   ULineString(ZMEwin, "New Z-mat from screen coordinates:", ZMEZOffx+ZMEWINW/2+5 ,ZMEButOffy+15+ZMEBWIDE);
   ULineString(ZMEwin, "Format:", ZMEZOffx ,ZMEWOffy+ZMEWBOFF+15);
   LineString(ZMEwin, "Gamess"           , ZMEZOffx+75+30 ,ZMEWOffy+ZMEWBOFF+15);
   LineString(ZMEwin, "US", ZMEZOffx+125 ,ZMEWOffy+ZMEWBOFF+30);
   LineString(ZMEwin, "Gaussian"         , ZMEZOffx+155+30 ,ZMEWOffy+ZMEWBOFF+15);
   LineString(ZMEwin, "Mopac"            , ZMEZOffx+245+30 ,ZMEWOffy+ZMEWBOFF+15);
   LineString(ZMEwin, "NWchem"           , ZMEZOffx+315+30 ,ZMEWOffy+ZMEWBOFF+15);
   LineString(ZMEwin, "Cartesian"        , ZMEZOffx+400+30 ,ZMEWOffy+ZMEWBOFF+15);
}

void RedrawStatus()
{

 if (!ZMEup) return;

 butje(ZMEwin,0,ZMEZOffy-ZMEFRBord+ZMEZHIGH+ZMEBHIGH-2,ZMEWINW-1,ZMESHIGH,1,0,0,1,None,0,0,0,0);
 butje(ZMEwin,ZMEZOffx,ZMEZOffy-ZMEFRBord+ZMEZHIGH+ZMEBHIGH+8,ZMEZWIDE,20,2,0,2,0,None,0,0,0,0);
 XSetForeground(display, gc, infobg);
 XDrawString(display,ZMEwin,gc,ZMEZOffx+5,ZMEZOffy-ZMEFRBord+ZMEZHIGH+ZMEBHIGH+22,ZMEerr,strlen(ZMEerr));
}

void UpdateZME()
{
   int i,j,k;
   int ZMEx,ZMEy,ZMESx,ZMESy;
   int isvis,isaa;

   if (DEBUG) fprintf(stderr,"UpdateZME in\n");
   if (!ZMEup) return;

   if (ZMEmode) {
	strcpy(ZMEerr,"Select Atom. Hit escape to abort");
	RedrawStatus();
	for (i=0; i<TABBUTN; i++) DrwBut(&TabBut[i]);
	return;
   }

   if (ZMEAA) {

	for (i=0; i<*zmptrp->nz; i++) {
	   BETbox[i].x = 0;
	   BETbox[i].y = 0;
	}

	zscroll.wn = &calfptr->ncalf;

	if (ZME_window_pos > calfptr->ncalf-1-ZME_window_high) {
	    if (calfptr->ncalf-1-ZME_window_high >= 0) {
		ZME_window_pos = calfptr->ncalf-ZME_window_high;
            } else ZME_window_pos = 0;
	}


        ZMESy = ZMEZOffy-ZMEFRBord+ZMEZHIGH-ZMETABA; 
        j = 0;
	for (i=0; i<calfptr->ncalf; i++) {

	   isvis = (i >= ZME_window_pos && i < ZME_window_pos + ZME_window_high);
	   if (isvis) {
		ZMEx = ZMEZOffx + ZMEBord - 3;
		ZMEy = ZMEZOffy + ZMEBord + (i - ZME_window_pos)*ZMEQHIGH;
		ZMESx = ZMEZOffx + ZMETab1 + 5 + j*ZMETABA;
	   } else {
		ZMEx = 0;
		ZMEy = 0;
	   }

           isaa = (*aaptr[i].iamino <= 23);

           if (isvis) {
		DefBut(&ZMEAAbut[j], ZMEwin, ZMEx, ZMEy, ZMEbutW, ZMETABH+2, 
        	   AminoAcids[*aaptr[i].iamino-1], infobg, 
		   -clfhptr->iamicl[*aaptr[i].iamino-1]);
		if (i == CurAmino) {
			ZMEAAbut[j].lastused = 1;
			ZMEAAbut[j].bg = 1;
		} else {
			ZMEAAbut[j].lastused = -1;
			ZMEAAbut[j].bg = 196;
		}
		DefBut(&ZMEAASbut[j], ZMEwin, ZMESx, ZMESy, ZMETABA, ZMETABA, 
        	   AAlet[*aaptr[i].iamino-1], infobg, 
		   -clfhptr->iamicl[*aaptr[i].iamino-1]);
		ZMEx = ZMEZOffx + ZMETab1 + 5 ;
		j++;
	   }

	   if (isaa) {
		BETbox[aaptr[i].phi].x = ZMEx;
		BETbox[aaptr[i].phi].y = ZMEy;
		if (isvis) PromptBox(&BETbox[aaptr[i].phi]);

		if (isvis) ZMEx = ZMEZOffx + ZMETab1 + 5 + 1*ZMEizs;
		BETbox[aaptr[i].psi].x = ZMEx;
		BETbox[aaptr[i].psi].y = ZMEy;
		if (isvis) PromptBox(&BETbox[aaptr[i].psi]);

		if (isvis) ZMEx = ZMEZOffx + ZMETab1 + 5 + 2*ZMEizs;
		if (aaptr[i].chi1 > -1) {
		   BETbox[aaptr[i].chi1].x = ZMEx;
		   BETbox[aaptr[i].chi1].y = ZMEy;
		   if (isvis) PromptBox(&BETbox[aaptr[i].chi1]);
		} else {
		   if (isvis) PFake(ZMEwin,ZMEx,ZMEy,ZMEvarWs,ZMEQHIGH,196);
		}

		if (isvis) ZMEx = ZMEZOffx + ZMETab1 + 5 + 3*ZMEizs;
		if (aaptr[i].chi2 > -1) {
		   BETbox[aaptr[i].chi2].x = ZMEx;
		   BETbox[aaptr[i].chi2].y = ZMEy;
		   if (isvis) PromptBox(&BETbox[aaptr[i].chi2]);
		} else {
		   if (isvis) PFake(ZMEwin,ZMEx,ZMEy,ZMEvarWs,ZMEQHIGH,196);
		}

		if (isvis) ZMEx = ZMEZOffx + ZMETab1 + 5 + 4*ZMEizs;
		if (aaptr[i].chi3 > -1) {
		   BETbox[aaptr[i].chi3].x = ZMEx;
		   BETbox[aaptr[i].chi3].y = ZMEy;
		   if (isvis) PromptBox(&BETbox[aaptr[i].chi3]);
		} else {
		   if (isvis) PFake(ZMEwin,ZMEx,ZMEy,ZMEvarWs,ZMEQHIGH,196);
		}

		if (isvis) ZMEx = ZMEZOffx + ZMETab1 + 5 + 5*ZMEizs;
		if (aaptr[i].chi4 > -1) {
		   BETbox[aaptr[i].chi4].x = ZMEx;
		   BETbox[aaptr[i].chi4].y = ZMEy;
		   if (isvis) PromptBox(&BETbox[aaptr[i].chi4]);
		} else {
		   if (isvis) PFake(ZMEwin,ZMEx,ZMEy,ZMEvarWs,ZMEQHIGH,196);
		}

	   } else {

		if (isvis) {
		   for (k=0; k<6; k++) {
			ZMEx = ZMEZOffx + ZMETab1 + 5 + k*ZMEizs;
			PFake(ZMEwin,ZMEx,ZMEy,ZMEvarWs,ZMEQHIGH,196);
		   }
		}
	   }
	}

        for (i=0; i<ZME_window_high; i++) {
	   if (i<calfptr->ncalf) {
		DrwBut(&ZMEAAbut[i]);
		DrwBut(&ZMEAASbut[i]);
	   }
	}
	ZMEx = ZMEZOffx + ZMEBord - 3;
        ZMESx = ZMEZOffx + ZMETab1;
        XSetForeground(display, gc, colors[190]);
	XFillRectangle(display, ZMEwin, gc,
                                ZMEx, ZMESy+3, 30, ZMETABA-4);
	sprintf(ZMEups,"%-4d",ZME_window_pos+1);
        XSetForeground(display, gc, colors[0]);
	XDrawString(display,ZMEwin,gc,ZMEx+5,ZMESy+17,ZMEups,4);
        EXPbox[0].fake = 0;
	PromptBox(&EXPbox[0]);

	return;
   }

   zscroll.wn = zmptrp->nz;

   if (ZME_window_pos > *zmptrp->nz-1-ZME_window_high) {
	if (*zmptrp->nz-1-ZME_window_high >= 0) {
	    ZME_window_pos = *zmptrp->nz-ZME_window_high;
        } 
	else ZME_window_pos = 0;
   }

   for (i=0; i<*zmptrp->nz; i++) {
	isvis = (i >= ZME_window_pos && i < ZME_window_pos + ZME_window_high);
	if (isvis) {
	   ZMEx = ZMEZOffx + ZMEBord;
	   ZMEy = ZMEZOffy + ZMEBord + (i - ZME_window_pos)*ZMEQHIGH;
	}
	else {
	   ZMEx = 0;
	   ZMEy = 0;
	}
	IANZbox[i].x = ZMEx;
	IANZbox[i].y = ZMEy;
	if (isvis) PromptBox(&IANZbox[i]);
	for (j=0; j<3; j++) {
		if (isvis) ZMEx = ZMEZOffx + ZMEBord + ZMETab1 + j*ZMEiz;
	   	IZbox[i*4+j].x = ZMEx;
	   	IZbox[i*4+j].y = ZMEy;
		if (isvis) PromptBox(&IZbox[i*4+j]);
		if (isvis) ZMEx = ZMEx + ZMEconW + ZMETab2;
		if (j == 0) {
	   	   BLbox[i].x = ZMEx;
	   	   BLbox[i].y = ZMEy;
		   if (isvis) PromptBox(&BLbox[i]);
		}
		else if (j == 1) {
	   	   ALPHbox[i].x = ZMEx;
	   	   ALPHbox[i].y = ZMEy;
		   if (isvis) PromptBox(&ALPHbox[i]);
		}
		else if (j == 2) {
	   	   BETbox[i].x = ZMEx;
	   	   BETbox[i].y = ZMEy;
		   if (isvis) PromptBox(&BETbox[i]);
		}
	}
	if (isvis) ZMEx = ZMEZOffx + ZMEBord + ZMETab1 + 3*ZMEiz;
	IZbox[i*4+3].x = ZMEx;
	IZbox[i*4+3].y = ZMEy;
	if (isvis) PromptBox(&IZbox[i*4+3]);
   }
   EXPbox[0].fake = 1;
   if (pdb) PFake(ZMEwin,ZMEZOffx+225,ZMEZOffy-ZMEFRBord+ZMEZHIGH-TOGGWH,130,
	QBOXHIGH-9, EXPbox[0].bgcol);
   if (DEBUG) fprintf(stderr,"UpdateZME out\n");
}

void QPcol(qp,iop)
QBOXSTRU *qp;
int iop;
{
    int icol;

    switch (iop) {
	case 0: icol = ZC_CONST; break;
	case 1: icol = ZC_VAR; break;
	default: icol = ZC_LINK;
    }
    qp->col = icol;
}

void SetConst(iop)
int iop;
{
 int i,icol;

    switch (iop) {
	case 0: icol = ZC_CONST; break;
	case 1: icol = ZC_VAR; break;
	default: icol = ZC_LINK;
    }
    for (i=0; i<*zmptrp->nz; i++) {
		zmptrp->ibl[i] = iop; 
		BLbox[i].col = icol; 
		BLbox[i].changed = 1;
		zmptrp->ialph[i] = iop; 
		ALPHbox[i].col = icol; 
		ALPHbox[i].changed = 1; 
		zmptrp->ibet[i] = iop; 
		BETbox[i].col = icol; 
		BETbox[i].changed = 1; 
    }
    UpdateZME();
}

void SetQZME()
{
   int i,j;
   int nvar,fake,zvw,zvwn;

   if (DEBUG) fprintf(stderr,"SetQZME in\n");

/*
   SetQZME updates on screen zmat information with the zmat-structure
*/

   if (!*zmptrp->ihaszm) return;

   strcpy(ZMEerr," ");
   for (i=0; i<*zmptrp->nz; i++) {
	   if (zmptrp->ianz[i] >= 0 && zmptrp->ianz[i] < 100) 
		sprintf(stemp,"%s",elements[zmptrp->ianz[i]]);
	   else sprintf(stemp,"%s","?");

	   qboxstr(&IANZbox[i],&ZMEwin,0,0,196,0,0,ZMEanW,ZMEQHIGH,
		    ZC_DEF,NULL,stemp,2,0,0,-1,dummyproc);
	   IANZbox[i].explstr = IANZstr;
	   nvar = 3; if (i <= 2) nvar = i;
	   for (j=0; j<3; j++) {
		fake = 1;
		if (j<nvar) fake = 0;
		sprintf(stemp,"%d",izz(i,j));
		qboxstr(&IZbox[i*4+j],&ZMEwin,0,fake,196,0,0,ZMEconW,ZMEQHIGH,
		     ZC_CONN,NULL,stemp,5,1,0,-1,dummyproc);
		IZbox[i*4+j].explstr = IZstr;
		if (j == 0) {
	   	   sprintf(stemp,zmeblform[ZMEAA],zmptrp->bl[i]);
	   	   qboxstr(&BLbox[i],&ZMEwin,0,fake,196,0,0,ZMEvarW,ZMEQHIGH,
		     ZC_DEF,NULL,stemp,11,2,0,-1,dummyproc);
		   QPcol(&BLbox[i],zmptrp->ibl[i]);
		   BLbox[i].explstr = BLstr;
		}
		else if (j == 1) {
	   	   sprintf(stemp,zmeform[ZMEAA],zmptrp->alph[i]);
	   	   qboxstr(&ALPHbox[i],&ZMEwin,0,fake,196,0,0,ZMEvarW,ZMEQHIGH,
		     ZC_DEF,NULL,stemp,11,2,0,-1,dummyproc);
		   QPcol(&ALPHbox[i],zmptrp->ialph[i]);
		   ALPHbox[i].explstr = ALPHstr;
		}
		else if (j == 2) {
		   zvw = ZMEvarW; zvwn = 11;
                   if (ZMEAA) {
			zvw = ZMEvarWs;
			zvwn = 8;
		   }
	   	   sprintf(stemp,zmeform[ZMEAA],zmptrp->bet[i]);
	   	   qboxstr(&BETbox[i],&ZMEwin,0,fake,196,0,0,zvw,ZMEQHIGH,
		     ZC_DEF,NULL,stemp,zvwn,3,0,-1,dummyproc);
		   QPcol(&BETbox[i],zmptrp->ibet[i]);
		   BETbox[i].explstr = BETstr;
		}
	   }
	   fake = 1;
	   if (i > 2) fake = 0;
	   sprintf(stemp,"%d",izz(i,3));
	   qboxstr(&IZbox[i*4+3],&ZMEwin,0,fake,196,0,0,ZMEiz4W,ZMEQHIGH,
	       ZC_CONN,NULL,stemp,1,1,0,-1,dummyproc);
   }
   if (DEBUG) fprintf(stderr,"SetQZME out\n");
}


#if defined(VMS) || defined(UNDERSC)
void upzme()
#else
#ifdef CRAY
void UPZME()
#else
void upzme_()
#endif
#endif
{
/* for the convenience of fortran */


  if (!xison) return;

	SetQZME();
	if (ZME_window_pos >= *zmptrp->nz) ZME_window_pos = 0;
	if (*zmptrp->nz < ZME_window_high) RedrawZME();
	else {
	   UpdateZME();
	   if (ZMEup) RedrawScroll(&zscroll);
	}
}

void GetQZME()
{
   int i,j;
   int nvar,found;

   if (DEBUG) fprintf(stderr,"GetQZME in\n");

/*
Textual zmat to numeric
*/

   for (i=0; i<*zmptrp->nz; i++) {

	   found = 0;
	   for (j=0; j<100; j++) {
		if (strcasecmp(IANZbox[i].str,elements[j]) == 0) {
		    found = 1;
		    zmptrp->ianz[i] = j;
		}
	   }
	   if (strcasecmp(IANZbox[i].str,"XX") == 0) {
		found = 1;
		zmptrp->ianz[i] = 99;
	   }
	   if (!found) {
		ActOnErr(i,0,"ZMAT NOT parsed: Unrecognised Atom Name !");
		return;
	   }

	   nvar = 3; if (i <= 2) nvar = i;
	   for (j=0; j<nvar; j++) {

		if (strlen(IZbox[i*4+j].str)) 
		    sscanf(IZbox[i*4+j].str,"%d",pizz(i,j));
		else {
		    ActOnErr(i,4+j,"ZMAT NOT parsed: Empty string !");
		    return;
		}

		switch (j) {
		case 0:

		    if (zmptrp->ibl[i] > 1) {
			zmptrp->bl[i] = zmptrp->bl[zmptrp->ibl[i] - 1];
			strcpy(BLbox[i].str,BLbox[zmptrp->ibl[i] - 1].str);
		    } else {
			if (BLbox[i].changed) {
	   		    if (strlen(BLbox[i].str)) 
				sscanf(BLbox[i].str,"%lf",&zmptrp->bl[i]);
			    else {
				ActOnErr(i,1,"ZMAT NOT parsed: Empty string !");
				return;
			    }
			    BLbox[i].changed = 0;
			}
		    }
		    break;
		case 1:

		    if (zmptrp->ialph[i] > 1) {
			zmptrp->alph[i] = zmptrp->alph[zmptrp->ialph[i] - 1];
			strcpy(ALPHbox[i].str,ALPHbox[zmptrp->ialph[i] - 1].str);
		    } else {
			if (ALPHbox[i].changed) {
	   		    if (strlen(ALPHbox[i].str)) 
				sscanf(ALPHbox[i].str,"%lf",&zmptrp->alph[i]);
			    else {
				ActOnErr(i,2,"ZMAT NOT parsed: Empty string !");
				return;
			    }
			    ALPHbox[i].changed = 0;
			}
		    }
		    break;
		case 2:
		    if (ABS(zmptrp->ibet[i]) > 1) {
			if (zmptrp->ibet[i] > 0) {
			    zmptrp->bet[i] = zmptrp->bet[zmptrp->ibet[i] - 1];
			    strcpy(BETbox[i].str,BETbox[zmptrp->ibet[i] - 1].str);
			} else {
			    zmptrp->bet[i] = -zmptrp->bet[ABS(zmptrp->ibet[i]) - 1];
			    sprintf(stemp,"%f",zmptrp->bet[i]);
			    strcpy(BETbox[i].str,stemp);
			}
		    } else {
			if (BETbox[i].changed) {
	   		    if (strlen(BETbox[i].str)) 
				sscanf(BETbox[i].str,"%lf",&zmptrp->bet[i]);
			    else {
				ActOnErr(i,3,"ZMAT NOT parsed: Empty string !");
				return;
			    }
			    BETbox[i].changed = 0;
			}
		    }
		    break;
		}
	   }
	   if (i > 2) {
		sscanf(IZbox[i*4+3].str,"%d",pizz(i,3));
	   }
   }
   if (DEBUG) fprintf(stderr,"GetQZME out\n");
}

void ActOnErr(zline,boxnum,errstr)
int zline;
int boxnum;
char *errstr;
{
    if (zline >= 0) {
	ZME_window_pos = zline;
	IANZbox[zline].col = ZC_AT1;
	switch(boxnum) {
	case 0: IANZbox[zline].active = 1; break;
	case 1: BLbox[zline].active = 1; break;
	case 2: ALPHbox[zline].active = 1; break;
	case 3: BETbox[zline].active = 1; break;
	case 4: IZbox[zline*4].active = 1; break;
	case 5: IZbox[zline*4+1].active = 1; break;
	case 6: IZbox[zline*4+2].active = 1; break;
	case 7: IZbox[zline*4+3].active = 1; break;
	}
	UpdateZME();
	RedrawScroll(&zscroll);
    }
#if !defined(DARWIN)
    strcpy(ZMEerr,errstr);
#endif
    RedrawStatus();
}

int MapAtom(jxyz)
int jxyz;
{
int j;

    for (j=0; j<*zmptrp->nz; j++) {
	if (jxyz == zmptrp->imap[j]) {
	    return j;
	}
    }
    return (-1);

}

float CalcBL(mult,atomnr1,atomnr2)
int atomnr1;
int atomnr2;
int mult;
{
  int iptr1,iptr2;
  float BL;

    iptr1 = FindInd(atomnr1,DisAtoms,NUMDIS);
    iptr2 = FindInd(atomnr2,DisAtoms,NUMDIS);

    if (iptr1 > -1 && iptr2 > -1) {
	switch (mult) {
	case 0: BL = SingleDis[iptr1][iptr2]; break;
	case 1: BL = DoubleDis[iptr1][iptr2]; break;
	case 2: BL = TripleDis[iptr1][iptr2]; break;
	}
	strcpy(ZMEerr,"Bondlength from literature");
    }
    else {
	BL = (elmptr->vdwr[atomnr1-1] + elmptr->vdwr[atomnr2-1])*0.98;
	strcpy(ZMEerr,"Bondlength estimated from Van der Waals Radii");
    }
    return BL;

}

void FirstLine()
{

	*zmptrp->nz = 1;
	xyzp->ianz[0] = zmptrp->ianz[0];
	zmptrp->imap[0] = 1;
	*xyzp->iatoms = 1;
	xyzp->coo[0] = 0.0;
	xyzp->coo[1] = 0.0;
	xyzp->coo[2] = 0.0;
	xyzp->iconn[0] = 0;
	xyzp->iaton[0] = 1;
	scalptr->scali = 3.5;
	scalptr->scal = 2.5*scalptr->scali;
	ZME_window_pos = 0;
#if defined(VMS) || defined(UNDERSC)
	strot(rotptr->rx,rotptr->ry,rotptr->rz);
#else
#ifdef CRAY
	STROT(rotptr->rx,rotptr->ry,rotptr->rz);
#else
	strot_(rotptr->rx,rotptr->ry,rotptr->rz);
#endif
#endif
	update_sel = 1;
}

int GetRes(atomnr,iph,opt,Asel)
int atomnr;
short int *iph;
int opt;
int Asel;
{
  int irt,irtt,n,i,ii,nt,nh[3];
  short int ipt;

  *iph = 0; irt = NHETRES;

  if (*ipdbon && !*ialtyp) {

#if defined(VMS) || defined(UNDERSC)
	numhed(&irt,xyzp->iresid);
#else
#ifdef CRAY
	NUMHED(&irt,xyzp->iresid);
#else
	numhed_(&irt,xyzp->iresid);
#endif
#endif
	if (irt != calfptr->ishoh) irt++; 
	irt++;
/* one extra incr irt because NUMHED does not see waters in zmat editor 
  after complte incomplte residues it does however */
	irt = -irt;

	irtt = xyzp->iresid[Asel];

	if (irtt > 0) {

/* attach to residue atom */

		if (atomnr == 1) {

		/* attach H to residue atom */

		   ipt = xyzp->ipdbt[Asel];
		   switch (calfptr->iamino[irtt-1]) {
		   case 3:
		   /* serine */
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			case 31:
			   *iph = 10;
			   irt = irtt;
			   break;
			}
			break;
		   case 5:
		   /* threonine */
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			case 31:
			   *iph = 10;
			   irt = irtt;
			   break;
			case 32:
			   *iph = 13;
			   irt = irtt;
			   break;
			}
			break;
		   case 4:
		   /* cysteine */
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			case 37:
			   *iph = 10;
			   irt = irtt;
			   break;
			}
			break;
		   case 9:
		   /* asparate */
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			case 29:
			   *iph = 22;
			   irt = irtt;
			   break;
			case 30:
			   *iph = 25;
			   irt = irtt;
			   break;
			}
			break;
		   case 13:
		   /* glutamate */
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			case 34:
			   *iph = 31;
			   irt = irtt;
			   break;
			case 35:
			   *iph = 34;
			   irt = irtt;
			   break;
			}
			break;
		   case 17:
		   /* histidine */
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			case 20:
			   *iph = 22;
			   irt = irtt;
			   break;
			case 24:
			   *iph = 34;
			   irt = irtt;
			   break;
			}
			break;
		   case 19:
		   /* tyrosine */
			switch (ipt) {
			case 33:
			   *iph = 52;
			   irt = irtt;
			   break;
			}
			break;
		   default:
			switch (ipt) {
			case 1:
			   *iph = 1;
			   irt = irtt;
			   break;
			}
			break;
		   }
		}
		if (*iph == 1) {
		   for (i=0; i < 3; i++) nh[i] = 0;
		   n = xyzp->iconn[Asel*(MXCON+1)];
		   for (i=0; i < n; i++) {
			ii = xyzp->iconn[Asel*(MXCON+1)+i+1];
			if (ii > 0) {
			    if (xyzp->ianz[ii-1] == 1) {
				nt = (int) xyzp->ipdbt[ii-1];
				if (nt >= 1 && nt <= 3) {
				   nh[nt-1] = 1;
				}
			    }
			}
		   }
		   for (i=0; i < 3; i++) {
			if (nh[i] == 0) {
			   *iph = i+1;
			   break;
			}
		   }
		}

	} else {

/* attach to NON residue atom */

		irt = irtt;
	}
	if (opt) {
	   if (irtt > 0 && irt != irtt) {

	     if (hetptr.NHetAtm < MXHETA) {
		calfptr->ihet[hetptr.NHetAtm] = 1;
		hetptr.Allocated[hetptr.NHetAtm] = 1;
		hetptr.HetAtm[hetptr.NHetAtm] = (char *) malloc(8);
		sprintf(stemp,"%s.Mod",AAlet[calfptr->iamino[irtt-1]-1]);
		strcpy(hetptr.HetAtm[hetptr.NHetAtm],stemp);
		hetptr.NHetAtm++;
	     }
	   }
	}
  }

  return(irt);
}

void AddLine(atomnr,activate,Asel,dist,covang,dihang,multip)
int atomnr;
int activate;
int *Asel;
float *dist;
float *covang;
float *dihang;
int multip;
{
  int i,j,fake,nvar,ioke,irt,irtt,row;
  int iptr1,iptr3,izptr;
  int hit,nhits;
  float angle[2],angtmp,dis,dihtmp;
  short int ipt,iph;

/*
  AddLine receives an atom to be connected to 3 atoms defined by asel
  and parses new zmat
*/

  iph = 0;
  ioke =1;
  if (*zmptrp->nz >= *zmptrp->mxzat - 1) {
	ioke = 0;
	if (AllocZMat(*xyzp->mxnat,ZERO)) ioke = 1;
  }
  if (!ioke) return;

  if (!mapchk()) map_prop();

  izptr = *zmptrp->nz;

  if (Asel != NULL) {
	irt = GetRes(atomnr,&iph,1,Asel[0]);
  } else {
	irt = NHETRES;
  }

  if (iph) {
	int imxt,imnt,ipartt;

	imxt = zmpart->imx; imnt = zmpart->imn; ipartt = zmpart->ipart;
	FindZRange(irt);
	row = zmpart->imx;
	zmpart->imx = imxt; zmpart->imn = imnt; zmpart->ipart = ipartt;
	InsertEmptyLines(0,row,1,0,0,NULL);
	izptr = row;
  }

  if (ZMEup) {

	qboxstr(&IANZbox[izptr],&ZMEwin,0,0,196,0,0,ZMEanW,ZMEQHIGH,
		    ZC_DEF,NULL,elements[atomnr],2,0,0,-1,dummyproc);
	zmptrp->ianz[izptr] = atomnr;
	if (activate) {
	    IANZbox[izptr].col = ZC_AT1;
	    IANZbox[izptr].active = 1;
	}

	nvar = 3; if (izptr <= 2) nvar = izptr;
	for (j=0; j<3; j++) {
	    fake = 1;
	    if (j<nvar) fake = 0;
	    qboxstr(&IZbox[izptr*4+j],&ZMEwin,0,fake,196,0,0,
		ZMEconW,ZMEQHIGH,ZC_CONN,NULL,NULL,3,1,0,-1,dummyproc);
	    switch (j) {
	    case 0: qboxstr(&BLbox[izptr],&ZMEwin,0,fake,196,0,0,
			ZMEvarW,ZMEQHIGH,ZC_DEF,NULL,NULL,11,2,0,-1,dummyproc);
		    break;
	    case 1: qboxstr(&ALPHbox[izptr],&ZMEwin,0,fake,196,0,0,
			ZMEvarW,ZMEQHIGH,ZC_DEF,NULL,NULL,11,2,0,-1,dummyproc);
		    break;
	    case 2: qboxstr(&BETbox[izptr],&ZMEwin,0,fake,196,0,0,
			ZMEvarW,ZMEQHIGH,ZC_DEF,NULL,NULL,11,3,0,-1,dummyproc);
		    break;
	    }
	}
	fake = 1;
	if (izptr > 2) fake = 0;
	qboxstr(&IZbox[izptr*4+3],&ZMEwin,0,fake,196,0,0,ZMEiz4W,ZMEQHIGH,
	       ZC_CONN,NULL,"0",1,1,0,-1,dummyproc);

	if (!nvar) {
	    GetQZME();
	    FirstLine();
	    return;
	}
/*
	connectivity
*/
	for (i = 0; i <4; i++) {
	    if (i == 3) {
		sizz(izptr,3,0);
	    } else {
		if (Asel[i] != -1) sizz(izptr,i, Asel[i] + 1);
	    }
	    sprintf(stemp,"%d",izz(izptr,i));
	    strcpy(IZbox[izptr*4+i].str,stemp);
	    IZbox[izptr*4+i].changed = 1;
	}

/*
	Bondlength
*/
	if (dist == NULL) {
	    dis = CalcBL(multip,zmptrp->ianz[izptr],zmptrp->ianz[Asel[0]]);
	} else dis = *dist;

	sprintf(BLbox[izptr].str,"%f",dis);
	zmptrp->bl[izptr] = (double) dis;
	BLbox[izptr].changed = 1;

/*
	BondAngle
*/
	angtmp = 109.471;
	if (covang == NULL) {
	    if (izz(Asel[1],0)-1 == Asel[0] &&
		izz(Asel[1],1)-1 == Asel[2] && izptr > 2) {
		if (ABS(zmptrp->alph[Asel[1]]-120.0) <=
		    ABS(zmptrp->alph[Asel[1]]-109.471)) angtmp = 120.0;
	    } else {
		for (i=0; i<izptr; i++) {
		    if (izz(i,0)-1 == Asel[0] &&
			izz(i,1)-1 == Asel[1] && izptr > 2) {
			if (ABS(zmptrp->alph[i]-120.0) <=
			   ABS(zmptrp->alph[i]-109.471)) angtmp = 120.0;
		    }
		}
	    }
	    switch (multip) {
	    case 0: break;
	    case 1: angtmp = 120.0; break;
	    case 2: angtmp = 179.0; break;
	    }
	}
	else angtmp = *covang;

	sprintf(ALPHbox[izptr].str,"%f",angtmp);
	zmptrp->alph[izptr] = (double) angtmp;
	ALPHbox[izptr].changed = 1;

/*
	DihedralAngle
*/
	if (dihang == NULL) {
	    nhits = 0;
	    for (j=0; j<izptr; j++) {
		hit = 1;
		for (i = 0; i <3; i++) {
		    if (izz(izptr,i) != izz(j,i)) {
			hit = 0;
		    }
		}
		if (hit) {
		    if (nhits < 2) angle[nhits] = zmptrp->bet[j];
		    nhits++;
		}
	    }

	    switch (nhits) {
	    case 0: iptr3 = izz(izptr,2);
		    if (izz(izptr,0) == izz(iptr3,0) &&
			izz(izptr,1) == izz(iptr3,1)) {
			if (angtmp == 120.0) dihtmp = 180.0;
			else dihtmp = 120.0;
		    } else dihtmp = 180.0;
		    break;
	    case 1: angtmp = angle[0]+120.0;
		    if (angtmp >= 360.0) angtmp = angtmp - 360.0;
		    dihtmp = angtmp;
		    break;
	    default:
	    case 2: angtmp = (angle[0] + angle[1])/2 + 180.0;
		    if (angtmp >= 360.0) angtmp = angtmp - 360.0;
		    dihtmp = angtmp;
		    break;
	    }
	}
	else dihtmp = *dihang;

	sprintf(BETbox[izptr].str,"%f",dihtmp);
	zmptrp->bet[izptr] = (double) dihtmp;
	BETbox[izptr].changed = 1;

        zmptrp->ibl[izptr] = 1;
        zmptrp->ialph[izptr] = 1;
        zmptrp->ibet[izptr] = 1;
        zmptrp->imap[izptr] = izptr+1;

        iptr1 = izptr;
	if (*ialtyp) iptr1 = iptr1 + *iscst;
        
	xyzp->ipdbt[iptr1] = iph;
	xyzp->iresid[iptr1] = irt;
	xyzp->ityp[iptr1] = 0;
	xyzp->iaton[iptr1] = 1;
	xyzp->iatclr[iptr1] = 1;

	(*zmptrp->nz)++;
	update_sel = 1;
	SetQZME();
  }
}

int SelZME(asel)
int *asel;
{
  int selMap[3];
  int i;
  float b,a,d;

/*
  SelZME receives an atom to be connected to 3 atoms defined by asel
  and parses new zmat
*/

  if (ZMEup && ZMEsel) {
	int minus = 0;
	for (i = 0; i <3; i++) {
	    selMap[i] = MapAtom(asel[i]);
	    if (selMap[i] == -1) minus = -1;
	}

	if (minus == -1) {
	    for (i = 0; i <3; i++) selMap[i] = asel[i]-1;
	}

	if (ZMEatom == 99) {
	   b = 1.0; a = 90.0; d = 180.0;
	   AddLine(ZMEatom,1,selMap,&b,&a,&d,ZMEmul);
	} else {
	   AddLine(ZMEatom,1,selMap,NULL,NULL,NULL,ZMEmul);
	}

	ActBut(&cbut[BDIST],1);
	ActBut(&cbut[BANGLE],1);
	ActBut(&cbut[BDIHED],1);
	ZMEsel = 0;
	ZME_window_pos = *zmptrp->nz-ZME_window_high;
	if (ZME_window_pos < 0) ZME_window_pos = 0;
	RedrawStatus();
	RedrawZME();
	*Sinct = 530;
	return(1);
  }
  return(0);
}

int GetRow(update)
int update;
{
    int type,row,column;

    activeZME(&type,&row,&column);
    if (type == -1 || row < 0) {
	if (type == -1 && update) {
	    strcpy(ZMEerr,"FRAGMENT NOT ADDED: no atom selected");
	}
	row = -1;
	if (update) RedrawStatus();
    } 
    return row;
}

void AddXH3(atnr,update) 
int atnr;
int update;
{
    int row,iptr1,irt,rest;
    int selMap[3];
    int isfirst;
    short int iph;

    isfirst = 0;
    if (!*zmptrp->nz) isfirst = 1;
    
    row = GetRow(1);
    if (row == -1) {
	if (isfirst) {
           AddLine(1,0,selMap,NULL,NULL,NULL,0);
           *zmptrp->nz = 1;
	   row = 0;
	   zmptr.ianz[0] = atnr;
	} else {
	   return;
	}
    }

    irt = NHETRES;
    rest = zmptrp->imap[row]-1;
    if (rest >= 0) irt = GetRes(atnr,&iph,1,rest);

    sizz(1,1,0);
    sizz(1,2,0);
    sizz(1,3,0);
    sizz(2,2,0);
    sizz(2,3,0);
    zmptrp->alph[1] = 0.0;
    zmptrp->bet[1] = 0.0;
    zmptrp->bet[2] = 0.0;

    *zmptrp->ihaszm = 1;

    switch(atnr) {
    case 6: strcpy(IANZbox[row].str,"C");break;
    case 7: strcpy(IANZbox[row].str,"N");break;
    }
    IANZbox[row].changed = 1;

    iptr1 = row;
    if (*ialtyp) iptr1 = iptr1 + *iscst;

    xyzp->ipdbt[iptr1] = 0;
    xyzp->ityp[iptr1] = 0;
    xyzp->iresid[iptr1] = irt;
    xyzp->iatclr[iptr1] = 1;
    xyzp->iaton[iptr1] = 1;
    update_sel = 1;

    if (*zmptrp->nz >1) {
	sprintf(BLbox[row].str,"%f",
	    CalcBL(0,atnr,zmptrp->ianz[izz(row,0)-1]));
	BLbox[row].changed = 1;
    }
    if (!isfirst) {
	GetQZME();
	DeActZME();
    }

    selMap[0] = row;
    if (row == 0) {
	selMap[1] = 1;
	selMap[2] = 2;
    } else if (row == 1) {
	selMap[1] = 0;
	selMap[2] = 2;
    } else {
	selMap[1] = izz(row,0)-1;
	selMap[2] = izz(row,1)-1;
    }
    AddLine(1,0,selMap,NULL,NULL,NULL,0);

    selMap[2] = *zmptrp->nz-1;

    switch(atnr) {
    case 6:	AddLine(1,0,selMap,NULL,NULL,NULL,0);
	        if (*zmptrp->nz == 3) selMap[2] = *zmptrp->nz-1;
    		AddLine(1,1,selMap,NULL,NULL,NULL,0);
		break;
    case 7:	AddLine(1,1,selMap,NULL,NULL,NULL,0);
		break;
    }

    if (update) {
	ZME_window_pos = *zmptrp->nz-ZME_window_high;
	if (ZME_window_pos < 0) ZME_window_pos = 0;

	RedrawZME();
	*Sinct = 530;
    }

}

#if defined(VMS) || defined(UNDERSC)
void cnvfrg(fraglen)
#else
#ifdef CRAY
void CNVFRG(fraglen)
#else
void cnvfrg_(fraglen)
#endif
#endif
int *fraglen;
{
    ZLINESTRU *frag;
    int frglen;
    int i,j,offset;

    frglen = *fraglen;

    frglen = *zmptrp->nz - frglen;
    *zmptrp->nz = *zmptrp->nz - frglen;

    if (!frglen) return;

    frag = (ZLINESTRU *) malloc((sizeof *frag)*frglen);

    for (i=0; i < frglen; i++) {
	offset = *zmptrp->nz + i;
	frag[i].ianz = zmptrp->ianz[offset];
	for (j=0; j < 3; j++) {
            frag[i].iz[j] = izz(offset,j);
	}
	frag[i].iz[3] = izz(offset,3);
	frag[i].bl = zmptrp->bl[offset];
	frag[i].alph = zmptrp->alph[offset];
	frag[i].bet = zmptrp->bet[offset];
    }
    AddFrag(frag,frglen,109.471,180.0,-1,1,1,1);
}

void scrfrg(ScrewNotTrans,nfrg)
int ScrewNotTrans;
int nfrg;
{
    ZLINESTRU *frag;
    int frglen;
    int i,j,offset,offhlp,xprev,xxprev;
    int scangle,iscangle;
    double *arr;

    if ((arr = (double *) malloc((sizeof *arr)*(*zmptrp->mxzat))) == NULL) 
	return;

    for (j=0; j<*zmptrp->nz; j++) {
	if (zmptrp->imap[j] > 0) {
	   arr[j] = xyzp->qat[zmptrp->imap[j]-1];
	} else {
	   arr[j] = 0.0;
	}
    }
    for (j=0; j<*zmptrp->nz; j++) xyzp->qat[j] = arr[j];

    if (ScrewNotTrans) {
	scangle = 180.0;
    } else {
	scangle = 0.0;
    }

    frglen = *zmptrp->nz;
    *zmptrp->nz = 0;

    if (!frglen) return;

    frag = (ZLINESTRU *) malloc((sizeof *frag)*frglen);


    for (i=0; i < frglen; i++) {
	offset = *zmptrp->nz + i;
	frag[i].ianz = zmptrp->ianz[offset];
	for (j=0; j < 3; j++) {
            frag[i].iz[j] = izz(offset,j);
	}
	frag[i].iz[3] = izz(offset,3);
	frag[i].bl = zmptrp->bl[offset];
	frag[i].alph = zmptrp->alph[offset];
	frag[i].bet = zmptrp->bet[offset];
    }
    *zmptrp->nz = 0;
    CopyFrag(SCREW,2,-1);
    CopyFrag(frag,frglen,-1);

    sizz(2,0,2);
    sizz(2,1,1);
    sizz(2,2,0);
    zmptrp->bl[2] = 1.08;
    if (!ScrewNotTrans) zmptrp->ibl[2] = 0;
    zmptrp->alph[2] = 90.0;
    zmptrp->ialph[2] = 0;
    zmptrp->bet[2] = 0.0;

    sizz(3,1,2);
    sizz(3,2,1);
    zmptrp->alph[3] = 120.0;
    zmptrp->bet[3] = 120.0;
    
    sizz(4,2,2);
    zmptrp->bet[4] = 120.0;

    for (j=0; j < *zmptrp->nz; j++) xyzp->iatclr[j] = 12;

    xyzp->qat[0] = 0.0;
    xyzp->qat[1] = 0.0;
    for (j=frglen-1; j >= 0; j--) {
	xyzp->iresid[j+2] = 1;
	xyzp->qat[j+2] = xyzp->qat[j];
    }

    xxprev = 1;
    xprev = 2;

    for (i=0; i < nfrg; i++) {

	offset = *zmptrp->nz;
	offhlp = offset;
	*zmptrp->nz = *zmptrp->nz + 1;
	zmptrp->ianz[offset] = 99;
	sizz(offset,0,xprev);
	sizz(offset,1,xprev + 1);
	sizz(offset,2,xxprev);
	zmptrp->bl[offset] = zmptrp->bl[1];
	zmptrp->ibl[offset] = 2;
	zmptrp->alph[offset] = 90.0;
	zmptrp->ialph[offset] = 0;
	zmptrp->bet[offset] = 180.0;
	zmptrp->ibet[offset] = 0;
        xyzp->qat[offset] = 0.0;

	offset++;

	CopyFrag(frag,frglen,3);

	sizz(offset,0,offset);
	sizz(offset,1,xprev);
	sizz(offset,2,xprev + 1);
	zmptrp->bl[offset] = zmptrp->bl[2];
	zmptrp->ibl[offset] = 3;
	zmptrp->alph[offset] = 90.0;
	zmptrp->ialph[offset] = 0;
	zmptrp->bet[offset] = scangle;
	if (i == 0) {
	   zmptrp->ibet[offset] = 0;
	   iscangle = offset + 1;
	} else {
	   zmptrp->ibet[offset] = iscangle;
	}
   
	offset++;

	sizz(offset,1,offset - 1);
	sizz(offset,2,xprev);
	zmptrp->alph[offset] = zmptrp->alph[3];
	zmptrp->ialph[offset] = 4;
	zmptrp->bet[offset] = zmptrp->bet[3];
	zmptrp->ibet[offset] = 4;
    
	offset++;
	sizz(offset,2,offset - 2);
	zmptrp->bet[offset] = zmptrp->bet[4];
	zmptrp->ibet[offset] = 5;

	xxprev = xprev;
	xprev = 2 + (1+frglen)*(i+1);

	for (j=offhlp; j < *zmptrp->nz; j++) xyzp->iatclr[j] = i + 1;

	for (j=frglen-1; j >= 0 ; j--) {
	   xyzp->iresid[j+offhlp+1] = i+1;
	   xyzp->qat[j+offhlp+1] =arr[j];
	}
    }

    for (j=0; j < *zmptrp->nz; j++) xyzp->iaton[j] = 1;
    update_sel = 1;

    DeActZME(); 

    *zmptrp->ihaszm = 1;

    SetQZME(); 

    ZME_window_pos = 0;

    if (*zmptrp->nz < ZME_window_high) RedrawZME();
    else UpdateZME();

#if defined(VMS) || defined(UNDERSC)
    dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
    doconn();docent();doclr();qupd();
#else
#ifdef CRAY
    DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
    DOCONN();DOCENT();doclr();QUPD();
#else
    dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
    doconn_();docent_();doclr();qupd_();
#endif
#endif

    free(arr);
}

void SetPDBArray(pdbt,frglen,value,offset)
int *pdbt;
int frglen;
int value;
int offset;
{
    int i,j;

    for (i=0; i<frglen; i++) {
	j = offset+i;
	if (j < *xyzp->mxnat) pdbt[j] = value;
    }
}

void CopyPDBTyp(pdbt,fragpdb,frglen,offset)
short int *pdbt;
short int *fragpdb;
int frglen;
int offset;
{
    int i,j;

    for (i=0; i<frglen; i++) {
	j = offset+i;
	if (j < *xyzp->mxnat) pdbt[j] = fragpdb[i];
    }
}

int AddAmino(iamin,addrow,aphi,apsi,omega,chi1,chi2,chi3,chi4,iconf,update,iadd)
int iamin;
int *addrow;
double aphi;
double apsi;
double *omega;
double *chi1;
double *chi2;
double *chi3;
double *chi4;
int iconf;
int update;
int iadd;
{
    int frglen;
    int i,isfirst,row,iret;
    int co,ca,nn,nz,amiami,sidechainstart;

    nz = *zmptrp->nz;

    iret = 1;
    if (nz > *zmptrp->mxzat-28) {
	iret = 0;
	if (AllocZMat(*xyzp->mxnat,ZERO)) iret = 1;
    }
    if (!iret) {
	if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
	     "No more room to add residues !",0)) { i = 0;}
	return(iret);
    }

    amiami = 0;
    isfirst = 0;
    if (!*zmptrp->nz) isfirst = 1;

/* Check if O is the right oxygen of the two connected to the C-terminus */

    co = ca = nn = -1;

    if (*addrow == -1) row = GetRow(0);
    else row = *addrow;
    if (!isfirst && row == -1) row = LastAmino;

    if (isfirst) {
	FirstLine();
	row = 0;
	nz = 1;
    } else {
	if (row == -1) {
	    row = GetRow(1); return(iret);
	} else {
	    if (zmptrp->ianz[row] == 8) {
		if (zmptrp->ianz[izz(row,0)-1] == 6) {
		   co = izz(row,0)-1;
		   if (izz(row,2) == row) {
			if (zmptrp->ianz[row-1] == 8) {
			    row--;
			    if (update) {
				DeActZME();
				IANZbox[row].active = 1;
			    }
			}
		   }
		   nn = row;
		   if (zmptrp->ianz[izz(co,0)-1] == 6)
			ca = izz(co,0)-1;
		}
	    }
	}
    }
    if (ca != -1 && co != -1 && nn != -1) amiami = 1;

    if (!pdb) {
	calfptr->nchain = 1;
	calfptr->ianf[0] = 1;
	pdb = 1;
	*ipdbon = 1;
	hbon = 0;
	ActBut(&cbut[BBACKB],1);
	cbut[BFORC].str = "Res.Comm.";
	cbut[BINCRF].str = "Residue";
	cbut[BDECRF].str = "HetAtm";
	cbut[BUNSC].str = " ";
	cbut[BHBOND].str = " ";
	cbut[BFORC].w = 80;
	cbut[BINCRF].w = 80;
	cbut[BDECRF].w = 80;
	cbut[BUNSC].w = TOGGWH;
	cbut[BHBOND].w = TOGGWH;
	hetptr.NHetAtm = 4;
	hetptr.Allocated[0] = 1;
	hetptr.HetAtm[0] = (char *) malloc(6);
	strcpy(hetptr.HetAtm[0],"Helix");
	hetptr.Allocated[1] = 1;
	hetptr.HetAtm[1] = (char *) malloc(5);
	strcpy(hetptr.HetAtm[1],"Beta");
	hetptr.Allocated[2] = 1;
	hetptr.HetAtm[2] = (char *) malloc(8);
	strcpy(hetptr.HetAtm[2],"RNA/DNA");
	hetptr.Allocated[3] = 1;
	hetptr.HetAtm[3] = (char *) malloc(4);
	strcpy(hetptr.HetAtm[3],"HET");
    } else if (!amiami && iadd) {
	calfptr->ianf[calfptr->nchain] = calfptr->ncalf+1;
	calfptr->nchain++;
    }
    calfptr->issdon = 0;

    calfptr->reson[calfptr->ncalf] = 0;
    calfptr->iamino[calfptr->ncalf] = iamin + 1;
    calfptr->icalf[calfptr->ncalf][0] = nz+1;
    if (isfirst) calfptr->icalf[calfptr->ncalf][1] = 1;
    else calfptr->icalf[calfptr->ncalf][1] = nn+1;
    calfptr->icalf[calfptr->ncalf][2] = nz+2;
    calfptr->icalf[calfptr->ncalf][3] = nz+5;
    calfptr->isal[calfptr->ncalf] = iconf;
    calfptr->irsnr[calfptr->ncalf] = calfptr->ncalf+1;
    if (calfptr->ncalf-1 > 0)
	strcpy(achain[calfptr->ncalf],achain[calfptr->ncalf-1]);
    calfptr->ncalf++;
    if (iadd) calfptr->islu[calfptr->nchain-1] = calfptr->ncalf;

    frglen = 6;
    if (iamin == 14) frglen = 5;
    MoveFrag(BACK,AMINO,frglen,0);
    CopyPDBTyp(xyzp->ipdbt,BACK_TYP,frglen-1,nz);
    if (isfirst) {
	xyzp->ipdbt[0] = 1;
	xyzp->iresid[0] = calfptr->ncalf;
	xyzp->iatclr[0] = 12;
    } else {
	xyzp->ipdbt[row] = 1;
	xyzp->iresid[row] = calfptr->ncalf;
	xyzp->iatclr[row] = 12;
    }

    MoveFrag(aminozmt[iamin].zmat,AMINO,aminozmt[iamin].zlines,frglen);
    CopyPDBTyp(xyzp->ipdbt,aminozmt[iamin].ipdbt,aminozmt[iamin].zlines,
		nz+frglen-1);
    frglen = frglen + aminozmt[iamin].zlines;

    if (isfirst) {
	MoveFrag(BACKHS,AMINO,2,frglen);
	CopyPDBTyp(xyzp->ipdbt,BACKHS_TYP,2,nz+frglen-1);
	frglen = frglen + 2;
    }
    AddFrag(AMINO,frglen,109.471,180.0,row,0,0,0);
    SetPDBArray(xyzp->iresid,frglen-1,calfptr->ncalf,nz);
    SetPDBArray(xyzp->iatclr,frglen-1,12,nz);

    if (isfirst) {
	zmptrp->bet[nz+2] = apsi;
    } else if (amiami) {
	if (iamin != 14) {
	    sizz(nz+4,2,co + 1);
	    zmptrp->bet[nz+4] = 180.0;
	}
	zmptrp->bl[nn] = 1.340;
	zmptrp->alph[nn] = 112.7;
	sizz(nz,1,co + 1);
	sizz(nz,2,ca + 1);
	zmptrp->alph[nz] = 121.0;
	if (omega != NULL) zmptrp->bet[nz] = *omega;
	else zmptrp->bet[nz] = 180.0;
	sizz(nz+1,2,co + 1);
	zmptrp->bet[nz+1] = aphi;
	zmptrp->bet[nz+2] = apsi;
    }

    sidechainstart = nz+5;
    if (iamin == 14) sidechainstart = nz+4;
    if (chi1 != NULL && aminozmt[iamin].chis[0] != -1) 
	zmptrp->bet[sidechainstart-1+aminozmt[iamin].chis[0]] = *chi1;
    if (chi2 != NULL && aminozmt[iamin].chis[1] != -1) 
	zmptrp->bet[sidechainstart-1+aminozmt[iamin].chis[1]] = *chi2;
    if (chi3 != NULL && aminozmt[iamin].chis[2] != -1) 
	zmptrp->bet[sidechainstart-1+aminozmt[iamin].chis[2]] = *chi3;
    if (chi4 != NULL && aminozmt[iamin].chis[3] != -1) 
	zmptrp->bet[sidechainstart-1+aminozmt[iamin].chis[3]] = *chi4;
    
    if (update) {
	SetQZME();
	DeActZME();
	if (isfirst) IANZbox[3].active = 1;
	else IANZbox[nz+2].active = 1;
	if (ZMEAA) {
	   make_aa();
	   ZME_window_pos = calfptr->ncalf-ZME_window_high;
	   if (ZME_window_pos < 0) ZME_window_pos = 0;
	} else {
	   ZME_window_pos = *zmptrp->nz-ZME_window_high;
	   if (ZME_window_pos < 0) ZME_window_pos = 0;
	}
	RedrawZME();
	*Sinct = 530;
    }

    *addrow = nz+2;
    LastAmino = *addrow;

    return(iret);

}
    
#define ALPHA 0
#define BETA 1
#define TURN 2

void AddSequence(sequence,seq_len,sec_struc)
int *sequence;
int seq_len;
int sec_struc;
{
    int i;
    int addrow,update;
    double phit;

    addrow = -1;

    for (i=0; i < seq_len; i++) {
	phit = phi_angle;
	update = 0;
	if (i == seq_len - 1) update = 1;
	if (sequence[i] == 14) phit = -70.0;
	if (!AddAmino(sequence[i],&addrow,
	   phit,psi_angle,NULL,NULL,NULL,NULL,NULL,iconform,update,1)) break;
        calfptr->reson[calfptr->ncalf-1] = 1;
    }

}

void InsertEmptyLines(ires,row,nlines,seq_len,nprot,iprot)
int ires;
int row;
int nlines;
int seq_len;
int nprot;
int *iprot;
{
/*
ires   = residue
row    = zmat line from which lines will be added/inserted
nlines = number of lines inserted
seq_len = number of amino acids inserted
*/

  int i,j,k,l,kcon,prot,ab,noab;

    for (j=*zmptrp->nz-1; j >= row; j--) {
	zmptrp->bl[j+nlines] = zmptrp->bl[j];
	zmptrp->alph[j+nlines] = zmptrp->alph[j];
	zmptrp->bet[j+nlines] = zmptrp->bet[j];
	zmptrp->ianz[j+nlines] = zmptrp->ianz[j];
	zmptrp->imap[j+nlines] = zmptrp->imap[j] + nlines;
	for (k=0; k < 4; k++) {
	   prot = 0;
	   for (l=0; l < nprot; l++) {
		if ((izz(j,k) == iprot[l]) && xyzp->iresid[j] <= 0) prot = 1;
	   }
	   if (izz(j,k) < row+1 || prot)
		sizz(j+nlines,k,izz(j,k));
	   else
		sizz(j+nlines,k,izz(j,k) + nlines);
	}
	if (ABS(zmptrp->ibl[j]) < row+1) 
	   zmptrp->ibl[j+nlines] = zmptrp->ibl[j];
	else zmptrp->ibl[j+nlines] = zmptrp->ibl[j]-SIGN(zmptrp->ibl[j]);

	if (ABS(zmptrp->ialph[j]) < row+1)
	   zmptrp->ialph[j+nlines] = zmptrp->ialph[j];
	else zmptrp->ialph[j+nlines] = zmptrp->ialph[j]-SIGN(zmptrp->ialph[j]);

	if (ABS(zmptrp->ibet[j]) < row+1) 
	   zmptrp->ibet[j+nlines] = zmptrp->ibet[j];
	else zmptrp->ibet[j+nlines] = zmptrp->ibet[j]-SIGN(zmptrp->ibet[j]);
    }

    for (j=*xyzp->iatoms-1; j >= row; j--) {
	xyzp->iatclr[j+nlines] = xyzp->iatclr[j];
	if (xyzp->iresid[j] >= ires) {
	   xyzp->iresid[j+nlines] = xyzp->iresid[j] + seq_len;
        } else {
	   xyzp->iresid[j+nlines] = xyzp->iresid[j];
	}
	xyzp->iaton[j+nlines] = xyzp->iaton[j];
	xyzp->ianz[j+nlines] = xyzp->ianz[j];
	stocp->ianstc[j+nlines] = xyzp->ianz[j];
	xyzp->ipdbt[j+nlines] = xyzp->ipdbt[j];
	xyzp->ityp[j+nlines] = xyzp->ityp[j];
	if (qdpptr->ihasq) xyzp->qat[j+nlines] = xyzp->qat[j];
	for (k=0; k < 3; k++) {
	   xyzp->coo[(j+nlines)*3+k] = xyzp->coo[j*3+k];
	   stocp->cstoc[(j+nlines)*3+k] = xyzp->coo[j*3+k];
	   stocp->czstoc[(j+nlines)*3+k] = xyzp->coo[j*3+k];
	}
	kcon = 0;
	for (k=0; k < xyzp->iconn[j*(MXCON+1)]; k++) {
	   noab = xyzp->iconn[j*(MXCON+1)+k+1];
	   ab = ABS(noab);
	   prot = 0;
	   for (l=0; l < nprot; l++) {
		if ((ab == iprot[l]) && xyzp->iresid[j] <= 0) prot = 1;
	   }
	   if (ab > row && !prot) {
		if (noab > 0) {
		   xyzp->iconn[(j+nlines)*(MXCON+1)+kcon+1] = noab + nlines;
		} else {
		   xyzp->iconn[(j+nlines)*(MXCON+1)+kcon+1] = noab - nlines;
		}
		kcon++;
	   } else {
		xyzp->iconn[(j+nlines)*(MXCON+1)+kcon+1] = noab;
		kcon++;
	   }
	}
	xyzp->iconn[(j+nlines)*(MXCON+1)] = kcon;
    }

}

int InsertSequence(sequence,seq_len,sec_struc,ires,nprot,iprot)
int *sequence;
int seq_len;
int sec_struc;
int ires;
int nprot;
int *iprot;
{
    int i,j,k,l, nzold, nlines,nlinesn,row,nc,nch,iaf,isl;
    int addrow,update;
    int ica,in,inn,icop,icap;
    double phit;


/* ires schuift op, dus insertie voor ires */

    addrow = -1;

    nc = calfptr->ncalf;
    nch = 0; iaf = 1; isl = nc;
    for (i=0; i < calfptr->nchain; i++) {
        if (ires >= calfptr->ianf[i] && ires < calfptr->islu[i]) {
	   nch = i;
	   iaf = calfptr->ianf[i];
	   isl = calfptr->islu[i];
	}
    }
    if (ires >= calfptr->islu[calfptr->nchain - 1]) {
	nch = calfptr->nchain - 1;
	isl = calfptr->islu[nch];
    }
    nzold = *zmptrp->nz;

    nlines = 0;
    for (i=0; i < seq_len; i++) {
	nlines = nlines + aminozmt[sequence[i]].zlines + 5;
	if (sequence[i] == 14) nlines--;
    }

    if (ZMEup) DeActZME();

    if (ires <= nc ) {
	row = calfptr->icalf[ires-1][0] - 1;
	addrow = izz(row,0) - 1;
	zmptrp->ianz[addrow] = 8;
    } else {
	row = -1;
	ica = calfptr->icalf[ires-2][0] - 1;
	for (i=ica; i < *zmptrp->nz; i++) {
	    if (xyzp->iresid[i] != ires-1) {
		row = i; break;
	    }
	}
	if (row == -1) row = *zmptrp->nz;
	addrow = ica + 2;
    }

    InsertEmptyLines(ires,row,nlines,seq_len,nprot,iprot);

    for (j=calfptr->ncalf-1; j >= 0; j--) {
	for (k=0; k < 4; k++) {
	   if (calfptr->icalf[j][k]-1 >= row) 
		calfptr->icalf[j+seq_len][k] = calfptr->icalf[j][k] + nlines;
	} 
	if (j >= ires-1) {
	   calfptr->iamino[j+seq_len] = calfptr->iamino[j];
	   calfptr->reson[j+seq_len] = calfptr->reson[j];
	   calfptr->isal[j+seq_len] = calfptr->isal[j];
	   calfptr->irsnr[j+seq_len] = calfptr->irsnr[j]+seq_len;
	   strcpy(achain[j+seq_len],achain[j]);
	}
    }

    *zmptrp->nz = row;
    calfptr->ncalf = ires - 1;

    update = 0;
    for (i=0; i < seq_len; i++) {
	phit = phi_angle;
	if (sequence[i] == 14) phit = -70.0;
	if (!AddAmino(sequence[i],&addrow,
	   phit,psi_angle,NULL,NULL,NULL,NULL,NULL,iconform,update,0)) break;
        calfptr->reson[calfptr->ncalf-1] = 1;
    }

/* Connect last of inserted residue to next residue, except when this
   was actually an add, insert at last residue, for the benefit of
   replace last residue (=del+ins) */

    if (ires-1 != nc) {

	ica = calfptr->icalf[ires-1+seq_len][0] - 1;
	icap = calfptr->icalf[ires-2+seq_len][0];
	icop = icap + 1;
	in = icap + 2;
	zmptrp->ianz[in-1] = 7;
	xyzp->ipdbt[in-1] = 1;
	xyzp->iresid[in-1] = ires+seq_len;
	calfptr->icalf[ires-1+seq_len][1] = in;

	inn = izz(ica,0);

	sizz(ica,0,in);
	sizz(ica,1,icop);
	sizz(ica,2,icap);

	sizz(ica+1,1,in);
	sizz(ica+1,2,icop);

	sizz(ica+2,2,in);

/* The general situation, the forth atom after Calfa is H attached to N */

	if (zmptrp->ianz[ica+4] == 1 && zmptrp->ianz[ica+3] == 8) {
	   sizz(ica+4,0,in);
	   sizz(ica+4,2,icop);
	}

/* When res after insert is the last res, the third atom after Calfa in not N but H */
	if (zmptrp->ianz[ica+3] == 1) {
	   sizz(ica+3,0,in);
	   sizz(ica+3,2,icop);
	}

/* if res after insert is proline, this is not actually a check for proline,
   this should deal with the Cbeta, why isnt this picked up later with check for inn ? */

	if (zmptrp->ianz[ica+3] == 8 && zmptrp->ianz[ica+4] == 6) {
/* regular pro */
	   sizz(ica+4,0,ica+1);
	   sizz(ica+4,2,in);
	} else if (zmptrp->ianz[ica+2] == 8 && zmptrp->ianz[ica+3] == 6) {
/* end pro */
	   sizz(ica+3,0,ica+1);
	   sizz(ica+3,2,in);
	}


	xyzp->iatclr[in-1] = xyzp->iatclr[ica];

    }
    if (ires == 1) {
	zmptrp->alph[ica] = 121.0;
	zmptrp->bet[ica] = 180.0;
	zmptrp->bet[ica+1] = phi_angle;
	zmptrp->bet[ica+4] = 180.0;
    }

/* search for more lines which where defines with respect to backbone
   N of residue ires+1; inn */

/* and Beware oflast residue */

    if (ires-1 != nc) {
      nlinesn = aminozmt[calfptr->iamino[ires-1+seq_len]-1].zlines + 5;
      if (calfptr->iamino[ires-1+seq_len]-1 == 14) nlinesn--;
	for (i=ica; i < nzold + nlines; i++) {
	     for (k=0; k < 3; k++) {
	        if (izz(i,k) == inn) sizz(i,k,in);
	     }
	}
    }


    *zmptrp->nz = nzold + nlines;
    calfptr->ncalf = nc + seq_len;

    for (i=0; i < calfptr->nchain; i++) {
        if (i == nch) {
	   calfptr->islu[i] = isl + seq_len;
	} else {
           if (ires <= calfptr->islu[i]) 
		calfptr->islu[i] = calfptr->islu[i] + seq_len;
           if (ires < calfptr->ianf[i]) 
		calfptr->ianf[i] = calfptr->ianf[i] + seq_len;
	}
    }

    calfptr->issdon = 0;
    UpdHet2(nlines);

    if (ZMEup) {
	SetQZME();
	DeActZME();

	if (ZMEAA) {
	   if (ZME_window_pos > calfptr->ncalf-1-ZME_window_high) {
		if (calfptr->ncalf-1-ZME_window_high >= 0) {
		   ZME_window_pos = calfptr->ncalf-ZME_window_high;
        	} else ZME_window_pos = 0;
	   }
	} else {
	   if (ZME_window_pos > *zmptrp->nz-1-ZME_window_high) {
		if (*zmptrp->nz-1-ZME_window_high >= 0) {
		   ZME_window_pos = *zmptrp->nz-ZME_window_high;
        	} else ZME_window_pos = 0;
	   }
	}
	if (ZME_window_pos < 0) ZME_window_pos = 0;
	if (ZMEAA) make_aa();
	RedrawZME();
    }
    *Sinct = 530;
    update_sel = 1;
    return(nlines);

}


#define MXPROTHET 100
void ReplaceSequence(sequence,seq_len,sec_struc,ires)
int *sequence;
int seq_len;
int sec_struc;
int ires;
{
   int ica0,ica,ica2,ict1,i,k,l,n,ilst1,ilst2,ilst2am,ilst2nl,ktyp;
   int ina, ico,icap;
   double ph,ps,omeg,ph2;
   int nprot;
   int iprot[3];
   double bl1[5],alph1[5],bet1[5];
   double bl2[3],alph2[3];
   double bl3[1],alph3[1];
   double refa1[3],refa2[3],refa3[3];
   int prothet[MXPROTHET][5],nprothet;
   int ndellin,ninslin,nefflin;

/* ica2 blijkt vrij nutteloos te zijn doch helemaal weg kan hij niet */

   ica0 = calfptr->icalf[ires-1][1] - 1;
   ica = calfptr->icalf[ires-1][0] - 1;
   ica2 = -1;

   if (ires == 1) {
	ina = calfptr->icalf[ires-1][1] - 1;
	ico = calfptr->icalf[ires-1][2] - 1;
   	icap = calfptr->icalf[ires][0] - 1;
	ph2 = zmptrp->bet[icap+1];
	for (i=0; i < 3; i++) {
	   refa1[i] = stocp->czstoc[ina*3+i];
	   refa2[i] = stocp->czstoc[ica*3+i];
	   refa3[i] = stocp->czstoc[ico*3+i];
	}
   }

   if (ires >= calfptr->ncalf) {
	for (i=ica; i < *zmptrp->nz; i++) {
	    if (xyzp->iresid[i] != ires) {
		ica2 = i; break;
	    }
	}
	if (ica2 == -1) ica2 = *zmptrp->nz - 1;

   } else {
	ica2 = calfptr->icalf[ires][0] - 1;
   }
   ilst2am = calfptr->iamino[ires] - 1;
   ilst2nl = aminozmt[ilst2am].zlines + 5;
   if (ilst2am == 14) ilst2nl--;

   ph = phi_angle;
   ps = psi_angle;

   if (seq_len == 1) {
	phi_angle = zmptrp->bet[ica+1];

/* if list2: psi_angle != zmptrp->bet[ica+2]; */
	psi_angle = zmptrp->bet[ica+2];

	omeg = zmptrp->bet[ica];
	for (i=0; i < 4; i++) {
           bl1[i] = zmptrp->bl[ica+i];
           alph1[i] = zmptrp->alph[ica+i];
           bet1[i] = zmptrp->bet[ica+i];
	}
	if (zmptrp->ianz[ica+2] == 7) {
	   ilst1 = 0;
	} else if (zmptrp->ianz[ica+2] == 8) {
	   ilst1 = 1;
	}

/* 
   check for chain break after to be replaced residue:
   then the atom just before Calfa is an N 
   (mind you zmatlines number 0 - nz-1, atom references in
   zmat run from 1 - iatoms, so:

   izz(ica2,0) == ica2 instead of izz(ica2,0) == ica2-1
*/

	ilst2 = 0;
	if (izz(ica2,0) == ica2) {
	   ilst2 = 1;
	   ica2 = ica2 - 1;
	   psi_angle = zmptrp->bet[ica2];
	}

	for (i=0; i < 3; i++) {
           bl2[i] = zmptrp->bl[ica2+i];
           alph2[i] = zmptrp->alph[ica2+i];
	}
	bl3[0] = zmptrp->bl[ica0];
	alph3[0] = zmptrp->alph[ica0];
   }


   ict1 = calfptr->icalf[ires-1][0];

   nprot = 3;
   iprot[0] = ica+1;
   iprot[1] = izz(ica,0);
   iprot[2] = ica+2;

   nprothet = 0; ndellin = 0; ninslin = 0;
   for (i=ica; i < *zmptrp->nz; i++) {
	ktyp = 0;
	if (xyzp->iresid[i] <= 0) ktyp = 1;
	if ((xyzp->iresid[i] == ires) && (xyzp->ianz[i] == 1) &&
	   (i > ica2) ) ktyp = 2;
	if (ktyp) {
	   for (k=0; k < 5; k++) prothet[nprothet][k] = -1;
	   for (k=0; k < 3; k++) {
		for (l=0; l < nprot; l++) {
		   if (izz(i,k) == iprot[l] && nprothet < MXPROTHET) {
			prothet[nprothet][k+1] = iprot[l];
			prothet[nprothet][0] = i;
			prothet[nprothet][4] = ktyp;
		   }
		}
	   }
	   if (prothet[nprothet][0] != -1) nprothet++;
	}
   }

   ndellin = DelAmino(ires);

   if (ires-1 == calfptr->ncalf) {
	calfptr->icalf[ires-1][0] = ict1;
   }

   ninslin = InsertSequence(sequence,seq_len,iconform,ires,0,NULL);

   if (seq_len == 1) {
	if (sequence[0] == 14) zmptrp->bet[ica+1] = phi_angle;
	if (ilst2) {
	   zmptrp->bet[ica+2] = psi_angle;
	   zmptrp->bet[ica+3] = bet1[2];
	}
	if (ires == 1) {
	   icap = calfptr->icalf[1][0] - 1;
	   zmptrp->bet[ica+2] = psi_angle;
	   zmptrp->bet[icap+1] = ph2;
	}
	phi_angle = ph;
	psi_angle = ps;

	n = 4;

/* if last res replaced (or actually last before chain break)
   if replaced by a a proline ica + 3 was H(-N) and then becomes a Cbeta */
/* NOG DOEN: als een PRO vervangen wordt door een PRO dan eigenlijk wel
   weer n = 4 */

	if (ilst1 && sequence[0] == 14) n = 3;

	for (i=0; i < n; i++) {
           zmptrp->bl[ica+i] = bl1[i];
           zmptrp->alph[ica+i] = alph1[i];
	}

/* ilst2 = 1
   Als laatste RES voor chainbreak vervangen wordt dan veranderd de volgorde
   van:

   Calfa(res)    N    (res)    Coo  (res-1) Calfa(res-1)
   Coo  (res)    Calfa(res)    N    (res)   Coo  (res-1)
   Ooc  (res)    Coo  (res)    Calfa(res)   N    (res)
   .... H or Cbeta (ANY or PRO)

-> N    (res+1)  Coo  (res)    Calfa(res)   N    (res)
   Calfa(res+1)  N    (res+1)  Coo  (res)   Calfa(res)
   Coo  (res+1)  Calfa(res+1)  N    (res+1) Coo  (res)

   Naar:

   Calfa(res)    N    (res)    Coo  (res-1) Calfa(res-1)
   Coo  (res)    Calfa(res)    N    (res)   Coo  (res-1)
-> N    (res+1)  Coo  (res)    Calfa(res)   N    (res)
   Ooc  (res)    Coo  (res)    Calfa(res)   N    (res)
   .... H or Cbeta (ANY or PRO)

   Calfa(res+1)  N    (res+1)  Coo  (res)   Calfa(res)
   Coo  (res+1)  Calfa(res+1)  N    (res+1) Coo  (res)

*/

	if (ilst2) {
           zmptrp->bl[ica+2] = bl2[0];
           zmptrp->alph[ica+2] = alph2[0];
           zmptrp->bl[ica+3] = bl1[3];
           zmptrp->alph[ica+3] = alph1[3];
	}
	zmptrp->bl[ica0] = bl3[0];
	zmptrp->alph[ica0] = alph3[0];
	zmptrp->bet[ica] = omeg;
   }

   nefflin = ninslin - ndellin;

   for (l=0; l < nprothet; l++) {
	i = prothet[l][0];
	for (k=0; k < 3; k++) {
	   if (prothet[l][1+k] != -1) {
		sizz(i+nefflin,k,prothet[l][1+k]);
	   }
	}
	if (prothet[l][4] == 2) xyzp->iresid[i+nefflin] = ires;
   }

   if (ires == 1) {
	for (i=0; i < 3; i++) {
	   xyzp->coo[i]   = refa1[i];
	   xyzp->coo[3+i] = refa2[i];
	   xyzp->coo[6+i] = refa3[i];
	}
   }


}

void prtzmt(ibeg)
int ibeg;
{
   int i;

   fprintf(stderr,"Zmatrix\n");
   fprintf(stderr,"zmptrp->nz %d\n",*zmptrp->nz);
   for (i=ibeg; i < *zmptrp->nz; i++) {
	fprintf(stderr,"zmt %d ianz %d iz0 %d iz1 %d iz2 %d\n",i,zmptrp->ianz[i],izz(i,0),izz(i,1),izz(i,2));
	fprintf(stderr,"atm iresid %d ipdbt %d ityp %d iaton %d \n",xyzp->iresid[i],xyzp->ipdbt[i],xyzp->ityp[i],xyzp->iaton[i]);
   }
   fprintf(stderr,"Residues\n");
   for (i=0; i < calfptr->ncalf; i++) {
	fprintf(stderr,"calf %d iamino %d reson %d isal %d irsnr %d\n",i,calfptr->iamino[i],calfptr->reson[i],calfptr->isal[i],calfptr->irsnr[i]);
   }
   fprintf(stderr,"Residues icalf\n");
   for (i=0; i < calfptr->ncalf; i++) {
	fprintf(stderr,"calf %d icalf0 %d icalf1 %d icalf2 %d\n",i,calfptr->icalf[i][0],calfptr->icalf[i][1],calfptr->icalf[i][2]);
   }
   fprintf(stderr,"Chains %d\n",calfptr->nchain);
   for (i=0; i < calfptr->nchain; i++) {
	fprintf(stderr,"ch ianf %d islu %d\n",calfptr->ianf[i],calfptr->islu[i]);
   }
}

#if defined(VMS) || defined(UNDERSC)
void readsq(ami,angs,namin)
#else
#ifdef CRAY
void READSQ(ami,angs,namin)
#else
void readsq_(ami,angs,namin)
#endif
#endif
int *ami;
double angs[][7];
int *namin;
{
    int i,j;
    int addrow,update;
    double phit,psit;
    double *omchi[5];


    addrow = -1;

    for (i=0; i < *namin; i++) {

	phit = -119.0;
	if (ami[i] == 14) phit = -70.0;
	psit = 113.0;
        if (angs[i][0] != -1) phit = angs[i][0];
        if (angs[i][1] != -1) psit = angs[i][1];

        for (j=0; j < 5; j++) {
	   if (angs[i][2+j] != -1) omchi[j] = &angs[i][2+j];
	   else omchi[j] = NULL;
	}

	update = 0;
	if (i == (*namin)-1) update = 1;
	if (!AddAmino(ami[i],&addrow,phit,psit,omchi[0],omchi[1],omchi[2],
		omchi[3],omchi[4],iconform,update,1)) break;
    }

    NSeq = 0;
    UpdateSeqStat();
}

void CopyFrag(frag,frglen,linkoffset) 
ZLINESTRU *frag;
int frglen;
int linkoffset;
{
    int i,j,offset,variablestatus;

    for (i=0; i < frglen; i++) {
	offset = *zmptrp->nz + i;
	if (linkoffset != -1) {
	   variablestatus = linkoffset + i;
	} else {
	   variablestatus = 1;
	}
	zmptrp->ianz[offset] = frag[i].ianz;
	for (j=0; j < 3; j++) {
	    sizz(offset,j, frag[i].iz[j] + *zmptrp->nz);
	}
	sizz(offset,3,0);
	zmptrp->bl[offset] = frag[i].bl;
	zmptrp->ibl[offset] = variablestatus;
	zmptrp->alph[offset] = frag[i].alph;
	zmptrp->ialph[offset] = variablestatus;
	zmptrp->bet[offset] = frag[i].bet;
	zmptrp->ibet[offset] = variablestatus;
    }
    *zmptrp->nz = *zmptrp->nz + frglen;
}

void MoveFrag(frag,destiny,frglen,destoff) 
ZLINESTRU *frag;
ZLINESTRU *destiny;
int frglen;
int destoff;
{
    int i,j;

    for (i=0; i < frglen; i++) {
	destiny[destoff+i].ianz = frag[i].ianz;
	for (j=0; j < 3; j++) {
	    destiny[destoff+i].iz[j] = frag[i].iz[j];
	}
	destiny[destoff+i].bl = frag[i].bl;
	destiny[destoff+i].alph = frag[i].alph;
	destiny[destoff+i].bet = frag[i].bet;
    }
}

void AddFrag(frag,fraglen,covang,dih,addrow,update,pdbt,doadd) 
ZLINESTRU *frag;
int fraglen;
double covang,dih;
int addrow;
int update;
int pdbt;
int doadd;
{
    int row,iptr1,irt,rest,atnr;
    int offset,i,j,isfirst;
    short int iph;

    isfirst = 0;
    if (!*zmptrp->nz) isfirst = 1;

    if (DEBUG) {
	fprintf(stderr,"nz %d\n",*zmptrp->nz);
	for (i=0; i < fraglen; i++) {
	    fprintf(stderr,"ianz %d\n",frag[i].ianz);
	    for (j=0; j < 4; j++) {
		fprintf(stderr,"iz[%d] %d\n",j,frag[i].iz[j]);
	    }
	fprintf(stderr,"bl %f\n",frag[i].bl);
	fprintf(stderr,"alph %f\n",frag[i].alph);
	fprintf(stderr,"bet %f\n",frag[i].bet);
	}
    }
    

    if (addrow == -1) {
        row = GetRow(1);
        if (row == -1) {
	   if (isfirst) {
		FirstLine();
		row = 0;
		*zmptrp->nz = 1;
	   } else {
		return;
	   }
	}
    } else row = addrow;

    atnr = 6;
    irt = NHETRES;
    rest = zmptrp->imap[row]-1;
    if (rest >= 0) irt = GetRes(atnr,&iph,doadd,rest);

    if (*zmptrp->nz >1) {
	zmptrp->ianz[row] = frag[0].ianz;
	zmptrp->bl[row] = 
		CalcBL(0,frag[0].ianz,zmptrp->ianz[izz(row,0)-1]);
	if (pdbt) {

	   iptr1 = row;
	   if (*ialtyp) iptr1 = iptr1 + *iscst;

	   xyzp->ipdbt[iptr1] = 0;
	   xyzp->ityp[iptr1] = 0;
	   xyzp->iresid[iptr1] = irt;
	   xyzp->iatclr[iptr1] = 1;
	   xyzp->iaton[iptr1] = 1;
	}
    }

    if (*zmptrp->nz == 1) {
	row = 0;
        zmptrp->ianz[0] = frag[0].ianz;
    }

    for (i=1; i < fraglen; i++) {
	offset = *zmptrp->nz + i - 1;
	zmptrp->ianz[offset] = frag[i].ianz;
	for (j=0; j < 3; j++) {
	    if (frag[i].iz[j] == 1) {
		sizz(offset,j, row + 1);
	    } else {
		sizz(offset,j, frag[i].iz[j] + *zmptrp->nz - 1);
	    }
	}
	sizz(offset,3, frag[i].iz[3]);
	zmptrp->bl[offset] = frag[i].bl;
	zmptrp->ibl[offset] = 1;
	zmptrp->alph[offset] = frag[i].alph;
	zmptrp->ialph[offset] = 1;
	zmptrp->bet[offset] = frag[i].bet;
	zmptrp->ibet[offset] = 1;
	zmptrp->imap[offset] = offset+1;
	xyzp->iatclr[offset] = 12;
	if (pdbt) {

	    iptr1 = offset;
	    if (*ialtyp) iptr1 = iptr1 + *iscst;

	    xyzp->ipdbt[iptr1] = 0;
	    xyzp->iresid[iptr1] = irt;
	    xyzp->iatclr[iptr1] = 1;
	    xyzp->ityp[iptr1] = 0;
	    xyzp->iaton[iptr1] = 1;
	}
    }


    sizz(1,1,0);
    sizz(1,2,0);
    sizz(1,3,0);
    sizz(2,2,0);
    sizz(2,3,0);
    zmptrp->alph[1] = 0.0;
    zmptrp->bet[1] = 0.0;
    zmptrp->bet[2] = 0.0;

    if (*zmptrp->nz > 1) {
	offset = *zmptrp->nz;
	if (row == 0) {
	    sizz(offset,1,2);
	    sizz(offset,2,3);
	} else if (row == 1) {
	    sizz(offset,1,1);
	    sizz(offset,2,3);
	} else {
	    sizz(offset,1,izz(row,0));
	    sizz(offset,2,izz(row,1));
	}
	zmptrp->alph[offset] = covang;
	zmptrp->bet[offset] = dih;
	offset++;
	if (row == 0) {
	    sizz(offset,2,2);
	} else if (row == 1) {
	    sizz(offset,2,1);
	} else {
	    sizz(offset,2,izz(row,0));
	}
	if (frag == cyclopentane) {
	   zmptrp->bet[offset] = 200.0;
	} else {
	   zmptrp->bet[offset] = 180.0;
	}
    }

    update_sel = 1;
    if (update) DeActZME(); 

    *zmptrp->nz = *zmptrp->nz + fraglen - 1;

    *zmptrp->ihaszm = 1;

    if (update) {

	SetQZME(); 

	ZME_window_pos = *zmptrp->nz-ZME_window_high;
	if (ZME_window_pos < 0) ZME_window_pos = 0;

	if (*zmptrp->nz < ZME_window_high) RedrawZME();
	else UpdateZME();

	*Sinct = 530;
    }
}

void AddCycloHexane() {

    AddXH3(6,0);
    (*zmptrp->nz)--;
    DeActZME();
    IANZbox[*zmptrp->nz-2].active = 1;
    AddXH3(6,0);
    DeActZME();
    IANZbox[*zmptrp->nz-3].active = 1;
    AddXH3(6,0);
    strcpy(BETbox[*zmptrp->nz-3].str,"60.0");
    BETbox[*zmptrp->nz-3].changed = 1;
    GetQZME();
    DeActZME();
    IANZbox[*zmptrp->nz-3].active = 1;
    AddXH3(6,0);
    strcpy(BETbox[*zmptrp->nz-3].str,"300.0");
    BETbox[*zmptrp->nz-3].changed = 1;
    DeActZME();
    GetQZME();
    IANZbox[*zmptrp->nz-3].active = 1;
    AddXH3(6,0);
    strcpy(BETbox[*zmptrp->nz-3].str,"60.0");
    BETbox[*zmptrp->nz-3].changed = 1;
    GetQZME();
    DeActZME();
    IANZbox[*zmptrp->nz-3].active = 1;
    AddXH3(6,0);
    strcpy(BETbox[*zmptrp->nz-3].str,"60.0");
    BETbox[*zmptrp->nz-3].changed = 1;
    DeActZME();
    GetQZME();
    (*zmptrp->nz)--;

    ZME_window_pos = *zmptrp->nz-ZME_window_high;
    if (ZME_window_pos < 0) ZME_window_pos = 0;

    RedrawZME();
    *Sinct = 530;

}

int ScreenZME(cursorx,cursory)
int cursorx;
int cursory;
{
 int i,j,k,n,ires;

/*

  ScreenZME light up atom closest to cursor, and light up corresponding
  atom in the zmatrix-editor

*/


 if (ZMEup) {

	i = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,*xyzp->iatoms,
			cursorx,cursory,MINDIFF);

	if (i >= 0) {
    		update_sel = 1;
		for (j=0; j<*zmptrp->nz; j++) {
			if (i == zmptrp->imap[j]-1) {
				for (k=0; k<*xyzp->iatoms; k++) 
				   if (xyzp->iaton[k] >= 1) xyzp->iaton[k] = 1;
				DeActZME();
				xyzp->iaton[i] = 3;
                                if (ZMEAA) {
				   ires = xyzp->iresid[i] - 1;
				   CurAmino = ires;
				   if (ires < 0) return(0);
				   ZME_window_pos =  ires;
				} else {
				   n = j/ZME_window_high;
				   ZME_window_pos =  n*ZME_window_high;
				   IANZbox[j].col = ZC_AT1;
				   IANZbox[j].active = 1;
				}
				UpdateZME();
				sprintf(ZMEerr, "Line %d Atom %d",i+1,zmptrp->imap[i]);
				RedrawStatus();
				RedrawScroll(&zscroll);
				return(1);
			}
		}
	}
 }
 return(0);
}

int ScreenPDB(cursorx,cursory)
int cursorx;
int cursory;
{
 int iat,ires;

/*

  ScreenPDB light up atom closest to cursor, set CurAmino for later use in AmiCom

*/

   iat = -1; ires = -1;

   if (has_opengl) {
	if (*ipdbon) {
	   if (*fancy || *fullgl) {
                iat = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
			*xyzp->iatoms,cursorx,cursory,MINDIFF);
	   } else {
                iat = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
			*xyzp->iatoms,cursorx,cursory,MINDIFF);
                if (iat < 0) ires = FindCaP(cursorx,cursory,MINDIFF);
	   }
	}
   } else {
	if (*ipdbon) {
           iat = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
			*xyzp->iatoms,cursorx,cursory,MINDIFF);
	   if (iat < 0) ires = FindCaP(cursorx,cursory,MINDIFF);
	}
   }

   if ((iat >= 0 || ires >= 0) && *ipdbon) {
	if (iat >= 0) {
	   CurAmino = xyzp->iresid[iat] - 1;
	} else if (ires >= 0) {
	   CurAmino = ires;
	}
	return(1);
   }

   return(0);
}

void map_prop()
{
  int j,k;
  int *iarr;
  int *imarr;


/*
 Dont do property mapping when doing interactive docking
*/
  if (*ialtyp == 1) return;
  if (!*zmptrp->ihaszm) return;

  if (qdpptr->ihasq) maparr(NULL,xyzp->qat,NULL,NULL,1);
  maparr(NULL,NULL,NULL,xyzp->ityp,3);
  maparr(NULL,NULL,NULL,xyzp->ipdbt,3);
  maparr(NULL,NULL,xyzp->iatclr,NULL,2);
  maparr(NULL,NULL,xyzp->iresid,NULL,2);

  if ((iarr = (int *) malloc((sizeof j)*(*zmptrp->mxzat))) != NULL) {
    if ((imarr = (int *) malloc((sizeof j)*(*zmptrp->mxzat))) != NULL) {
	rearrz(iarr);
	for (k=0; k<6; k++) {
	   for (j=0; j<calfptr->ncalf; j++)
		imarr[j] = calfptr->icalf[j][k];

	   for (j=0; j<calfptr->ncalf; j++) {
		if (imarr[j]-1 >= 0)
		   calfptr->icalf[j][k] = iarr[imarr[j]-1]+1;
	   }
	}
	free(imarr);

     }
     free(iarr);
  }
}

void DelLine(row,nlines,nprot,iprot)
int row;
int nlines;
int nprot;
int *iprot;
{
  int j,k,l,rowmap,prot,kcon,noab,ab;
 
   if (ZMEup) DeActZME();
   rowmap = zmptrp->imap[row];

   map_prop();

   for (j=row; j < *zmptrp->nz-nlines; j++) {
	zmptrp->bl[j] = zmptrp->bl[j+nlines];
	zmptrp->alph[j] = zmptrp->alph[j+nlines];
	zmptrp->bet[j] = zmptrp->bet[j+nlines];
	zmptrp->ianz[j] = zmptrp->ianz[j+nlines];
	for (k=0; k < 4; k++) {
	   prot = 0;
	   for (l=0; l < nprot; l++) {
		if ((izz(j+nlines,k) == iprot[l]) && xyzp->iresid[j+nlines] <= 0) prot = 1;
	   }
	   if ((izz(j+nlines,k) < row+1) || prot) 
		sizz(j,k,izz(j+nlines,k));
	   else sizz(j,k,izz(j+nlines,k)-nlines);
	}
	if (ABS(zmptrp->ibl[j+nlines]) < row+1) 
	   zmptrp->ibl[j] = zmptrp->ibl[j+nlines];
	else zmptrp->ibl[j] = zmptrp->ibl[j+nlines]-SIGN(zmptrp->ibl[j+nlines]);

	if (ABS(zmptrp->ialph[j+nlines]) < row+1)
	   zmptrp->ialph[j] = zmptrp->ialph[j+nlines];
	else zmptrp->ialph[j] = zmptrp->ialph[j+nlines]-SIGN(zmptrp->ialph[j+nlines]);

	if (ABS(zmptrp->ibet[j+nlines]) < row+1) 
	   zmptrp->ibet[j] = zmptrp->ibet[j+nlines];
	else zmptrp->ibet[j] = zmptrp->ibet[j+nlines]-SIGN(zmptrp->ibet[j+nlines]);

	xyzp->iatclr[j]  = xyzp->iatclr[j+nlines];
	xyzp->iresid[j]  = xyzp->iresid[j+nlines];
	xyzp->iaton[j]   = xyzp->iaton[j+nlines];
	xyzp->ianz[j]    = xyzp->ianz[j+nlines];
	stocp->ianstc[j] = xyzp->ianz[j+nlines];
	xyzp->ipdbt[j]   = xyzp->ipdbt[j+nlines];
	xyzp->ityp[j]    = xyzp->ityp[j+nlines];
	if (qdpptr->ihasq) xyzp->qat[j] = xyzp->qat[j+nlines];
	for (k=0; k < 3; k++) {
	   xyzp->coo[j*3+k] = xyzp->coo[(j+nlines)*3+k];
	   stocp->cstoc[j*3+k] = xyzp->coo[(j+nlines)*3+k];
	   stocp->czstoc[j*3+k] = xyzp->coo[(j+nlines)*3+k];
	}
	kcon = 0;
	for (k=0; k < xyzp->iconn[(j+nlines)*(MXCON+1)]; k++) {
	   noab = xyzp->iconn[(j+nlines)*(MXCON+1)+k+1];
	   ab = ABS(noab);
	   prot = 0;
	   for (l=0; l < nprot; l++) {
		if ((ab == iprot[l]) && xyzp->iresid[j+nlines] <= 0) prot = 1;
	   }
	   if (ab > row && !prot) {
		if (noab > 0) {
		   xyzp->iconn[j*(MXCON+1)+kcon+1] = noab - nlines;
		} else {
		   xyzp->iconn[j*(MXCON+1)+kcon+1] = noab + nlines;
		}
		kcon++;
	   } else {
		xyzp->iconn[j*(MXCON+1)+kcon+1] = noab;
		kcon++;
	   }
	}
	xyzp->iconn[j*(MXCON+1)] = kcon;

   }

   for (j=0; j < *zmptrp->nz; j++) {
	zmptrp->imap[j] = j + 1;
   }


   for (j=0; j < calfptr->ncalf; j++) {
	for (k=0; k < 4; k++) 
	   if (calfptr->icalf[j][k] >= row) 
		calfptr->icalf[j][k] = calfptr->icalf[j][k] - nlines;
   }

   *zmptrp->nz = *zmptrp->nz - nlines;
   update_sel = 1;
}

int CheckCOO(ires)
int ires;
{
   int i,ica,icnt,iresult;

   ica = calfptr->icalf[ires-1][0] - 1;
   icnt = 0; iresult = 0;

/* Coo is always the next line after Calfa */

   for (i=0; i < xyzp->iconn[(ica+1)*(MXCON+1)]; i++)
	if (xyzp->ianz[xyzp->iconn[(ica+1)*(MXCON+1)+1+i]-1] == 8) icnt++;
   if (icnt == 2) iresult = 1;

   return(iresult);
   
}

int CheckNH3(ires,icnn1,icnn2)
int ires;
int *icnn1;
int *icnn2;
{
   int i,k,ica,in,icnt,iatje;

   ica = calfptr->icalf[ires-1][0] - 1;
   in = izz(ica,0) - 1;
   icnt = 0; 
   for (i=0; i < xyzp->iconn[in*(MXCON+1)]; i++)
	iatje = xyzp->iconn[in*(MXCON+1)+1+i]-1;
	if (xyzp->ianz[iatje] == 1) {
	   icnt++;
	   if (icnt == 2) {
		icnn1[0] = iatje;
		for (k=0; k<3; k++) {
		   icnn1[k+1] = izz(iatje,k);
		}
	   }
	   if (icnt == 3) {
		icnn2[0] = iatje;
		for (k=0; k<3; k++) {
		   icnn2[k+1] = izz(iatje,k);
		}
	   }
	}
   icnt--;

   return(icnt);
   
}

int DelAmino(ires)
int ires;
{
   int i,j,k,n,ica,ican,nlines,in,inn,icap,icop,iaminn,nlinesn;
   int iend,ibeg,nprot,isrend,isnh3;
   int iprot[3];
   int icnn1[4],icnn2[4];

   ica = calfptr->icalf[ires-1][0] - 1;

   iend = 0; ibeg = 0;

   for (i=0; i < calfptr->nchain; i++) {
	if (ires == calfptr->islu[i]) iend = i + 1;
	if (ires == calfptr->ianf[i]) ibeg = i + 1;
   }

   isrend = CheckCOO(ires);
   isnh3 = CheckNH3(ires,icnn1,icnn2);

   if (iend && isrend) {
	iaminn = calfptr->iamino[ires-1] - 1;
	nlines = aminozmt[iaminn].zlines + 5;
	if (iaminn == 14) nlines--;
	nlinesn = 0;
   } else {
	if (iend == calfptr->nchain) {
	   nlines = *zmptrp->nz - ica;
	   for (i=ica; i < *zmptrp->nz; i++) {
		if (xyzp->iresid[i] != ires) {
		   nlines = i - ica; break;
		}
	   }
	   nlinesn = 0;
	} else {
	   ican = calfptr->icalf[ires][0] - 1;
	   nlines = ican - ica;
	   iaminn = calfptr->iamino[ires] - 1;
	   nlinesn = aminozmt[iaminn].zlines + 5;
	   if (iaminn == 14) nlinesn--;
	}
   }


   in = izz(ica,0);
   icop = izz(ica,1);
   icap = izz(ica,2);

   nprot = 3;
   iprot[0] = ica+1;
   iprot[1] = izz(ica,0);
   iprot[2] = ica+2;
   nprot = 0;

   DelLine(ica,nlines,0,NULL);

   inn = izz(ica,0);
   n = 0;

   if (! (iend && (isrend || iend == calfptr->nchain)) ) {
	sizz(ica,0,in);
	sizz(ica,1,icop);
	sizz(ica,2,icap);

	sizz(ica+1,1,in);
	sizz(ica+1,2,icop);

	n = 5;

	if (zmptrp->ianz[ica+2] == 7) {

	   sizz(ica+2,2,in);
	   sizz(ica+4,0,in);
	   sizz(ica+4,2,icop);

	} else {

	   if (zmptrp->ianz[ica+2] == 8) {

		if (zmptrp->ianz[ica+3] == 1) {
		   sizz(ica+3,0,in);
		   sizz(ica+3,2,icop);
		   n = 4;
		}
		if (zmptrp->ianz[ica+3] == 8) {
		   sizz(ica+2,2,in);
		   sizz(ica+4,0,in);
		   sizz(ica+4,2,icop);
		   n = 5;
		}
	
	   }
	}
   }

   if (ibeg) sizz(ica+4,2,ica + 2);

   if (iend && (isrend || iend == calfptr->nchain) ) {

/* 
   if this was the last residue, change the N to OXT
   BUT what if it was the last of this chain, and it goes on
   with an other chain. Then you have lost the N which belonged to
   the next residue !!!. You now have the first residue of a new chain
   WITHOUT an N
*/
	zmptrp->ianz[in-1] = 8;
	xyzp->iresid[in-1] = xyzp->iresid[in-1] - 1;
	xyzp->ipdbt[in-1] = 38;
   } else {
	xyzp->iatclr[in-1] = xyzp->iatclr[ica];
   }

/* search for more lines which where defines with respect to backbone
   N of residue ires+1; inn */

   if (! (iend && (isrend || iend == calfptr->nchain)) ) {
	for (i=ica+n; i < *zmptrp->nz; i++) {
	   for (k=0; k < 3; k++) 
		if (izz(i,k) == inn) sizz(i,k,in);
	}
/* 
   In case of res after the deleted one is after a chain break, the N has
   three H's attached to it. Two of them are not located in the amino part of
   the zmatrix, but rather much further down. The have to be connected to
   the right atom again.
   DUBBEL OP zie boven !!!, alleen als grenzen i=ica; i < ica+nlinesn
   voegt dit iets toe
*/
	for (i=ica+nlinesn; i < *zmptrp->nz; i++) {
	   if (izz(i,0) == inn) sizz(i,0,in);
	}
   }

   for (i=0; i < *zmptrp->nz; i++) {
	if (xyzp->iresid[i] > ires) 
	   xyzp->iresid[i] = xyzp->iresid[i] - 1;
   }

   for (j=ires-1; j < calfptr->ncalf; j++) {
	for (k=0; k < 4; k++) 
		calfptr->icalf[j][k] = calfptr->icalf[j+1][k];
	calfptr->iamino[j] = calfptr->iamino[j+1];
	calfptr->reson[j] = calfptr->reson[j+1];
	calfptr->irsnr[j] = calfptr->irsnr[j+1] - 1;
	calfptr->isal[j] = calfptr->isal[j+1];
	strcpy(achain[j],achain[j+1]);
   }

   calfptr->ncalf = calfptr->ncalf - 1;
   calfptr->issdon = 0;

   for (i=0; i < calfptr->nchain; i++) {
	if (ires <= calfptr->islu[i]) calfptr->islu[i] = calfptr->islu[i] - 1;
	if (ires < calfptr->ianf[i]) calfptr->ianf[i] = calfptr->ianf[i] - 1;
   }

   UpdHet2(-nlines);
   if (ZMEup) {
      if (ZME_window_pos >= *zmptrp->nz-1) ZME_window_pos = 0;
      SetQZME(); RedrawZME(); 
   }

   return(nlines);
}

void FindZRange(ires)
int ires;
{
   int ica,ica2,i;

   ica = calfptr->icalf[ires-1][0] - 1;
   ica2 = calfptr->icalf[ires][0] - 1;

   zmpart->imx = -1;
   for (i=ica; i < *zmptrp->nz; i++) {
        if (xyzp->iresid[i] != ires) {
            zmpart->imx = i; break;
        }
   }
   zmpart->imn = ica + 1;
   /*
   zmpart->imn = ica;
   */
   if (zmpart->imx == -1) zmpart->imx = *zmptrp->nz;
   else zmpart->imx++;

   if (ires <= calfptr->ncalf-1) zmpart->imx = ica2;

   if (zmpart->imx > zmpart->imn) zmpart->ipart = 2;
}

void FindZRangeFromBox(isel)
int isel;
{
   int ica,ires,iamino,sidechainstart,i;

   if (!*ipdbon || *ialtyp) return;
/*
 Dont do partial zmatrix update when doing interactive docking
*/

   ires = xyzp->iresid[isel];

   if (ires < 0) {
	zmpart->imn = isel + 1;
	zmpart->imx = *zmptrp->nz;

	if (zmpart->imx > zmpart->imn) zmpart->ipart = 1;
	return;
   }

   iamino = calfptr->iamino[ires-1];

   if (!(iamino > 0 && iamino <= 23)) return;

   ica = calfptr->icalf[ires-1][0] - 1;

   sidechainstart = ica+5;

   if (iamino == 15) {
	sidechainstart = ica+4;
	if (zmptrp->ianz[ica+2] == 8) { 
		sidechainstart--; 
	}
   } else {
/* if start residue there might be an N missing at nz+2 */

	if (zmptrp->ianz[ica+4] != 1 && zmptrp->ianz[ica+3] == 1) 
		sidechainstart--; 
   }

/*
   if (isel < sidechainstart) return;
*/
   if (isel < sidechainstart) sidechainstart = isel;

   for (i=sidechainstart; i < *zmptrp->nz; i++) {
        if (xyzp->iresid[i] != ires) {
            zmpart->imx = i; break;
        }
   }
   zmpart->imn = sidechainstart + 1;
   zmpart->imx = zmpart->imx + 1;

   if (zmpart->imx > zmpart->imn) zmpart->ipart = 1;
}

int IsPhiPsi(isel)
int isel;
{
   int i;

   for (i=0; i<calfptr->ncalf; i++) {
	if (aaptr[i].phi == isel || aaptr[i].psi == isel)
		return(1);
   }
   return(0);
}

int AmiCom(iopt,x,y)
int iopt;
int x;
int y;
{

  if (ZMEAA || (!(ZMEup && *zmptrp->ihaszm) && *ipdbon) ) {
        int ires,i,iflp,ihis;

	iflp = 0;
	ires = -1;

	if (iopt) {
	   ires = CurAmino + 1;
	   if (ires <= -4) {
		if (HetCom(x,y)) return(1);
	   }
	} else {
	   i = Clickwin(ZMEAAbut,ZME_window_high,x,y,1);
	   if (i>=0) {
		ires = ZME_window_pos+i+1;
		CurAmino = ires-1;
	   }
	}
	moving = gmoving = 0;
	if (ires > 0) {
	   LSSTRU List; int iamin, aminotyp;

	   aminotyp = calfptr->iamino[ires-1]-1;

	if (has_opengl && (*fancy || *fullgl)) {

           if (calfptr->iamino[ires-1] > 23) {
		List.list = AmiBOpt; List.nents = 7;
	   } else {
		if (ZMEup && *zmptrp->ihaszm && *ipdbon) {
		   if (aminotyp == 9 || aminotyp == 13) {
			List.list = AmiNQOpt; List.nents = 17;
	   	   } else if (aminotyp == 16) {
			List.list = AmiHOpt; List.nents = 17;
	   	   } else {
			List.list = AmiBOpt; List.nents = 16;
	   	   }
		   if (ires == calfptr->ncalf) List.nents++;
		} else {
		   if (aminotyp == 9 || aminotyp == 13) {
			List.list = AmiNQOpt; List.nents = 13;
		   } else if (aminotyp == 16) {
			List.list = AmiHOpt; List.nents = 13;
		   } else {
			List.list = AmiBOpt; List.nents = 12;
		   }
		}
	   }
	} else if (!has_opengl || (has_opengl && !(*fancy || *fullgl) )) {


           if (calfptr->iamino[ires-1] > 23) {
		List.list = AmiBOptS; List.nents = 5;
	   } else {
		if (ZMEup && *zmptrp->ihaszm && *ipdbon) {
		   if (aminotyp == 9 || aminotyp == 13) {
			List.list = AmiNQOptS; List.nents = 15;
		   } else if (aminotyp == 16) {
			List.list = AmiHOptS; List.nents = 15;
		   } else {
			List.list = AmiBOptS; List.nents = 14;
	   	   }
		   if (ires == calfptr->ncalf) List.nents++;
		} else {
		   if (aminotyp == 9 || aminotyp == 13) {
			List.list = AmiNQOptS; List.nents = 11;
		   } else if (aminotyp == 16) {
			List.list = AmiHOptS; List.nents = 11;
		   } else {
			List.list = AmiBOptS; List.nents = 10;
	   	   }
		}
	   }
	}
  
	   if (iopt) {
		if (DoPopUp(win,x,y,&List,&iamin,0) == -1) return 0;
	   } else {
		if (DoPopUp(ZMEwin,
			ZMEAAbut[i].x+5,ZMEAAbut[i].y+5,
			&List,&iamin,0) == -1) return 0;
		RedrawZME();
	   }

	   if (aminotyp == 9 || aminotyp == 13) {
		if (iamin == 5) iflp = 1;
		if (iflp) {
#if defined(VMS) || defined(UNDERSC)
		    sngflp(&ires,
#else
#ifdef CRAY
		    SNGFLP(&ires,
#else
		    sngflp_(&ires,
#endif
#endif
			calfptr->iamino,xyzp->coo);
#ifdef DOGL
		    ogres(ires,1,1);
		    update_model = 0;
#endif
		    update_struct();
		    return(0);
		} else {
	   	    if (iamin > 5) iamin--;
		}
	   }

	   if (aminotyp == 16) {
		if (iamin == 5) iflp = 1;
		if (iflp) {
	           List.list = HisOpt; List.nents = 3;

	   	   if (iopt) {
			if (DoPopUp(win,x,y,&List,&ihis,0) == -1) return 0;
	   	   } else {
			if (DoPopUp(ZMEwin,
			   ZMEAAbut[i].x+5,ZMEAAbut[i].y+5,
			   &List,&ihis,0) == -1) return 0;
	   	   }

		   ihis++;
#if defined(VMS) || defined(UNDERSC)
		   sethis(&ires,&ihis,
#else
#ifdef CRAY
		   SETHIS(&ires,&ihis,
#else
		   sethis_(&ires,&ihis,
#endif
#endif
			xyzp->coo,xyzp->qat,xyzp->iresid,xyzp->iatclr,
			xyzp->iaton,xyzp->iconn,xyzp->ianz,&calfptr->ncalf,
			calfptr->icalf,xyzp->ityp,xyzp->ipdbt);
#ifdef DOGL
		   ogres(ires,1,1);
		   update_model = 0;
#endif
		   update_struct();
		   return(0);

		} else {
	   	    if (iamin > 5) iamin--;
		}
	   }

	if (!has_opengl || (has_opengl && !(*fancy || *fullgl) )) {
	   if (iamin >= 5) {
		iamin++;
		iamin++;
	   }
	}

	   switch (iamin) {
	   case 0:
		   if (calfptr->reson[ires-1] == 0) {
#if defined(VMS) || defined(UNDERSC)
			actami(&ires,&ZERO,&ONE,&ZERO);
#else
#ifdef CRAY
			ACTAMI(&ires,&ZERO,&ONE,&ZERO);
#else
			actami_(&ires,&ZERO,&ONE,&ZERO);
#endif
#endif
			rsold = RESUND;
#ifdef DOGL
			ogres(ires,ONE,1);
#else
			return(1);
#endif
		  } else {
#if defined(VMS) || defined(UNDERSC)
			actami(&ires,&ZERO,&ZERO,&ZERO);
#else
#ifdef CRAY
			ACTAMI(&ires,&ZERO,&ZERO,&ZERO);
#else
			actami_(&ires,&ZERO,&ZERO,&ZERO);
#endif
#endif
			rsold = RESUND;
#ifdef DOGL
			ogres(ires,ONE,1);
			update_model = 0;
			return(1);
#else
			update_model = 1;
			return(1);
#endif
		  }
			break;
	   case 1:	
			strcpy(molwstr,"Entering Amino Acid range select");
			StatusStr(0,1);

			if (DisHlp) {
			   DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"Residue range selection: Follow the point of the read arrow\nwhen it appears. To end selection hit the escape key.",0);
			   DisHlp = 0;
			}

			DisAmino = ires;
#if defined(VMS) || defined(UNDERSC)
			actami(&DisAmino,&ZERO,&ONE,&ZERO);
#else
#ifdef CRAY
			ACTAMI(&DisAmino,&ZERO,&ONE,&ZERO);
#else
			actami_(&DisAmino,&ZERO,&ONE,&ZERO);
#endif
#endif
			update_casel = 1;
#ifdef DOGL
			ogres(DisAmino,ONE,1);
#else
			return(1);
#endif
			break;
	   case 2:	{
			LSSTRU List;
			List.list = labels; 
			List.nents = 6;
			if (calfptr->lab[ires-1] == 0) {
			   if (DoPopUp(win,x,y,&List,
				&calfptr->lab[ires-1],0) == -1) return(0);
			   calfptr->lab[ires-1]++;
			   calfptr->lab[ires-1]++;
			} else {
			   calfptr->lab[ires-1] = 0;
			}
#ifdef DOGL
			update_model = 0;
#else
			update_model = 1;
			return(1);
#endif
			}
			break;
	   case 3:
#if defined(VMS) || defined(UNDERSC)
			setorg(&calfptr->icalf[ires-1][0]);
#else
#ifdef CRAY
			SETORG(&calfptr->icalf[ires-1][0]);
#else
			setorg_(&calfptr->icalf[ires-1][0]);
#endif
#endif
			return(1);
			break;
	   case 4:
#if defined(VMS) || defined(UNDERSC)
			proxic(&calfptr->icalf[ires-1][0],backb,&ZERO,&ONE,&THRESH);
#else
#ifdef CRAY
			PROXIC(&calfptr->icalf[ires-1][0],backb,&ZERO,&ONE,&THRESH);
#else
			proxic_(&calfptr->icalf[ires-1][0],backb,&ZERO,&ONE,&THRESH);
#endif
#endif
			XMapRaised(display,DISTwin);
			distup = 1;
			RedrawDIST();
			return(1);
			break;
	   case 5:
#if defined(VMS) || defined(UNDERSC)
			proxic(&calfptr->icalf[ires-1][0],backb,&ONE,&ONE,&THRESH);
			initsrf();
#else
#ifdef CRAY
			PROXIC(&calfptr->icalf[ires-1][0],backb,&ONE,&ONE,&THRESH);
	 		INITSRF();
#else
			proxic_(&calfptr->icalf[ires-1][0],backb,&ONE,&ONE,&THRESH);
			initsrf_();
#endif
#endif
			XMapRaised(display,DISTwin);
			distup = 1;
			RedrawDIST();
			return(1);
			break;
	   case 6:
			calfptr->iams[ires-1] = 1;
#if defined(VMS) || defined(UNDERSC)
			initsrf();
#else
#ifdef CRAY
	 		INITSRF();
#else
			initsrf_();
#endif
#endif
		/*	return(1);*/
			break;
	   case 7:	{  
			LSSTRU List; int inrs;
			List.list = Rotamers; 
			List.nents = aminozmt[aminotyp].nrots;

			inrs = 0;
			if (iopt) {
			   if (DoPopUp(win,x,y,&List,&inrs,0) == -1) return 0;
			} else {
			   if (DoPopUp(ZMEwin,
				ZMEAAbut[i].x+5,ZMEAAbut[i].y+5,
				&List,&inrs,0) == -1) return 0;
			}
			if (!ZMEup) {
#if defined(VMS) || defined(UNDERSC)
			   dfiass();
#else
#ifdef CRAY
			   DFIASS();
#else
			   dfiass_();
#endif
#endif

			   pmfrot->ndrs = 1;
			   pmfrot->idrs[0] = ires;
			   AllocRot();
			   rotset(ires,inrs);
			   DeAllocRot();
#ifdef DOGL
			   ogres(ires,ONE,1);
#endif
			   return(1);
			} else {
			   if (aminozmt[aminotyp].chis[0] != -1) 
				zmptrp->bet[aaptr[ires-1].chi1] = 
					aminozmt[aminotyp].rots[inrs].rots[0];
			   if (aminozmt[aminotyp].chis[1] != -1) 
				zmptrp->bet[aaptr[ires-1].chi2] = 
					aminozmt[aminotyp].rots[inrs].rots[1];
			   if (aminozmt[aminotyp].chis[2] != -1) 
				zmptrp->bet[aaptr[ires-1].chi3] = 
					aminozmt[aminotyp].rots[inrs].rots[2];
			   if (aminozmt[aminotyp].chis[3] != -1) 
				zmptrp->bet[aaptr[ires-1].chi4] = 
					aminozmt[aminotyp].rots[inrs].rots[3];
#if defined(VMS) || defined(UNDERSC)
			   curs(&ONE);
#else
#ifdef CRAY
	 		   CURS(&ONE);
#else
			   curs_(&ONE);
#endif
#endif
			   SetQZME();
			   if (ZME_window_pos >= calfptr->ncalf) ZME_window_pos = 0;
			   if (calfptr->ncalf < ZME_window_high) RedrawZME();
			   else UpdateZME();
			   RedrawScroll(&zscroll);
			   FindZRange(ires);
   			   zmt2cor(ires,0);
			}
			}
			break;
	   case 8:	{  
			void scanrot(int,int);

			scanrot(ires,aminotyp);

			}
			return(1);
			break;
	   case 9:	{  
			void onerot(int ires,int print);

			onerot(ires,1);

			}
			return(1);
			break;
	   case 10:	
			{int ikeus;
	   		List.list = RotLib; List.nents = 2;
			if (DoPopUp(win,x,y,&List,&ikeus,0) == -1) return 0;
			if (ZMEup) {
			   if (ikeus) aminozmt = aminozmtd;
			   else aminozmt = aminozmtr;
			} else {
			   if (ikeus) RDrots = aminorots;
			   else RDrots = raminorots;
			}
			}
			break;
	   case 11:	
			initflx();
			for (i=0; i < *xyzp->iatoms; i++) {
			   if (xyzp->iresid[i] == ires) {
				xyzp->iatclr[i] = 15;
			   }
			}
			pmfrot->idrs[pmfrot->ndrs] = ires;
			resrot[0].idrs[pmfrot->ndrs] = ires;
			pmfrot->ndrs++;
			resrot[0].ndrs = pmfrot->ndrs;
#ifdef DOGL
			ogres(ires,1,1);
#endif
			update_model = 0;
			break;
	   case 12:
#if defined(VMS) || defined(UNDERSC)
			curs(&ONE);
#else
#ifdef CRAY
	 		CURS(&ONE);
#else
			curs_(&ONE);
#endif
#endif
			idum1 = DelAmino(ires);
			make_aa();
			if (ZME_window_pos >= calfptr->ncalf) ZME_window_pos = 0;
			if (calfptr->ncalf < ZME_window_high) RedrawZME();
			else UpdateZME();
			RedrawScroll(&zscroll);
			*Sinct = 530;
			update_model = 1;
			return(1);
			break;
	   case 13:
			InsertAmino = ires;
			ReplaceAmino = 0;
			if (SEQup) {
			   XMapRaised(display,SEQwin);
			   RedrawSEQ();
			} else {
			   InitSEQ(event.xbutton.x_root,event.xbutton.y_root);
			}
			update_model = 1;
			break;
	   case 14:	{
			LSSTRU List; int inrs; int irsnrt;
			List.list = AminoAcids; List.nents = 20;

			if (!calfptr->icalf[ires][0]) {
			   DoCan(event.xbutton.x_root, event.xbutton.y_root,
			"Amino acid can not be replaced: \nMissing C alpha next residue.",0);
			   break;
			}

			if (iopt) {
			   if (DoPopUp(win,x,y,&List,&inrs,0) == -1) return 0;
			} else {
			   if (DoPopUp(ZMEwin,
				ZMEAAbut[i].x+5,ZMEAAbut[i].y+5,
				&List,&inrs,0) == -1) return 0;
			}
#if defined(VMS) || defined(UNDERSC)
			curs(&ONE);
#else
#ifdef CRAY
	 		CURS(&ONE);
#else
			curs_(&ONE);
#endif
#endif
			Sequence[0] = inrs;

    			irsnrt = calfptr->irsnr[ires-1];
			ReplaceSequence(Sequence,1,0,ires);
    			calfptr->irsnr[ires-1] = irsnrt;
			make_aa();
			SetQZME();
			if (ZME_window_pos >= calfptr->ncalf) ZME_window_pos = 0;
			if (calfptr->ncalf < ZME_window_high) RedrawZME();
			else UpdateZME();
			RedrawScroll(&zscroll);
			FindZRange(ires);
			if (ires <= calfptr->ncalf-1) 
				xyzp->iaton[calfptr->icalf[ires][1]-1] = 1;

#if defined(VMS) || defined(UNDERSC)
			actami(&ires,&ZERO,&ONE,&ZERO);
#else
#ifdef CRAY
			ACTAMI(&ires,&ZERO,&ONE,&ZERO);
#else
			actami_(&ires,&ZERO,&ONE,&ZERO);
#endif
#endif
   			zmt2cor(ires,1);
			if (*fftyp == 7) {
			   cell->ichx = 0;

#if defined(VMS) || defined(UNDERSC)
			   dotyp(&cell->ichx);
#else
#ifdef CRAY
			   DOTYP(&cell->ichx);
#else
			   dotyp_(&cell->ichx);
#endif
#endif
			}

			}
			break;
	   case 15:	  
			if (!AddCap(ires)) return(0);
			if (ZMEup) {
#ifdef DOGL
#if defined(VMS) || defined(UNDERSC)
			   dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
			   doconn();docent();doclr();qupd();
#else
#ifdef CRAY
			   DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
			   DOCONN();DOCENT();doclr();QUPD();
#else
			   dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
			   doconn_();docent_();doclr();qupd_();
#endif
#endif
#endif
			   return(1);
			}
			break;
	   case 16:	
#if defined(VMS) || defined(UNDERSC)
			curs(&ONE);
#else
#ifdef CRAY
	 		CURS(&ONE);
#else
			curs_(&ONE);
#endif
#endif
			InsertAmino = -1;
			ReplaceAmino = 0;
			LastAmino = calfptr->icalf[ires-1][2];
			if (SEQup) {
			   XMapRaised(display,SEQwin);
			   RedrawSEQ();
			} else {
			   InitSEQ(event.xbutton.x_root,event.xbutton.y_root);
			}
			break;
	   }
	}
  }
  return(0);
}

int HetCom(x,y)
int x;
int y;
{

  if (ZMEAA || (!(ZMEup && *zmptrp->ihaszm) && *ipdbon) ) {
        int ires,i;
	double rdist;

        rdist = 5.0;


	ires = CurAmino + 1;

	moving = gmoving = 0;

	if (ires < 0) {
	   LSSTRU List; int iamin, aminotyp;

#ifdef DOGL
	   List.list = HetOpt; List.nents = 10;

#else
	   List.list = HetOpt; List.nents = 9;

#endif
  
	   if (DoPopUp(win,x,y,&List,&iamin,0) == -1) return 0;

	   switch (iamin) {
	   case 0:
			i = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
					*xyzp->iatoms,x,y,MINDIFF);
			if (i != -1) {
			   i++;
#if defined(VMS) || defined(UNDERSC)
			setorg(&i);
#else
#ifdef CRAY
			SETORG(&i);
#else
			setorg_(&i);
#endif
#endif
			return(1);
			}
			break;
	   case 1:	{
			LSSTRU List;
			List.list = labhet; 
			List.nents = 5;
			if (clfstrptr->labhet[ABS(ires)] == 0) {
			   if (DoPopUp(win,x,y,&List,
				&clfstrptr->labhet[ABS(ires)],0) == -1) return(0);
			   clfstrptr->labhet[ABS(ires)]++;
			   clfstrptr->labhet[ABS(ires)]++;
			} else {
			   clfstrptr->labhet[ABS(ires)] = 0;
			}
			CentLig();
#ifdef DOGL
			update_model = 0;
#else
			update_model = 1;
			return(1);
#endif
			}
			break;
	   case 2:
			i = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
					*xyzp->iatoms,x,y,MINDIFF);
			i++; 
#if defined(VMS) || defined(UNDERSC)
			proxic(&i,backb,&ZERO,&ONE,&THRESH);
#else
#ifdef CRAY
			PROXIC(&i,backb,&ZERO,&ONE,&THRESH);
#else
			proxic_(&i,backb,&ZERO,&ONE,&THRESH);
#endif
#endif
			XMapRaised(display,DISTwin);
			distup = 1;
			RedrawDIST();
			return(1);
			break;
	   case 3:
			i = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
					*xyzp->iatoms,x,y,MINDIFF);
			i++; 
#if defined(VMS) || defined(UNDERSC)
			proxic(&i,backb,&ONE,&ONE,&THRESH);
			initsrf();
#else
#ifdef CRAY
			PROXIC(&i,backb,&ONE,&ONE,&THRESH);
	 		INITSRF();
#else
			proxic_(&i,backb,&ONE,&ONE,&THRESH);
			initsrf_();
#endif
#endif
			XMapRaised(display,DISTwin);
			distup = 1;
			RedrawDIST();
			return(1);
			break;
	   case 4:
			inichg(ires);
			break;
	   case 5:
			DelHet(ires);
			return(1);
			break;
	   case 6:
			LigandStruct(ires);
			break;
	   case 7:
			if (CheckWGET()) {
			   LigandHydro(ires);
			} else {
			   if (CheckHydro(ires)) {
				if (!DoCan(event.xbutton.x_root,
				           event.xbutton.y_root,
				   "Hydrogens already present !!\nAdding Hydrogens will render the\n stored formal charge as incorrect\nContinue ?",1)) {
				LigandHydroPBE(ires);
				}
			   } else {
				LigandHydroPBE(ires);
			   }
			}

#ifdef DOGL
			if (*fancy) {
			    oghet(0);
			} else {
			    oglines();
			}
			update_model = 0;
#endif
			update_struct();
			break;
	   case 8:
			if (ires < 0) {
			   int aires;

			   aires = ABS(ires);

			   if (aires < MXHETA) 
				calfptr->ihet[aires] = 0;

			   if (DoPopUp(win, x,y,
				  NULL,Snstr,0) == -1) break;
			   *Sinct = 330;
			   *Sincp = ires;

			   sndon(ires,1,*Snstr);
			   return(1);
			}
			break;
	   case 9:
			if (ires < 0) {
			   int aires;

			   aires = ABS(ires);

			   if (aires < MXHETA) 
				calfptr->ihets[aires] = 1;

#if defined(VMS) || defined(UNDERSC)
			   initsrf();
#else
#ifdef CRAY
	 		   INITSRF();
#else
			   initsrf_();
#endif
#endif
			}
		/*	return(1);*/
			break;
	   }
	}
  }
  return(0);
}

int PressZME(butnr,x,y)
int butnr;
int x;
int y;
{
  int i,j,k,iptr;
  int nat,nattmp,nprev,nvar;
  int type,row,column,deloke;
  LSSTRU List;

  if (DEBUG) fprintf(stderr,"PressZME in\n");

if (ZMEmode) {
  i = Clickwin(TabBut,TABBUTN,x,y,1);
      if (i>=0) {
	DeActZME();
        if (i==TABBUTN-1) ZMEatom = 99;
	else ZMEatom = i+1;
	nvar = 3; if (*zmptrp->nz <= 2) nvar = *zmptrp->nz;
	ZMEmode = 0;
	if (nvar > 0) {
	    int ln;
	    ZMEsel = 1;
	    aflag = nvar;anum = nvar;acnt = 0;
	    sprintf(stemp,
		"Select %d Atoms to define the connectivety of this Center. Escape to abort"
		,nvar);
	    ln = strlen(stemp);
	    strncpy(ZMEerr,stemp,MINI(ln,MAXZMEERR));
	    XDefineCursor(display,win,AtomCursor);
	    ActBut(&cbut[BDIST],0);
	    ActBut(&cbut[BANGLE],0);
	    ActBut(&cbut[BDIHED],0);
	}
	else AddLine(ZMEatom,1,NULL,NULL,NULL,NULL,ZMEmul);
	RedrawZME();
	return(1);
      }
      i = Clickwin(&ZMEBbut[ZMESIN],3,x,y,1);

      if (i>=0) {
	  switch (i) {
	  case ZMESIN:	TogBut(&ZMEBbut[ZMEmul]);ActBut(&ZMEBbut[ZMEmul],1);
			ZMEmul = ZMESIN;
			TogBut(&ZMEBbut[ZMEmul]);ActBut(&ZMEBbut[ZMEmul],-1);
			break;
	  case ZMEDBL:	TogBut(&ZMEBbut[ZMEmul]);ActBut(&ZMEBbut[ZMEmul],1);
			ZMEmul = ZMEDBL;
			TogBut(&ZMEBbut[ZMEmul]);ActBut(&ZMEBbut[ZMEmul],-1);
			break;
	  case ZMETRI:	TogBut(&ZMEBbut[ZMEmul]);ActBut(&ZMEBbut[ZMEmul],1);
			ZMEmul = ZMETRI;
			TogBut(&ZMEBbut[ZMEmul]);ActBut(&ZMEBbut[ZMEmul],-1);
			break;
	  }
      }
      return(0);
}
else if (!Selecting && !ZMEsel) {

  if (butnr == 3) { 
	k = 0;
	if (QBoxPaste(ZMEwin,IANZbox,*zmptrp->nz)) k = 1;;
	if (QBoxPaste(ZMEwin,BLbox,*zmptrp->nz)) k = 1;;
	if (QBoxPaste(ZMEwin,ALPHbox,*zmptrp->nz)) k = 1;;
	if (QBoxPaste(ZMEwin,BETbox,*zmptrp->nz)) k = 1;;
	if (!k) OnTop();
	return(0);
  } else { 

     if (!ZMEAA) {
        i = ClickBox(IANZbox,*zmptrp->nz,x,y);
        if (i>=0) {
   	   DeActZME();
	   IANZbox[i].col = ZC_AT1;
	   IANZbox[i].active = 1; UpdateZME();
	   if (zmptrp->imap[i]-1 >= 0) xyzp->iaton[zmptrp->imap[i]-1] = 3;
	   sprintf(ZMEerr, "Line %d Atom %d",i+1,zmptrp->imap[i]);
	   RedrawStatus();
	   update_model = 0;
	   update_sel = 1;
	   return(1);
        }
        i = ClickBox(BLbox,*zmptrp->nz,x,y);
        if (i>=0) {
	   ActVar(i,0,butnr);
	   return(1);
        }
        i = ClickBox(ALPHbox,*zmptrp->nz,x,y);
        if (i>=0) {
	   ActVar(i,1,butnr);
	   return(1);
        }
     }
     i = ClickBox(BETbox,*zmptrp->nz,x,y);
     if (i>=0) {
	ActVar(i,2,butnr);
	return(1);
     }
     for (i=0; i<*zmptrp->nz; i++) {
	j = ClickBox(&IZbox[i*4],4,x,y);
	if (j>=0) {
		update_model = 0;
		DeActZME(); 
		iptr = izz(i,j)-1;
		if (iptr < *zmptrp->nz && iptr >= 0) {
			IANZbox[iptr].col = ZC_AT2+j;
			xyzp->iaton[zmptrp->imap[iptr]-1] = 4+j;
		}
		IANZbox[i].col = ZC_AT1;
		IZbox[i*4+j].active = 1;
		UpdateZME();
		if (zmptrp->imap[i]-1 >= 0) xyzp->iaton[zmptrp->imap[i]-1] = 3;
		update_sel = 1;
		return(1);
	}
     }
   }
}

if (ZMEsel) return(0);

  i = ClickBox(&qboxes[QBZMAT],1,x,y);
  if (i>=0) {
		DeActZME(); 
		UpdateZME();
		qboxes[QBZMAT].active = 1;
		EXPbox[0].active = 0;
		PromptBox(&qboxes[QBZMAT]);
		PromptBox(&EXPbox[0]);
  }

  i = ClickBox(&EXPbox[0],1,x,y);
  if (i>=0) {
		DeActZME(); 
		UpdateZME();
		EXPbox[0].active = 1;
		qboxes[QBZMAT].active = 0;
		PromptBox(&EXPbox[0]);
		PromptBox(&qboxes[QBZMAT]);
  }

  i = Clickwin(ZMEswitch,2,x,y,1);
  if (i>=0) {
     switch (i) {
     case 0:
	if (pdb && ! *ialtyp) {
	   if (ZMEAA) {
		ZMEAA = 0;
		TogDown(&ZMEswitch[0]);
		EXPbox[0].fake = 1;
	   } else {
		ZMEAA = 1;
		make_aa();
		TogUp(&ZMEswitch[0]);
		EXPbox[0].fake = 0;
	   }
	   DeActZME();
	   SetQZME();
	   RedrawZME();
	}
	break;
     case 1:
	size_hints.flags =  USSize;
	size_hints.width = ZMEWINW;
	if (!ZMEbig) {
	   size_hints.height = ZMEWINH;
	   ZMEbig = 1;
	} else {
	   size_hints.height = ZMEZOffy-ZMEFRBord+ZMEZHIGH+1;
	   ZMEbig = 0;
	}
	XSetNormalHints(display, ZMEwin, &size_hints);
	XResizeWindow(display, ZMEwin, ZMEWINW,size_hints.height);
	TogBut(&ZMEswitch[1]);
	DrwBut(&ZMEswitch[1]);
	break;
     }
  }

  if (AmiCom(0,x,y) == 1) {
	update_model = 0;
	return(1);
  }

  i = Clickwin(ZMEbut,ZMEBUTTS,x,y,1);

      if (i>=0) {
	  strcpy(ZMEerr," ");
	  RedrawStatus();
	  switch (i) {
	  case ZMEARR1: ScrollBut(i); break;
	  case ZMEARR2: ScrollBut(i); break;
          case ZMEAPPL:	if (!Selecting && !ZMEsel) {
			    Zmat2Copy();
			    DeActZME(); GetQZME(); UpdateZME(); 
		  	    map_prop();
			    for (j=0; j<MAXSURF; j++) SSon[istruct][j] = 0;
			    SSdone[istruct] = 0;
			    RedrawSTRC();
			    *Sinct = 530; return(1); 
			}
			break;
          case ZMECAN1:	if (!Selecting && !ZMEsel) {
			    DeActZME(); SetQZME(); UpdateZME(); return(1); 
			}
			break;
          case ZMEREVT:	
			if (zmcnz == -1) break;

			if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
				"Revert to last known good Z-matrix", 1)) {
			    if (!Selecting && !ZMEsel) {
				Copy2Zmat();
				DeActZME(); SetQZME(); UpdateZME(); return(1); 
			    }
			}
			break;
          case ZMEFRG:	
			{int iret; 
			   iret = GetFrag(0,0,0);
			   if (iret != -1) return(iret);
			}
			break;
	  case ZMEADD:	if (!Selecting && !ZMEsel) {
			    ZMEmode = 1; RedrawZME(); return(0); 
			    calfptr->issdon = 0;
			}
			break;
	  case ZMEDEL:	if (Selecting || ZMEsel) break;
			activeZME(&type,&row,&column);
			deloke = 1;
			calfptr->issdon = 0;
			if (row < *zmptrp->nz && row >= 0) {
				for (j=row+1; j < *zmptrp->nz; j++) {
					for (k=0; k < 4; k++)
						if (izz(j,k) == row+1) 
							deloke = 0;
					if (deloke) {
					if (ABS(zmptrp->ibl[j]) == row+1) 
						deloke = -1;
					if (ABS(zmptrp->ialph[j]) == row+1) 
						deloke = -1;
					if (ABS(zmptrp->ibet[j]) == row+1) 
						deloke = -1;
					}
				}
			} else {
				deloke = -2;
			}
			if (deloke == 1) {
				DelLine(row,1,0,NULL);
				if (ZME_window_pos >= *zmptrp->nz-1) ZME_window_pos = 0;
				SetQZME(); RedrawZME(); *Sinct = 530; return(1);
			}
			else {
				if (deloke == -1) strcpy(ZMEerr,
					"LINE NOT DELETED: first remove all links to this line");
				else if (deloke == -2) strcpy(ZMEerr,
					"LINE NOT DELETED: no atom selected");
				else strcpy(ZMEerr,
					"LINE NOT DELETED: first remove all atoms connected to this line");
				if (*ibell) XBell(display,0);
				RedrawStatus();
			}
			break;
	  case ZMENEW:	if (!Selecting && !ZMEsel) {
			   *irtcel = 0;
			   *fftyp = 0;
			   pdb = 0;
			   *ipdbon = 0;
			   *icalc = 0;
			   cell->ichx = 0;
			   *natorg = 0;
			   DeActZME();
			   *xyzp->iatoms = 0;
			   for (j=0; j < 3; j++)
			      for (k=0; k < 3; k++)
				xyzp->coo[j*3+k] = 0.0;
			   *zmptrp->nz = 0;
			   ZME_window_pos = 0;
			   *zmptrp->ihaszm = 1;
			   geo1ptr->ieav = 0;
			   calfptr->ncalf = 0;
			   *backb = 0;
			   calfptr->nchain = 0;
			   LastAmino = -1;
			   calfptr->issdon = 0;
			   ZMEAA = 0;
          		   SetQZME(); RedrawZME();
			   nwater[istruct] = 0;
			   if (ATMup) {
				UpdateATM();
				XMapRaised(display,ATMwin);
				RedrawATM();
			   }
			   send_expose();
			   empty_model(istruct,1);
			   return(1);
			}
			break;
	  case ZMEMAP:	if (!Selecting && !ZMEsel) {
			   int ff; List.list = mapopt; List.nents = 7;
			   if (DoPopUp(ZMEwin,
				ZMEbut[ZMEMAP].x+1,ZMEbut[ZMEMAP].y-BUTTH,
				&List,iixyz,0) == -1) break;
			   if (*iixyz >= 4) {
				switch(*iixyz) {
				case 4:
					ff = 5;
					break;
				case 5:
					ff = 6;
					break;
				case 6:
					if (! (*fftyp >= 1 && *fftyp <= 4) ) {
					   ff = 1;
					   if (pdb) ff = 2;
					} else {
					   ff = *fftyp;
					}
					break;
				default:
					break;
				}
				if (typit(ff,0)) {
				   if (DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
					"Found UnTyped Atoms !",0)) {}
				} else {
				   if (*iixyz == 6) {
					if (TNKup) {
					   XMapRaised(display,TNKwin);
					   RedrawTNK();
					} else {
					   InitTNK(event.xbutton.x_root,
						event.xbutton.y_root);
					}
				   } else {
					*Sinct = 151; return(1);
				   }
				}
			   } else {
			      qboxstr(&qboxes[QMXYZ],NULL,1,0,-1,DEFQX,DEFQY,
				   QBOXWIDE,QBOXHIGH, 0,"XYZ file ? ",NULL,
				   0,0,151,0,dummyproc);
			   }
			}
			break;
	  case ZMECANC:	
			UnMapZME();
			RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);
			break;
	  case ZMECVAR:	 { int iop;
			   List.list = zmevarclr; List.nents = 2;
			   if (DoPopUp(ZMEwin,
				ZMEbut[ZMECVAR].x+1,ZMEbut[ZMECVAR].y+BUTTH,
				&List,&iop,0) == -1) break;
			   SetConst(iop);
			}
			break;
	  case ZMEGAM:	TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],1);
			ZMEopt = ZMEGAM;
			TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],-1);
			break;
	  case ZMEUS:
			if (*igztyp) {
			   TogBut(&ZMEbut[ZMEUS]);
			   *igztyp = 0;
			   strcpy(ZMEerr,"Switching to Gamess-UK style of Z-Matrix writing");
			} else {
			   TogDown(&ZMEbut[ZMEUS]);
			   *igztyp = 1;
			   strcpy(ZMEerr,"Switching to Gamess-US style of Z-Matrix writing");
			}
			RedrawStatus();
			break;
	  case ZMEGAU:	TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],1);
			ZMEopt = ZMEGAU;
			TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],-1);
			break;
	  case ZMEMOP:	TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],1);
			ZMEopt = ZMEMOP;
			TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],-1);
			break;
	  case ZMENWC:	TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],1);
			ZMEopt = ZMENWC;
			TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],-1);
			break;
	  case ZMECAR:	{LSSTRU List;
			TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],1);
			ZMEopt = ZMECAR;
			TogBut(&ZMEbut[ZMEopt]);ActBut(&ZMEbut[ZMEopt],-1);
			List.list = xyzopt; List.nents = 5; /* List.nents = 4; */
			DoPopUp(ZMEwin,ZMEbut[ZMECAR].x+1,
					ZMEbut[ZMECAR].y-3*BUTTH,&List,ixyz,0);
			/* DoPopUp(ZMEwin,ZMEbut[ZMECAR].x+1,
					ZMEbut[ZMECAR].y-2*BUTTH,&List,ixyz,0); */
			}
			break;
	  case ZMESUB:
			if (TogBut(&ZMEbut[ZMESUB])) {
			   XDestroyWindow(display,SUBwin);
		   	   SUBup = 0;
			} else {
			   if ((ZMEopt == ZMEGAM) && *igztyp) {
		  	 	if (DoCan(event.xbutton.x_root,
					event.xbutton.y_root,
					"Submit Gamess-US not available",0)) {
				}
				TogBut(&ZMEbut[ZMESUB]); 
			   } else {
				int jmode;

				jmode = ZMEopt-ZMEGAM;
				if (jmode == 4) jmode = 3;
 				if (*zmptrp->nz == 1) *zmptrp->ihaszm = 1;
				if (!CreateSUB(jmode)) 
					TogBut(&ZMEbut[ZMESUB]);
			   }
			}
			break;
	  case ZMEWRT:
			*Sinct = qboxes[QBZMAT].qbinct;
			*iwropt = ZMEopt-ZMEGAM + 1;
	 		if (*iwropt == 5) *iwropt = 7;
			cpstr(qboxes[QBZMAT].str,Sstr,
				strlen(qboxes[QBZMAT].str));
			*Snstr = strlen(qboxes[QBZMAT].str);
			return(1);
			break;
	  case ZMEORD:
			if (!Selecting && !dflag && !cflag) {
			   if (!DoCan(event.xbutton.x_root,
				event.xbutton.y_root,
				"Use ESC to cancel\nUse CNTL to rotate",1)) {
				for (i = 0; i <*xyzp->iatoms; i++) 
				   if (i < *xyzp->mxnat) jring[i] = 0;
				Selecting = 1; ZMEsel = 1;
				dflag = 1;
				aflag = *xyzp->iatoms; 
				anum = *xyzp->iatoms; acnt = 0;
				XDefineCursor(display,win,AtomCursor);
				strcpy(ZMEerr,"Select Atoms in the order you want the Z-matrix created");
				RedrawStatus();
				DeActZME();
			   }
			}
			break;
	  case ZMESEL:
			strcpy(ZMEerr,selstr);
			RedrawStatus();
			DeActZME();
			Selecting = 1;
			ZoomEnable = True;Select = True;
			break;
	  case ZMEUSEL:
			strcpy(ZMEerr,dselstr);
			ZoomEnable = True;Select = False;
			break;
	  case ZMESELA:
			Selecting = 0;
			nat = 0;
			for ( i = 0; i < *xyzp->iatoms; i++ ) 
				if (xyzp->iaton[i] > 1) nat++;
			if (!nat) {
				strcpy(ZMEerr,"Invalid Selection: No atoms selected");
				if (*ibell) XBell(display,0);
				RedrawStatus();
				return(0);
			}
			if (nat > *zmptrp->mxzat) {
			   strcpy(ZMEerr,"Invalid Selection: Too many atoms selected");
			   if (*ibell) XBell(display,0);
			   RedrawStatus();
			   for ( i = 0; i < *xyzp->iatoms; i++ ) 
				if (xyzp->iaton[i] >= 2) xyzp->iaton[i] = 1;
			   update_sel = 1;
		  	   return(1);
			}
			else {
			   AGLAB:
			   nprev = -1;
			   nattmp = 0;
			   for ( i = 0; i < *xyzp->iatoms; i++ ) {
				if (xyzp->iaton[i] >= 2) {
			  	    nattmp++;
				    if (i != nprev+1) {
					for ( j = 0; j < *xyzp->iatoms-i; j++ ) {
					    for (k=0; k < 3; k++)
						xyzp->coo[(nprev+1+j)*3+k] = 
						   xyzp->coo[(i+j)*3+k];
					    xyzp->ianz[nprev+1+j] = xyzp->ianz[i+j];
					    xyzp->iaton[nprev+1+j] = xyzp->iaton[i+j];
					    xyzp->iatclr[nprev+1+j] = xyzp->iatclr[i+j];
					    xyzp->iresid[nprev+1+j] = xyzp->iresid[i+j];
					    xyzp->qat[nprev+1+j] = xyzp->qat[i+j];
					    xyzp->ipdbt[nprev+1+j] = xyzp->ipdbt[i+j];
					    xyzp->ityp[nprev+1+j] = xyzp->ityp[i+j];
					}
					if (nattmp < nat) goto AGLAB;
				    }
				    nprev = i;
				}
			   }
		 	   *xyzp->iatoms = nat;
			   cell->ichx = 0; cellpnt->iclon = 0;
			   *ipdbon = 0;
			   ZMEAA = 0;
			   ApplSel(1);
			   empty_model(istruct,1);
			   *Sinct = 530;
			   update_sel = 1;
			   return(1);
			}
			break;
          }
      }
  ScrollPage(NULL,&zscroll,x,y);

  if (DEBUG) fprintf(stderr,"PressZME out\n");
  return (0);
}

void ApplSel(iop)
int iop;
{
int i,j;

   ZME_window_pos = 0;
   *doesp = 0;

   if (iop) {
#if defined(VMS) || defined(UNDERSC)
	docent();doconn();doscal();setxyv();
#else
#ifdef CRAY
	DOCENT();DOCONN();DOSCAL();SETXYV();
#else
	docent_();doconn_();doscal_();setxyv_();
#endif
#endif
   }



#if defined(VMS) || defined(UNDERSC)
   intzmt(&ZERO);
#else
#ifdef CRAY
   INTZMT(&ZERO);
#else
   intzmt_(&ZERO);
#endif
#endif

   if (qdpptr->ihasq) maparr(NULL,xyzp->qat,NULL,xyzp->ityp,1);
   maparr(NULL,NULL,NULL,xyzp->ityp,3);
   maparr(NULL,NULL,NULL,xyzp->ipdbt,3);
   maparr(NULL,NULL,xyzp->iatclr,NULL,2);
   maparr(NULL,NULL,xyzp->iresid,NULL,2);

   for ( i = 0; i < *xyzp->iatoms; i++ ) {
	if (xyzp->iaton[i] >= 2) xyzp->iaton[i] = 1;
   }
   update_sel = 1;
   SetQZME();
   RedrawZME();
}

void maparr(flarr,dblarr,intarr,shintarr,iopt)
float *flarr;
double *dblarr;
int *intarr;
short int *shintarr;
int iopt;
{
   float *flarrt;
   double *dblarrt;
   int *intarrt;
   short int *shintarrt;
   int j;

   switch(iopt) {
   case 0:
	if ((flarrt = (float *) malloc((sizeof *flarrt)*(*zmptrp->mxzat))) 
	   != NULL) {

	   for (j=0; j<*zmptrp->nz; j++) {
	      if (zmptrp->imap[j] > 0) {
		flarrt[j] = flarr[zmptrp->imap[j]-1];
	      } else {
		flarrt[j] = 0.0;
	      }
	   }
	   for (j=0; j<*zmptrp->nz; j++) flarr[j] = flarrt[j];
	   free(flarrt);
	}
	break;
   case 1:
	if ((dblarrt = (double *) malloc((sizeof *dblarrt)*(*zmptrp->mxzat))) 
	   != NULL) {

	   for (j=0; j<*zmptrp->nz; j++) {
	      if (zmptrp->imap[j] > 0) {
		dblarrt[j] = dblarr[zmptrp->imap[j]-1];
	      } else {
		dblarrt[j] = 0.0;
	      }
	   }
	   for (j=0; j<*zmptrp->nz; j++) dblarr[j] = dblarrt[j];
	   free(dblarrt);
	}
	break;
   case 2:
	if ((intarrt = (int *) malloc((sizeof *intarrt)*(*zmptrp->mxzat))) 
	   != NULL) {

	   for (j=0; j<*zmptrp->nz; j++) {
	      if (zmptrp->imap[j] > 0) {
		intarrt[j] = intarr[zmptrp->imap[j]-1];
	      } else {
		intarrt[j] = 0;
	      }
	   }
	   for (j=0; j<*zmptrp->nz; j++) intarr[j] = intarrt[j];
	   free(intarrt);
	}
	break;
   case 3:
	if ((shintarrt = (short int *) malloc((sizeof *shintarrt)*(*zmptrp->mxzat))) 
	   != NULL) {

	   for (j=0; j<*zmptrp->nz; j++) {
	      if (zmptrp->imap[j] > 0) {
		shintarrt[j] = shintarr[zmptrp->imap[j]-1];
	      } else {
		shintarrt[j] = 0;
	      }
	   }
	   for (j=0; j<*zmptrp->nz; j++) shintarr[j] = shintarrt[j];
	   free(shintarrt);
	}
	break;
   default:
	break;
   }

}

void ScrollBut(i)
int i;
{

    switch (i) {
    case ZMEARR1: 
#ifdef HASTIMER
        XSync(display, False);
	do {
		if (*zscroll.wn > ZME_window_high) 
		   if (ZME_window_pos) {
			ZME_window_pos--;
			RedrawScroll(&zscroll);
			UpdateZME();
			Timer(50,0);
		   }
		}
	while (!XCheckWindowEvent(display, ZMEwin, ButtonReleaseMask, &event));
#else
	if (*zscroll.wn > ZME_window_high) {
	   if (ZME_window_pos) {
		ZME_window_pos--;UpdateZME();
		RedrawScroll(&zscroll);
	   }
	}
#endif
	break;
    case ZMEARR2:	
#ifdef HASTIMER
        XSync(display, False);
        do {
       		if (*zscroll.wn > ZME_window_high) {
           		ZME_window_pos++; 
               		if (ZME_window_pos > *zscroll.wn-ZME_window_high) 
				ZME_window_pos = *zscroll.wn-ZME_window_high;
               		else {RedrawScroll(&zscroll); UpdateZME(); }
			Timer(50,0);
              	}
	 } while (!XCheckWindowEvent(display, ZMEwin, ButtonReleaseMask, &event));
#else
	if (*zscroll.wn > ZME_window_high) {
		ZME_window_pos++; 
		if (ZME_window_pos > *zscroll.wn-ZME_window_high) 
			ZME_window_pos = *zscroll.wn-ZME_window_high;
		UpdateZME();
		RedrawScroll(&zscroll);
	}
#endif
	break;
    }
}


int ScrollPage(lp,sc,x,y)
SCRSTRU *sc;
LISTSTRU *lp;
int x;
int y;
{
  int i,slidey,slideh,fnd,wposold;
  float ZMEScrRatio;
  XEvent xev;

  fnd = 0;

/* 
   divide number of elements in scroll window (wh) 
   by total number of elements (wn). Height of slider (slideh)
   with respect to height scroll bar (sc->h) has the same ratio
   wh : slideh = wn : sc->h
   or
   wh : wn = slideh : sc->h
*/

  if (*sc->wn > 0) ZMEScrRatio = (sc->wh*1.0) / (*sc->wn);
  else ZMEScrRatio = 1.0;
  if (ZMEScrRatio > 1.0) ZMEScrRatio = 1.0;

  slideh = sc->h * ZMEScrRatio;
  if (slideh < SCRMIN) slideh = SCRMIN;

/* sc->wpos position of first element visible listbox in the element array.
  Height per elemnt =  h/wn , Hwpos = wpos*(h/wn)
*/

  if (*sc->wn > 0) ZMEScrRatio = (sc->h-slideh)*1.0 / (*sc->wn - sc->wh);
  else ZMEScrRatio = 0.0;
  slidey = *sc->wpos * ZMEScrRatio;

  if (VIERKANT(x, y, sc->x, sc->y, sc->w, sc->h)) {
	fnd = 2;
/*      clicked on slider */
  }
  if (VIERKANT(x, y, sc->x, sc->y, sc->w, slidey)) {
	*sc->wpos = *sc->wpos - sc->wh;
	fnd = 1;
/*      clicked above slider */
  }
  if (VIERKANT(x, y, sc->x, sc->y+slidey+slideh, sc->w, 
               sc->h-slideh-slidey)) {
	*sc->wpos = *sc->wpos + sc->wh;
	fnd = 1;
/*      clicked below slider */
  }
  if (VIERKANT(x, y, sc->x, slidey, sc->w, 
               slideh)) {
	fnd = 2;
/*      clicked below slider */
  }


  wposold = -1;
  while (fnd) {
	if (*sc->wpos > (*sc->wn) - 1 - sc->wh) {
	   if ((*sc->wn) - 1 - sc->wh >= 0) {
		*sc->wpos = (*sc->wn) - sc->wh;
	   }
	   else *sc->wpos = 0;
	}
	if (*sc->wpos < 0) *sc->wpos = 0;

        if (*sc->wpos != wposold) {
	   if (sc->win == ZMEwin) {
		UpdateZME();
		RedrawScroll(sc);
	   } else if (sc->win == DPTwin) {
		RedrawScroll(&dptscr[0]);
		UpdateDPT();
	   } else if (lp != NULL) {
		RedrawLBox(lp); RedrawScroll(&lp->scrbar);
	   } else {
		RedrawScroll(sc);
	   }
	   XSync(display,True);
	}
	wposold = *sc->wpos;

	if (fnd == 1) {
	   return(1);
	} else {
	   XNextEvent(display, &xev);
	   switch (xev.type) {
		case ButtonRelease:
		case LeaveNotify:
		   return(1);
		   break;
		case MotionNotify:
		   if (xev.xmotion.window == sc->win)  {
			*sc->wpos = *sc->wn * ((int) xev.xmotion.y - sc->y) 
				/ (int) (sc->h);
		   }
		   break;
	   }
	}
  } 

  return(0);

}

void ActVar(isel,itype,butnr)
int isel;
int itype;
int butnr;
{
   int i,j,iptr,ierr;
   int *ii;

   i = isel;

   ierr = 0;

   if (butnr == 2) ierr = QBselect(i,itype);

   switch (itype) {
	case 0: ii = &zmptrp->ibl[isel] ; break;
	case 1: ii = &zmptrp->ialph[isel]; break;
	case 2: ii = &zmptrp->ibet[isel]; break;
   }

   switch (ABS(*ii)) {
	case 0: strcpy(ZMEerr,"Constant"); break;
	case 1: strcpy(ZMEerr,"Variable"); break;
	default: i = ABS(*ii) - 1;
		 if (*ii < 0) {
			strcpy(ZMEerr,"Negative Linked Variable");
		 } else {
			strcpy(ZMEerr,"Linked Variable");
		 }
   }
   if (!ierr) RedrawStatus();

   DeActZME();
   for (j=0; j<itype+1; j++) {
	iptr = izz(i,j)-1;
	if (iptr < *zmptrp->nz && iptr >= 0) {
		IANZbox[iptr].col = ZC_AT2+j;
		xyzp->iaton[zmptrp->imap[iptr]-1] = 4+j;
	}
   }
   IANZbox[i].col = ZC_AT1;

   switch (itype) {
   case 0:	BLbox[i].active = 1; break;
   case 1:	ALPHbox[i].active = 1; break;
   case 2:	BETbox[i].active = 1; break;
   }

   
   if (ZMEAA) {
	CurAmino = -1;
	for (j=0; j<ZME_window_high; j++) {
	   ZMEAAbut[j].lastused = -1;
	   ZMEAAbut[j].bg = 196;
	}
   }

   update_model = 0;
   update_sel = 1;
   UpdateZME();
   if (zmptrp->imap[i]-1 >= 0) xyzp->iaton[zmptrp->imap[i]-1] = 3;

}

int QBselect(isel,itype)
int isel;
int itype;
{
    XEvent xev;
    int x,y,doit,ierr,ilnkerr,i,icol;
    LSSTRU List; int iop; int ltype;

    switch (itype) {
	case 0: x = BLbox[isel].x; y = BLbox[isel].y; break;
	case 1: x = ALPHbox[isel].x; y = ALPHbox[isel].y; break;
	case 2: x = BETbox[isel].x; y = BETbox[isel].y; break;
    }

    if (*ipdbon) 
	if (xyzp->iresid[isel] > 0) update_res = xyzp->iresid[isel];

    ierr = 0; ilnkerr = 0;
    List.list = zmevaropt; List.nents = 6;
    if (itype == 2) List.nents = 7;
    if (DoPopUp(ZMEwin,x+1,y+BUTTH,&List,&iop,0) == -1) return 0;

    if (iop == 4) {
	animptr.isel = isel;
	animptr.vdirection = 1;
	animptr.frame = 0;
	switch (itype) {
	    case 0: 
		animptr.variable = &zmptrp->bl[isel]; 
		if (zmptrp->ibl[isel] > 1) {
		   animptr.variable = &zmptrp->bl[zmptrp->ibl[isel] - 1];
		   animptr.isel = zmptrp->ibl[isel] - 1;
		}
		break;
	    case 1: 
		animptr.variable = &zmptrp->alph[isel]; 
		if (zmptrp->ialph[isel] > 1) {
		   animptr.variable = &zmptrp->alph[zmptrp->ialph[isel] - 1];
		   animptr.isel = zmptrp->ialph[isel] - 1;
		}
		break;
	    case 2: 
		animptr.variable = &zmptrp->bet[isel]; 
		if (ABS(zmptrp->ibet[isel]) > 1) {
		   animptr.variable = &zmptrp->bet[ABS(zmptrp->ibet[isel])-1];
		   animptr.isel = ABS(zmptrp->ibet[isel])-1;
		}
		break;
	}
	animptr.varinit = *animptr.variable;
	animptr.vartype = itype;
	if (IsPhiPsi(isel)) {
	   FindZRangeFromBox(isel);
	   if (zmpart->ipart) {
		animptr.part = zmpart->ipart;
		zmpart->imx = *zmptrp->nz;
		update_res = -1;
		animptr.ssdone = 0;
	   }
	} else {
	   FindZRangeFromBox(isel);
	   if (zmpart->ipart) animptr.part = zmpart->ipart;
	}
	*Sinct = 530;
	InitANIM(event.xbutton.x_root,event.xbutton.y_root);
	RedrawZME();
	animptr.on = 1;
        return(0);
    }
    if (iop > 4) iop--;

    if (iop == 2 || iop == 3) {
	if (iop == 2) icol = ZC_MARK;
	if (iop == 3) {
	    switch (itype) {
	    case 0: iop = zmptrp->ibl[isel]; break;
	    case 1: iop = zmptrp->ialph[isel]; break;
	    case 2: iop = zmptrp->ibet[isel]; break;
	    }
	    switch (iop) {
		case 0: icol = ZC_CONST; break;
		case 1: icol = ZC_VAR; break;
		default: icol = ZC_LINK;
	    }
	}
	switch (itype) {
	case 0: BLbox[isel].col = icol; break;
	case 1: ALPHbox[isel].col = icol; break;
	case 2: BETbox[isel].col = icol; break;
	}
	return(0);
    }

    if (iop > 3) {
      switch (itype) {
	case 0: strcpy(ZMEerr,"Click on a Z-matrix Bondlength"); break;
	case 1: strcpy(ZMEerr,"Click on a Z-matrix BondAngle"); break;
	case 2: strcpy(ZMEerr,"Click on a Z-matrix Dihedral"); break;
      }
      if (*ibell) XBell(display,0);
      RedrawStatus();
      ltype = 1;
      if (iop == 5) ltype = -1;
      doit = 1;
      while (doit) {
        XNextEvent(display, &xev);
        if (xev.xexpose.window == ZMEwin) {
	    switch (xev.type) {

		case Expose:	RedrawZME(); break;
		case ButtonPress:    
		    i = Clickwin(ZMEbut,ZMEBUTTS,xev.xbutton.x,xev.xbutton.y,1);

		    if (i>=0) {
			switch (i) {
			    case ZMEARR1: ScrollBut(i); break;
			    case ZMEARR2: ScrollBut(i); break;
			}
			break;
		    }
		    if (ScrollPage(NULL,&zscroll,xev.xbutton.x,xev.xbutton.y)) 
			break;
                    iop = 1;
		    switch (itype) {
			case 0: iop = 1+ClickBox(BLbox,*zmptrp->nz,
						xev.xbutton.x,xev.xbutton.y); 
				if (ABS(zmptrp->ibl[iop-1]) > 1) ilnkerr = 1;
				break;
			case 1: iop = 1+ClickBox(ALPHbox,*zmptrp->nz,
						xev.xbutton.x,xev.xbutton.y); 
				if (ABS(zmptrp->ialph[iop-1]) > 1) ilnkerr = 1;
				break;
			case 2: iop = 1+ClickBox(BETbox,*zmptrp->nz,
						xev.xbutton.x,xev.xbutton.y); 
				if (ABS(zmptrp->ibet[iop-1]) > 1) ilnkerr = 1;
				break;
		    }

		    if (!iop) {
			iop = 1;
			strcpy(ZMEerr,"No suitable variable chosen");
			ierr = 1;
		    }
		    if (iop > isel) {
			iop = 1;
			strcpy(ZMEerr,"ERROR: Link only to earlier defined variable");
			ierr = 1;
		    }
		    if (ilnkerr) {
			iop = 1;
			strcpy(ZMEerr,"ERROR: CAN Not link to a linked variable");
			ierr = 1;
		    }
		    if (ierr) {
			if (*ibell) XBell(display,0);
      			RedrawStatus();
		    }
		    iop = iop * ltype;
		    if (iop == -1) iop = 1;
		    doit = 0;
            }
	}
      }
    }
    switch (iop) {
	case 0: icol = ZC_CONST; break;
	case 1: icol = ZC_VAR; break;
	default: icol = ZC_LINK;
    }
    switch (itype) {
	case 0: 
		zmptrp->ibl[isel] = iop; 
		BLbox[isel].col = icol; 
		BLbox[isel].changed = 1;
		break;
	case 1: 
		zmptrp->ialph[isel] = iop; 
		ALPHbox[isel].col = icol; 
		ALPHbox[isel].changed = 1; 
		break;
	case 2: 
		zmptrp->ibet[isel] = iop; 
		BETbox[isel].col = icol; 
		BETbox[isel].changed = 1; 
		break;
    }
    /*fprintf(stderr,"itype %d , %d\n",itype,iop);*/
    if (ABS(iop) > 1) {GetQZME();*Sinct = 530; }
    return (ierr);
}

void SwitchOffAnim()
{
	if (!animptr.on) return;

	animptr.on = 0;
	if (animptr.part) zmpart->ipart = animptr.part;
	*animptr.variable = animptr.varinit;
	if (!animptr.ssdone) SSdone[istruct] = 0;
	AnimLinks(animptr.varinit);
	anim();
	if (*ipdbon) presetp();
        update_res = -1;
	animptr.part = 0;
	animptr.ssdone = 1;
	if (ANIMup) {
	   XDestroyWindow(display,ANIMwin);
	   ANIMup = 0;
	}
	XSync(display, False);
}

void AnimLinks(vartmp)
double vartmp;
{
	int i;

	switch (animptr.vartype) {
	   case 0:
		sprintf(BLbox[animptr.isel].str,"%f",vartmp);
		PromptBox(&BLbox[animptr.isel]);
		break;
	   case 1:
		sprintf(ALPHbox[animptr.isel].str,"%f",vartmp);
		PromptBox(&ALPHbox[animptr.isel]);
		break;
	   case 2:
		sprintf(BETbox[animptr.isel].str,"%f",vartmp);
		PromptBox(&BETbox[animptr.isel]);
		break;
	}

	if (zmpart->ipart) return;

	for (i=0; i<*zmptrp->nz; i++) {
	    switch (animptr.vartype) {
		case 0:
		   if (zmptrp->ibl[i] > 1 && 
			zmptrp->ibl[i] - 1 == animptr.isel)
			zmptrp->bl[i] = vartmp;
		   break;
		case 1:
		   if (zmptrp->ialph[i] > 1 &&
			zmptrp->ialph[i] - 1 == animptr.isel)
			zmptrp->alph[i] = vartmp;
		   break;
		case 2:
		   if (ABS(zmptrp->ibet[i]) > 1 && 
			ABS(zmptrp->ibet[i]) - 1 == animptr.isel) {
			if (zmptrp->ibet[i] > 0) {
			   zmptrp->bet[i] = vartmp;
			} else {
			   zmptrp->bet[i] = -vartmp;
			}
		   }
		   break;
	    }
	}
}

void DefSlide(sc,win,x,y,w,h,sh,wn,wpos,rat,callback)
SLIDESTRU	*sc;
Window		win;
int		x,y;
unsigned int	w,h;
int		sh;
int		*wn;
int		*wpos;
float		*rat;
ptr_void_proc	callback;
{
  sc->win = win;
  sc->x = x;  sc->y = y;  sc->w = w;  sc->h = h;
  sc->wn = wn;
  sc->wpos = wpos;
  sc->ratio = rat;
  *sc->ratio = *wpos / *wn;
  sc->sh = sh;
  sc->callback = callback;
}


void RedrawSlide(sc)
SLIDESTRU *sc;
{
  int slidey,slideh;

  slideh = sc->sh;
  slidey = (int) (sc->h - sc->sh) * (*sc->ratio);

  butje(sc->win, sc->x, sc->y,        sc->w, sc->h ,3,0,0,0,None,0,0,0,0);
  butje(sc->win, sc->x, sc->y+slidey, sc->w, slideh,3,0,0,1,None,0,0,0,0);

}

int SlideScroll(sc,x,y)
SLIDESTRU *sc;
int x;
int y;
{
  int i,inslide,wposold;
  XEvent xev;

  inslide = 0;
  if (VIERKANT(x, y, sc->x, sc->y, sc->w, sc->h)) {
	inslide = 1;
  }

  wposold = -1;
  while (inslide) {

	if (*sc->wpos > *sc->wn) *sc->wpos = *sc->wn;
	if (*sc->wpos < 0) *sc->wpos = 0;

        if (*sc->wpos != wposold) {
	   RedrawSlide(sc);
	   if (sc->win == OMAPwin) sc->callback();
	   XSync(display,True);
	}
	wposold = *sc->wpos;

	   XNextEvent(display, &xev);
	   switch (xev.type) {
		case ButtonRelease:
		case LeaveNotify:
		   return(1);
		   break;
		case MotionNotify:
		   if (xev.xmotion.window == sc->win)  {
			*sc->ratio = ((float) xev.xmotion.y - (float) sc->y) 
				/ (float) (sc->h - sc->sh);
			if (*sc->ratio < 0.0) *sc->ratio = 0.0;
			if (*sc->ratio > 1.0) *sc->ratio = 1.0;
			*sc->wpos = *sc->wn * (*sc->ratio);
		   }
		   break;
	   }
  } 

  return(0);

}

void DefScroll(sc,win,x,y,w,h,wn,wpos,wh,callback)
SCRSTRU		*sc;
Window		win;
int		x,y;
unsigned int	w,h;
int		*wn;
int		*wpos;
int		wh;
ptr_void_proc	callback;
{
  sc->win = win;
  sc->x = x;  sc->y = y;  sc->w = w;  sc->h = h;
  sc->wn = wn;
  sc->wpos = wpos;
  sc->wh = wh;
  sc->callback = callback;
}


void RedrawScroll(sc)
SCRSTRU		*sc;
{
  int slidey,slideh;
  float ZMEScrRatio;

  if (sc->wn == NULL) return;

  if (*sc->wn > 0) ZMEScrRatio = (sc->wh*1.0) / (*sc->wn);
  else ZMEScrRatio = 1.0;
  if (ZMEScrRatio > 1.0) ZMEScrRatio = 1.0;
  slideh = (int) sc->h * ZMEScrRatio;
  if (slideh < 5) slideh = SCRMIN;
  if (*sc->wn > 0) ZMEScrRatio = (*sc->wpos)*1.0 / (*sc->wn);
  else ZMEScrRatio = 0.0;
  slidey = (int) sc->h * ZMEScrRatio;
  if (sc->h - slidey < slideh) slidey = sc->h - slideh;

  butje(sc->win, sc->x, sc->y,        sc->w, sc->h ,3,0,0,0,None,0,0,0,0);
  butje(sc->win, sc->x, sc->y+slidey, sc->w, slideh,3,0,0,1,None,0,0,0,0);

}

void DeActZME()
{
  int i,j,type,iptr;

  if (!ZMEup) return;

  if (qboxes[QBZMAT].active) {
	qboxes[QBZMAT].active = 0;
	PromptBox(&qboxes[QBZMAT]);
	return;
  }
  if (EXPbox[0].active) {
	EXPbox[0].active = 0;
	PromptBox(&EXPbox[0]);
	return;
  }
  activeZME(&type,&i,&j);
  switch(type) {
  case 0:
	IANZbox[i].col = ZC_DEF;
	IANZbox[i].active = 0;
	if (zmptrp->imap[i]-1 >= 0)
		xyzp->iaton[zmptrp->imap[i]-1] = 1;
	break;
  case 1:
	iptr = izz(i,0)-1;
	if (iptr < *zmptrp->nz && iptr >= 0) {
		IANZbox[iptr].col = ZC_DEF;
		xyzp->iaton[zmptrp->imap[iptr]-1] = 1;
	}
	IANZbox[i].col = ZC_DEF;
	BLbox[i].active = 0;
	if (zmptrp->imap[i]-1 >= 0)
		xyzp->iaton[zmptrp->imap[i]-1] = 1;
	break;
  case 2:
	for (j=0; j<2; j++) {
		iptr = izz(i,j)-1;
		if (iptr < *zmptrp->nz && iptr >= 0) {
			IANZbox[iptr].col = ZC_DEF;
			xyzp->iaton[zmptrp->imap[iptr]-1] = 1;
		}
	}
	IANZbox[i].col = ZC_DEF;
	ALPHbox[i].active = 0;
	if (zmptrp->imap[i]-1 >= 0)
		xyzp->iaton[zmptrp->imap[i]-1] = 1;
	break;
  case 3:
	for (j=0; j<3; j++) {
		iptr = izz(i,j)-1;
		if (iptr < *zmptrp->nz && iptr >= 0) {
			IANZbox[iptr].col = ZC_DEF;
			xyzp->iaton[zmptrp->imap[iptr]-1] = 1;
		}
	}
	IANZbox[i].col = ZC_DEF;
	BETbox[i].active = 0;
	if (zmptrp->imap[i]-1 >= 0)
		xyzp->iaton[zmptrp->imap[i]-1] = 1;
	break;
  case 4:
	iptr = izz(i,j)-1;
	if (iptr < *zmptrp->nz && iptr >= 0) {
		IANZbox[iptr].col = ZC_DEF;
		xyzp->iaton[zmptrp->imap[iptr]-1] = 1;
	}
	IANZbox[i].col = ZC_DEF;
	IZbox[i*4+j].active = 0;
	if (zmptrp->imap[i]-1 >= 0)
		xyzp->iaton[zmptrp->imap[i]-1] = 1;
	break;
  }
  update_sel = 1;
}

void UndoZME()
{
  int i,j,type;

  activeZME(&type,&i,&j);
  switch(type) {
  case 0:
        if (zmptrp->ianz[i] >= 0 && zmptrp->ianz[i] < 100)
             sprintf(stemp,"%s",elements[zmptrp->ianz[i]]);
        else sprintf(stemp,"%s","?");
	strcpy(IANZbox[i].str,stemp);
	PromptBox(&IANZbox[i]);
	break;
  case 1:
	sprintf(stemp,"%f",zmptrp->bl[i]);
	strcpy(BLbox[i].str,stemp);
	PromptBox(&BLbox[i]);
	break;
  case 2:
	sprintf(stemp,"%f",zmptrp->alph[i]);
	strcpy(ALPHbox[i].str,stemp);
	PromptBox(&ALPHbox[i]);
	break;
  case 3:
	sprintf(stemp,"%f",zmptrp->bet[i]);
	strcpy(BETbox[i].str,stemp);
	PromptBox(&BETbox[i]);
	break;
  case 4:
	sprintf(stemp,"%d",izz(i,j));
	strcpy(IZbox[i*4+j].str,stemp);
	PromptBox(&IZbox[i*4+j]);
	break;
  }
}


void activeZME(type,row,column)
int *type;
int *row;
int *column;
{
  int i,j;

  *type = -1;
  *column = 0;
  for (i=0; i<*zmptrp->nz; i++) {
	if (IANZbox[i].active) {
	   *type = 0; *row = i; 
	}
	if (BLbox[i].active) {
	   *type = 1; *row = i; 
	}
	if (ALPHbox[i].active) {
	   *type = 2; *row = i; 
	}
	if (BETbox[i].active) {
	   *type = 3; *row = i; 
	}
	for (j=0; j<4; j++) {
		if (IZbox[i*4+j].active) {
	   	   *type = 4; *row = i; *column = j;
		}
	}
  }
}

int FindInd(ival,iarr,idimens)
int ival;
int *iarr;
int idimens;
{
	int i;

	for (i=0; i<idimens; i++) 
		if (ival == iarr[i]) return(i);
	return(-1);
}

typedef unsigned char Byte;
#ifdef _LONGLONG
typedef unsigned int Card;
#else
typedef unsigned long Card;
#endif

static XImage *image;
static FILE *GIFFile;
static int LZWClrCode; 
static int LZWEOICode;
static short store1[4096];
static short store2[4096];
static short HashTable[256];
static Byte UsedColors[4096];
static int UsedCol[256];
static Byte Buffer[256];
static Byte MapPixel[256];
static Card BitBuffer;
static int BitBufLen;
static int ByteCount;
static int CodeSize;
static Byte pix2col[256],red[256],green[256],blue[256];

int CompressCMap()
{
    register int i,x,y, NumUsedColors;

    for (i=0; i<256; i++) {   
        MapPixel[colors[i]] = i;
        Buffer[i] = 0;
        UsedCol[i] = 5;
    }

    NumUsedColors = 0;

    for (x=0; x < width; x++) {
	for (y=0; y < height; y++) {
	    i = MapPixel[XGetPixel(image,x,y)];
	    if( !Buffer[i] )
	    {   UsedCol[NumUsedColors++] = i;
		Buffer[i] = NumUsedColors;
	    }
	}
    }

    for (i=0; i<256; i++)
        MapPixel[i] = Buffer[MapPixel[i]]-1;
    return (NumUsedColors);
}

int MapPixel24(pixval)
    unsigned long pixval;
{
    int i;

    for (i=255; i>=0; i--) {   
	if (pixval == colors[i]) return(i);
    }

    return(0);
}
    
int MapPixel24U(pixval,NumUsedColors)
    unsigned long pixval;
    int NumUsedColors;
{
    int i;

    for (i=0; i<NumUsedColors; i++) {   
	if (pixval == colors[UsedCol[i]]) return(i);
    }

    return(0);
}
    
int FakeCompress24()
{
    register int i,x,y, NumUsedColors;

    for (i=0; i<256; i++) {   
        Buffer[i] = 0;
        UsedCol[i] = 5;
    }

    NumUsedColors = 0;

    for (x=0; x < width; x++) {
	for (y=0; y < height; y++) {
	    i = MapPixel24(XGetPixel(image,x,y));
	    if( !Buffer[i] )
	    {   UsedCol[NumUsedColors++] = i;
		Buffer[i] = NumUsedColors;
	    }
	}
    }

    return (NumUsedColors);
}


void LZWwrite(code)
    int code;
{
    register int max;

    max = (code==LZWEOICode)? 0 : 7;
    BitBuffer |= ((Card)code<<BitBufLen);
    BitBufLen += CodeSize;

    while (BitBufLen > max) {    
         Buffer[ByteCount++]=BitBuffer;
         BitBuffer >>= 8;
         BitBufLen -= 8;

        if (ByteCount==255) {
	    fputc(0xff,GIFFile);
            fwrite((char*)Buffer,1,255,GIFFile);
            ByteCount = 0;
        }
    }
}

void compress(BitsPerPixel,NumUsedColors,imag,do24)
    int BitsPerPixel;
    int NumUsedColors;
    int do24;
    Byte *imag;
{
    register int i,CurrentColor;
    register int Prefix,next,last,ilast;
    register unsigned long pixel;
    register short *prev;
    register int x,y;
    int istart;

    ByteCount=0; BitBuffer=0; BitBufLen=0;

    LZWClrCode = (1<<BitsPerPixel);
    LZWEOICode = LZWClrCode + 1;
    ilast = (LZWClrCode<<1) - LZWEOICode;
    BitsPerPixel++;

    for( i=0; i<NumUsedColors; i++ )
        HashTable[i]=0;
    CodeSize = BitsPerPixel;
    next = 1; last = ilast;

/* begin of compression */

    LZWwrite(LZWClrCode);

    istart = 0;
    Prefix = 0;
    prev = (short *)0; 

    for (y=0; y<height; y++) {   
        for (x=0; x<width; x++) {   
	    if (do24 == 2) {
		pixel = imag[(height-(y+1))*width+x];
	    } else {
		pixel = XGetPixel(image,x,y);
	    }
	    if (!istart) {
		if (do24 == 2) Prefix = pix2col[pixel];
		else if (do24) Prefix = MapPixel24U(pixel,NumUsedColors);
		else Prefix = MapPixel[pixel];
                prev = HashTable+Prefix;
                istart = 1;
                continue;
            }

	    if (do24 == 2) CurrentColor = pix2col[pixel];
	    else if (do24) CurrentColor = MapPixel24U(pixel,NumUsedColors);
            else CurrentColor = MapPixel[pixel];

            while (*prev && (UsedColors[*prev] != (Byte)CurrentColor))
                prev = store1+*prev;

            if (*prev) {
		Prefix = *prev+LZWEOICode; prev = store2+*prev;
            } else {
		LZWwrite(Prefix);
                if (next==last) {
		    if (CodeSize==12) {
			LZWwrite(LZWClrCode);
                        Prefix = CurrentColor;  prev = HashTable+CurrentColor;
                        for( i=0; i<NumUsedColors; i++ )
                            HashTable[i] = 0;
                        CodeSize = BitsPerPixel;
                        next = 1; last = ilast;
                        continue;
                    }
                    last = (last<<1)+LZWEOICode;
                    CodeSize++;
                }
                *prev = next;
                store1[next] = 0; store2[next] = 0;
                UsedColors[next] = CurrentColor;
                prev = HashTable+CurrentColor; Prefix = CurrentColor;
                next++;
            }
        }
    }


    LZWwrite(Prefix);

/* end of compression */

    LZWwrite(LZWEOICode);

/* write last buffer */

    if (ByteCount) {
	fputc(ByteCount,GIFFile);
        fwrite((char*)Buffer,1,ByteCount,GIFFile);
    }

/* zero byte count terminates Raster Data stream */

    fputc(0x00,GIFFile);
}


void ToGIF(win,filename)
    char *filename;
    Drawable win;
{
    int i,NumUsedColors,BitsPerPixel,do24;
    XColor exact_def;
    Byte *imag = NULL;

    GIFFile = fopen(filename,"w");
    if (!GIFFile) {
	fprintf(stderr,"Output Error: Unable to create GIF file %s\n",filename);
	return;
    }

    do24 = 0;
    if (DisplayPlanes(display, screen) > 8) do24 = 1;

    image = XGetImage(display,win,0,0,width,height,AllPlanes,ZPixmap);

    if (image == NULL) {
	fprintf(stderr,"Output Error: Unable to create GIF file\n");
	return;
    }

    if (do24) NumUsedColors = FakeCompress24();
    else NumUsedColors = CompressCMap();

    if (NumUsedColors<2) {
	XDestroyImage(image);
	return;
    }

    for (BitsPerPixel=0; BitsPerPixel<8; BitsPerPixel++)
        if( (1<<BitsPerPixel)>=NumUsedColors ) break;
    NumUsedColors = 1<<BitsPerPixel;

/* Signature */

    fwrite("GIF87a",1,6,GIFFile);

/* Screen descriptor */

    fputc(width&0xff,GIFFile);  fputc((width>>8)&0xff,GIFFile);
    fputc(height&0xff,GIFFile);  fputc((height>>8)&0xff,GIFFile);
    fputc(0xf0|(BitsPerPixel-1),GIFFile); 
    fputc(0x00,GIFFile); 
    fputc(0x00,GIFFile);

/* Global Colormap */



    for (i=0; i<NumUsedColors; i++) {   
	exact_def.pixel = colors[UsedCol[i]];
	XQueryColor(display,cmap,&exact_def);
        fputc((int)exact_def.red>>8,GIFFile);
        fputc((int)exact_def.green>>8,GIFFile);
        fputc((int)exact_def.blue>>8,GIFFile);
    }

/* Image Descriptor */

    fputc(',',GIFFile);
    fputc(0x00,GIFFile); fputc(0x00,GIFFile);
    fputc(0x00,GIFFile); fputc(0x00,GIFFile);
    fputc(width&0xff,GIFFile); fputc((width>>8)&0xff,GIFFile);
    fputc(height&0xff,GIFFile); fputc((height>>8)&0xff,GIFFile);
    fputc(0x00,GIFFile); fputc(BitsPerPixel,GIFFile);

/* Raster Data */

    compress(BitsPerPixel,NumUsedColors,imag,do24);

/* Gif Terminator */

    fputc(';',GIFFile);
    fclose(GIFFile);

    XDestroyImage(image);
    return;
}

#define RANGE(a,b,c) { if (a < b) a = b;  if (a > c) a = c; }
#define MAXCOL  256
#define BOX_DIM  128

typedef unsigned short histcell;
typedef unsigned short * histptr;
typedef unsigned short hist1d[32];
typedef hist1d hist2d[64];
typedef hist2d hist3d[32];
static hist2d * histogram;

typedef struct {
  int rmin, rmax;
  int gmin, gmax;
  int bmin, bmax;
  int volume;
  long colorcount;
} box;
typedef box * boxptr;

static short * fserrors;
static int * maxerr;
static unsigned char * clmap[3];
static int num_colors;

void initz(s, len)
     char   *s;
     size_t  len;
{
  for ( ; len>0; len--) *s++ = 0;
}

void inithis(rgbimg, npix)
Byte *rgbimg;
int   npix;
{
  histptr histp;

  initz((char *) histogram, sizeof(hist3d));

  while (npix-- > 0) {
    histp = & histogram[rgbimg[0]/8] [rgbimg[1]/4] [rgbimg[2]/8];
    if (++(*histp) <= 0)
      (*histp)--;
    rgbimg += 3;
  }
}

boxptr cbmax(boxlist, nbox)
boxptr boxlist;
int nbox;
{
  boxptr boxp, w = NULL;
  int i, maxc = 0;
  
  for (i = 0, boxp = boxlist; i < nbox; i++, boxp++) {
    if (boxp->colorcount > maxc && boxp->volume > 0) {
      w = boxp;
      maxc = boxp->colorcount;
    }
  }
  return w;
}


boxptr colmax(bl, nbox)
boxptr bl;
int nbox;
{
  boxptr boxp;
  int i;
  int maxv = 0;
  boxptr wh = NULL;
  
  for (i = 0, boxp = bl; i < nbox; i++, boxp++) {
    if (boxp->volume > maxv) {
      wh = boxp;
      maxv = boxp->volume;
    }
  }
  return wh;
}

/* based on jpeg library routine */

void boxupd(boxp)
boxptr boxp;
{
  histptr histp;
  int r,g,b;
  int rmin,rmax,gmin,gmax,bmin,bmax;
  int dr,dg,db;
  long ccount;
  
  rmin = boxp->rmin;  
  rmax = boxp->rmax;
  gmin = boxp->gmin;  
  gmax = boxp->gmax;
  bmin = boxp->bmin;  
  bmax = boxp->bmax;
  
  if (rmax > rmin)
    for (r = rmin; r <= rmax; r++)
      for (g = gmin; g <= gmax; g++) {
	histp = &histogram[r][g][bmin];
	for (b = bmin; b <= bmax; b++)
	  if (*histp++ != 0) {
	    boxp->rmin = rmin = r;
	    goto have_rmin;
	  }
      }
 have_rmin:
  if (rmax > rmin)
    for (r = rmax; r >= rmin; r--)
      for (g = gmin; g <= gmax; g++) {
	histp = &histogram[r][g][bmin];
	for (b = bmin; b <= bmax; b++)
	  if (*histp++ != 0) {
	    boxp->rmax = rmax = r;
	    goto have_rmax;
	  }
      }
 have_rmax:
  if (gmax > gmin)
    for (g = gmin; g <= gmax; g++)
      for (r = rmin; r <= rmax; r++) {
	histp = &histogram[r][g][bmin];
	for (b = bmin; b <= bmax; b++)
	  if (*histp++ != 0) {
	    boxp->gmin = gmin = g;
	    goto have_gmin;
	  }
      }
 have_gmin:
  if (gmax > gmin)
    for (g = gmax; g >= gmin; g--)
      for (r = rmin; r <= rmax; r++) {
	histp = &histogram[r][g][bmin];
	for (b = bmin; b <= bmax; b++)
	  if (*histp++ != 0) {
	    boxp->gmax = gmax = g;
	    goto have_gmax;
	  }
      }
 have_gmax:
  if (bmax > bmin)
    for (b = bmin; b <= bmax; b++)
      for (r = rmin; r <= rmax; r++) {
	histp = &histogram[r][gmin][b];
	for (g = gmin; g <= gmax; g++, histp += 32)
	  if (*histp != 0) {
	    boxp->bmin = bmin = b;
	    goto have_bmin;
	  }
      }
 have_bmin:
  if (bmax > bmin)
    for (b = bmax; b >= bmin; b--)
      for (r = rmin; r <= rmax; r++) {
	histp = &histogram[r][gmin][b];
	for (g = gmin; g <= gmax; g++, histp += 32)
	  if (*histp != 0) {
	    boxp->bmax = bmax = b;
	    goto have_bmax;
	  }
      }
 have_bmax:

  dr = (rmax - rmin) * 16;
  dg = (gmax - gmin) * 12;
  db = (bmax - bmin) *  8;
  boxp->volume = dr*dr + dg*dg + db*db;
  
  ccount = 0;
  for (r = rmin; r <= rmax; r++)
    for (g = gmin; g <= gmax; g++) {
      histp = &histogram[r][g][bmin];
      for (b = bmin; b <= bmax; b++, histp++)
	if (*histp != 0) {
	  ccount++;
	}
    }
  boxp->colorcount = ccount;
}

int setavg(bl, nbox, nc)
boxptr bl;
int nbox, nc;
{
  int n,dr,dg,db,cmax;
  boxptr b1,b2;

  while (nbox < nc) {

    if (nbox*2 <= nc) {
      b1 = cbmax(bl, nbox);
    } else {
      b1 = colmax(bl, nbox);
    }

    if (b1 == NULL) break;

    b2 = &bl[nbox];

    *b2 = *b1; /* copy box at b1 to box at b2 */

    dr = (b1->rmax - b1->rmin) * 16;
    dg = (b1->gmax - b1->gmin) * 12;
    db = (b1->bmax - b1->bmin) *  8;

    cmax = dg; n = 1;
    if (dr > cmax) { cmax = dr; n = 0; }
    if (db > cmax) n = 2;

    switch (n) {
    case 0:
      b1->rmax = AVG(b1->rmax,b1->rmin);
      b2->rmin = b1->rmax+1;
      break;
    case 1:
      b1->gmax = AVG(b1->gmax,b1->gmin);
      b2->gmin = b1->gmax+1;
      break;
    case 2:
      b1->bmax = AVG(b1->bmax,b1->bmin);
      b2->bmin = b1->bmax+1;
      break;
    }

    boxupd(b1);
    boxupd(b2);
    nbox++;
  }
  return nbox;
}


void setclr(boxp, ic)
boxptr boxp;
int ic;
{
  histptr histp;
  int r,g,b;
  int tel,tot,rtot,gtot,btot;
  
  tot = rtot = gtot = btot = 0;

  for (r = boxp->rmin; r <= boxp->rmax; r++)
    for (g = boxp->gmin; g <= boxp->gmax; g++) {
      histp = &histogram[r][g][boxp->bmin];
      for (b = boxp->bmin; b <= boxp->bmax; b++) {
	if ((tel = *histp++) != 0) {
	  tot += tel;
	  rtot += (r*8 + 4) * tel;
	  gtot += (g*4 + 2) * tel;
	  btot += (b*8 + 4) * tel;
	}
      }
    }
  
  clmap[0][ic] = (unsigned char) ((rtot + (tot/2)) / tot);
  clmap[1][ic] = (unsigned char) ((gtot + (tot/2)) / tot);
  clmap[2][ic] = (unsigned char) ((btot + (tot/2)) / tot);
}

#define AB2(a,b) ((a)*(a)*(b)*(b))

int appcols(rgbmin,cl)
int *rgbmin;
unsigned char *cl;
{
  int i,j, ct, ncolors;
  int dmaxje, dmin, dmax;
  int dmincl[MAXCOL];
  int rgbext[3][4], rgbfac[3], rgbmlt[3];

  rgbfac[0] = 24; rgbfac[1] = 28; rgbfac[2] = 24;
  rgbmlt[0] = 2; rgbmlt[1] = 3; rgbmlt[2] = 1;

  for (j = 0; j < 3; j++) {
     rgbext[j][0] = rgbmin[j];
     rgbext[j][1] = rgbmin[j] + rgbfac[j];
     rgbext[j][2] = (2*rgbmin[j] + rgbfac[j])/2;
     rgbext[j][3] = rgbmlt[j];
  }

  dmaxje = 0x7FFFFFFFL;

  for (i = 0; i < num_colors; i++) {

    dmin = dmax = 0;

    for (j = 0; j < 3; j++) {

	ct = clmap[j][i];

	if (ct < rgbext[j][0]) {

	   dmin += AB2(ct-rgbext[j][0],rgbext[j][3]);
	   dmax += AB2(ct-rgbext[j][1],rgbext[j][3]);

	} else if (ct > rgbext[j][1]) {

	   dmin += AB2(ct-rgbext[j][1],rgbext[j][3]);
	   dmax += AB2(ct-rgbext[j][0],rgbext[j][3]);

	} else {

	   if (ct <= rgbext[j][2]) {
		dmax += AB2(ct-rgbext[j][1],rgbext[j][3]);
	   } else {
		dmax += AB2(ct-rgbext[j][0],rgbext[j][3]);
	   }

	}
    }

    dmincl[i] = dmin;

    if (dmax < dmaxje) dmaxje = dmax;
  }

  ncolors = 0;
  for (i = 0; i < num_colors; i++) {
    if (dmincl[i] <= dmaxje)
      cl[ncolors++] = (unsigned char) i;
  }
  return ncolors;
}


void optcols(rgbmin, numcolors, cl, bc)
int *rgbmin;
int numcolors;
unsigned char *cl;
unsigned char *bc;
{
  int i, ir, ig, ib, ic;
  int * bptr;
  unsigned char * cptr;
  int drgb2, drgb2t, drgb2tt;
  int tr, tg, tb;
  int dr, dg, db;
  int optdrgb2[BOX_DIM];

  bptr = optdrgb2;

  for (i = BOX_DIM-1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;
  
  for (i = 0; i < numcolors; i++) {

    ic = cl[i];
    drgb2 = 0;

    dr = (rgbmin[0] - (int) clmap[0][ic]) * 2;
    drgb2 += dr*dr;
    dg = (rgbmin[1] - (int) clmap[1][ic]) * 3;
    drgb2 += dg*dg;
    db = (rgbmin[2] - (int) clmap[2][ic]) * 1;
    drgb2 += db*db;

    dr = dr*32 + 256;
    dg = dg*24 + 144;
    db = db*16 + 64;

    bptr = optdrgb2;
    cptr = bc;
    tr = dr;

    for (ir = 3; ir >= 0; ir--) {
      drgb2t = drgb2;
      tg = dg;

      for (ig = 7; ig >= 0; ig--) {
	drgb2tt = drgb2t;
	tb = db;

	for (ib = 3; ib >= 0; ib--) {
	  if (drgb2tt < *bptr) {
	    *bptr = drgb2tt;
	    *cptr = (unsigned char) ic;
	  }
	  drgb2tt += tb;
	  tb += 128;
	  bptr++;
	  cptr++;
	}
	drgb2t += tg;
	tg += 288;
      }
      drgb2 += tr;
      tr += 512;
    }
  }
}

void ininvcm(r,g,b)
int r,g,b;
{
  int rgbmin[3];
  int i, j, k;
  unsigned char * cptr;
  histptr ptr;
  unsigned char cl[MAXCOL], bc[BOX_DIM];
  int nc;

  r = r/4;
  g = g/8;
  b = b/4;

  rgbmin[0] = r*32 + 4;
  rgbmin[1] = g*32 + 2;
  rgbmin[2] = b*32 + 4;
  
  nc = appcols(rgbmin, cl);

  optcols(rgbmin, nc, cl, bc);

  r = r*4;
  g = g*8;
  b = b*4;

  cptr = bc;

  for (i = 0; i < 4; i++) 

    for (j = 0; j < 8; j++) {

      ptr = &histogram[r+i][g+j][b];

      for (k = 0; k < 4; k++) 
	*ptr++ = (unsigned short) (*cptr++ + 1);

    }

}

void map_pixels(rgbimg, width, height, imag, rtoggle)
Byte *rgbimg, *imag;
int   width, height;
int rtoggle;
{
  int cur[3],bel[3],bpr[3];
  short * errorptr;
  unsigned char *inptr,*outptr;
  histptr tmpptr;
  int j, dir, dir3;
  int row, col;

  for (row = 0; row < height; row++) {

    inptr  = &rgbimg[row*width * 3];
    outptr = &imag[row*width];

    if (rtoggle) {

      inptr += (width-1)*3;
      outptr += width-1;
      dir = -1;
      dir3 = -3;
      errorptr = fserrors + (width+1)*3;
      rtoggle = False;

    } else {

      dir = 1;
      dir3 = 3;
      errorptr = fserrors;
      rtoggle = True;

    }

    for (j = 0; j < 3; j++) {
	cur[j] = 0; bel[j] = 0; bpr[j] = 0;
    }

    for (col = width; col > 0; col--) {

      for (j = 0; j < 3; j++) {
	cur[j] = (cur[j] + errorptr[dir3+j] + 8)/16;
	cur[j] = maxerr[cur[j]];
	cur[j] += inptr[j];
	RANGE(cur[j], 0, 255);
      }

      tmpptr = &histogram[cur[0]/8][cur[1]/4][cur[2]/8];

      if (*tmpptr == 0)
	ininvcm(cur[0]/8, cur[1]/4, cur[2]/8);

      *outptr = (unsigned char) (*tmpptr - 1);
      for (j = 0; j < 3; j++) 
	   cur[j] -= (int) clmap[j][*tmpptr - 1];

      { int nxterr, dc;

	for (j = 0; j < 3; j++) {
	   nxterr = cur[j];
	   dc = cur[j] * 2;
	   cur[j] += dc;
	   errorptr[j] = (short) (bpr[j] + cur[j]);
	   cur[j] += dc;	
	   bpr[j] = bel[j] + cur[j];
	   bel[j] = nxterr;
	   cur[j] += dc;
	}

      }

      inptr += dir3;
      outptr += dir;
      errorptr += dir3;	
    }

    for (j = 0; j < 3; j++) 
	errorptr[j] = (short) bpr[j]; 
  }
}


void init_err()
{
  int i, j;

  maxerr = (int *) malloc((size_t) ((255*2+1) * sizeof(int)));
  if (!maxerr) return;

  maxerr += 255;

  j = 0;
  for (i = 0; i < 16; i++, j++) {
    maxerr[i] = j; maxerr[-i] = -j;
  }
  for (; i < 48; i++, j += (i&1) ? 0 : 1) {
    maxerr[i] = j; maxerr[-i] = -j;
  }
  for (; i <= 255; i++) {
    maxerr[i] = j; maxerr[-i] = -j;
  }
}

void pickcol(nc)
int nc;
{
  box bl[MAXCOL];
  int nbox;
  int i;

  nbox = 1;

  bl[0].rmin = bl[0].gmin = bl[0].bmin = 0;
  bl[0].rmax = bl[0].bmax = 31;
  bl[0].gmax = 63;

  boxupd(bl);

  nbox = setavg(bl, nbox, nc);

  for (i = 0; i < nbox; i++)
    setclr(&bl[i], i);

  num_colors = nbox;

}

int quant(rgbimg, width, height, imag, nc)
Byte *rgbimg, *imag;
int   width, height, nc;
{
  size_t fssize = (width + 2) * (3 * sizeof(short));

  if (maxerr == NULL) init_err();

  histogram = (hist2d *) malloc(sizeof(hist3d));
  fserrors = (short *) malloc(fssize);

  if (! maxerr || ! histogram || ! fserrors) {
    if (histogram) free(histogram);
    if (fserrors) free(fserrors);
    fprintf(stderr,"24->8 failed to allocate workspace\n");
    return 1;
  }

  inithis(rgbimg, width*height);

  pickcol(nc);

  initz((char *) histogram, sizeof(hist3d));
  initz((char *) fserrors, fssize);

  map_pixels(rgbimg, width, height, imag, False);

  free(histogram);
  free(fserrors);

  return 0;
}

static int curson = 0;

#if defined(VMS) || defined(UNDERSC)
void curs(on)
#else
#ifdef CRAY
void CURS(on)
#else
void curs_(on)
#endif
#endif
int *on;
{

   if (!xison) return;
   if (animptr.on) return;

   if (*on) {
        curson = 1;
	XDefineCursor(display, win, WaitCursor);
	XDefineCursor(display, winMC, WaitCursor);
	XDefineCursor(display, winC, WaitCursor);
	XDefineCursor(display, fsel.win, WaitCursor);
	XDefineCursor(display, ZMEwin, WaitCursor);
	if (specup) XDefineCursor(display, winspec, WaitCursor);
	if (FRup) XDefineCursor(display, FrBox, WaitCursor);
	if (FLXup) XDefineCursor(display, FLXwin, WaitCursor);
	if (STRup) XDefineCursor(display, STRwin, WaitCursor);
	if (STRCup) XDefineCursor(display, STRCwin, WaitCursor);
	if (OMAPup) XDefineCursor(display, OMAPwin, WaitCursor);
	if (SRCHup) XDefineCursor(display, SRCHwin, WaitCursor);
	if (QSARup) XDefineCursor(display, QSARwin, WaitCursor);
	if (MLTup) XDefineCursor(display, MLTwin, WaitCursor);
	if (PHRMup) XDefineCursor(display, PHRMwin, WaitCursor);
	if (PSRCHup) XDefineCursor(display, PSRCHwin, WaitCursor);
   } else {
        curson = 0;
	XUndefineCursor(display, win);
	XUndefineCursor(display, winMC);
	XUndefineCursor(display, winC);
	XUndefineCursor(display, fsel.win);
	XUndefineCursor(display, ZMEwin);
	if (specup) XUndefineCursor(display, winspec);
	if (FRup) XUndefineCursor(display, FrBox);
	if (FLXup) XUndefineCursor(display, FLXwin);
	if (STRup) XUndefineCursor(display, STRwin);
	if (STRCup) XUndefineCursor(display, STRCwin);
	if (OMAPup) XUndefineCursor(display, OMAPwin);
	if (SRCHup) XUndefineCursor(display, SRCHwin);
	if (QSARup) XUndefineCursor(display, QSARwin);
	if (MLTup) XUndefineCursor(display, MLTwin);
	if (PHRMup) XUndefineCursor(display, PHRMwin);
	if (PSRCHup) XUndefineCursor(display, PSRCHwin);
   }
   XSync(display, False);
}

#if defined(VMS) || defined(UNDERSC)
void messg(istat)
#else
#ifdef CRAY
void MESSG(istat)
#else
void messg_(istat)
#endif
#endif
int *istat;
{
   char statstr[200];
   int x,y,w,h;

   if (!xison) return;
#ifdef DOGL
   if (xyzp->ixp == NULL) return;
   dispsf();
#endif

   switch (*istat) {
	case 0: 
		strcpy(statstr,"Optimisation complete");
		break;
	case 1: 
		strcpy(statstr,"Error Job");
		break;
	case 2: 
		strcpy(statstr,"Some Required Potential Energy\nParameters are Undefined\nSee the file jobname.log");
		break;
	case 3: 
		strcpy(statstr,"Incomplete Convergence");
		break;
	case 4: 
		strcpy(statstr,"Too many Parameters");
		break;
	case 5: 
		strcpy(statstr,"Job Aborted");
		break;
	case 6: 
		strcpy(statstr,"Job started");
		break;
	case 7: 
		strcpy(statstr,"WARNING: reading connectivity from file molden_connect");
		break;
	case 8: 
		strcpy(statstr,"ERROR: couldnt open mapfile");
		break;
	case 9: 
		strcpy(statstr,"ERROR: error reading mapfile");
		break;
	case 10: 
		strcpy(statstr,"ERROR: dimensions grid dont match first grid");
		break;
	case 11: 
		strcpy(statstr,"WARNING: current grid does not hold density !");
		break;
	case 12: 
		strcpy(statstr,"WARNING: could not open file !");
		break;
	case 13: 
		strcpy(statstr,"WARNING: Only Hetatm atoms may be selected !");
		break;
	case 14: 
		strcpy(statstr,"WARNING EEM: element missing parameters!");
		break;
	case 15: 
		strcpy(statstr,"WARNING Mol2: untyped atoms !");
		break;
	case 16: 
		InitOmap(0);
		omapr = 1;
		return;
		break;
	case 17: 
		strcpy(statstr,"WARNING Mol2: atom type inconsistancy, please retyp !");
		break;
	case 18: 
		strcpy(statstr,"Succesfully wrote file resrot");
		break;
	case 19: 
		strcpy(statstr,"Did not find file resrot");
		break;
	case 20: 
		strcpy(statstr,"Optimisation aborted");
		break;
	case 21: 
		strcpy(statstr,"MD complete");
		break;
	case 22: 
		InitOmap(1);
		omapr = 2;
		return;
		break;
	default:
		break;
   }

   x = event.xbutton.x_root; y = event.xbutton.y_root;
   w = DisplayWidth(display,screen);
   h = DisplayHeight(display,screen);
   if (x < 0 || x > w) x = w / 2;
   if (y < 0 || y > h) y = h / 2;

   if (DoCan(x,y,statstr,0)) {}
}

void MkDistWin(int *asel,int opt,float val)
{
   int nval;

   dstpxini = 1;

   if (monoscr || colcells <= 32) {
	XSetForeground(display, gc, colors[7]);
	XFillRectangle(display,distpix,gc,0,0,DBWIDE,DBHIGH-5);
	if (monoscr) XSetForeground(display, gc, colors[0]);
	else XSetForeground(display, gc, colors[6]);
	XDrawRectangle(display,distpix,gc,0,0,DBWIDE,DBHIGH-5);}
   else {
	XSetForeground(display, gc, colors[190]);
	XFillRectangle(display,distpix,gc,0,0,DBWIDE,DBHIGH);
	butje(distpix,0,0,DBWIDE,DBHIGH,3,0,0,1,None,0,0,0,0);
   }
   XSetForeground(display, gc, colors[0]);
/*
   if (monoscr) XSetForeground(display, gc, colors[0]);
   else  XSetForeground(display, gc, colors[9]);
*/


   switch(opt) {
   case 6:	sprintf(stemp,"J-Coupling %#11.5f",val);
		nval = 22;
		aselkeep[0] = asel[0];
		aselkeep[1] = asel[1];
		monmode = opt;
		break;
   case 5:	sprintf(stemp,"Electrost. Pot. %#11.5f",val);
		nval = 27;break;
   case 4:	sprintf(stemp,"Dihedral %#8.3f Degrees",val);
		nval = 25;break;
   case 3:	sprintf(stemp,"Covalent Angle %#8.3f Degrees",val);
		nval = 31;break;
   case 2:	sprintf(stemp, "         %#11.5f a.u.",val);
		nval=25;
		XDrawString(display,distpix,gc,10,35,stemp,nval);
		sprintf(stemp, "Distance %#11.5f Angstrom",val*toangs);
		nval=29;
		aselkeep[0] = asel[0];
		aselkeep[1] = asel[1];
		monmode = opt;
		break;
   default:	break;
   }
   XDrawString(display, distpix, gc, 10, 15, stemp, nval);

   if (opt == 2 || opt == 6) {
	ActBut(&clbut[BMONI],1);
   } else {
	ActBut(&clbut[BMONI],0);
   }

   if (!distup) {
	XMapRaised(display,DISTwin);
	RedrawDIST();
	distup = 1;
   } else {
	RedrawDIST();
   }

}

void RedrawDIST()
{
 int i;

   if (dstpxini) {
	XCopyArea(display,distpix,DISTwin,gc,0,0,DBWIDE,DBHIGH,0,0);
   } else {
	XSetForeground(display, gc, colors[190]);
	XFillRectangle(display,DISTwin,gc,0,0,DBWIDE,DBHIGH);
	butje(DISTwin,0,0,DBWIDE,DBHIGH,3,0,0,1,None,0,0,0,0);
	XSetForeground(display, gc, colors[0]);
   }

   for (i=0; i<NCLBUT; i++) DrwBut(&clbut[i]);
}

int ButtonsDIST(i)
int i;
{
 int j,iscon1,iscon2;


	switch (i) {
	case BCLOSE:
		distup = 0;
		if (!bcksvg.UpSVG) signal(SIGALRM,SIG_IGN);
		XUnmapWindow(display,DISTwin);
		return(0);
		break;
	case BMONI:
		if (monmode == 2) {
#if defined(VMS) || defined(UNDERSC)
		   setmon(aselkeep,&anum);
#else
#ifdef CRAY
		   SETMON(aselkeep,&anum);
#else
		   setmon_(aselkeep,&anum);
#endif
#endif
		} else if (monmode == 6) {
		   double coupl;

		   coupl = jcoupl[(aselkeep[0]-1)*NAT->natoms + aselkeep[1]-1];
#if defined(VMS) || defined(UNDERSC)
		   stjmon(&coupl,aselkeep,&TWO);
#else
#ifdef CRAY
		   STJMON(&coupl,aselkeep,&TWO);
#else
		   stjmon_(&coupl,aselkeep,&TWO);
#endif
#endif
		}
		if (has_opengl && (*fancy || *fullgl)) {
		   update_model = 0;
		   dispsf();
		} else {
		   update_model = 1;
		   return(1);
		}
		break;
	case BCLR:
#if defined(VMS) || defined(UNDERSC)
		clrmon();
#else
#ifdef CRAY
		CLRMON();
#else
		clrmon_();
#endif
#endif
		if (has_opengl && *fancy ) {
		   update_model = 0;
		   dispsf();
		} else {
		   update_model = 1;
		   return(1);
		}
		break;
	case BCNTCT:
		if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
			   "Select Atom for close contact",1)) {
		   bflag = 1; bretval = 461;
		   XDefineCursor(display,win,AtomCursor);
		   return(0);
		}
		break;
	case BCONN:
		iscon1 = -1;
		iscon2 = -1;
		for (j=0; j<xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)]; j++) {
		   if (ABS(xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)+1+j]) == aselkeep[1]) 
			iscon1 = j;
       		}
		for (j=0; j<xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)]; j++) {
		   if (ABS(xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)+1+j]) == aselkeep[0]) 
			iscon2 = j;
       		}
		if (iscon1 != -1 || iscon2 != -1) {
		    if (iscon1 != -1) {
			for (j=iscon1; j<xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)]-1; j++) 
			   xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)+1+j] = 
				xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)+2+j];
			xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)] = 
				xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)] - 1;
		    }
		    if (iscon2 != -1) {
			for (j=iscon2; j<xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)]-1; j++) 
			   xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)+1+j] = 
				xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)+2+j];
			xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)] = 
				xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)] - 1;
		    }
		} else {
		   if (xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)] < MXCON) {
			xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)] = 
			   xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)] + 1;
			xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)+xyzp->iconn[(aselkeep[0]-1)*(MXCON+1)]] =
			aselkeep[1];
		   }
		   if (xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)] < MXCON) {
			xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)] = 
			   xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)] + 1;
			xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)+xyzp->iconn[(aselkeep[1]-1)*(MXCON+1)]] =
			aselkeep[0];
		   }
		}
		update_model = 1;
		return(1);
		break;
	}
}

int ChangeLevel(button12,cursorx,cursory)
int button12;
int cursorx;
int cursory;
{
 int i,j,jx,jy;
 int PEH,PH,PW,NE,MW;

 if (*doesp) {
    NE = potcom->nplev+1;
    if (hlpsrf->itsrf) NE = 5;
    PEH = 20;
    PW = 70;
    PH = NE*PEH;
    MW = 10;
    jx = width-70-20;
    jy = 20;
    if (VIERKANT(cursorx, cursory, jx-MW, jy-MW, PW+2*MW, PH+2*MW)) {

         if (button12 == 1) {
   	     qboxstr(&qboxes[QCSPACE],NULL,1,0,-1,DEFQX,DEFQY,QBOXWIDE,QBOXHIGH,
		     0,"Level Spacing ? ",NULL,0,3,590,-1,dummyproc);
         } else {
	     if (!(has_opengl && (*fancy || *fullgl) && hlpsrf->itsrf)) {
		if (DoPopUp(win,cursorx-20,cursory,NULL,&j,0) == -1) return 0;
		i = (cursory - jy) / PEH;
		if (i > potcom->nplev) i = potcom->nplev;
		potcom->ipcol[i] = j;
		*Sinct = 591;
	     }
	 }
	 update_model = 1;
         return(1);
    }

 }
 return(0);
}

int FindEsp(button12,cursorx,cursory)
int button12;
int cursorx;
int cursory;
{
 int i;

 update_model = 0;
 if (hlpsrf->itsrf) return(0);

 if (*doesp) {
	i = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,*xyzp->iatoms,
			cursorx,cursory,MINDIFF);
	if (i >= 0) {
	    MkDistWin(xyzp->iaton,5,esp[i]);
            return(1);
        } else {
	    if (ChangeLevel(button12,cursorx,cursory)) return(1);
	}

 }

 return(0);

}

void PlotColIndex()
{
  int i,PEH,PH,PW,NE,MW,jx,jy;

  NE = potcom->nplev+1;
  if (hlpsrf->itsrf) NE = 5;
  PEH = 20;
  PW = 70;
  PH = NE*PEH;
  MW = 10;

  jx = width-PW-20;
  jy = 20;


  if (hlpsrf->itsrf) {
     if (has_opengl && (*fancy || *fullgl) ) {
	butje(win,jx-MW,jy-MW,PW+2*MW,PH+2*MW,3,0,0,1,None,0,0,0,0);
	for (i=0; i < NE; i++) {
	   XSetForeground(display, gc, mappedcols[i]);
	   XFillRectangle(display, win, gc, jx,jy+(i * PH)/NE, PW,PEH);
	}
     }
  } else {
     if (has_opengl && (*fancy || *fullgl) ) {
	butje(win,jx-MW,jy-MW,PW+2*MW,PH+2*MW,3,0,0,1,None,0,0,0,0);
	for (i=0; i < NE; i++) {
	   XSetForeground(display, gc, colors[potcom->ipcol[i]]);
	   XFillRectangle(display, win, gc, jx,jy+(i * PH)/NE, PW,PEH);
	}
     } else {
	butje(molcur,jx-MW,jy-MW,PW+2*MW,PH+2*MW,3,0,0,1,None,0,0,0,0);
	for (i=0; i < NE; i++) {
	   XSetForeground(display, gc, colors[potcom->ipcol[i]]);
	   XFillRectangle(display, molcur, gc, jx,jy+(i * PH)/NE, PW,PEH);
	}
     }
  }

  XSetForeground(display, gc, Black);
  if (hlpsrf->itsrf) {
     if (has_opengl && (*fancy || *fullgl) ) {
	for (i=0; i < 5; i++) {
	   sprintf(stemp, "%#11.5f",valcol[i]);
	   XDrawString(display,win,gc,jx-10,jy+14+(i * PH)/NE,
	   	stemp,strlen(stemp));
	}
     }
  } else {
     for (i=0; i < NE-1; i++) {
	sprintf(stemp, "%#11.5f",potcom->plevel[i]);
	if (has_opengl && (*fancy || *fullgl) ) 
	   XDrawString(display,win,gc,jx-10,jy+4+((i+1) * PH)/NE,
		stemp,strlen(stemp));
	else
	   XDrawString(display,molcur,gc,jx-10,jy+4+((i+1) * PH)/NE,
		stemp,strlen(stemp));
     }
  }
}

#if defined(VMS) || defined(UNDERSC)
void butset(class,butnr,on)
#else
#ifdef CRAY
void BUTSET(class,butnr,on)
#else
void butset_(class,butnr,on)
#endif
#endif
int *class;
int *butnr;
int *on;
{
	if (!xison) return;

	switch(*class) {
	case 0: if (*on) TogUp(&dbut[*butnr]);
		else TogDown(&dbut[*butnr]);
		RedrawwinC(0,0,WINCWIDE,WINCHIGH);
		break;
	case 1: if (*on) TogUp(&cbut[*butnr]);
		else TogDown(&cbut[*butnr]);
	/*	RedrawwinMC(0,0,WINMCWIDE,WINMCHIGH);*/
		break;
	case 2: if (*on) TogUp(&ZMEbut[*butnr]);
		else TogDown(&ZMEbut[*butnr]);
		RedrawZME();
		break;
	}
}

void OnTop()
{
int i;

	if (ZMEup) DirBox(ZMEwin,1);

	if (CHGup) DirBox(CHGwin,1);
	if (SRFup) DirBox(SRFwin,1);
	if (MLTup) DirBox(MLTwin,1);
	if (PARup) DirBox(PARwin,1);
	if (FLXup) DirBox(FLXwin,1);
	if (fsel.qbrfile) DirBox(fsel.win,1);
	if (qbres) DirBox(RESwin,1);
	if (geoup) DirBox(wingeo,1);
	if (cnvup) DirBox(wincnv,1);
	if (distup) DirBox(DISTwin,1);
	if (ANIMup) DirBox(ANIMwin,1);
	if (ATMup) DirBox(ATMwin,1);
	if (COLup) DirBox(COLwin,1);
	if (SEQup) DirBox(SEQwin,1);
	if (TNKup) DirBox(TNKwin,1);
	if (FLRup) DirBox(FLRwin,1);
	if (ONIup) DirBox(ONIwin,1);
	if (specup) DirBox(winspec,1);
	if (scoup) DirBox(winsco,1);
	if (Movup) DirBox(MOVwin,1);
	if (OMAPup) DirBox(OMAPwin,1);
	if (QSARup) DirBox(QSARwin,1);
	if (QEDITup) DirBox(QEDITwin,1);

	if (denmode) DirBox(winC,1);
	else DirBox(winMC,1);

	if (STRCup) DirBox(STRCwin,1);
	if (STRup) DirBox(STRwin,1);

	for (i=0; i<NQBOX; i++) 
		if (qboxes[i].pop && qboxes[i].active) 
			XMapRaised(display,qboxes[i].win);
}

void InitCOL()
{
   int i;
   
   COLup = 1;

   COLwin = CreateWindow("Element Property Editor","-0+0",COLWINW,COLWINHT,
	 		 infobg,infofg,(Window)0);
   XSelectInput(display, COLwin, EnterWindowMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask);
   XMapWindow(display,COLwin);

   WinObj[26].win = &COLwin;
   WinObj[26].subwin = NULL;
   WinObj[26].butarr = colbut;
   WinObj[26].numbut = NBUTSC;
   WinObj[26].winup = &COLup;
   WinObj[26].redraw = RedrawCOL;

   DefBut(&colbut[0], COLwin, COLOffx, 5, 50, 23, "Close", infobg, 0);
   DefBut(&colbut[1], COLwin, COLOffx+225, 5, 120, 23, "Radius", infobg, 0);

   for (i=0; i < TABBUTN; i++) {
	if (i==TABBUTN-1)
	   DefBut(&AtmBut[i],COLwin, COLOffx+COLBord+TabPos[i][1]*(ZMETABH+1), 
		COLOffy+COLBord+TabPos[i][0]*(ZMETABH+1), ZMETABH, ZMETABH, 
        	   elements[99], infobg, -elmptr->icol[98]);
	else
	   DefBut(&AtmBut[i],COLwin, COLOffx+COLBord+TabPos[i][1]*(ZMETABH+1), 
		COLOffy+COLBord+TabPos[i][0]*(ZMETABH+1), ZMETABH, ZMETABH, 
        	   elements[i+1], infobg, -elmptr->icol[i]);
   }

   qboxstr(&qboxes[QRADI],&COLwin,1,0,190,COLOffx+345,5,
	120,38,2," "," ",SUBLEN2,QPOSREAL,2000,-1,colcall);

   ipropopt = 0;
   colbut[1].str = propopts[ipropopt];
}

void RedrawCOL()
{
   int i;

   if (!COLup) return;

   if (monoscr) {
	XSetFillStyle(display, gc, FillStippled);
	XSetStipple(display, gc, hlfgrey);
	XSetForeground(display, gc, infobg);
	XFillRectangle(display, COLwin, gc, 0, COLOffy-COLFRBord, 
		COLWINW, COLWINH+1);
	XSetFillStyle(display,gc,FillSolid);
   } else {
	butje(COLwin,0,0,COLWINW-1,COLOffy-COLFRBord+1,1,0,0,1,None,0,0,0,0);
        XSetForeground(display, gc, infobg);
	butje(COLwin,0,COLOffy-COLFRBord,COLWINW-1,COLWINH,
			1,0,0,1,None,0,0,0,0);
   }


   ULineString(COLwin, "Edit Property:",COLOffx+120, 20);

   for (i=0; i<NBUTSC; i++) DrwBut(&colbut[i]);

   if (ipropopt) PromptBox(&qboxes[QRADI]);

   butje(COLwin, COLOffx+1, COLOffy, COLWINIW, COLWINIH,2,0,2,0,None,0,0,0,0);
   for (i=0; i<TABBUTN; i++) DrwBut(&AtmBut[i]);

   if (propat == 98) SelBut(&AtmBut[TABBUTN-1]);
   else SelBut(&AtmBut[propat]);

}

void RButtonsCOL(i)
int i;
{
    LSSTRU List;

    SetRadius();

    switch (i) {
    case 0: XDestroyWindow(display,COLwin);COLup = 0; break;
    case 1: List.list = propopts; List.nents = 4;
	    if (DoPopUp(COLwin,
			colbut[1].x+60,colbut[1].y+BUTTH,
			&List,&ipropopt,1) == -1) break;
	    colbut[1].str = propopts[ipropopt];
	    switch (ipropopt) {
	    case PVDWRAD:
		sprintf(qboxes[QRADI].str,"%f",elmptr->vdwr[propat]);
		break;
	    case PDISRAD:
		sprintf(qboxes[QRADI].str,"%f",elmptr->vrad[propat]*toangs);
		break;
	    case PESPRAD:
		sprintf(qboxes[QRADI].str,"%f",espvdw[propat]);
		break;
	    }
	    qboxes[QRADI].curpos = strlen(qboxes[QRADI].str);
	    RedrawCOL();
 	    break;
    }
}

void ButtonsCOL(i)
int i;
{
    int csel,updown;

    
    SetRadius();

    if (i==TABBUTN-1) propat = 98;
    else propat = i;

    switch (ipropopt) {
    case PATMCOL:
	updown = AtmBut[i].y+BUTTH;
	if (i > 85 || (i > 56 && i < 71) ) updown = updown - NUMCOL*14;
	if (DoPopUp(COLwin,AtmBut[i].x-8,updown,NULL,&csel,0) == -1) return;
	elmptr->icol[propat] = csel;
#if defined(VMS) || defined(UNDERSC)
	wrtres();
#else
#ifdef CRAY
	WRTRES();
#else
	wrtres_();
#endif
#endif

	DefBut(&AtmBut[i],COLwin, 
		COLOffx+COLBord+TabPos[i][1]*(ZMETABH+1), 
		COLOffy+COLBord+TabPos[i][0]*(ZMETABH+1), 
		ZMETABH, ZMETABH, elements[propat+1], infobg, 
		-elmptr->icol[propat]);

	DrwBut(&AtmBut[i]);

	break;
    case PVDWRAD:
	sprintf(qboxes[QRADI].str,"%f",elmptr->vdwr[propat]);
	qboxes[QRADI].curpos = strlen(qboxes[QRADI].str);
	RedrawCOL();
#if defined(VMS) || defined(UNDERSC)
	doconn();
#else
#ifdef CRAY
	DOCONN();
#else
	doconn_();
#endif
#endif
#ifdef DOGL
        ogsetel20(propat);
        ogsetel20_bs(propat);
        ogsetel12(propat);
        ogsetel12_bs(propat);
#endif
	break;
    case PDISRAD:
	sprintf(qboxes[QRADI].str,"%f",elmptr->vrad[propat]*toangs);
	qboxes[QRADI].curpos = strlen(qboxes[QRADI].str);
	RedrawCOL();
	break;
    case PESPRAD:
	sprintf(qboxes[QRADI].str,"%f",espvdw[propat]);
	qboxes[QRADI].curpos = strlen(qboxes[QRADI].str);
	RedrawCOL();
	break;
    }

}

void SetRadius()
{
     switch (ipropopt) {
     case PATMCOL: 
		break;
     case PVDWRAD: 
		elmptr->vdwr[propat] = atof(qboxes[QRADI].str);
		break;
     case PDISRAD: 
		elmptr->vrad[propat] = atof(qboxes[QRADI].str)/toangs;
		break;
     case PESPRAD:
		espvdw[propat] = atof(qboxes[QRADI].str);
		break;
     }

}

void colcall(char* str)
{
	SetRadius();
#if defined(VMS) || defined(UNDERSC)
	doconn();
#else
#ifdef CRAY
	DOCONN();
#else
	doconn_();
#endif
#endif
}

void CreateCellPar()
{
  int i;

  if (CPup) {
	XMapRaised(display,CPwin);
	return;
  }

  CPup = 1;

  CPwin = CreateWindow("Edit Cell Parameters","-80-80",
			 CPBOXWIDE,CPBOXHIGH,infobg,infofg,(Window)0);
  XSelectInput(display, CPwin, EnterWindowMask |
	ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask);

  XMapWindow(display,CPwin);

  WinObj[14].win = &CPwin;
  WinObj[14].subwin = NULL;
  WinObj[14].butarr = cpbut;
  WinObj[14].numbut = NBUTCP;
  WinObj[14].winup = &CPup;
  WinObj[14].redraw = RedrawCP;

  DefBut(&cpbut[BCPAPP], CPwin, 70, 5+8*(BUTTN+8), 50, 23,
	"Apply", infobg, -15);

  DefBut(&cpbut[BCPCAN], CPwin, 70+60, 5+8*(BUTTN+8), 50, 23,
	"Close", infobg, -15);

  for (i=0; i<8; i++) {
	qboxstr(&qboxes[QCPA+i],&CPwin,0,0,190,CPBOXOFFX,CPBOXOFFY+i*(BUTTN+5), 
		200,QBOXHIGH,2,cellpars[i],"10.0",9,2,2000,-1,dummyproc);
  }
  qboxes[QCPSPGN].qbopt = 1;
  qboxes[QCPSPGS].qbopt = 0;
  qboxes[QCPSPGN].changed = 0;
  qboxes[QCPSPGS].changed = 0;
  UpdateCP();
}

void UpdateCP()
{
 int i,j;
 double todeg;

 todeg = 45.0e0/atan(1.0e0);

 for (j=0; j<6; j++) {
	if (j<3) sprintf(qboxes[QCPA+j].str,"%-9.4f",
			cell->cellc[j]);
	else if (j<6) sprintf(qboxes[QCPA+j].str,"%-9.3f",
			cell->cellc[j]*todeg);
	qboxes[QCPA+j].curpos = strlen(qboxes[QCPA+j].str);
 }
 sprintf(qboxes[QCPSPGN].str,"%d",cell->nspg);
 qboxes[QCPSPGN].curpos = strlen(qboxes[QCPSPGN].str);
 
 if (cell->nspg != 0) {
   i = fndchr(spacegr[cell->nspg - 1],' ');
   if (i == 0) i = 7;
   str2qbox(&qboxes[QCPSPGS],spacegr[cell->nspg - 1],i);
   qboxes[QCPSPGS].str[i] = '\0';
 } else {
   str2qbox(&qboxes[QCPSPGS],"unknown",-1);
 }

 if (cell->nspg == 1 || cell->nspg == 2) CPopt = 0;
 if ((cell->nspg >= 3 && cell->nspg <= 15) ||
	cell->nspg == 231 ) CPopt = 1;
 if (cell->nspg >= 16 && cell->nspg <= 74) CPopt = 2;
 if ((cell->nspg >= 75 && cell->nspg <= 194) ||
       (cell->nspg >= 232 && cell->nspg <= 238)) CPopt = 3;
 if (cell->nspg >= 195 && cell->nspg <= 230) CPopt = 4;

}

void RedrawCP()
{
  int i;

  butje(CPwin,0,0,CPBOXWIDE,CPBOXHIGH,4,0,0,1,None,0,0,0,0);
  for (i=0; i<NBUTCP; i++) DrwBut(&cpbut[i]);
  for (i=0; i<8; i++) PromptBox(&qboxes[QCPA+i]);
}

int ButtonsCP(x,y)
int x,y;
{
 int i,j;

 i = Clickwin(cpbut,NBUTCP,x,y,1);
 if (i>=0) {
	switch (i) {
	case BCPAPP:

	   for (j=0; j<6; j++) 
		cell->cellc[j] = atof(qboxes[QCPA+j].str);

	   if (qboxes[QCPSPGN].changed) {

		cell->nspg = atoi(qboxes[QCPSPGN].str);

	   } 

	   if (qboxes[QCPSPGS].changed) {
		int n, fnd;
		char spgtmp[] = "       ";

		n = strlen(qboxes[QCPSPGS].str);
		if (n > 7) n = 7;
		strncpy(spgtmp,qboxes[QCPSPGS].str,n);

		fnd = 0;
		for (i=0; i<MXSG; i++)
		   if (strcasecmp(spgtmp, spacegr[i]) == 0) {
			cell->nspg = i + 1;
			fnd = 1;
		   }
		if (!fnd) {
		   strcpy(molwstr,"Unrecognized Spacegroup !");
		   StatusStr(0,1);
		}
	   }
	   qboxes[QCPSPGN].changed = 0;
	   qboxes[QCPSPGS].changed = 0;

#if defined(VMS) || defined(UNDERSC)
	   chgpar(xyzp->ianz,xyzp->coo,
#else
#ifdef CRAY
	   CHGPAR(xyzp->ianz,xyzp->coo,
#else
	   chgpar_(xyzp->ianz,xyzp->coo,
#endif
#endif
	   &cell->natc,&cell->icent,&cell->nspg,&cell->ichx,
	   &cell->nopr,cell->ir,cell->it,
	   &cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	   &cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

	   UpdateCP();
	   RedrawCP();
	   return(1);
	   break;

	case BCPCAN:
	   XDestroyWindow(display,CPwin);
	   CPup = 0;
	   break;
	default: break;
	}
 } else {
	i = ClickBox(&qboxes[QCPA],8,x,y);
	if (i>=0) {
		for (j=0; j<8; j++) qboxes[QCPA+j].active = 0;
		if (i == 6) qboxes[QCPSPGN].active = 1;
		if (i == 7) qboxes[QCPSPGS].active = 1;
		else if (CPact[CPopt][i]) qboxes[QCPA+i].active = 1;
		RedrawCP();
	}

 }

 return(0);

}

void InitISO(x,y)
int x,y;
{
   char wgeom[64];
   
   ISOup = 1;

   sprintf(wgeom,"+%d+%d",x,y);

   ISOwin = CreateWindow("Isodensity Window",wgeom,ISOWINW,ISOWINH,
	 		 infobg,infofg,(Window)0);
   XSelectInput(display, ISOwin, EnterWindowMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask);
   XMapWindow(display,ISOwin);

   WinObj[19].win = &ISOwin;
   WinObj[19].subwin = NULL;
   WinObj[19].butarr = isobut;
   WinObj[19].numbut = NBUTISO;
   WinObj[19].winup = &ISOup;
   WinObj[19].redraw = NULL;

   DefBut(&isobut[0], ISOwin, ISOWINW/2+15, 15+2*QBOXHIGH, 50, 23, "Number of Surfaces", infobg, ZMBCOL);
   isobut[0].str = ChainLength[surface->nvalc-1];
   DefBut(&isobut[1], ISOwin, ISOWINW/2-50/2, 250, 50, 23, "OK", infobg, ZMBCOL);

   qboxstr(&qboxes[QEDGE],&ISOwin,1,0,190,ISOOffx,15,
	200,QBOXHIGH,2,"Grid Size        "," ",SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QNPTS],&ISOwin,0,0,190,ISOOffx,15+1*QBOXHIGH,
	200,QBOXHIGH,2,"Number of Points "," ",SUBLEN2,QPOSINT,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QVALC1],&ISOwin,0,0,190,ISOOffx,15+3*QBOXHIGH,
	200,QBOXHIGH,2,"Contour Value1   "," ",SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QVALC2],&ISOwin,0,0,190,ISOOffx,15+4*QBOXHIGH,
	200,QBOXHIGH,2,"Contour Value2   "," ",SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QVALC3],&ISOwin,0,0,190,ISOOffx,15+5*QBOXHIGH,
	200,QBOXHIGH,2,"Contour Value3   "," ",SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   sprintf(qboxes[QEDGE].str,"%f",surface->edge);
   sprintf(qboxes[QVALC1].str,"%f",surface->ctval[0]);
   sprintf(qboxes[QVALC2].str,"%f",surface->ctval[1]);
   sprintf(qboxes[QVALC3].str,"%f",surface->ctval[2]);
   sprintf(qboxes[QNPTS].str,"%d",surface->nspts);
   qboxes[QEDGE].curpos = strlen(qboxes[QEDGE].str);
   qboxes[QVALC1].curpos = strlen(qboxes[QVALC1].str);
   qboxes[QVALC2].curpos = strlen(qboxes[QVALC2].str);
   qboxes[QVALC3].curpos = strlen(qboxes[QVALC3].str);
   qboxes[QNPTS].curpos = strlen(qboxes[QNPTS].str);

}

void RedrawISO()
{
  int i;

  butje(ISOwin,0,0,ISOWINW,ISOWINH,4,0,0,1,None,0,0,0,0);
  for (i=0; i<NBUTISO; i++) DrwBut(&isobut[i]);
  ULineString(ISOwin, "Number of Surfaces:",ISOOffx, 30+2*QBOXHIGH);
  PromptBox(&qboxes[QEDGE]);
  PromptBox(&qboxes[QVALC1]);
  PromptBox(&qboxes[QVALC2]);
  PromptBox(&qboxes[QVALC3]);
  PromptBox(&qboxes[QNPTS]);
}

int ButtonsISO(i)
int i;
{
  switch (i) {
  case 1:	
	surface->edge = atof(qboxes[QEDGE].str);
	surface->ctval[0] = atof(qboxes[QVALC1].str);
	surface->ctval[1] = atof(qboxes[QVALC2].str);
	surface->ctval[2] = atof(qboxes[QVALC3].str);
	surface->nspts = atoi(qboxes[QNPTS].str);
	XDestroyWindow(display,ISOwin);
	ISOup = 0;
	*Sinct = ISOt;
	return(1);
	break;
  case 0:	{
	LSSTRU List;
	List.list = ChainLength; List.nents = 3;
	if (DoPopUp(ISOwin,isobut[0].x+20,isobut[0].y,
		&List,&surface->nvalc,0) == -1) break;
	   surface->nvalc++;
	   isobut[0].str = ChainLength[surface->nvalc-1];
	   DrwBut(&isobut[0]);
	}
	break;
  }
  return(0);
}

void InitATM(x,y)
int x,y;
{
   char wgeom[64];
   
   ATMup = 1;

   sprintf(wgeom,"+%d+%d",x,y);

   ATMwin = CreateWindow("Atom Attributes Window",wgeom,ATMWINW,ATMWINH,
	 		 infobg,infofg,(Window)0);
   subATM = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],ATMwin);
   XSelectInput(display, ATMwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);
   XMapWindow(display,ATMwin);

   WinObj[20].win = &ATMwin;
   WinObj[20].subwin = &subATM;
   WinObj[20].butarr = butATM;
   WinObj[20].numbut = NBUTATM;
   WinObj[20].winup = &ATMup;
   WinObj[20].redraw = RedrawATM;

   DefBut(&butATM[1],ATMwin, 100, 15, 100, 23, "Force Field", infobg, ZMBCOL);
   butATM[1].str = ForceFields[*fftyp];
   butATM[1].explstr = "Select a Force Field to type atoms with";
   butATM[1].style = 1;

   DefBut(&butATM[2],ATMwin, 100, 15+BUTTN, 100, 23, "Total Charge", infobg, 
	ZMBCOL);
   butATM[2].str = copt[itcopt];
   butATM[2].explstr = "Select the total charge of the molecule";
   butATM[2].style = 1;

   DefBut(&butATM[0], ATMwin, 170, 15+3*BUTTN, 70, 23, "AtomColor", infobg, 
	ZMBCOL);
   butATM[0].explstr = "Select substructure color of the atom.\nSelect atom: 2nd Mouse Button";
   butATM[0].style = 1;

   DefBut(&butATM[3], ATMwin, ATMWINW/2-50/2, 315, 50, 23, "OK", infobg, ZMBCOL);
   butATM[3].explstr = "Close the window";

   DefBut(&butATM[4], ATMwin, 210, 15, 30, 23, "OPT", infobg, ZMBCOL);
   butATM[4].explstr = "Setup Tinker/AMBFOR optimisation\nAMBFOR is Molden\'s own optimiser\nfor AMBER/GAFF force fields\nGAFF is for small molecules";

   DefBut(&butATM[5], ATMwin, 210, 15+BUTTN, 30, 23, "E q", infobg, ZMBCOL);
   butATM[5].explstr = "Calculate van der Waals and \nElectrostatic energies between\n atoms with different residue numbers";

   qboxstr(&qboxes[QCHARG],&ATMwin,1,0,190,ATMOffx,35+4*BUTTN,
	110,QBOXHIGH,2,"Charge"," ",10,QREAL,2000,-1,dummyproc);
   qboxes[QCHARG].explstr = "Partial charge of selected atom\nSelect atom: 2nd Mouse Button";

   qboxstr(&qboxes[QRSD],&ATMwin,0,0,190,ATMOffx+115,35+4*BUTTN,
	100,QBOXHIGH,2,"Residue"," ",4,QREAL,2000,-1,dummyproc);
   qboxes[QRSD].explstr = "Residue number of selected atom\nSelect atom: 2nd Mouse Button";

   qboxstr(&qboxes[QATOM],&ATMwin,0,0,190,ATMOffx+55,36+2*BUTTN,
	100,QBOXHIGH,2,"Number:"," ",6,QPOSINT,2000,-1,dummyproc);
   qboxes[QATOM].explstr = "Number of selected atom\nType a number \nto change Atom selected";

   DefList(&fftlist,ATMwin,6,35+5*BUTTN+QBOXHIGH,ATMWINW-37,110,
	NULL,9,typs[1],NULL,NULL,NULL,Ntyps[1],NULL);

   UpdateATM();

}

void UpdateATM()
{
   int i;

   sprintf(qboxes[QCHARG].str,"%f",xyzp->qat[ATMsel]);
   qboxes[QCHARG].curpos = strlen(qboxes[QCHARG].str);
   qboxes[QCHARG].dflt = &xyzp->qat[ATMsel];
   sprintf(qboxes[QRSD].str,"%d",xyzp->iresid[ATMsel]);
   qboxes[QRSD].curpos = strlen(qboxes[QRSD].str);
   qboxes[QRSD].iflt = &xyzp->iresid[ATMsel];
   sprintf(qboxes[QATOM].str,"%d",ATMselp);
   qboxes[QATOM].curpos = strlen(qboxes[QATOM].str);
   qboxes[QATOM].iflt = &ATMselp;
   fftlist.list.ilst = ffptr[*fftyp];
   if (xyzp->ityp[ATMsel] < 0) {
	fftlist.list.list = typsn[*fftyp];
	fftlist.list.nents = Ntypsn[*fftyp];
	fftlist.scrbar.wn = Ntypsn[*fftyp];
   } else {
	fftlist.list.list = typs[*fftyp]; 
	fftlist.list.nents = Ntyps[*fftyp];
	fftlist.scrbar.wn = Ntyps[*fftyp];
   }

   if (ffptr[*fftyp] == NULL) {
	fftlist.select = abs(xyzp->ityp[ATMsel]) - 1;
   } else {
	fftlist.select = -1;
	for (i=0; i<*Ntyps[*fftyp]; i++)
	   if (abs(xyzp->ityp[ATMsel]) - 1 == fftlist.list.ilst[i]) fftlist.select = i;
   }
   if (fftlist.select >= *fftlist.list.nents) fftlist.select = 0;
   if (fftlist.select == -1 && ffptr[*fftyp] != NULL 
	&& fftlist.list.ilst != NULL) {
	for (i=0; i<*Ntyps[*fftyp]; i++) {
	   if (xyzp->ianz[ATMsel] == ffatnr[*fftyp][i]) {
		fftlist.lpnt = i;
		break;
	   }
	}
   } else {
	if (fftlist.select != -1) {
	   fftlist.lpnt = fftlist.select - 4;
	}
   }
   if (fftlist.lpnt < 0) fftlist.lpnt = 0;
   if (fftlist.lpnt > *fftlist.list.nents - fftlist.mxents) 
	fftlist.lpnt = *fftlist.list.nents - fftlist.mxents;
   if (! *fftyp) {
	fftlist.select = 0;
	fftlist.lpnt = 0;
	*fftlist.scrbar.wpos = 0;
   }
   butATM[1].str = ForceFields[*fftyp];
}

void RedrawATM()
{
  int i;
  char nrstr[80];
  char atstr[3];

  butje(ATMwin,0,0,ATMWINW,75,4,0,0,1,None,0,0,0,0);
  butje(ATMwin,0,75,ATMWINW,ATMWINH-75,4,0,0,1,None,0,0,0,0);
  LineString(ATMwin, "Force Field ",ATMOffx, 30);
  LineString(ATMwin, "Total Charge",ATMOffx, 30+BUTTN);
  strcpy(atstr,"  ");
  if (ATMsel >= 0 && ATMsel < *xyzp->mxnat) {
     if (xyzp->ianz[ATMsel] >= 0 && xyzp->ianz[ATMsel] < MXEL)
	strcpy(atstr,elements[xyzp->ianz[ATMsel]]);
	
  }

  sprintf(nrstr,"Atom: %s", atstr);
  LineString(ATMwin, nrstr,ATMOffx, 30+3*BUTTN);
  ULineString(ATMwin,"Atom Type",ATMOffx, 43+4*BUTTN+QBOXHIGH);
  for (i=0; i<NBUTATM; i++) DrwBut(&butATM[i]);
  PromptBox(&qboxes[QCHARG]);
  PromptBox(&qboxes[QRSD]);
  PromptBox(&qboxes[QATOM]);
  RedrawList(&fftlist);
}

int ButtonsATM(i)
int i;
{
  int ff,nuse;

  switch (i) {
  case 0:	{
	if (DoPopUp(ATMwin,butATM[0].x-8,butATM[0].y+BUTTH,
			NULL,&xyzp->iatclr[ATMsel],0) == -1) break;
	   DrwBut(&butATM[0]);
	   *Sinct = 0;
	   return(1);
	}
	break;
  case 1:	{
	LSSTRU List;
	List.list = ForceFields; List.nents = 8;
	if (DoPopUp(ATMwin,butATM[1].x+20,butATM[1].y,
			&List,fftyp,0) == -1) break;
	   butATM[1].str = ForceFields[*fftyp];
	   DrwBut(&butATM[1]);
#if defined(VMS) || defined(UNDERSC)
	   dotyp(&cell->ichx);
#else
#ifdef CRAY
	   DOTYP(&cell->ichx);
#else
	   dotyp_(&cell->ichx);
#endif
#endif
	   Progs = TnkProgs;
	   nprogs = 6;
	   if (*fftyp == 7) {
		Progs = AmbProgs; 
		nprogs = 3;
		*tnkprg = 0;
	   }
           UpdateATM();
           RedrawATM();
	   return(1);
	}
	break;
  case 2:	{
	LSSTRU List; int totch;

	List.list = copt; List.nents = 7;
	if (DoPopUp(ATMwin,butATM[2].x+20,butATM[2].y,
		&List,&itcopt,0) == -1) break;
	   butATM[2].str = copt[itcopt];
	   DrwBut(&butATM[2]);
	   totch = itcopt -3;
#if defined(VMS) || defined(UNDERSC)
	   fixchg(&totch,xyzp->qat);
#else
#ifdef CRAY
	   FIXCHG(&totch,xyzp->qat);
#else
	   fixchg_(&totch,xyzp->qat);
#endif
#endif
	   qdpptr->ihasq = 1;
           UpdateATM();
           RedrawATM();
	   return(1);
	}
	break;
  case 3:
#ifdef DOGL
	if ((*fancy || *fullgl) && has_opengl) ogunsel();
#endif
	XDestroyWindow(display,ATMwin);
	ATMup = 0;
	*Sinct = ATMt;
	return(1);
	break;
  case 4:
	if ( ! ((*fftyp >= 1 && *fftyp <= 4) || *fftyp == 7) ) {
	   if (DoCan(event.xbutton.x_root,
		event.xbutton.y_root,"No Tinker or AMBFOR Force Field Selected !",0)) {}
	} else {
	   if ( ! ((*fftyp >= 1 && *fftyp <= 4) || *fftyp == 7) ) {
		ff = 1;
		if (pdb) ff = 7;
	   } else {
		ff = *fftyp;
	   }
	   if (typit(ff,0)) {
		if (DoCan(event.xbutton.x_root,
		   event.xbutton.y_root,"Found UnTyped Atoms !",0)) {}
	   } else {
		*iixyz = 6;
		if (TNKup) {
		   XMapRaised(display,TNKwin);
		   RedrawTNK();
		} else {
		   InitTNK(event.xbutton.x_root,
			event.xbutton.y_root);
		}
	   }
	}
	break;
  case 5:
	*icalc = 1;
	fprintf(stderr,"\n - vdWaals only for H,C,N,O,S,Cl\n\
 - residue 0 is not considered in residue-residue electrostatics\n");
#if defined(VMS) || defined(UNDERSC)
	nuse = 0; calcij(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 2; calcij(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 3; calcij(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 4; calcij(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
#else
#ifdef CRAY
	nuse = 0; CALCIJ(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 2; CALCIJ(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 3; CALCIJ(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 4; CALCIJ(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
#else
	nuse = 0; calcij_(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 2; calcij_(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 3; calcij_(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
	nuse = 4; calcij_(&nuse,xyzp->coo,xyzp->ianz,xyzp->iresid,xyzp->iconn,xyzp->qat);
#endif
#endif
	break;
  }
  return(0);
}

#define ROWLEN 10

void InitSEQ(x,y)
int x,y;
{
   int i,row,col;
   char wgeom[64];
   
   SEQup = 1;

   sprintf(wgeom,"+%d+%d",x,y);

   SEQwin = CreateWindow("Build Sequence Window",wgeom,SEQWINW,SEQWINH,
	 		 infobg,infofg,(Window)0);
   XSelectInput(display, SEQwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask | EnterWindowMask);
   XMapWindow(display,SEQwin);

   WinObj[21].win = &SEQwin;
   WinObj[21].subwin = NULL;
   WinObj[21].butarr = butSEQ;
   WinObj[21].numbut = NBUTSEQ;
   WinObj[21].winup = &SEQup;
   WinObj[21].redraw = RedrawSEQ;

   DefBut(&butSEQ[0], SEQwin, 100, SEQCONFY, 100, 23, "Alpha", infobg, ZMBCOL);
   butSEQ[0].str = Conformations[iconform];

   DefBut(&butSEQ[1], SEQwin, SEQOffx,      SEQBROWY, 75, 23, "Build", 
	infobg, ZMBCOL);

   DefBut(&butSEQ[2], SEQwin, SEQOffx+90,   SEQBROWY, 75, 23, "Undo", 
	infobg, ZMBCOL);

   DefBut(&butSEQ[4], SEQwin, SEQOffx+2*90, SEQBROWY, 75, 23, "Read", 
	infobg, ZMBCOL);

   DefBut(&butSEQ[3], SEQwin, SEQOffx+3*90, SEQBROWY, 75, 23, "Close", 
	infobg, ZMBCOL);

   for (i=0; i < NAminos; i++) {
      row = i / ROWLEN;
      col = i - row*ROWLEN;
      DefBut(&butSEQ[5+i], SEQwin, SEQOffx+col*40, SEQRESY+row*30, 35, 23, 
	AminoAcids[i], infobg, ZMBCOL);
   }

   qboxstr(&qboxes[QPHI],&SEQwin,1,0,190,210,SEQCONFY-5,
        100,QBOXHIGH,2,"PHI"," ",SUBLEN2,QREAL,2000,-1,dummyproc);
   qboxstr(&qboxes[QPSI],&SEQwin,0,0,190,320,SEQCONFY-5,
        100,QBOXHIGH,2,"PSI"," ",SUBLEN2,QREAL,2000,-1,dummyproc);

   phi_angle = phis[iconform];
   psi_angle = psis[iconform];
   sprintf(qboxes[QPHI].str,"%-9.3f",phi_angle);
   sprintf(qboxes[QPSI].str,"%-9.3f",psi_angle);
   qboxes[QPHI].curpos = strlen(qboxes[QPHI].str);
   qboxes[QPSI].curpos = strlen(qboxes[QPSI].str);
}

void RedrawSEQ()
{
  int i;

  butje(SEQwin,0,0,SEQWINW,SEQWINH,4,0,0,1,None,0,0,0,0);

  LineString(SEQwin, "Residues:",SEQOffx, SEQRESY - 10);
  LineString(SEQwin, "Conformation:",SEQOffx, SEQCONFY+13);
  for (i=0; i<NBUTSEQ; i++) DrwBut(&butSEQ[i]);
  UpdateSeqStat();
  PromptBox(&qboxes[QPHI]);
  PromptBox(&qboxes[QPSI]);

}

void UpdateSeqStat()
{
  int i;
  int il;

  il = NSeq-16;
  if (il < 0) il = 0;

  strcpy(SeqStat," ");
  for (i=il; i < NSeq; i++) {
	strcat(SeqStat,AminoAcids[Sequence[i]]);
	if (i < NSeq-1) strcat(SeqStat,"-");
  }

  butje(SEQwin,SEQOffx,SEQSTATY,SEQWINW-2*SEQOffx,30,2,0,2,0,None,0,0,0,0);
  LineString(SEQwin, SeqStat,SEQOffx, SEQSTATY+18);

}

int ButtonsSEQ(i)
int i;
{
  int residue, newSQ;

  switch (i) {
  case 0:	{
	LSSTRU List;
	List.list = Conformations; List.nents = 3;
	   if (DoPopUp(SEQwin,butSEQ[0].x+4,butSEQ[0].y+BUTTH-5,
		&List,&iconform,0) == -1) break;
	   butSEQ[0].str = Conformations[iconform];
	   phi_angle = phis[iconform];
	   psi_angle = psis[iconform];
	   sprintf(qboxes[QPHI].str,"%-9.3f",phi_angle);
	   sprintf(qboxes[QPSI].str,"%-9.3f",psi_angle);
	   qboxes[QPHI].curpos = strlen(qboxes[QPHI].str);
	   qboxes[QPSI].curpos = strlen(qboxes[QPSI].str);
	   PromptBox(&qboxes[QPHI]);
	   PromptBox(&qboxes[QPSI]);
	   DrwBut(&butSEQ[0]);
	}
	break;
  case 1:
	phi_angle = atof(qboxes[QPHI].str);
	psi_angle = atof(qboxes[QPSI].str);
	newSQ = LastAmino;
	if (InsertAmino != -1) {
	   if (ReplaceAmino) 
		ReplaceSequence(Sequence,NSeq,iconform,InsertAmino);
	   else
		idum1 = InsertSequence(Sequence,NSeq,iconform,InsertAmino,0,NULL);
	   InsertAmino = -1;
	   ReplaceAmino = 0;
	   NSeq = 0;
	   UpdateSeqStat();
	   XSync(display, False);
	   XDestroyWindow(display,SEQwin);
	   SEQup = 0;
	} else {
	   ReplaceAmino = 0;
	   AddSequence(Sequence,NSeq,iconform);
	   NSeq = 0;
	   UpdateSeqStat();
	}
	if (ZMEAA) { 
	   *Sinct = 530; 
	} else {
	   make_aa();
	   SetQZME();
/*
	   TogUp(&ZMEswitch[0]);
	   EXPbox[0].fake = 0;
*/
	   UpdateZME(); RedrawZME();
	}
	if (newSQ == -1) {
#if defined(VMS) || defined(UNDERSC)
	   dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	   conpdb();docent();doscal();setxyv();doclr();qupd();
#else
#ifdef CRAY
	   DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	   CONPDB();DOCENT();DOSCAL();SETXYV();doclr();QUPD();
#else
   	   dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	   conpdb_();docent_();doscal_();setxyv_();doclr();qupd_();
#endif
#endif
	}
	return(1);
	break;
  case 2:
	NSeq--;
	if (NSeq < 0) NSeq = 0;
	UpdateSeqStat();
	break;
  case 3:	
	XDestroyWindow(display,SEQwin);
	SEQup = 0;
	break;
  case 4:	
	if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
	   "Protein File, per line:\n\n\
3 letter amino acid code Phi Psi [Omega] [Chi1] [Chi2] [Chi3] [Chi4]\n\n\
The current Conformation will be assigned to it",0)) {}
	qboxstr(&qboxes[QPROT],NULL,1,0,-1, DEFQX,DEFQY,
	   QBOXWIDE,QBOXHIGH,0,"Protein Filename ? ",NULL,0,0,
	   640,0,dummyproc);
	break;
  default:
	residue = i - 5;
	if (residue >= 0 && residue < NAminos) {
	   if (NSeq < MAXSEQ-1) {
		Sequence[NSeq] = residue;
		NSeq++;
	   }
	}
	UpdateSeqStat();
	break;
  }
  return(0);
}

#if defined(VMS) || defined(UNDERSC)
void addchg()
#else
#ifdef CRAY
void ADDCHG()
#else
void addchg_()
#endif
#endif
{
	int ir,ifft;

	ifft = *fftyp;
        *fftyp = 7;

#if defined(VMS) || defined(UNDERSC)
	clceem(&calfptr->ishoh);
#else
#ifdef CRAY
	CLCEEM(&calfptr->ishoh);
#else
	clceem_(&calfptr->ishoh);
#endif
#endif
        *fftyp = ifft;
	ir = abs(xyzp->iresid[0]);
	clfstrptr->ihetq[ir] = 0;
	clfstrptr->ihqset[ir] = 1;
}

void InitTNK(x,y)
int x,y;
{
   char wgeom[64];
   int i,xmax;
   
   TNKup = 1;

   Progs = TnkProgs;
   nprogs = 6;
   AddChrg = 0;

   if (*ipdbon && calfptr->ncalf) {
	Cutoff = 1;
   } else {
	Cutoff = 0;
   }

   if (*fftyp == 7) {
	Progs = AmbProgs; 
	nprogs = 3;
	AddChrg = 1;
	*tnkprg = 0;
   }

   xmax = DisplayWidth(display,screen) - TNKWINW;
   if (x > xmax) x = xmax;
   sprintf(wgeom,"+%d+%d",x,y);

   TNKwin = CreateWindow("Tinker/AMBFOR Preferences",wgeom,TNKWINW,TNKWINH,
	 		 infobg,infofg,(Window)0);
   XSelectInput(display, TNKwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask 
	| SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);
   subTNK = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],TNKwin);
   XMapWindow(display,TNKwin);

   WinObj[22].win = &TNKwin;
   WinObj[22].subwin = &subTNK;
   WinObj[22].butarr = butTNK;
   WinObj[22].numbut = NBUTTNK;
   WinObj[22].winup = &TNKup;
   WinObj[22].redraw = RedrawTNK;

   DefBut(&butTNK[0], TNKwin, 100, TNKRESY, 80, 23, "minimize", infobg, ZMBCOL);
   butTNK[0].str = Progs[*tnkprg];
   butTNK[0].explstr = "Choose optimisation/MD program";
   butTNK[0].style = 1;

   DefBut(&butTNK[1], TNKwin, 100, TNKRESY+TNKBWIDE, 15, 15, " ", 
	infobg, ZMBCOL);
   butTNK[1].explstr = "Detach Job:\ndont wait for the job to finish";

   DefBut(&butTNK[2], TNKwin, 100, TNKRESY+2*TNKBWIDE, 15, 15, " ", 
	infobg, ZMBCOL);
   butTNK[2].explstr = "Archive Job:\ncreate archive file with multiple\nintermediate structures";

   DefBut(&butTNK[3], TNKwin, TNKOffx, TNKBROWY, 75, 23, "GO", 
	infobg, ZMBCOL);
   butTNK[3].explstr = "Start the optimisation/MD";

   DefBut(&butTNK[4], TNKwin, TNKOffx+100, TNKBROWY, 75, 23, "Close", 
	infobg, ZMBCOL);
   butTNK[4].explstr = "close this window";

   DefBut(&butTNK[5], TNKwin, 100, TNKRESY+3*TNKBWIDE, 15, 15, " ", 
	infobg, ZMBCOL);
   butTNK[5].explstr = "Calculate partial charges";


   DefBut(&butTNK[6], TNKwin, TNKOffx+200, TNKBROWY, 100, 23, "Constrain", 
	infobg, ZMBCOL);
   butTNK[6].explstr = "Select rigid and flexible parts";

   DefBut(&butTNK[7], TNKwin, 100, TNKRESY+4*TNKBWIDE, 15, 15, " ", 
	infobg, ZMBCOL);
   butTNK[7].explstr = "Use/Create periodic water box";

   DefBut(&butTNK[8], TNKwin, 210, TNKRESY+4*TNKBWIDE, 15, 15, " ", 
	infobg, ZMBCOL);
   butTNK[8].explstr = "Use cutoffs and switch functions (Faster)";

   if (hasmpi) {
	DefBut(&butTNK[9], TNKwin, 300, TNKRESY+4*TNKBWIDE, 15, 15, " ", 
		infobg, ZMBCOL);
	butTNK[9].explstr = "Use multiple processors";
	DefBut(&butTNK[10], TNKwin, 350, TNKRESY+4*TNKBWIDE-5, 30, 23, " ", 
		infobg, ZMBCOL);
	butTNK[10].explstr = "Use # processors";
	butTNK[10].str = Processors[useproc-1];
   }

   if (*tnkbg) {
	TogDown(&butTNK[1]);
   } else {
	TogUp(&butTNK[1]);
   }
 
   if (*arch) {
	TogDown(&butTNK[2]);
   } else {
	TogUp(&butTNK[2]);
   }
 
   if (AddChrg) {
	TogDown(&butTNK[5]);
   } else {
	TogUp(&butTNK[5]);
   }
 
   if (Cutoff) {
	TogDown(&butTNK[8]);
   } else {
	TogUp(&butTNK[8]);
   }
 
   if (hasmpi) {
	if (usempi) {
	   TogDown(&butTNK[9]);
	} else {
	   TogUp(&butTNK[9]);
	}
   }
 
   qboxstr(&qboxes[QGRD],&TNKwin,0,0,190,210,TNKRESY-5,
        200,QBOXHIGH,2,"RMS Gradient"," ",SUBLEN1,QREAL,2000,-1,dummyproc);
   qboxstr(&qboxes[QTNKJN],&TNKwin,1,0,190,210,TNKRESY+TNKBWIDE-5,
        200,QBOXHIGH,2,"Job Name",NULL,SUBLEN2,0,2000,-1,dummyproc);
   qboxstr(&qboxes[QARCH],&TNKwin,0,0,190,210,TNKRESY+2*TNKBWIDE-5,
        200,QBOXHIGH,2,"Archive Update Freq.",NULL,SUBLEN1,QPOSINT,2000,-1,dummyproc);
   qboxstr(&qboxes[QMAXIT],&TNKwin,0,0,190,210,TNKRESY+3*TNKBWIDE-5,
        200,QBOXHIGH,2,"Max. Iteration",NULL,SUBLEN1,QPOSINT,2000,-1,dummyproc);

   *currgrd = mxgrads[*tnkprg];
   sprintf(qboxes[QGRD].str,"%-9.3f",*currgrd);
   qboxes[QGRD].explstr = "Gradient at which the optimisation\n is considered finished";
   sprintf(qboxes[QARCH].str,"%d",*archfrq);
   qboxes[QARCH].explstr = "How frequent an intermediate structure \nshould be added to the archive file";
   sprintf(qboxes[QTNKJN].str,"molin");
   qboxes[QTNKJN].explstr = "Job name and basename of output files";
   strcp(tnkjn,qboxes[QTNKJN].str,SUBLEN2);
   TrmStr(&qboxes[QTNKJN]);
   sprintf(qboxes[QMAXIT].str,"%d",*tnkit);
   qboxes[QMAXIT].explstr = "Maximum number of iterations of the \noptimisation/MD";
   qboxes[QGRD].curpos = strlen(qboxes[QGRD].str);
   qboxes[QARCH].curpos = strlen(qboxes[QARCH].str);
   qboxes[QTNKJN].curpos = strlen(qboxes[QTNKJN].str);
   qboxes[QMAXIT].curpos = strlen(qboxes[QMAXIT].str);

}

void RedrawTNK()
{
  int i;

  butje(TNKwin,0,0,TNKWINW,TNKWINH,4,0,0,1,None,0,0,0,0);

  LineString(TNKwin, "Optimizer:",TNKOffx, TNKRESY+13);
  LineString(TNKwin, "Archive",TNKOffx, TNKRESY+2*TNKBWIDE+11);
  LineString(TNKwin, "Detach Job",TNKOffx, TNKRESY+TNKBWIDE+11);
  if (Progs == AmbProgs) {
	LineString(TNKwin, "Calc. Charge",TNKOffx, TNKRESY+3*TNKBWIDE+11);
	for (i=0; i<ntnkb; i++) DrwBut(&butTNK[i]);
	if (*tnkprg == 1) {
	   qboxes[QGRD].prompt = "Temperature";
	   qboxes[QMAXIT].prompt = "No. of steps";
	} else {
	   qboxes[QGRD].prompt = "RMS Gradient";
	   qboxes[QMAXIT].prompt = "Max. Iteration";
	}
        LineString(TNKwin, "Water Box",TNKOffx, TNKRESY+4*TNKBWIDE+11);
        LineString(TNKwin, "Use Cutoff",235, TNKRESY+4*TNKBWIDE+11);
	if (hasmpi) LineString(TNKwin, "MPI",325, TNKRESY+4*TNKBWIDE+11);
  } else {
	for (i=0; i<NBUTTNK-6; i++) DrwBut(&butTNK[i]);
	qboxes[QGRD].prompt = "RMS Gradient";
	qboxes[QMAXIT].prompt = "Max. Iteration";
  }
  PromptBox(&qboxes[QGRD]);
  PromptBox(&qboxes[QARCH]);
  PromptBox(&qboxes[QTNKJN]);
  PromptBox(&qboxes[QMAXIT]);

}

int ChkJobName()
{
   char JobName[MAXSTRLEN];

   strcpy(JobName,qboxes[QTNKJN].str);
   strcat(JobName,".xyz");
   if (strcmp(strname,JobName) == 0) {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"Jobname and file currently read can not be the same.",0);
	return(0);
   }
   return(1);
}

int ButtonsTNK(i)
int i;
{
  int nwat;

  switch (i) {
  case 0:	{
	LSSTRU List; 
	List.list = Progs; List.nents = nprogs;
	   if (DoPopUp(TNKwin,butTNK[0].x+4,butTNK[0].y+BUTTH-5,
		&List,tnkprg,0) == -1) break;
	   butTNK[0].str = Progs[*tnkprg];
	   if (Progs == AmbProgs) {
		pbc->icell = 0;
		butTNK[10].str = Processors[useproc-1];
		if (*tnkprg == 1) {
		   *currgrd = 298.0;
		   sprintf(qboxes[QGRD].str,"%-7.2f",*currgrd);
		   *tnkit = 1000;
		   sprintf(qboxes[QMAXIT].str,"%-5d",*tnkit);
		} else {
	   	   *currgrd = mxgrads[0];
		   sprintf(qboxes[QGRD].str,"%-7.2f",*currgrd);
		   *tnkit = 999;
		   sprintf(qboxes[QMAXIT].str,"%-d",*tnkit);
		   if (*tnkprg == 2) {
			pbc->icell = 1;
#if defined(VMS) || defined(UNDERSC)
			fdat(&EIGHTEEN,&ZERO,&ZERO,&ZERO,&ZERO,&ZERO);
#else
#ifdef CRAY
			FDAT(&EIGHTEEN,&ZERO,&ZERO,&ZERO,&ZERO,&ZERO);
#else
			fdat_(&EIGHTEEN,&ZERO,&ZERO,&ZERO,&ZERO,&ZERO);
#endif
#endif
		   }
		}
		qboxes[QGRD].curpos = strlen(qboxes[QGRD].str);
		qboxes[QMAXIT].curpos = strlen(qboxes[QMAXIT].str);
	  	RedrawTNK();
	   } else {
	   	*currgrd = mxgrads[*tnkprg];
	   	sprintf(qboxes[QGRD].str,"%-9.3f",*currgrd);
		qboxes[QGRD].curpos = strlen(qboxes[QGRD].str);
	   	PromptBox(&qboxes[QGRD]);

		if (*tnkprg == 4) {
		   List.list = xtinkopts; List.nents = 2;
		   if (DoPopUp(TNKwin,butTNK[0].x-8,butTNK[0].y+BUTTH,
				&List,iqopt,0) == -1) {int idum; idum = 1;}
		}
		DrwBut(&butTNK[0]);
	   }
	}
	break;
  case 1:	
/* background */
	*tnkbg = ! TogBut(&butTNK[1]);
	break;
  case 2:
/* archive */
	*arch = ! TogBut(&butTNK[2]);
	break;
  case 3:
/* go */
	if (ChkJobName()) {
#ifdef DOGL
	   ogunsel();
#endif
	   if (*ipdbon) {
#ifdef DOGL
		if (!bckrig) empty_ribb();
#endif

#if defined(VMS) || defined(UNDERSC)
		quwat(&nwat);
#else
#ifdef CRAY
		QUWAT(&nwat);
#else
		quwat_(&nwat);
#endif
#endif
		if (nwat > 0) {
		    if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Waters without Hydrogens detected.\n Should Molden clean up waters ?",1)) {
			if (*fftyp != 7) typit(7,0);
#if defined(VMS) || defined(UNDERSC)
			evwat();
#else
#ifdef CRAY
			EVWAT();
#else
			evwat_();
#endif
#endif
#ifdef DOGL
			if (*fancy) {
			   oghet(0);
			} else {
			   oglines();
			}
			update_model = 0;
#endif
			update_struct();
		    }
	       }
	   
	   }
	   *currgrd = atof(qboxes[QGRD].str);
	   *archfrq = atoi(qboxes[QARCH].str);
	   *tnkit = atoi(qboxes[QMAXIT].str);
	   cpstr(qboxes[QTNKJN].str,tnkjn,SUBLEN1);
	   XDestroyWindow(display,TNKwin);
	   TNKup = 0;
   	   if (*fftyp == 7) {
		*iixyz = 11;
	   } else {
		if (*tnkprg == 4) {
		   *iixyz = 10;
		} else {
		   *iixyz = 6;
		}
	   }
	   if (AddChrg) {
#if defined(VMS) || defined(UNDERSC)
		clceem(&calfptr->ishoh);
#else
#ifdef CRAY
		CLCEEM(&calfptr->ishoh);
#else
		clceem_(&calfptr->ishoh);
#endif
#endif
	   }
	   if (*ibox || Box) *igfmap = 0;

	   *Sinct = 151;
	   return(1);
	}
	break;
  case 4:	
/* close */
	*currgrd = atof(qboxes[QGRD].str);
	*archfrq = atoi(qboxes[QARCH].str);
	*tnkit = atoi(qboxes[QMAXIT].str);
	cpstr(qboxes[QTNKJN].str,tnkjn,SUBLEN1);
	XDestroyWindow(display,TNKwin);
	TNKup = 0;
	break;
  case 5:	
/* Calculate Charge */
	AddChrg = ! TogBut(&butTNK[5]);
	break;
  case 6:	
	if (!FLRup) CreateFLR();
	break;
  case 7:	
/* Box */
	Box = ! TogBut(&butTNK[7]);
	break;
  case 8:	
/* Cutoffs */
	Cutoff = ! TogBut(&butTNK[8]);
	break;
  case 9:	
/* mpi */
	if (hasmpi) usempi = ! TogBut(&butTNK[9]);
	break;
  case 10:	
/* number of processors */
	{
	LSSTRU List;
	List.list = Processors; List.nents = maxproc;
	if (DoPopUp(TNKwin,butTNK[10].x+1,
		   butTNK[10].y-(maxproc/2)*BUTTH,&List,&useproc,0) == -1) break;
	useproc++;
	butTNK[10].str = Processors[useproc-1];
	DrwBut(&butTNK[10]);
	}
	break;
  default:
	break;
  }
  return(0);
}

void rearr(itarr,arr)
int *itarr;
int *arr;
{
   int j;

   for (j=0; j<*zmptrp->nz; j++) {
	itarr[j] = arr[zmptrp->imap[j]-1];
   }
   for (j=0; j<*zmptrp->nz; j++) {
	arr[j] = itarr[j];
   }
}

void rearrs(itarr,arr)
int *itarr;
short int *arr;
{
   int j;

   for (j=0; j<*zmptrp->nz; j++) {
	itarr[j] = (int) arr[zmptrp->imap[j]-1];
   }
   for (j=0; j<*zmptrp->nz; j++) {
	arr[j] = (short int) itarr[j];
   }
}

void rearrd(itarr,arr)
double *itarr;
double *arr;
{
   int j;

   for (j=0; j<*zmptrp->nz; j++) {
	itarr[j] = arr[zmptrp->imap[j]-1];
   }
   for (j=0; j<*zmptrp->nz; j++) {
	arr[j] = itarr[j];
   }
}

void rearrz(itarr)
int *itarr;
{
   int j;

   for (j=0; j<*zmptrp->nz; j++) itarr[j] = -1;
   for (j=0; j<*zmptrp->nz; j++) {
	if (zmptrp->imap[j] > 0) {
	   itarr[zmptrp->imap[j]-1] = j;
	}
   }
}

int mapchk()
{
   int j;

    if (*ialtyp) return(1);

    for (j=0; j<*zmptrp->nz; j++) {
	if (zmptrp->imap[j]-1 != j) {
	    return(0) ;
	}
    }
    return (1);
}

#if defined(VMS) || defined(UNDERSC)
int dozmt(ioke)
#else
#ifdef CRAY
int DOZMT(ioke)
#else
int dozmt_(ioke)
#endif
#endif
int *ioke;
{


        *ioke = 0;
        if (!xison) return 0;
	if (!*zmptrp->ihaszm) { 
	   if (!DoCan(200,100,
		"Do You want to create a Z-matrix for this molecule ?",1)) {
	     *ioke = 1;
	     if (*xyzp->iatoms > *zmptrp->mxzat - 100) {
		*ioke = 0;
                if (AllocZMat(*xyzp->mxnat,ZERO)) *ioke = 1;
	     }
	   }
	}
	return 1;
}

int DoPDB(int ivis)
{
int i,j,k;
double d;
int *iarr;
double *darr;
int imarr[NUMCAL];
int ioke,ido;

	ido = 0;
	if (ivis) {
	   if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
                "Do You want to create a Z-matrix for this protein ?",1)) {
		ido = 1;
	   }
	} else {
	   ido = 1;
	}

	if (!*zmptrp->ihaszm) { 
	   if (ido) {
	     ioke = 1;
	     if (*xyzp->iatoms > *zmptrp->mxzat - 100) {
		ioke = 0;
		if (AllocZMat(*xyzp->mxnat,ZERO)) ioke = 1;
	     }
			
	     if (ioke) {
#if defined(VMS) || defined(UNDERSC)
		curs(&ONE);
		XSync(display, False);
        	pdbzmt();
#else
#ifdef CRAY
		CURS(&ONE);
		XSync(display, False);
        	PDBZMT();
#else
		curs_(&ONE);
		XSync(display, False);
        	pdbzmt_();
#endif
#endif
		if (*zmptrp->ihaszm) {

		   if ((iarr = (int *) malloc((sizeof j)*(*zmptrp->mxzat))) 
				!= NULL) {

			rearr(iarr,xyzp->iatclr);
			rearr(iarr,xyzp->iresid);
			rearr(iarr,xyzp->iaton);
			rearrs(iarr,xyzp->ityp);
			rearrs(iarr,xyzp->ipdbt);

			rearrz(iarr);
			for (k=0; k<6; k++) {
			   for (j=0; j<calfptr->ncalf; j++) 
				imarr[j] = calfptr->icalf[j][k];

			   for (j=0; j<calfptr->ncalf; j++) {
				if (imarr[j]-1 >= 0)
				   calfptr->icalf[j][k] = iarr[imarr[j]-1]+1;
			   }
			}

			free(iarr);
		   }

		   if ((darr = (double *) malloc((sizeof d)*(*zmptrp->mxzat))) 
				!= NULL) {

			rearrd(darr,xyzp->qat);
			free(darr);
		   }

/* old, with centering */   /*conpdb();chkbck();docent();doclr();qupd();*/

		   UpdHet();
#if defined(VMS) || defined(UNDERSC)
		   dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
		   conpdb();chkbck(&ONE);doclr();qupd();
		   if (*backb) {
			for (i=0;i<4;i++) 
			   acthel(&ONE,&i,&clfhptr->isndcl[i],&ZERO);
		   }
#else
#ifdef CRAY
		   DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
		   CONPDB();CHKBCK(&ONE);doclr();QUPD();
		   if (*backb) {
			for (i=0;i<4;i++)
			   ACTHEL(&ONE,&i,&clfhptr->isndcl[i],&ZERO);
		   }
#else
		   dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
		   conpdb_();chkbck_(&ONE);doclr();qupd_();
		   if (*backb) {
			for (i=0;i<4;i++) 
			   acthel_(&ONE,&i,&clfhptr->isndcl[i],&ZERO);
		   }
#endif
#endif
		   if (*backb) {
			int it;
            		for (i=0;i < calfptr->ncalf;i++) {
			   if (calfptr->reson[i] > 0) {
		   		if (calfptr->iamino[i] > 23) {
            	   		   for (j=0;j<6;j++)  {
				     it = calfptr->icalf[i][j];
				     if (it > 0 && it < NUMCAL) 
			   		xyzp->iaton[calfptr->icalf[i][j]-1] = 1;
				   }
		   		} else {
            			   for (j=0;j<4;j++)  {
				      it = calfptr->icalf[i][j];
				      if (it > 0 && it < NUMCAL) 
			   		xyzp->iaton[calfptr->icalf[i][j]-1] = 1;
				   }
		   		}
			   }
	    		}
		   }
		   make_aa();
		
		   if (ZMEup) {
			SetQZME();
			if (ZME_window_pos >= *zmptrp->nz) ZME_window_pos = 0;
			RedrawZME();
			RedrawScroll(&zscroll);
		   }
		}
		SSdone[istruct] = 0;
#if defined(VMS) || defined(UNDERSC)
		curs(&ZERO);
#else
#ifdef CRAY
		CURS(&ZERO);
#else
		curs_(&ZERO);
#endif
#endif
	 	return(1);
	      } else {
		sprintf(ZMEerr,
			"Couldnt allocate memory for Z-Matrix");
		RedrawStatus();
	      }
	   } else {
	      InitZME();
	   }
	}

	return(0);
}

void DelCellAtoms()
{
int i,j,k,nstor,nold,kcon,ab,noab;

	i = 0; 
	nstor = *xyzp->mxnat - cell->natc;
	while (i < cell->natc) {
	  if (xyzp->iaton[i] == 2) {
	    for (j=i; j < cell->natc - 1; j++) {
		xyzp->iatclr[nstor+j] = xyzp->iatclr[nstor+j+1];
		xyzp->ianz[nstor+j] = xyzp->ianz[nstor+j+1];
		xyzp->ipdbt[nstor+j] = xyzp->ipdbt[nstor+j+1];
		xyzp->ityp[nstor+j] = xyzp->ityp[nstor+j+1];
		xyzp->qat[j] = xyzp->qat[j+1];
		for (k=0; k < 3; k++)
		   xyzp->coo[(nstor+j)*3+k] = xyzp->coo[(nstor+j+1)*3+k];
		kcon = 0;
		for (k=0; k < xyzp->iconn[(nstor+j+1)*(MXCON+1)]; k++) {
		   noab = xyzp->iconn[(nstor+j+1)*(MXCON+1)+k+1];
		   ab = ABS(noab);
		   if (ab > i+1) {
			if (noab > 0) {
			   xyzp->iconn[(nstor+j)*(MXCON+1)+kcon+1] = noab - 1;
			} else {
			   xyzp->iconn[(nstor+j)*(MXCON+1)+kcon+1] = noab + 1;
			}
			kcon++;
		   } else if (ab != i+1) {
			xyzp->iconn[(nstor+j)*(MXCON+1)+kcon+1] = noab;
			kcon++;
		   }
		}
		xyzp->iconn[(nstor+j)*(MXCON+1)] = kcon;
		xyzp->iaton[j] = xyzp->iaton[j+1];
	    }
	    cell->natc = cell->natc - 1;
	    for (j=0; j < i; j++) {
		kcon = 0;
		for (k=0; k < xyzp->iconn[(nstor+j)*(MXCON+1)]; k++) {
		   noab = xyzp->iconn[(nstor+j)*(MXCON+1)+k+1];
		   ab = ABS(noab);
		   if (ab > i+1) {
			if (noab > 0) {
			   xyzp->iconn[(nstor+j)*(MXCON+1)+kcon+1] = noab - 1;
			} else {
			   xyzp->iconn[(nstor+j)*(MXCON+1)+kcon+1] = noab + 1;
			}
			kcon++;
		   } else if (ab != i+1) {
			xyzp->iconn[(nstor+j)*(MXCON+1)+kcon+1] = noab;
			kcon++;
		   }
		}
		xyzp->iconn[(nstor+j)*(MXCON+1)] = kcon;
	    }
	  } else {
	    i++;
	  }
	}
	nold = nstor;
	nstor = *xyzp->mxnat - cell->natc;
	for (j=cell->natc - 1; j >= 0; j--) {
	   xyzp->iatclr[nstor+j] = xyzp->iatclr[nold+j];
	   xyzp->ianz[nstor+j] = xyzp->ianz[nold+j];
	   xyzp->ipdbt[nstor+j] = xyzp->ipdbt[nold+j];
	   xyzp->ityp[nstor+j] = xyzp->ityp[nold+j];
 	   for (k=0; k < 3; k++)
		xyzp->coo[(nstor+j)*3+k] = xyzp->coo[(nold+j)*3+k];
	   for (k=0; k < xyzp->iconn[(nold+j)*(MXCON+1)]+1; k++)
		xyzp->iconn[(nstor+j)*(MXCON+1)+k] = xyzp->iconn[(nold+j)*(MXCON+1)+k];
	}
	update_sel = 1;
}

void MoveCellAtoms(CellTrans)
double *CellTrans;
{
int i,k,nstor;

	i = 0; 
	nstor = *xyzp->mxnat - cell->natc;

	for (i=0; i < cell->natc; i++) {
	    if (xyzp->iaton[i] == 2) {
		for (k=0; k < 3; k++)
		   xyzp->coo[(nstor+i)*3+k] = 
			xyzp->coo[(nstor+i)*3+k] + CellTrans[k];
	    }
	}
}

void InitCellDelTrans(dtopt)
int dtopt;
{
  int i,CTdelbck;

  CTdelbck = CTdel;
  CTdel = dtopt;

  if (CTup) {
	if (dtopt != CTdelbck) RedrawCT();
	return;
  }

  CTup = 1;

  CTwin = CreateWindow("Translate / Delete Cell Atoms","-80-80",
			 CTBOXWIDE,CTBOXHIGH,infobg,infofg,(Window)0);
  XSelectInput(display, CTwin, EnterWindowMask |
	ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask);

  XMapWindow(display,CTwin);

  WinObj[15].win = &CTwin;
  WinObj[15].subwin = NULL;
  WinObj[15].butarr = ctbut;
  WinObj[15].numbut = NBUTCT;
  WinObj[15].winup = &CTup;
  WinObj[15].redraw = RedrawCT;

  DefBut(&ctbut[0], CTwin, 70, 5+3*(BUTTN+5), 50, 23,
	"Apply", infobg, -15);

  DefBut(&ctbut[1], CTwin, 70+60, 5+3*(BUTTN+5), 50, 23,
	"Close", infobg, -15);

  DefBut(&ctbut[2], CTwin, 70, 5+2*(BUTTN+5), 50, 23,
	"Select", infobg, -15);

  DefBut(&ctbut[3], CTwin, 70+60, 5+2*(BUTTN+5), 70, 23,
	"DeSelect", infobg, -15);

  for (i=0; i<3; i++) {
	qboxstr(&qboxes[QCTA+i],&CTwin,0,0,190,CTBOXOFFX+i*80,CTBOXOFFY, 
		75,QBOXHIGH,2,cellvec[i],"0.0",9,QREAL,2000,-1,dummyproc);
	qboxes[QCTA+i].dflt = &CellTran[i];
  }
}

void RedrawCT()
{
  int i;

  butje(CTwin,0,0,CTBOXWIDE,CTBOXHIGH,4,0,0,1,None,0,0,0,0);
  for (i=0; i<NBUTCT; i++) DrwBut(&ctbut[i]);
  if (!CTdel) for (i=0; i<3; i++) PromptBox(&qboxes[QCTA+i]);
}

int ButtonsCT(x,y)
int x,y;
{
 int i,j;

 i = Clickwin(ctbut,NBUTCT,x,y,1);
 if (i>=0) {
	switch (i) {
	case 0:
	   if (CTdel) {
		DelCellAtoms();
	   } else {
		for (j=0; j<3; j++) 
		   CellTran[j] = atof(qboxes[QCTA+j].str);
		RedrawCT();
		MoveCellAtoms(CellTran);
	   }
	   SelDel = 0;
	   Selecting = 0;
	   update_sel = 1;
	   if (!CTdel && CTconn) return(2);
	   else return(1);
	   break;

	case 1:
	   for (i=0; i < *xyzp->iatoms; i++ ) 
		if (xyzp->iaton[i] > 1) xyzp->iaton[i] = 1;
	   SelDel = 0;
	   XDestroyWindow(display,CTwin);
	   CTup = 0;
	   break;
	case 2:
	   if (!CTsdone) {
		if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		   selstr,0)) {}
		CTsdone = 1;
	   }
	   Selecting = 1; ZoomEnable = True;
	   Select = True; SelDel = 1;
	   break;
	case 3:
	   if (!CTdsdone) {
		if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		   dselstr,0)) {}
		CTdsdone = 1;
	   }
	   Selecting = 1; ZoomEnable = True;
	   Select = False; SelDel = 1;
	   update_sel = 1;
	   break;
	default: break;
	}
 } else if (!CTdel) {
	i = ClickBox(&qboxes[QCTA],3,x,y);
	if (i>=0) {
		for (j=0; j<3; j++) qboxes[QCTA+j].active = 0;
		qboxes[QCTA+i].active = 1;
		RedrawCT();
	}

 }

 update_sel = 1;
 return(0);

}

void InitMovie(x,y)
int x,y;
{
  int i;
  char wgeom[64];
   

  sprintf(wgeom,"+%d+%d",x-20,y);

  if (Movup) {
	RedrawMOV();
	return;
  }

  Movup = 1;

  MOVwin = CreateWindow("Create Movie Window",wgeom,
			 MOVWINW,MOVWINH,infobg,infofg,(Window)0);
  XSelectInput(display, MOVwin, 
		SubstructureNotifyMask | ExposureMask | KeyPressMask | 
		ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | 
		LeaveWindowMask | PointerMotionMask | EnterWindowMask);
  subMOV = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],MOVwin);

  XMapWindow(display,MOVwin);

  WinObj[37].win = &MOVwin;
  WinObj[37].subwin = &subMOV;
  WinObj[37].butarr = movbut;
  WinObj[37].numbut = 5;
  WinObj[37].winup = &Movup;
  WinObj[37].redraw = RedrawMOV;

  DefBut(&movbut[0], MOVwin, 20, 5+2*(BUTTN+5), 15, 15,
	" ", infobg, -15);
  movbut[0].explstr = "Clean up bmp snapshots after \nmovie creation.";

  DefBut(&movbut[3], MOVwin, 20, 3*(BUTTN+5), 60, 23,
	"Current ", infobg, -15);
  movbut[3].explstr = "Screen resolution for movie.";

  DefBut(&movbut[1], MOVwin, 20, 4*(BUTTN+5), 50, 23,
	"Record", infobg, -15);
  movbut[1].explstr = "Begin recording of the movie.";

  DefBut(&movbut[2], MOVwin, 20+60, 4*(BUTTN+5), 150, 23,
	"Stop & Create Movie", infobg, -15);
  movbut[2].explstr = "Stop recording and write the movie.";

  DefBut(&movbut[4], MOVwin, 160, 5+3*(BUTTN+5), 15, 15,
	" ", infobg, -15);
  movbut[4].explstr = "Approximate movie play time by \nsimulation time.";

  rmsnap = 1;
  TogDown(&movbut[0]);

  timsnap = 0;
  TogUp(&movbut[4]);

  qboxstr(&qboxes[QMOV],&MOVwin,0,0,190,CTBOXOFFX,CTBOXOFFY, 
		200,QBOXHIGH,2,"Movie filename:","molden.avi",
		SUBLEN1,QSTRING,2000,0,dummyproc);

  qboxes[QMOV].active = 1;
}

void RedrawMOV()
{
  int i;

  butje(MOVwin,0,0,MOVWINW,MOVWINH,4,0,0,1,None,0,0,0,0);
  for (i=0; i<5; i++) DrwBut(&movbut[i]);
  LineString(MOVwin, "Clean up snap shots when done", 50, 18+2*(BUTTN+5));
  LineString(MOVwin, "Resolution", 90, 18+3*(BUTTN+5));
  LineString(MOVwin, "Real Time", 180, 18+3*(BUTTN+5));
  PromptBox(&qboxes[QMOV]);
}

int ButtonsMOV(i)
int i;
{
   struct timeval tv;
   int fps;

	switch (i) {
	case 0:
	   if (rmsnap) {
		rmsnap = 0;
	   	TogUp(&movbut[0]);
	   } else {
		rmsnap = 1;
	   	TogDown(&movbut[0]);
	   }
	   RedrawMOV();
	   break;

	case 1:
	   if (record) {
		record = 0;
	   	TogUp(&movbut[1]);
	   } else {
		record = 1;
	   	TogDown(&movbut[1]);
                setgif(1);
		tmpfmt = *igffrm;
		tmpmxg = *picmax;
		*picmax = 1000;
		*igffrm = 3;
		gettimeofday(&tv,NULL);
		Tbeg = tv.tv_sec;
	   }
	   RedrawMOV();
	   break;

	case 2:

	   *igffrm = tmpfmt;
	   *picmax = tmpmxg;
	   TogUp(&movbut[1]);
           setgif(1);

	   if ( (access(qboxes[QMOV].str,F_OK) == 0 && 
		!isdir(qboxes[QMOV].str)) ) {
		if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"File already exists.\nPlease choose other file name.",1)) {
		   i = -1;
		}
	   } else {
		record = 0;
		if (timsnap) {
		   gettimeofday(&tv,NULL);
		   Tend = tv.tv_sec;
		   fps = picnum/(Tend-Tbeg);
		} else {
		    fps = 10;
		}
	   	sprintf(stemp, 
		   "avconv -r %d -i %s%%03d.bmp -target pal-dvd -s %dx%d %s",
		   fps,GifFile,width,height,qboxes[QMOV].str);
		system(stemp);
		if (rmsnap) system("rm mol*.bmp");
		XDestroyWindow(display,MOVwin);
		Movup = 0;
	   }
	   break;

	case 3:
	   {
	   int restyp;
	   LSSTRU List;

	   List.list = rsopt; List.nents = 2;
	   if (DoPopUp(MOVwin,movbut[3].x+1,movbut[3].y+BUTTH,
			    &List,&restyp,0) == -1)  break;
	   switch (restyp) {
		case 0:
              		XResizeWindow(display, win, 640, 480);
	      		width = 640; height = 480;
			break;
		case 1:
              		XResizeWindow(display, win, 1280, 720);
	      		width = 1280; height = 720;
			break;
		default:
			break;
	   }
	   movbut[3].str = rsopt[restyp];
	   RedrawMOV();
#ifdef DOGL
	   if (has_opengl && (*fancy || *fullgl)) {
		Reshape(1);
		Aspect = (float) width / (float) height;
	   }
#endif
	   }
	   break;

	case 4:
	   if (timsnap) {
		timsnap = 0;
	   	TogUp(&movbut[4]);
	   } else {
		timsnap = 1;
	   	TogDown(&movbut[4]);
	   }
	   RedrawMOV();
	   break;

	default: break;
	}


}

void make_aa()
{
   int i,nz,sidechainstart,iamino,ichi;

   for (i=0; i < calfptr->ncalf; i++) {
	aaptr[i].iamino = &(calfptr->iamino[i]);
	iamino = *aaptr[i].iamino;
        if (iamino < 1 || iamino > 23) continue;
	nz = calfptr->icalf[i][0] - 1;
	aaptr[i].phi = nz+1;
	aaptr[i].psi = nz+2;
	aaptr[i].omega = nz;

	aaptr[i].chi1 = -1; 
	aaptr[i].chi2 = -1; 
	aaptr[i].chi3 = -1; 
	aaptr[i].chi4 = -1;

	sidechainstart = nz+5;

	if (iamino == 15) {
	   sidechainstart = nz+4;
	   if (zmptrp->ianz[nz+2] == 8) { 
		sidechainstart--; 
	   }
	} else {
/* if start residue there might be an N missing at nz+2 */

	   if (zmptrp->ianz[nz+4] != 1 && zmptrp->ianz[nz+3] == 1) 
		sidechainstart--; 
	}

	ichi = aminozmt[iamino-1].chis[0];
	if (ichi != -1)
	   aaptr[i].chi1 = sidechainstart-1+ichi;
	ichi = aminozmt[iamino-1].chis[1];
	if (ichi != -1) {
	   int hsi = 0;
	   int ispec = 0;

	   if (zmptrp->ianz[sidechainstart-1+ichi] == 1) hsi = 1;
	   if (iamino == 4 || iamino == 3) ispec = 1;

	   if (!ispec || (ispec && hsi) ) {
		 aaptr[i].chi2 = sidechainstart-1+ichi;
	   }
	}
	ichi = aminozmt[iamino-1].chis[2];
	if (ichi != -1)
	   aaptr[i].chi3 = sidechainstart-1+ichi;
	ichi = aminozmt[iamino-1].chis[3];
	if (ichi != -1) 
	   aaptr[i].chi4 = sidechainstart-1+ichi;

/*
        fprintf(stderr,"%d \n",*aaptr[i].iamino - 1);
        fprintf(stderr,"aa %d %s %f %f %f\n",i,AminoAcids[*aaptr[i].iamino - 1],
		zmptrp->bet[aaptr[i].phi],zmptrp->bet[aaptr[i].psi],
		zmptrp->bet[aaptr[i].omega]);
*/
   }

   if (calfptr->ncalf > 0) {
	ZMEAA = 1;
   } else {
	ZMEAA = 0;
   }
}

void aaexp(aastr,sl)
char* aastr;
int sl;
{
   int i,j,k,istrt,nque,olfnd,exfnd,que[MXEXP];

   nque = -1;
   if (sl > MXEXP) sl = MXEXP;

   for (i=0; i < sl; i++) {
      for (j=0; j < 20; j++) {
	if (strncasecmp(&aastr[i],AAlet[j],1) == 0) {
	   nque++;
	   que[nque] = j + 1;
	}
      }
   }
   nque++;
   if (nque != sl) {
	strcpy(ZMEerr,"Unrecognized one letter");
	RedrawStatus();
	return;
   }

   istrt = 0;
   olfnd = 0;
   if (oqlen == nque) {
      olfnd = 1;
      for (j=0; j < nque; j++) if (que[j] != oque[j]) olfnd = 0;
      if (olfnd) istrt = oqpos + 1;
   }
   

   for (i=istrt; i < calfptr->ncalf; i++) {
      exfnd = 1;
      for (j=0; j < nque; j++) {
	if (calfptr->iamino[i+j] != que[j]) exfnd = 0;
      }
      if (exfnd) {
	ZME_window_pos = i;
	UpdateZME();
	RedrawScroll(&zscroll);
	for (k=0; k < nque; k++) oque[k] = que[k];
	oqlen = nque;
	oqpos = i;
        strcpy(ZMEerr,"Match!");
        RedrawStatus();
        return;
      }
   }

   if (olfnd) {
      oqpos = 0;
      strcpy(ZMEerr,"End of sequence!");
   } else {
      strcpy(ZMEerr,"NO match!");
   }
   RedrawStatus();
}

void FreeAllFirst()
{
	int j;

	if (xyz.mxorg) {
	   free(xyz.coo);
	   free(xyz.rzp);
	   free(xyz.qat);
	   free(xyz.isurf);
	   free(xyz.lwrit);
	   free(xyz.lring);
	   free(xyz.ianz);
	   free(xyz.iaton);
	   free(xyz.iatclr);
	   free(xyz.iresid);
	   free(xyz.ixp);
	   free(xyz.iyp);
	   free(xyz.iconn);
	   free(xyz.inat);
	   free(xyz.ityp);
	   free(xyz.ipdbt);
	}

	if (dorb.mxorg) {
	   free(dorb.focc);
	   free(dorb.focb);
	   free(dorb.vectrs);
	   free(dorb.vectrb);
	   free(dorb.p);
	   free(dorb.paa);
	   free(dorb.phi);
	   free(dorb.dxpsi);
	   free(dorb.dypsi);
	   free(dorb.dzpsi);
	   free(dorb.averag);
	   free(dorb.dphi);
	   free(dorb.eiga);
	   free(dorb.eigb);
	   free(dorb.stoalfa);
	   free(dorb.stobnorm);
	   free(dorb.istos);
	   free(orb.qd);
	   free(orb.pd);
	   free(orb.gd);
	   free(orb.hd);
	}

	if (sgrd.mxorg) {
	   free(sgrd.denn);
	   free(sgrd.pmnn);
	   free(sgrd.dens);
	   free(sgrd.denst);
	   free(sgrd.edx);
	   free(sgrd.edy);
	   free(sgrd.rz);
	   free(sgrd.bucket);
	   free(sgrd.iedlog);
	   free(sgrd.ix);
	   free(sgrd.iy);
	}
	if (geopntr.mxorg) {
	   free(geopntr.formax);
	   free(geopntr.forrms);
	   free(geopntr.dismax);
	   free(geopntr.disrms);
	   free(geopntr.epoints);
	   free(geopntr.isav);
	}
	if (zmptr.mxzorg) {
	   free(zmptr.bl);
	   free(zmptr.ibl);
	   free(zmptr.alph);
	   free(zmptr.ialph);
	   free(zmptr.bet);
	   free(zmptr.ibet);
	   free(zmptr.imap);
	   free(zmptr.ianz);
	   free(zmptr.iz);
	   free(stoc.cstoc);
	   free(stoc.czstoc);
	   free(stoc.astoc);
	   free(stoc.bstoc);
	   free(stoc.ianstc);
	   free(IANZbox);
	   free(BLbox);
	   free(ALPHbox);
	   free(BETbox);
	   free(IZbox);
 	}
	for (j=0; j<hetptr.NHetAtm; j++) {
	   if (hetptr.Allocated[j]) free(hetptr.HetAtm[j]);
	}
}

void FreePixmaps()
{
   XFreePixmap(display,stipple);
   XFreePixmap(display,qwgrey);
   XFreePixmap(display,tqwgrey);
   XFreePixmap(display,molPix);
   XFreePixmap(display,upPix);
   XFreePixmap(display,downPix);
   XFreePixmap(display,lPix);
   XFreePixmap(display,rPix);
   XFreePixmap(display,ballPix);
   XFreePixmap(display,HourPix);
   XFreePixmap(display,gPix);
   XFreePixmap(display,SkullPix);
   XFreePixmap(display,FFPix);
   XFreePixmap(display,MLFPix);
   XFreePixmap(display,HPix);
   XFreePixmap(display,VRMLPix);
   XFreePixmap(display,AlignPix);
   XFreePixmap(display,OrigPix);
   XFreePixmap(display,CellPix);
   XFreePixmap(display,SurfPix);
   XFreePixmap(display,FotoPix);
   XFreePixmap(display,ColPix);
   XFreePixmap(display,slowPix);
   XFreePixmap(display,fastPix);
   XFreePixmap(display,blastPix);
   XFreePixmap(display,BigPix);
   XFreePixmap(display,OGLPix);
   XFreePixmap(display,icon_pixmap);
#ifdef DOGL
   glXDestroyContext(display,cx);
#endif
}

void FreeOne(sel)
int sel;
{
	int j;

	xyzp   = &COO[sel]->coo;
	geop   = &COO[sel]->geop;
	zmptrp = &COO[sel]->zmt;
	stocp  = &COO[sel]->stoc;
	dorbp  = &COO[sel]->dorb;
	orbp   = &COO[sel]->orb;

	if (xyzp->mxorg) FreeCoo(*xyzp);

	if (dorbp->mxorg) {
	   free(dorbp->focc);
	   free(dorbp->focb);
	   free(dorbp->vectrs);
	   free(dorbp->vectrb);
	   free(dorbp->p);
	   free(dorbp->paa);
	   free(dorbp->phi);
	   free(dorbp->dxpsi);
	   free(dorbp->dypsi);
	   free(dorbp->dzpsi);
	   free(dorbp->averag);
	   free(dorbp->dphi);
	   free(dorbp->eiga);
	   free(dorbp->eigb);
	   free(dorbp->stoalfa);
	   free(dorbp->stobnorm);
	   free(dorbp->istos);
	   free(orbp->qd);
	   free(orbp->pd);
	   free(orbp->gd);
	   free(orbp->hd);
	}

	if (geop->mxorg) {
	   free(geop->formax);
	   free(geop->forrms);
	   free(geop->dismax);
	   free(geop->disrms);
	   free(geop->epoints);
	   free(geop->isav);
	}

	if (zmptrp->mxzorg) {
	   free(zmptrp->bl);
	   free(zmptrp->ibl);
	   free(zmptrp->alph);
	   free(zmptrp->ialph);
	   free(zmptrp->bet);
	   free(zmptrp->ibet);
	   free(zmptrp->imap);
	   free(zmptrp->ianz);
	   free(zmptrp->iz);
	   free(stocp->cstoc);
	   free(stocp->czstoc);
	   free(stocp->astoc);
	   free(stocp->bstoc);
	   free(stocp->ianstc);
	   free(COO[sel]->fname);
	   free(COO[sel]->IANZbox);
	   free(COO[sel]->BLbox);
	   free(COO[sel]->ALPHbox);
	   free(COO[sel]->BETbox);
	   free(COO[sel]->IZbox);
	}
	if (COO[sel]->pdbcode != NULL) free(COO[sel]->pdbcode);
	if (COO[sel]->memfil.str != NULL) {
	   free(COO[sel]->memfil.line_index);
	   free(COO[sel]->memfil.str);
	   COO[sel]->memfil.str = NULL;
	}
	if (COO[sel]->hetatm.NHetAtm > 0) {
	      for (j=0; j<COO[sel]->hetatm.NHetAtm; j++) {
		if (COO[sel]->hetatm.Allocated[j]) free(COO[sel]->hetatm.HetAtm[j]);
	      }
	}
	if (COO[sel]->mfdata.mollin != NULL) free(COO[sel]->mfdata.mollin);
	if (COO[sel]->mlftit != NULL) free(COO[sel]->mlftit);

	free(COO[sel]);

	if (watres[sel] != NULL) free(watres[sel]);
	if (watanz[sel] != NULL) free(watanz[sel]);
	if (watcoo[sel] != NULL) free(watcoo[sel]);
	if (watcon[sel] != NULL) free(watcon[sel]);
	if (watmap[sel] != NULL) free(watmap[sel]);
	if (watqat[sel] != NULL) free(watqat[sel]);
	if (wattyp[sel] != NULL) free(wattyp[sel]);

	empty_model(sel,0);

}

void FreeAll(delpix)
int delpix;
{
   int i,mul;
   int n;
   char cmdfil[MAXSTRLEN];

   mul = 0;
   if (multstruct==NULL) {
	mul = 0;
   } else {
      if (*multstruct) mul = 1;
   }

   if (!mul) {
	FreeAllFirst();
   } else {

      for (i=0; i<nstruct; i++) {
	if (bcksvg.UpSVG && bcksvg.istruct == i) {
	   if (strstr(COO[istruct]->fname,".sdf") ||
	       strstr(COO[istruct]->fname,".mol2")) {
		killob();
		wrsvgs(COO[bcksvg.istruct]->fname);
		bcksvg.UpSVG = 0;
	   }
	}
	FreeOne(i);
      }
   }
   if (delpix) FreePixmaps();

   if (pdbcode != NULL) {
	if (pdbcode == pdbcbck) {
	   free(pdbcode);
	}
   }
}

void DeleteOne()
{
   int i,j;

   update_model = 0;
   if (nstruct == 1) {
	DeleteAll();
   } else {
	FreeOne(istruct);
	free(strfiles[istruct]);
	for (i=0; i<nstruct-1; i++) 
	    if (i >= istruct) {
		COO[i]       = COO[i+1];
		strfiles[i]  = strfiles[i+1];
		scl[i]       = scl[i+1];
#ifdef DOGL
		MoveOne(i);
#endif
	    }
#ifdef DOGL
	initOne(nstruct-1);
#endif
	strfiles[nstruct-1] = NULL;
	COO[nstruct-1] = NULL;
	nstruct--;
	if (istruct > nstruct - 1) istruct = nstruct - 1;
	if (istruct < 0) istruct = 0;
	strlist.select = istruct;
	RedrawSTR();

	NewActiveStruct();

	doclr();
	if (NMols[istruct] == -1) update_model = 1;
	update_struct();
   }
}

void DeleteAll()
{
   int i;

   FreeAll(0);
   for (i=0; i<nstruct; i++) {
	free(strfiles[i]);
	strfiles[i] = NULL;
	COO[i] = NULL;
   }

   istruct = nstruct = 0;
   nfilesstart = 0;
   NSurf[0] = 0;

   xyzp   = &xyz;
   geop   = &geopntr;
   zmptrp = &zmptr;
   stocp  = &stoc;
   dorbp  = &dorb;
   orbp   = &orb;

   IANZbox = IANZboxes;
   BLbox = BLboxes;
   ALPHbox = ALPHboxes;
   BETbox = BETboxes;
   IZbox = (QBOXSTRU *) IZboxes;

   *backb = 0;
   *xyz.iatoms = 0;
   *zmptr.nz = 0;
   *zmptr.ihaszm = 0;
   calfptr->ncalf = 0;
   zmptr.mxzorg = 0;
   geo1ptr->gcvav = 0;
   cnvptr->icvav1 = 0;
   cnvptr->icvav2 = 0;
   out_spec = NULL;
   FRQ->nfreq = 0;

   XDestroyWindow(display,STRwin);STRup = 0;

   doclr();
   update_model = 1;
   update_struct();
}

void Copy2Zmat()
{
   int i,j;

   if (zmcnz == -1) return;

   for (i=0; i< zmcnz; i++) {
	zmptrp->bl[i] = zmcptrp->bl[i];
	zmptrp->ibl[i] = zmcptrp->ibl[i];
	zmptrp->alph[i] = zmcptrp->alph[i];
	zmptrp->ialph[i] = zmcptrp->ialph[i];
	zmptrp->bet[i] = zmcptrp->bet[i];
	zmptrp->ibet[i] = zmcptrp->ibet[i];
	zmptrp->ianz[i] = zmcptrp->ianz[i];
	zmptrp->imap[i] = zmcptrp->imap[i];
	for (j=0; j<3; j++)
	   zmptrp->iz[i*4+j] = zmcptrp->iz[i*4+j];

   }

   *zmptrp->nz = zmcnz;
}

void Zmat2Copy()
{
   int i,j;

   for (i=0; i<*zmptrp->nz; i++) {
	zmcptrp->bl[i] = zmptrp->bl[i];
	zmcptrp->ibl[i] = zmptrp->ibl[i];
	zmcptrp->alph[i] = zmptrp->alph[i];
	zmcptrp->ialph[i] = zmptrp->ialph[i];
	zmcptrp->bet[i] = zmptrp->bet[i];
	zmcptrp->ibet[i] = zmptrp->ibet[i];
	zmcptrp->ianz[i] = zmptrp->ianz[i];
	zmcptrp->imap[i] = zmptrp->imap[i];
	for (j=0; j<3; j++)
	   zmcptrp->iz[i*4+j] = zmptrp->iz[i*4+j];
   }

   zmcnz = *zmptrp->nz;
}

int AllocZMat(ZSize,first)
int ZSize;
int first;
{
   int memstat,i,j;
   double f;
   int ii;
   QBOXSTRU *TMPIANZbox;
   QBOXSTRU *TMPBLbox;
   QBOXSTRU *TMPALPHbox;
   QBOXSTRU *TMPBETbox;
   QBOXSTRU *TMPIZbox;

   memstat = 1;

   if (first) {
	ZSize = MAXAT;
   } else {
	TMPzmptr = *zmptrp;
	TMPzmcptr = *zmcptrp;
	TMPstoc = *stocp;
	TMPIANZbox = IANZbox;
	TMPBLbox = BLbox;
	TMPALPHbox = ALPHbox;
	TMPBETbox = BETbox;
	TMPIZbox = IZbox;
   }

   if ((zmptrp->bl = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->bl = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->ibl = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->ibl = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->alph = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->alph = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->ialph = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->ialph = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->bet = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->bet = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->ibet = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->ibet = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->imap = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->imap = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->ianz = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->ianz = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((zmptrp->iz = (int *) malloc((sizeof ii)*ZSize*4)) == NULL) {
	memstat = 0;
   }

   if ((zmcptrp->iz = (int *) malloc((sizeof ii)*ZSize*4)) == NULL) {
	memstat = 0;
   }

   if ((stocp->cstoc = (double *) malloc((sizeof f)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if ((stocp->czstoc = (double *) malloc((sizeof f)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if ((stocp->astoc = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((stocp->bstoc = (double *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((stocp->ianstc = (int *) malloc((sizeof ii)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((IANZbox = (QBOXSTRU *) malloc((sizeof TMPbox)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((BLbox = (QBOXSTRU *) malloc((sizeof TMPbox)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((ALPHbox = (QBOXSTRU *) malloc((sizeof TMPbox)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((BETbox = (QBOXSTRU *) malloc((sizeof TMPbox)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((IZbox = (QBOXSTRU *) malloc((sizeof TMPbox)*ZSize*4)) == NULL) {
	memstat = 0;
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory AllocZMat\n");
	if (!first) {
	   *zmptrp = TMPzmptr;
	   *stocp = TMPstoc;
	}
	return(0);
   } else {
	if (first) {

	   zmptrp->ibl[0] = 0;
	   zmptrp->ialph[0] = zmptrp->ialph[1] = 0;
	   zmptrp->ibet[0] = zmptrp->ibet[1] = zmptrp->ibet[2] = 0;
	   zmptrp->bl[0] = 0.0;
	   zmptrp->alph[0] = zmptrp->alph[1] = 0.0;
	   zmptrp->bet[0] = zmptrp->bet[1] = zmptrp->bet[2] = 0.0;
	   for (i=0; i<ZSize*4; i++) zmptrp->iz[i] = 0;

	   zmptrp->nz = zmptr.nz;
	   zmptrp->ihaszm = zmptr.ihaszm;
	   zmptrp->mxzat = zmptr.mxzat;

	   zmcptrp->ibl[0] = 0;
	   zmcptrp->ialph[0] = zmcptrp->ialph[1] = 0;
	   zmcptrp->ibet[0] = zmcptrp->ibet[1] = zmcptrp->ibet[2] = 0;
	   zmcptrp->bl[0] = 0.0;
	   zmcptrp->alph[0] = zmcptrp->alph[1] = 0.0;
	   zmcptrp->bet[0] = zmcptrp->bet[1] = zmcptrp->bet[2] = 0.0;
	   for (i=0; i<ZSize*4; i++) zmcptrp->iz[i] = 0;

	   zmcptrp->nz = &zmcnz;
	   *zmcptrp->nz = *zmcptr.nz;
	   zmcptrp->ihaszm = zmcptr.ihaszm;
	   zmcptrp->mxzat = zmcptr.mxzat;

	} else {

	   for (i=0; i < *zmptrp->mxzat; i++) {
		zmptrp->bl[i] = TMPzmptr.bl[i];
		zmptrp->ibl[i] = TMPzmptr.ibl[i];
		zmptrp->alph[i] = TMPzmptr.alph[i];
		zmptrp->ialph[i] = TMPzmptr.ialph[i];
		zmptrp->bet[i] = TMPzmptr.bet[i];
		zmptrp->ibet[i] = TMPzmptr.ibet[i];
		zmptrp->imap[i] = TMPzmptr.imap[i];
		zmptrp->ianz[i] = TMPzmptr.ianz[i];
		for (j=0; j<3; j++)
		   zmptrp->iz[i*4+j] = TMPzmptr.iz[i*4+j];

		zmcptrp->bl[i] = TMPzmcptr.bl[i];
		zmcptrp->ibl[i] = TMPzmcptr.ibl[i];
		zmcptrp->alph[i] = TMPzmcptr.alph[i];
		zmcptrp->ialph[i] = TMPzmcptr.ialph[i];
		zmcptrp->bet[i] = TMPzmcptr.bet[i];
		zmcptrp->ibet[i] = TMPzmcptr.ibet[i];
		zmcptrp->imap[i] = TMPzmcptr.imap[i];
		zmcptrp->ianz[i] = TMPzmcptr.ianz[i];
		for (j=0; j<3; j++)
		   zmcptrp->iz[i*4+j] = TMPzmcptr.iz[i*4+j];

		IANZbox[i] = TMPIANZbox[i];
		BLbox[i] = TMPBLbox[i];
		ALPHbox[i] = TMPALPHbox[i];
		BETbox[i] = TMPBETbox[i];
		for (j=0; j<3; j++)
		   IZbox[i*4+j] = TMPIZbox[i*4+j];

	   }
	   if (TMPzmptr.mxzorg) {
		FreeZmt(TMPzmptr,TMPstoc,
			TMPIANZbox,TMPBLbox,TMPALPHbox,TMPBETbox,TMPIZbox);
	   }

	}
	if (COO[istruct] != NULL) {
		COO[istruct]->IANZbox = IANZbox;
		COO[istruct]->BLbox   = BLbox;
		COO[istruct]->ALPHbox = ALPHbox;
		COO[istruct]->BETbox  = BETbox;
		COO[istruct]->IZbox   = IZbox;
	}
	zmptrp->mxzorg = 1;
	*zmptrp->mxzat = ZSize;
	return(ZSize);
   }
}

#if defined(VMS) || defined(UNDERSC)
void allorb(ZSizep,first)
#else
#ifdef CRAY
void ALLORB(ZSizep,first)
#else
void allorb_(ZSizep,first)
#endif
#endif
int *ZSizep;
int *first;
{
   int memstat;
   double d;
   float f;
   int i;
   int ZSize;

   memstat = 1;
   if (*first) {
	ZSize = MAXORB;
   } else {
	ZSize = *ZSizep;
	TMPdorb = *dorbp;
	TMPorb = *orbp;
   }


   if ((dorbp->focc = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->focb = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->vectrs = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->vectrb = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->p = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->paa = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->phi = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->dphi = (double *) malloc((sizeof d)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->dxpsi = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->dypsi = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->dzpsi = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }


   if ((dorbp->averag = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->eiga = (float *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->eigb = (float *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->stoalfa = (float *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->stobnorm = (float *) malloc((sizeof f)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((dorbp->istos = (int *) malloc((sizeof i)*ZSize*5)) == NULL) {
	memstat = 0;
   }

   if ((orbp->qd = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((orbp->pd = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((orbp->gd = (double *) malloc((sizeof d)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if ((orbp->hd = (double *) malloc((sizeof d)*ZSize*6)) == NULL) {
	memstat = 0;
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory allorb\n");
	if (!*first) {
	   *dorbp = TMPdorb;
	   *orbp = TMPorb;
	}
   } else {
	if (*first) {
	   dorbp->ncols  = dorb.ncols;
	   dorbp->ncolb  = dorb.ncolb;
	   dorbp->nocc   = dorb.nocc;
	   dorbp->nocb   = dorb.nocb;
	   dorbp->naorbs = dorb.naorbs;
	   dorbp->mxorb  = dorb.mxorb;
 	} else {
	   if (TMPdorb.mxorg) {
		free(TMPdorb.focc);
	   	free(TMPdorb.focb);
		free(TMPdorb.vectrs);
		free(TMPdorb.vectrb);
		free(TMPdorb.p);
		free(TMPdorb.paa);
		free(TMPdorb.phi);
		free(TMPdorb.dphi);
		free(TMPdorb.dxpsi);
		free(TMPdorb.dypsi);
		free(TMPdorb.dzpsi);
		free(TMPdorb.averag);
		free(TMPdorb.eiga);
		free(TMPdorb.eigb);
		free(TMPdorb.stoalfa);
		free(TMPdorb.stobnorm);
		free(TMPdorb.istos);
		free(TMPorb.qd);
		free(TMPorb.pd);
		free(TMPorb.gd);
		free(TMPorb.hd);
	   }
	}
	dorbp->mxorg  = 1;
	*dorbp->mxorb = ZSize;
   }
}

#define LNBUCK 10

#if defined(VMS) || defined(UNDERSC)
void allgrd(ZSizep)
#else
#ifdef CRAY
void ALLGRD(ZSizep)
#else
void allgrd_(ZSizep)
#endif
#endif
int *ZSizep;
{
   int memstat;
   double d;
   int i;
   int ZSize;

   ZSize = *ZSizep;
   memstat = 1;

   TMPsgrd = sgrd;

   if ((sgrd.denn = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.pmnn = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.dens = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.denst = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.edx = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.edy = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.rz = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.bucket = (double *) malloc((sizeof d)*(ZSize + LNBUCK))) == NULL) {
	memstat = 0;
   }

   if ((sgrd.iedlog = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.ix = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.iy = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }


   if (!memstat) {
	fprintf(stderr,"Out of memory allgrd\n");
	sgrd = TMPsgrd;
   } else {
	if (TMPsgrd.mxorg) {
	   free(TMPsgrd.denn);
	   free(TMPsgrd.pmnn);
	   free(TMPsgrd.dens);
	   free(TMPsgrd.denst);
	   free(TMPsgrd.edx);
	   free(TMPsgrd.edy);
	   free(TMPsgrd.rz);
	   free(TMPsgrd.bucket);
	   free(TMPsgrd.iedlog);
	   free(TMPsgrd.ix);
	   free(TMPsgrd.iy);
	}
	sgrd.mxorg = 1;
	*sgrd.mx3d = ZSize;
	*sgrd.mx3d2 = ZSize*ZSize;
   }
}

#if defined(VMS) || defined(UNDERSC)
void allgrd2(ZSizep)
#else
#ifdef CRAY
void ALLGRD2(ZSizep)
#else
void allgrd2_(ZSizep)
#endif
#endif
int *ZSizep;
{
   int memstat;
   double d;
   int i;
   int ZSize;

   ZSize = *ZSizep;
   memstat = 1;

   TMPsgrd = sgrd;

   if ((sgrd.denn = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.denn2 = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.pmnn = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.dens = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.denst = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.edx = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.edy = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.rz = (double *) malloc((sizeof d)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.bucket = (double *) malloc((sizeof d)*(ZSize + LNBUCK))) == NULL) {
	memstat = 0;
   }

   if ((sgrd.iedlog = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.ix = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((sgrd.iy = (int *) malloc((sizeof i)*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }


   if (!memstat) {
	fprintf(stderr,"Out of memory allgrd2\n");
	sgrd = TMPsgrd;
   } else {
	if (TMPsgrd.mxorg) {
	   free(TMPsgrd.denn);
	   free(TMPsgrd.pmnn);
	   free(TMPsgrd.dens);
	   free(TMPsgrd.denst);
	   free(TMPsgrd.edx);
	   free(TMPsgrd.edy);
	   free(TMPsgrd.rz);
	   free(TMPsgrd.bucket);
	   free(TMPsgrd.iedlog);
	   free(TMPsgrd.ix);
	   free(TMPsgrd.iy);
	}
	sgrd.mxorg = 1;
	*sgrd.mx3d = ZSize;
	*sgrd.mx3d2 = ZSize*ZSize;
   }
}

#if defined(VMS) || defined(UNDERSC)
void allgeo(ZSizep,first)
#else
#ifdef CRAY
void ALLGEO(ZSizep,first)
#else
void allgeo_(ZSizep,first)
#endif
#endif
int *ZSizep;
int *first;
{
   int memstat;
   double d;
   int i, mxpnto,mxorgo;
   int ZSize;

   memstat = 1;
   if (*first) {
	ZSize = MAXPNT;
   } else {
	ZSize = *ZSizep;
	TMPgeopntr = *geop;
   }

   if ((geop->formax = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((geop->forrms = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((geop->dismax = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((geop->disrms = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((geop->epoints = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((geop->isav = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory allgeo\n");
	if (!*first) *geop = TMPgeopntr;
   } else {
	if (TMPgeopntr.mxorg) {
		free(TMPgeopntr.formax);
		free(TMPgeopntr.forrms);
		free(TMPgeopntr.dismax);
		free(TMPgeopntr.disrms);
		free(TMPgeopntr.epoints);
		free(TMPgeopntr.isav);
	}
	geop->mxorg = 1;
	geo1ptr->mxpnt = ZSize;
   }
}

typedef struct {
  int ptr;
  float depth;
} DepthIndex;

DepthIndex dptdemo;
DepthIndex dpt[NUMAT];
DepthIndex *dptptr = dpt;
static int dptsiz = NUMAT;

typedef struct {
  int ptr;
  int depth;
} IntIndex;

IntIndex idpt[MXCON+1];
IntIndex *intptr = idpt;

void FreeCoo(txyz)
COOSTRU txyz;
{
   free(txyz.coo);
   free(txyz.rzp);
   free(txyz.qat);
   free(txyz.isurf);
   free(txyz.icont);
   free(txyz.lwrit);
   free(txyz.lring);
   free(txyz.ianz);
   free(txyz.iaton);
   free(txyz.iatclr);
   free(txyz.iresid);
   free(txyz.ixp);
   free(txyz.iyp);
   free(txyz.iconn);
   free(txyz.inat);
   free(txyz.ityp);
   free(txyz.ipdbt);
}

void FreeZmt(tzmt,tstoc,tbox1,tbox2,tbox3,tbox4,tbox5)
ZMSTRU tzmt;
STOCSTRU tstoc;
QBOXSTRU *tbox1,*tbox2,*tbox3,*tbox4,*tbox5;
{
   free(tzmt.bl);
   free(tzmt.ibl);
   free(tzmt.alph);
   free(tzmt.ialph);
   free(tzmt.bet);
   free(tzmt.ibet);
   free(tzmt.imap);
   free(tzmt.ianz);
   free(tzmt.iz);
   free(tstoc.cstoc);
   free(tstoc.czstoc);
   free(tstoc.astoc);
   free(tstoc.bstoc);
   free(tstoc.ianstc);
   free(tbox1);
   free(tbox2);
   free(tbox3);
   free(tbox4);
   free(tbox5);
}

#if defined(VMS) || defined(UNDERSC)
void allcoo(ZSizep,first)
#else
#ifdef CRAY
void ALLCOO(ZSizep,first)
#else
void allcoo_(ZSizep,first)
#endif
#endif
int *ZSizep;
int *first;
{
   int memstat;
   double d;
   int i;
   short int j;
   int ZSize;

   memstat = 1;
   if (*first) {
        if (*first == 1) {
	   ZSize = NUMAT;
	} else {
	   ZSize = *ZSizep;
	}
   } else {
	ZSize = *xyzp->mxnat + *ZSizep;
	TMPxyz = *xyzp;
   }

   if ((xyzp->coo = (double *) malloc((sizeof d)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->rzp = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->qat = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->isurf = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->icont = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->lwrit = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->lring = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->ianz = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->iaton = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->iatclr = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->iresid = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->ixp = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->iyp = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->iconn = (int *) malloc((sizeof i)*ZSize*(MXCON+1))) == NULL) {
	memstat = 0;
   }

   if ((xyzp->inat = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->ityp = (short int *) malloc((sizeof j)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzp->ipdbt = (short int *) malloc((sizeof j)*ZSize)) == NULL) {
	memstat = 0;
   }

   if (ZSize > dptsiz) {
	if ((dptptr = (DepthIndex *) malloc((sizeof dptdemo)*ZSize)) == NULL) {
	   memstat = 0;
	} else {
	   dptsiz = ZSize;
	}
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory allcoo\n");
	if (!*first) *xyzp = TMPxyz;
   } else {
	if (*first) {
	   xyzp->iatoms = xyz.iatoms;
	   xyzp->ncont = xyz.ncont;
	   xyzp->mxnat = xyz.mxnat;
	   for (i=0; i < ZSize; i++) {
		xyzp->qat[i] = 0.0;
		xyzp->ianz[i] = 0;
		xyzp->ityp[i] = 0;
		xyzp->iaton[i] = 0;
		xyzp->iatclr[i] = 1;
		xyzp->iresid[i] = 0;
		xyzp->ipdbt[i] = 0;
		xyzp->lring[i] = 0;
	   }
	} else {
	   for (i=0; i < *xyzp->iatoms; i++) {
	   	for (j=0; j<3; j++) xyzp->coo[i*3+j] = TMPxyz.coo[i*3+j];
		xyzp->qat[i] = TMPxyz.qat[i];
		xyzp->ianz[i] = TMPxyz.ianz[i];
		xyzp->iaton[i] = TMPxyz.iaton[i];
		xyzp->iatclr[i] = TMPxyz.iatclr[i];
		xyzp->iresid[i] = TMPxyz.iresid[i];
		xyzp->ityp[i] = TMPxyz.ityp[i];
		xyzp->ipdbt[i] = TMPxyz.ipdbt[i];
		xyzp->lring[i] = TMPxyz.lring[i];
		xyzp->isurf[i] = TMPxyz.isurf[i];
		for (j=0; j<MXCON; j++)
		   xyzp->iconn[i*(MXCON+1)+j] = TMPxyz.iconn[i*(MXCON+1)+j];
	   }
	   if (TMPxyz.mxorg) FreeCoo(TMPxyz);
	}
	xyzp->mxorg = 1;
	*(xyzp->mxnat) = ZSize;
   }
}

int allConf(xyzc,ZSize)
double **xyzc;
int ZSize;
{
   int memstat;
   double d;

   memstat = 1;

   if ((*xyzc = (double *) malloc((sizeof d)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory AllConf\n");
	return(0);
   }

   return(1);
}

int allFConf(xyzc,ZSize)
float **xyzc;
int ZSize;
{
   int memstat;
   float f;

   memstat = 1;

   if ((*xyzc = (float *) malloc((sizeof f)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory AllFConf\n");
	return(0);
   }

   return(1);
}

#if defined(VMS) || defined(UNDERSC)
void almgrd()
#else
#ifdef CRAY
void ALMGRD()
#else
void almgrd_()
#endif
#endif
{
   int memstat;
   double d;
   int ZSize;

   if (*mgrd.mx3d >= *sgrd.mx3d) return;

   ZSize = *sgrd.mx3d;
   memstat = 1;

   TMPmgrd = mgrd;

   if ((mgrd.fmap = (double *) malloc((sizeof d)*ZSize*ZSize*ZSize)) == NULL) {
	memstat = 0;
   }

   if (!memstat) {
	fprintf(stderr,"Out of memory almgrd\n");
	mgrd = TMPmgrd;
   } else {
	if (TMPmgrd.mxorg) {
	   free(TMPmgrd.fmap);
	}
	mgrd.mxorg = 1;
	*mgrd.mx3d = ZSize;
   }
}

void EditCOL()
{
   int i;
   XColor exact_def;
   
   ECOLup = 1;

   ECOLwin = CreateWindow("Color Editor","-0+0",ECOLWINW,ECOLWINH,
	 		 infobg,infofg,(Window)0);
   XSelectInput(display, ECOLwin, 
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask 
		| ButtonMotionMask | LeaveWindowMask | EnterWindowMask);
   XMapWindow(display,ECOLwin);

   WinObj[25].win = &ECOLwin;
   WinObj[25].subwin = NULL;
   WinObj[25].butarr = butecol;
   WinObj[25].numbut = 1;
   WinObj[25].winup = &ECOLup;
   WinObj[25].redraw = RedrawECOL;

   DefBut(&butecol[0], ECOLwin, 100, 140, 50, 23,
	"Close", infobg, -15);

   for (i=0; i<3; i++) {
	ecolwn[i] = 70535; ecolwpos[i] = 0;
	DefScroll(&ecolscr[i],ECOLwin,20+i*40,30,20,100,&ecolwn[i],&ecolwpos[i],5000,NULL);
   }

   exact_def.pixel = colors[activecolor];
   XQueryColor(display, cmap, &exact_def);
   
   ecolwpos[0] = 65535 - exact_def.red;
   ecolwpos[1] = 65535 - exact_def.green;
   ecolwpos[2] = 65535 - exact_def.blue;
 
}

void RedrawECOL()
{
   int i;

   if (!ECOLup) return;

   butje(ECOLwin,0,0,ECOLWINW,ECOLWINH,4,0,-15,1,None,0,0,0,0);
   ULineString(ECOLwin,"Red",20,20);
   ULineString(ECOLwin,"Green",60,20);
   ULineString(ECOLwin,"Blue",100,20);
   for (i=0; i<3; i++) RedrawScroll(&ecolscr[i]);
   XSetForeground(display, gc, colors[activecolor] );
   XFillRectangle(display, ECOLwin, gc, 140, 30, 100, 100);

   DrwBut(&butecol[0]);

}

void SetPalCol(updateshades)
int updateshades;
{
   XColor exact_def;
   int r,g,b;

   r = (65535 - ecolwpos[0]);
   g = (65535 - ecolwpos[1]);
   b = (65535 - ecolwpos[2]);
   exact_def.red = (unsigned short) r;
   exact_def.green = (unsigned short) g;
   exact_def.blue = (unsigned short) b;

   XFreeColors(display, cmap,&colors[activecolor],1,0);

   if (XAllocColor(display, cmap, &exact_def) ) {
	colors[activecolor] = exact_def.pixel;
	colorr[activecolor] = exact_def.red;
	colorg[activecolor] = exact_def.green;
	colorb[activecolor] = exact_def.blue;
   }
   if (updateshades) {
	ParseBasicColor(activecolor,0);
#if defined(VMS) || defined(UNDERSC)
	wrtres();
#else
#ifdef CRAY
	WRTRES();
#else
	wrtres_();
#endif
#endif
   }
   RedrawECOL();
}

#if defined(VMS) || defined(UNDERSC)
void wrtres()
#else
#ifdef CRAY
void WRTRES()
#else
void wrtres_()
#endif
#endif
{
   int i;
   unsigned short r,g,b;
   char wfile[500];
   char *hm;
   FILE *out;

#ifdef __CYGWIN__
   strcpy(wfile,".moldenrc");
#else
   hm = getenv("HOME");
   if (hm == NULL) return;
   strcpy(wfile,hm);
   strcat(wfile,"/.moldenrc");
#endif

   out = fopen(wfile,"w");
   if (out != NULL) {
	for (i=1; i<99; i++) {
	   fprintf(out,"%s %d %f\n",elements[i],elmptr->icol[i-1],
		elmptr->vdwr[i-1]);
	}
	fprintf(out,"background %d \n",IBGcolor);
	fprintf(out,"oglbackground %d \n",OBGcolor);
	fprintf(out,"backgroundmode %d \n",BGmode);
	fprintf(out,"palette ");
	for (i=1; i<15; i++) {
	   r = colorr[i] / 256; 
	   g = colorg[i] / 256;
	   b = colorb[i] / 256;
	   fprintf(out,"#%02X%02X%02X ",r,g,b);
	}
	fprintf(out,"\n");
	if (*ball) {
	   fprintf(out,"newrot\n");
	} else {
	   fprintf(out,"oldrot\n");
	}
	if (DelayRemember && *ideltm) {
	   fprintf(out,"delaytime %d\n",*ideltm);
	}
	if (*igffrm != 1) {
	   fprintf(out,"snapformat %d\n",*igffrm);
	}
	   
   }
   fclose(out);
}

void UpdateDPT()
{
   double i;

   *uscl = (double) (5.0*(double) dptwpos[0] / 200.0);
   if (*uscl <= 0.0) *uscl = 0.01;

   update_struct();
   
}


void InitDPT()
{
   int i;
   
   DPTup = 1;

   DPTwin = CreateWindow("Depth Editor","-0+0",ECOLWINW,ECOLWINH,
	 		 infobg,infofg,(Window)0);
   XSelectInput(display, DPTwin, 
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask 
		| ButtonMotionMask | LeaveWindowMask | EnterWindowMask);
   XMapWindow(display,DPTwin);

   WinObj[23].win = &DPTwin;
   WinObj[23].subwin = NULL;
   WinObj[23].butarr = butdpt;
   WinObj[23].numbut = 2;
   WinObj[23].winup = &DPTup;
   WinObj[23].redraw = RedrawDPT;

   DefBut(&butdpt[0], DPTwin, 100, 140, 50, 23,
	"Close", infobg, -15);

   DefBut(&butdpt[1], DPTwin, 100, 10, 120, 23,
	"Max. Linewdith", infobg, -15);

   for (i=0; i<1; i++) {
	dptwn[i] = 240; dptwpos[i] = 100;
	DefScroll(&dptscr[i],DPTwin,20+i*40,30,20,100,&dptwn[i],&dptwpos[i],40,UpdateDPT);
   }

}

void RedrawDPT()
{
   int i;

   if (!DPTup) return;

   butje(DPTwin,0,0,ECOLWINW,ECOLWINH,4,0,-15,1,None,0,0,0,0);
   ULineString(DPTwin,"Shade Depth",20,20);
   for (i=0; i<1; i++) RedrawScroll(&dptscr[i]);

   DrwBut(&butdpt[0]);
   DrwBut(&butdpt[1]);

}

void WriteCML()
{
  int i;
  char wfile[500];
  FILE *out;

  strcpy(wfile,"molecule.cml");

  out = fopen(wfile,"w");
  if (out != NULL) {
	fprintf(out,"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
	fprintf(out,"<!DOCTYPE molecule SYSTEM \"cml.dtd\" [\n");
	fprintf(out,"<!ATTLIST list convention CDATA #IMPLIED>\n");
	fprintf(out,"]>\n");

	fprintf(out,"<molecule id=\"mol\">\n");
	fprintf(out,"  <atomArray>\n");

        fprintf(out,"    <stringArray builtin=\"elementType\">\n");
	for (i=0; i<*xyzp->iatoms; i++)
	   fprintf(out,"%s ",elements[xyzp->ianz[i]]);
	fprintf(out,"\n");
	fprintf(out,"    </stringArray>\n");

	fprintf(out,"    <floatArray builtin=\"x3\">\n");
	fprintf(out,"      ");
	for (i=0; i<*xyzp->iatoms; i++)
	   fprintf(out,"%f ",xyzp->coo[i*3]*toangs);
	fprintf(out,"\n");
	fprintf(out,"    </floatArray>\n");

	fprintf(out,"    <floatArray builtin=\"y3\">\n");
	fprintf(out,"      ");
	for (i=0; i<*xyzp->iatoms; i++)
	   fprintf(out,"%f ",xyzp->coo[i*3+1]*toangs);
	fprintf(out,"\n");
	fprintf(out,"    </floatArray>\n");

	fprintf(out,"    <floatArray builtin=\"z3\">\n");
	fprintf(out,"      ");
	for (i=0; i<*xyzp->iatoms; i++)
	   fprintf(out,"%f ",xyzp->coo[i*3+2]*toangs);
	fprintf(out,"\n");
	fprintf(out,"    </floatArray>\n");

	fprintf(out,"  </atomArray>\n");
	fprintf(out,"</molecule>\n");

	fclose(out);
  }
}

void InitMAP()
{
  int i;
   
  MAPup = 1;

  MAPwin = CreateWindow("Mapped Surface","-0+0",MAPWINW,MAPWINH,
	 		 infobg,infofg,(Window)0);
  XSelectInput(display, MAPwin, EnterWindowMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask);
  XMapWindow(display,MAPwin);

  WinObj[27].win = &MAPwin;
  WinObj[27].subwin = NULL;
  WinObj[27].butarr = mapbut;
  WinObj[27].numbut = NBUTSM;
  WinObj[27].winup = &MAPup;
  WinObj[27].redraw = RedrawMAP;

  DefBut(&mapbut[0], MAPwin, 125, 355, 50, 23,
	"Apply", infobg, -15);

  DefBut(&mapbut[1], MAPwin, 375, 355, 50, 23,
	"Cancel", infobg, -15);

  DefBut(&mapbut[2], MAPwin, 370, 40, 120, 23, "wrlfile", infobg, 0);
  mapbut[2].str = mapopts[*imapopt];

  DefBut(&mapbut[3], MAPwin, 370, 70, 120, 23, "output", infobg, 0);
  mapbut[3].str = viropts[iviropt];

  DefBut(&mapbut[4], MAPwin, 390, 180, 15, 15, "", infobg, 0);
  DefBut(&mapbut[5], MAPwin, 390, 200, 15, 15, "", infobg, 0);
  DefBut(&mapbut[6], MAPwin, 20, 40, 70, 23, "Map file:", infobg, 0);

  if (*icpsa) TogDown(&mapbut[4]);
  if (*idtpsa) TogDown(&mapbut[5]);

  qboxstr(&qboxes[QMFILE],&MAPwin,0,0,190,15,40, 
	350,QBOXHIGH,2,"                 ","0.0",SUBLEN1,QSTRING,2000,0,dummyproc);
  strcp(mfile,qboxes[QMFILE].str,SUBLEN1);
  TrmStr(&qboxes[QMFILE]);
  qboxes[QMFILE].curpos = strlen(qboxes[QMFILE].str);

  qboxstr(&qboxes[QVFILE],&MAPwin,0,0,190,15,70, 
	350,QBOXHIGH,2,"VRML/OpenGL file:","0.0",SUBLEN1,QSTRING,2000,0,dummyproc);
  if (*ivtwo >= 3) {
	strcp(oglfile,qboxes[QVFILE].str,SUBLEN1);
  } else {
	strcp(vfile,qboxes[QVFILE].str,SUBLEN1);
  }
  TrmStr(&qboxes[QVFILE]);
  qboxes[QVFILE].curpos = strlen(qboxes[QVFILE].str);

  if (*ipsi) {
	qboxstr(&qboxes[QCNTVAL],&MAPwin,0,0,190,15,MAPOFFY, 
	250,QBOXHIGH,2,"Contour Value    ","0.1",12,QREAL,2000,-1,dummyproc);
  } else {
	qboxstr(&qboxes[QCNTVAL],&MAPwin,0,0,190,15,MAPOFFY, 
	250,QBOXHIGH,2,"Contour Value    ","0.02",12,QREAL,2000,-1,dummyproc);
  }
  sprintf(qboxes[QCNTVAL].str,"%f", cntval);
  qboxes[QCNTVAL].curpos = strlen(qboxes[QCNTVAL].str);

  for (i=0; i<5; i++) {
	qboxstr(&qboxes[QCOLVAL1+i],&MAPwin,0,0,190,38,MAPOFFY+60+i*30, 
		180,QBOXHIGH,2,mapstr[i],"0.0",12,QREAL,2000,-1,dummyproc);
	qboxes[QCOLVAL1+i].dflt = &mapval[i];
	sprintf(qboxes[QCOLVAL1+i].str,"%f",mapval[i]);
	qboxes[QCOLVAL1+i].curpos = strlen(qboxes[QCOLVAL1+i].str);
  }

  qboxstr(&qboxes[QPOLVAL1],&MAPwin,0,0,190,MAPOFFX+140,MAPOFFY, 
	110,QBOXHIGH,2,"<","0.001",12,QREAL,2000,-1,dummyproc);
  sprintf(qboxes[QPOLVAL1].str,"%f", *pol);
  qboxes[QPOLVAL1].curpos = strlen(qboxes[QPOLVAL1].str);

  qboxstr(&qboxes[QPOLVAL2],&MAPwin,0,0,190,MAPOFFX+250,MAPOFFY, 
	105,QBOXHIGH,2,">","0.001",12,QREAL,2000,-1,dummyproc);
  sprintf(qboxes[QPOLVAL2].str,"%f", *pol2);
  qboxes[QPOLVAL2].curpos = strlen(qboxes[QPOLVAL2].str);

  qboxes[QMFILE].active = 1;
}

void RedrawMAP()
{
   int i;

   if (!MAPup) return;

   butje(MAPwin,0,0,MAPWINW,MAPWINH,4,0,-15,1,None,0,0,0,0);

   ULineString(MAPwin,"Select Types:",373,25);
   LineString(MAPwin,"Apolar potential range (for PSA):",280,120);
   ULineString(MAPwin,"Color         Elec. potential:",38,182);
   LineString(MAPwin,"Mark PSA        ",280,195);
   LineString(MAPwin,"Incl. Topol. PSA",280,215);

/*
   XSetForeground(display, gc, colors[activecolor] );
   XFillRectangle(display, MAPwin, gc, 140, 30, 100, 100);
*/

   for (i=0; i<NBUTSM; i++) DrwBut(&mapbut[i]);
   for (i=0; i<8; i++) PromptBox(&qboxes[QVFILE+i]);
   PromptBox(&qboxes[QPOLVAL1]); 
   PromptBox(&qboxes[QPOLVAL2]); 

}

int ButtonsMAP(i)
int i;
{
   LSSTRU List;
   int j;

   switch(i) {
   case 0:
	*Sinct = 600;
	cpstr(qboxes[QCNTVAL].str,Sstr,strlen(qboxes[QCNTVAL].str));
	*Snstr = strlen(qboxes[QCNTVAL].str);
	cntval = atof(qboxes[QCNTVAL].str);
	*pol = atof(qboxes[QPOLVAL1].str);
	*pol2 = atof(qboxes[QPOLVAL2].str);
	for (j=0; j<5; j++) mapval[j] = atof(qboxes[QCOLVAL1+j].str);
	if (iviropt == 0) *ivtwo = 1;
	if (iviropt == 1) *ivtwo = 3;
	if (iviropt == 2) *ivtwo = 4;
	cpstr(qboxes[QMFILE].str,mfile,SUBLEN1);
	if (iviropt == 1) {
	    cpstr(qboxes[QVFILE].str,oglfile,SUBLEN1);
        } else {
	    cpstr(qboxes[QVFILE].str,vfile,SUBLEN1);
	}
	XDestroyWindow(display,MAPwin);MAPup = 0;
	*mapit = 1;
	return(1);
	break;
   case 1:
	XDestroyWindow(display,MAPwin);MAPup = 0;
	break;
   case 2: List.list = mapopts; List.nents = 2;
	   if (DoPopUp(MAPwin,mapbut[2].x+60,mapbut[2].y+BUTTH,
		&List,imapopt,1) == -1) break;
	   mapbut[2].str = mapopts[*imapopt];
	break;
   case 3: List.list = viropts; List.nents = 3;
	   if (DoPopUp(MAPwin,mapbut[3].x+60,mapbut[3].y+BUTTH,
		&List,&iviropt,1) == -1) break;
	   mapbut[3].str = viropts[iviropt];
	   if (iviropt >= 1) {
		strcp(oglfile,qboxes[QVFILE].str,SUBLEN1);
	   } else {
		strcp(vfile,qboxes[QVFILE].str,SUBLEN1);
	   }
	   TrmStr(&qboxes[QVFILE]);
	   qboxes[QVFILE].curpos = strlen(qboxes[QVFILE].str);
	   RedrawMAP();
	break;
   case 4: 
	if (*icpsa) {
	   *icpsa = 0;
	   TogUp(&mapbut[4]);
	} else {
	   *icpsa = 1;
	   TogDown(&mapbut[4]);
	}
	break;
   case 5: 
	if (*idtpsa) {
	   *idtpsa = 0;
	   TogUp(&mapbut[5]);
	} else {
	   *idtpsa = 1;
	   TogDown(&mapbut[5]);
	}
	break;
   case 6: 
	gsel.qbrfile = 1;
	gsel.subopt = 1;
	FileSelectList(&gsel);
	break;
   }
   return(0);
}

void InitVIR()
{
   
  VIRup = 1;

  VIRwin = CreateWindow("VR file","-0+0",VIRWINW,VIRWINH,
	 		 infobg,infofg,(Window)0);
  XSelectInput(display, VIRwin, EnterWindowMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask);
  XMapWindow(display,VIRwin);

  WinObj[28].win = &VIRwin;
  WinObj[28].subwin = NULL;
  WinObj[28].butarr = virbut;
  WinObj[28].numbut = 2;
  WinObj[28].winup = &VIRup;
  WinObj[28].redraw = RedrawVIR;

  DefBut(&virbut[0], VIRwin, 125, 110, 50, 23,
	"Apply", infobg, -15);

  DefBut(&virbut[1], VIRwin, 375, 110, 50, 23,
	"Cancel", infobg, -15);

  qboxstr(&qboxes[QSVFILE],&VIRwin,0,0,190,15,30, 
	450,QBOXHIGH,2,"Output file:","0.0",SUBLEN1,QSTRING,2000,0,dummyproc);

  switch(*ivtwo) {
	case 0:
	case 1:
		strcp(vfile,qboxes[QSVFILE].str,SUBLEN1);
		break;
	case 2:
		strcp(povfile,qboxes[QSVFILE].str,SUBLEN1);
		break;
	case 3:
		strcp(oglfile,qboxes[QSVFILE].str,SUBLEN1);
		break;
  }
  TrmStr(&qboxes[QSVFILE]);
  qboxes[QSVFILE].curpos = strlen(qboxes[QSVFILE].str);

  if (*ipsi) {
	qboxstr(&qboxes[QSCNT],&VIRwin,0,0,190,15,70, 
	250,QBOXHIGH,2,"Contour Value    ","0.1",12,QREAL,2000,-1,dummyproc);
  } else {
	qboxstr(&qboxes[QSCNT],&VIRwin,0,0,190,15,70, 
	250,QBOXHIGH,2,"Contour Value    ","0.02",12,QREAL,2000,-1,dummyproc);
  }

  qboxes[QSVFILE].active = 1;
}

void RedrawVIR()
{
   int i;

   if (!VIRup) return;

   butje(VIRwin,0,0,VIRWINW,VIRWINH,4,0,-15,1,None,0,0,0,0);

   for (i=0; i<2; i++) DrwBut(&virbut[i]);
   for (i=0; i<2; i++) PromptBox(&qboxes[QSVFILE+i]);

}

int ButtonsVIR(i)
int i;
{

   switch(i) {
   case 0:
	*Sinct = 600;
	cpstr(qboxes[QSCNT].str,Sstr,strlen(qboxes[QSCNT].str));
	*Snstr = strlen(qboxes[QSCNT].str);
	switch(*ivtwo) {
	case 0:
	case 1:
		cpstr(qboxes[QSVFILE].str,vfile,SUBLEN1);
		break;
	case 2:
		cpstr(qboxes[QSVFILE].str,povfile,SUBLEN1);
		break;
	case 3:
		cpstr(qboxes[QSVFILE].str,oglfile,SUBLEN1);
		break;
	}
	XDestroyWindow(display,VIRwin);VIRup = 0;
	return(1);
	break;
   case 1:
	XDestroyWindow(display,VIRwin);VIRup = 0;
	break;
   }
   return(0);
}

#define MAXONIERR 70
static char ONIerr[MAXONIERR];

void CreateONI()
{
  int i;
   
  ONIup = 1;

  ONIwin = CreateWindow("Oniom","-80-80",
                         OBOXWIDE,OBOXHIGH,infobg,infofg,(Window)0);
  subONI = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],ONIwin);
  XSelectInput(display, ONIwin,
        ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask | LeaveWindowMask);

  XMapWindow(display,ONIwin);

  WinObj[38].win = &ONIwin;
  WinObj[38].subwin = &subONI;
  WinObj[38].butarr = onbut;
  WinObj[38].numbut = NBUTSO;
  WinObj[38].winup = &ONIup;
  WinObj[38].redraw = RedrawONI;

  DefBut(&onbut[OMETHH], ONIwin, OBOXOFFX, 30,         OBOXBLEN, 23,
        "Method", infobg, -15);
  onbut[OMETHH].explstr = "Method for the High quality layer";

  DefBut(&onbut[OBASSH], ONIwin, OBOXOFFX, 30+BUTTN,   OBOXBLEN, 23,
        "Basis Set", infobg, -15);
  onbut[OBASSH].explstr = "Basis Set for the High quality layer\nIf applicable";

  DefBut(&onbut[OCHARH], ONIwin, OBOXOFFX, 30+2*BUTTN, OBOXBLEN, 23,
        "Charge", infobg, -15);
  onbut[OCHARH].explstr = "Total charge of the High quality layer";

  DefBut(&onbut[OMULTH], ONIwin, OBOXOFFX, 30+3*BUTTN, OBOXBLEN, 23,
        "Multiplicity", infobg, -15);
  onbut[OMULTH].explstr = "Spin multiplicity of the High quality layer";

  DefBut(&onbut[OALLH],  ONIwin, OBOXOFFX, 30+4*BUTTN, OBOXBLEN, 23, 
        "All H", infobg, -ONIHCOL);
  onbut[OALLH].explstr = "All atoms are assigned to the High quality layer";

  DefBut(&onbut[OSELH],  ONIwin, OBOXOFFX, 35+6*BUTTN, OBOXBLEN, 23, 
        "Apply H", infobg, -ONIHCOL);
  onbut[OSELH].explstr = "Assign currently selected atoms\nto the High quality layer";


  DefBut(&onbut[OMETHM], ONIwin, OBOXOFFX+110, 30,         OBOXBLEN, 23,
        "Method", infobg, -15);
  onbut[OMETHM].explstr = "Method for the Medium quality layer";

  DefBut(&onbut[OBASSM], ONIwin, OBOXOFFX+110, 30+BUTTN,   OBOXBLEN, 23,
        "Basis Set", infobg, -15);
  onbut[OBASSM].explstr = "Basis Set for the Medium quality layer\nIf applicable";

  DefBut(&onbut[OCHARM], ONIwin, OBOXOFFX+110, 30+2*BUTTN, OBOXBLEN, 23,
        "Charge", infobg, -15);
  onbut[OCHARM].explstr = "Total charge of the Medium quality layer";

  DefBut(&onbut[OMULTM], ONIwin, OBOXOFFX+110, 30+3*BUTTN, OBOXBLEN, 23,
        "Multiplicity", infobg, -15);
  onbut[OMULTM].explstr = "Spin multiplicity of the Medium quality layer";

  DefBut(&onbut[OALLM],  ONIwin, OBOXOFFX+110, 30+4*BUTTN, OBOXBLEN, 23,
        "All M", infobg,-ONIMCOL);
  onbut[OALLM].explstr = "All atoms are assigned to\nthe Medium quality layer";

  DefBut(&onbut[OSELM],  ONIwin, OBOXOFFX+110, 35+6*BUTTN, OBOXBLEN, 23,
        "Apply M", infobg,-ONIMCOL);
  onbut[OSELM].explstr = "Assign currently selected atoms\nto the Medium quality layer";


  DefBut(&onbut[OMETHL], ONIwin, OBOXOFFX+220, 30,         OBOXBLEN, 23,
        "Method", infobg, -15);
  onbut[OMETHL].explstr = "Method for the Low quality layer";

  DefBut(&onbut[OBASSL], ONIwin, OBOXOFFX+220, 30+BUTTN,   OBOXBLEN, 23,
        "Basis Set", infobg, -15);
  onbut[OBASSL].explstr = "Basis Set for the Low quality layer\nIf applicable";

  DefBut(&onbut[OCHARL], ONIwin, OBOXOFFX+220, 30+2*BUTTN, OBOXBLEN, 23,
        "Charge", infobg, -15);
  onbut[OCHARL].explstr = "Total charge of the Low quality layer";

  DefBut(&onbut[OMULTL], ONIwin, OBOXOFFX+220, 30+3*BUTTN, OBOXBLEN, 23,
        "Multiplicity", infobg, -15);
  onbut[OMULTL].explstr = "Spin multiplicity of the Low quality layer";

  DefBut(&onbut[OALLL],  ONIwin, OBOXOFFX+220, 30+4*BUTTN, OBOXBLEN, 23,
        "All L", infobg,-ONILCOL);
  onbut[OALLL].explstr = "All atoms are assigned to\nthe Low quality layer";

  DefBut(&onbut[OSELL],  ONIwin, OBOXOFFX+220, 35+6*BUTTN, OBOXBLEN, 23,
        "Apply L", infobg,-ONILCOL);
  onbut[OSELL].explstr = "Assign currently selected atoms\nto the Low quality layer";


  DefBut(&onbut[OSEL],   ONIwin, OBOXOFFX,     35+5*BUTTN, OBOXBLEN+20, 23,
        "Select by pointer", infobg, -15);
  onbut[OSEL].explstr = "Select atoms to be assigned to layer\nSelect: Left mouse button+drag+release";

  DefBut(&onbut[OUSEL],  ONIwin, OBOXOFFX+125, 35+5*BUTTN, OBOXBLEN-20, 23,
        "DeSelect", infobg,-15);
  onbut[OUSEL].explstr = "Deselect atoms to be assigned to layer\nDeselect: Left mouse button+drag+release";

  DefBut(&onbut[OSELR],  ONIwin, OBOXOFFX+220, 35+5*BUTTN, OBOXBLEN, 23,
        "Select residue", infobg,-15);
  onbut[OSELR].explstr = "Select residue to be assigned to layer\nSelect: click residue with left mouse button";
  if (*ipdbon == 0) ActBut(&onbut[OSELR],0);


  DefBut(&onbut[OCOLO],  ONIwin, OBOXOFFX+10, 35+10*BUTTN, 15, 15,
        " ", infobg,-15);
  onbut[OCOLO].explstr = "Use different colors for each layer";

  DefBut(&onbut[OCLOS],  ONIwin, OBOXOFFX+110, 35+11*BUTTN, OBOXBLEN, 23,
        "Close", infobg,-15);

  DefBut(&onbut[OAMBCH], ONIwin, OBOXOFFX+120, 35+10*BUTTN, 15, 15,
        " ", infobg,-15);
  onbut[OAMBCH].explstr = "Write amber charges and atom types\nas part of the atom label";

  onbut[OMETHH].str = mopt[imopth];
  onbut[OBASSH].str = bopt[ibopth];
  onbut[OCHARH].str = copt[jobcom->icopth+3];
  onbut[OMULTH].str = spopt[jobcom->ispopth-1];
  onbut[OMETHL].str = mopt[imoptl];
  onbut[OBASSL].str = bopt[iboptl];
  onbut[OCHARL].str = copt[jobcom->icoptl+3];
  onbut[OMULTL].str = spopt[jobcom->ispoptl-1];
  onbut[OMETHM].str = mopt[imoptm];
  onbut[OBASSM].str = bopt[iboptm];
  onbut[OCHARM].str = copt[jobcom->icoptm+3];
  onbut[OMULTM].str = spopt[jobcom->ispoptm-1];

  if (*fftyp != 3) {
     for (i=0;i<*xyzp->iatoms;i++) {
	xyzp->ityp[i] = 0;
     }
  }

  ParseLine();

  if (*atcol) {
	TogUp(&onbut[OCOLO]);
  } else {
	TogDown(&onbut[OCOLO]);
  }

  if (*ambchg) {
	TogDown(&onbut[OAMBCH]);
  } else {
	TogUp(&onbut[OAMBCH]);
  }
}

void RedrawONI()
{
  int i;

  butje(ONIwin,0,0,OBOXWIDE,OBOXHIGH,4,0,0,1,None,0,0,0,0);
  ULineString(ONIwin,"High",OBOXOFFX+30,21);
  ULineString(ONIwin,"Medium",OBOXOFFX+140,21);
  ULineString(ONIwin,"Low",OBOXOFFX+250,21);
  ULineString(ONIwin,"Color by Layer",OBOXOFFX+30,46+10*BUTTN);
  ULineString(ONIwin,"write amber charges",OBOXOFFX+140,46+10*BUTTN);
  for (i=0; i<NBUTSO; i++) DrwBut(&onbut[i]);

  RedrawONIStatus();

}

int ButtonsONI(i)
int i;
{
  LSSTRU List;
  int ret=0;
  int nat;

  switch (i) {
  case OMETHH:
                List.list = mopt; List.nents = moptn;
                if (DoPopUp(ONIwin,
			onbut[OMETHH].x+OBOXBLEN/2,onbut[OMETHH].y+BUTTH,
                        &List,&imopth,1) == -1) break;
                onbut[OMETHH].str = mopt[imopth];
                break;
  case OBASSH:
                List.list = bopt; List.nents = boptn;
                if (DoPopUp(ONIwin,
			onbut[OBASSH].x+OBOXBLEN/2,onbut[OBASSH].y+BUTTH,
                        &List,&ibopth,1) == -1) break;
                onbut[OBASSH].str = bopt[ibopth];
                break;
  case OMETHL:
                List.list = mopt; List.nents = moptn;
                if (DoPopUp(ONIwin,
			onbut[OMETHL].x+OBOXBLEN/2,onbut[OMETHL].y+BUTTH,
                        &List,&imoptl,1) == -1) break;
                onbut[OMETHL].str = mopt[imoptl];
                break;
  case OBASSL:
                List.list = bopt; List.nents = boptn;
                if (DoPopUp(ONIwin,
			onbut[OBASSL].x+OBOXBLEN/2,onbut[OBASSL].y+BUTTH,
                        &List,&iboptl,1) == -1) break;
                onbut[OBASSL].str = bopt[iboptl];
                break;
  case OMETHM:
                List.list = mopt; List.nents = moptn;
                if (DoPopUp(ONIwin,
			onbut[OMETHM].x+OBOXBLEN/2,onbut[OMETHM].y+BUTTH,
                        &List,&imoptm,1) == -1) break;
                onbut[OMETHM].str = mopt[imoptm];
                break;
  case OBASSM:
                List.list = bopt; List.nents = boptn;
                if (DoPopUp(ONIwin,
			onbut[OBASSM].x+OBOXBLEN/2,onbut[OBASSM].y+BUTTH,
                        &List,&iboptm,1) == -1) break;
                onbut[OBASSM].str = bopt[iboptm];
                break;
  case OALLH:
                strcpy(ONIerr,"H level for all atoms");
                RedrawONIStatus();
                for ( i = 0; i < *xyzp->iatoms; i++ ) {
                   if (xyzp->ityp[i] >= 10000) 
			xyzp->ityp[i] -= (xyzp->ityp[i]/10000)*10000
;
                   xyzp->iatclr[i] = ONIHCOL;
                }
		ret = 1;
                break;
  case OALLM:
                strcpy(ONIerr,"M level for all atoms");
                RedrawONIStatus();
                for ( i = 0; i < *xyzp->iatoms; i++ ) {
                   if (xyzp->ityp[i] >= 20000) {
                      xyzp->ityp[i] -= 10000;
                   } else {
                      if (xyzp->ityp[i]<10000) xyzp->ityp[i] += 10000;
                   }
                   xyzp->iatclr[i] = ONIMCOL;
                }
		ret = 1;
                break;
  case OALLL:
                strcpy(ONIerr,"L level for all atoms");
                RedrawONIStatus();
                for ( i = 0; i < *xyzp->iatoms; i++ ) {
                   if (xyzp->ityp[i] < 20000) 
			xyzp->ityp[i] += (2-xyzp->ityp[i]/10000)*10000;
                   xyzp->iatclr[i] = ONILCOL;
                }
		ret = 1;
                break;
  case OSELH:
                Selecting = 0;
                nat = 0;
                for ( i = 0; i < *xyzp->iatoms; i++ ) if (xyzp->iaton[i] > 1) nat++;
                if (!nat) {
                        strcpy(ONIerr,"Invalid Selection: No atoms selected");
                        if (*ibell) XBell(display,0);
                        RedrawONIStatus();
                        return(0);
                }
                if (nat > *zmptrp->mxzat) {
                   strcpy(ONIerr,"Invalid Selection: Too many atoms selected");
                   if (*ibell) XBell(display,0);
                   RedrawONIStatus();
                   for ( i = 0; i < *xyzp->iatoms; i++ )
                        if (xyzp->iaton[i] >= 2) xyzp->iaton[i] = 1;
                   ret = 1;
                }
                else {
                   strcpy(ONIerr,"Selected atoms at H level");
                   RedrawONIStatus();
                   for ( i = 0; i < *xyzp->iatoms; i++ ) {
                        if (xyzp->iaton[i] >= 2) {
                            if (xyzp->ityp[i] >= 10000) xyzp->ityp[i] -= 
                                (xyzp->ityp[i] /10000)*10000;
                                xyzp->iatclr[i] = ONIHCOL;
                        }
                        xyzp->iaton[i] = 1;
                   }
		   ret = 1;
                }
                break;
  case OSELM:
		Selecting = 0;
		nat = 0;
		for ( i = 0; i < *xyzp->iatoms; i++ ) if (xyzp->iaton[i] > 1) nat++;
		if (!nat) {
			strcpy(ONIerr,"Invalid Selection: No atoms selected");
			if (*ibell) XBell(display,0);
			RedrawONIStatus();
			return(0);
		}
		if (nat > *zmptrp->mxzat) {
		   strcpy(ONIerr,"Invalid Selection: Too many atoms selected");
		   if (*ibell) XBell(display,0);
		   RedrawONIStatus();
		   for ( i = 0; i < *xyzp->iatoms; i++ ) 
			if (xyzp->iaton[i] >= 2) xyzp->iaton[i] = 1;
	  	   ret = 1;
		}
		else {
		   strcpy(ONIerr,"Selected atoms at M level");
		   RedrawONIStatus();
		   for ( i = 0; i < *xyzp->iatoms; i++ ) {
			if (xyzp->iaton[i] >= 2) {
				if (xyzp->ityp[i] >= 20000) {
		      		   xyzp->ityp[i] -= 10000;
		   		} else {
		   	   	   if (xyzp->ityp[i] < 10000) 
				   xyzp->ityp[i] += 10000;
		   		}
			       xyzp->iatclr[i] = ONIMCOL;
			}
			xyzp->iaton[i] = 1;
		   }
		   ret = 1;
	        }
		break;
  case OSELL:
		Selecting = 0;
		nat = 0;
		for ( i = 0; i < *xyzp->iatoms; i++ ) if (xyzp->iaton[i] > 1) nat++;
		if (!nat) {
			strcpy(ONIerr,"Invalid Selection: No atoms selected");
			if (*ibell) XBell(display,0);
			RedrawONIStatus();
			return(0);
		}
		if (nat > *zmptrp->mxzat) {

		   strcpy(ONIerr,"Invalid Selection: Too many atoms selected");
		   if (*ibell) XBell(display,0);
		   RedrawONIStatus();
		   for ( i = 0; i < *xyzp->iatoms; i++ ) 
			if (xyzp->iaton[i] >= 2) xyzp->iaton[i] = 1;
	  	   ret = 1;

		} else {

		   strcpy(ONIerr,"Selected atoms at L level");
		   RedrawONIStatus();
		   for ( i = 0; i < *xyzp->iatoms; i++ ) {
			if (xyzp->iaton[i] >= 2) {
			   if (xyzp->ityp[i] < 20000) xyzp->ityp[i] += 
                              (2-xyzp->ityp[i]/10000)*10000;
			   xyzp->iatclr[i] = ONILCOL;
			}
			xyzp->iaton[i] = 1;
		   }
		   ret = 1;

  	        }
		break;
  case OSEL:
                strcpy(ONIerr,selstr);
                RedrawONIStatus();
                DeActZME();
                Selecting = 1;
                ZoomEnable = True;Select = True;
                break;
  case OUSEL:
                strcpy(ONIerr,dselstr);
                RedrawONIStatus();
                ZoomEnable = True;Select = False;
                break;
  case OSELR:
		if (*ipdbon) {
		   strcpy(ONIerr,"Pick a residue");
		   RedrawONIStatus();
		   bflag = 1; bretval = 565;
		   XDefineCursor(display,win,AtomCursor);
		} else {
		   ActBut(&onbut[OSELR],0);
		}
                break;
  case OCOLO:
		TogBut(&cbut[BATCOL]);
		TogBut(&onbut[OCOLO]);
		if (*atcol) *atcol = 0;
		else *atcol = 1;
                *Sinct = 400;*Sincp = 0; 
		ret = 1;
                break;
  case OCLOS:
	        XDestroyWindow(display,ONIwin);ONIup = 0;
		return(0);
                break;
  case OCHARH:
		List.list = copt; List.nents = 7;
		if (DoPopUp(ONIwin,
			onbut[OCHARH].x+OBOXBLEN/2,onbut[OCHARH].y+BUTTH,
			&List,&jobcom->icopth,1) == -1) break;
		jobcom->icopth = jobcom->icopth - 3;
		onbut[OCHARH].str = copt[jobcom->icopth+3];
		break;
  case OMULTH:
		List.list = spopt; List.nents = 8;
		if (DoPopUp(ONIwin,
			onbut[OMULTH].x+OBOXBLEN/2,onbut[OMULTH].y+BUTTH,
			&List,&jobcom->ispopth,1) == -1) break;
		jobcom->ispopth = jobcom->ispopth + 1;
		onbut[OMULTH].str = spopt[jobcom->ispopth-1];
		break;
  case OCHARM:
		List.list = copt; List.nents = 7;
		if (DoPopUp(ONIwin,
			onbut[OCHARM].x+OBOXBLEN/2,onbut[OCHARM].y+BUTTH,
			&List,&jobcom->icoptm,1) == -1) break;
		jobcom->icoptm = jobcom->icoptm - 3;
		onbut[OCHARM].str = copt[jobcom->icoptm+3];
		break;
  case OMULTM:
		List.list = spopt; List.nents = 8;
		if (DoPopUp(ONIwin,
			onbut[OMULTM].x+OBOXBLEN/2,onbut[OMULTM].y+BUTTH,
			&List,&jobcom->ispoptm,1) == -1) break;
		jobcom->ispoptm = jobcom->ispoptm + 1;
		onbut[OMULTM].str = spopt[jobcom->ispoptm-1];
		break;
  case OCHARL:
		List.list = copt; List.nents = 7;
		if (DoPopUp(ONIwin,
			onbut[OCHARL].x+OBOXBLEN/2,onbut[OCHARL].y+BUTTH,
			&List,&jobcom->icoptl,1) == -1) break;
		jobcom->icoptl = jobcom->icoptl - 3;
		onbut[OCHARL].str = copt[jobcom->icoptl+3];
		break;
  case OMULTL:
		List.list = spopt; List.nents = 8;
		if (DoPopUp(ONIwin,
			onbut[OMULTL].x+OBOXBLEN/2,onbut[OMULTL].y+BUTTH,
			&List,&jobcom->ispoptl,1) == -1) break;
		jobcom->ispoptl = jobcom->ispoptl + 1;
		onbut[OMULTL].str = spopt[jobcom->ispoptl-1];
		break;
  case OAMBCH:
		TogBut(&onbut[OAMBCH]);
		if (*ambchg) *ambchg = 0;
		else *ambchg = 1;
		break;
  default: break;
  }

  if (SUBup) {
     RedrawSUB();
     ParseLine();
     PromptBox(&qboxes[QGLIN1]);
     PromptBox(&qboxes[QGLIN2]);
  }
  RedrawONI();

  update_sel = 1;

  if (ret) {
     return(1);
  } else {
     return(0);
  }

}


void RedrawONIStatus()
{

 if (!ONIup) return;

 butje(ONIwin,0,220,OBOXWIDE-1,40,1,0,0,1,None,0,0,0,0);
 butje(ONIwin,ZMEZOffx,220+10,OBOXWIDE-2*ZMEZOffx,20,2,0,2,0,None,0,0,0,0);
 XSetForeground(display, gc, infobg);
 XDrawString(display,ONIwin,gc,ZMEZOffx+5,220+24,ONIerr,strlen(ONIerr));
}


void DeActOButs()
{
  ActBut(&onbut[OMETHL],2);
  ActBut(&onbut[OBASSL],2);
  ActBut(&onbut[OALLL],2);
  ActBut(&onbut[OSELL],2);
}

void ActOButs()
{
  ActBut(&onbut[OMETHL],1);
  ActBut(&onbut[OBASSL],1);
  ActBut(&onbut[OALLL],1);
  ActBut(&onbut[OSELL],1);
}


void CreateFLR()
{
  int i;
   
  FLRup = 1;
  bckrig = 0;
  *icst = 1;

  FLRwin = CreateWindow("FlexRigid","-80-80",
                         FBOXWIDE,FBOXHIGH,infobg,infofg,(Window)0);
  subFLR = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],FLRwin);
  XSelectInput(display, FLRwin,
        ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask | LeaveWindowMask);

  XMapWindow(display,FLRwin);

  WinObj[39].win = &FLRwin;
  WinObj[39].subwin = &subFLR;
  WinObj[39].butarr = flrbut;
  WinObj[39].numbut = NBUTSF;
  WinObj[39].winup = &FLRup;
  WinObj[39].redraw = RedrawFLR;

  DefBut(&flrbut[FRIGD],  FLRwin, FBOXOFFX, 30, FBOXBLEN, 23, 
        "All Rigid", infobg, -FRIGCOL);
  flrbut[FRIGD].explstr = "All atoms are assigned rigid";

  DefBut(&flrbut[FSELR],  FLRwin, FBOXOFFX, 35+5*BUTTN, FBOXBLEN, 23, 
        "Selection Rigid", infobg, -FRIGCOL);
  flrbut[FSELR].explstr = "Assign currently selected atoms rigid";


  DefBut(&flrbut[FFLEX],  FLRwin, FBOXOFFX+110, 30, FBOXBLEN, 23,
        "All Flexible", infobg,-FLEXCOL);
  flrbut[FFLEX].explstr = "All atoms are assigned flexible";

  DefBut(&flrbut[FSELF],  FLRwin, FBOXOFFX+110, 35+5*BUTTN, FBOXBLEN+20, 23,
        "Selection Flexible", infobg,-FLEXCOL);
  flrbut[FSELF].explstr = "Assign currently selected atoms flexible";

  DefBut(&flrbut[FSEL],   FLRwin, FBOXOFFX,     35+2*BUTTN, FBOXBLEN+20, 23,
        "Select by pointer", infobg, -15);
  flrbut[FSEL].explstr = "Select atoms to be assigned rigid/flexible\nSelect: Left mouse button+drag+release";

  DefBut(&flrbut[FUSEL],  FLRwin, FBOXOFFX+125, 35+2*BUTTN, FBOXBLEN-20, 23,
        "DeSelect", infobg,-15);
  flrbut[FUSEL].explstr = "Deselect atoms to be assigned\nDeselect: Left mouse button+drag+release";

  DefBut(&flrbut[FSELA],  FLRwin, FBOXOFFX+220, 35+2*BUTTN, FBOXBLEN, 23,
        "Select residue", infobg,-15);
  flrbut[FSELA].explstr = "Select residue to be assigned rigid/flexible\nSelect: click residue with left mouse button";
  if (*ipdbon == 0) ActBut(&flrbut[FSELR],0);

  DefBut(&flrbut[FCONT],  FLRwin, FBOXOFFX, 35+3*BUTTN, FBOXBLEN+105, 23,
        "residue/ligand + neighbours", infobg,-15);
  flrbut[FCONT].explstr = "Select residue/ligand + neighbours \nto be assigned rigid/flexible.\nSelect: click residue with left mouse button";
  if (*ipdbon == 0) ActBut(&flrbut[FCONT],0);

  DefBut(&flrbut[FBACK],  FLRwin, FBOXOFFX, 39+6*BUTTN, 15, 15,
        " ", infobg,-15);
  flrbut[FBACK].explstr = "Backbone rigid";

  DefBut(&flrbut[FCLOS],  FLRwin, FBOXOFFX+110, 35+7*BUTTN, FBOXBLEN, 23,
        "Close", infobg,-15);

  if (bckrig) {
	TogDown(&flrbut[FBACK]);
  } else {
	TogUp(&flrbut[FBACK]);
  }

  for ( i = 0; i < *xyzp->iatoms; i++ ) {
	xyzp->isurf[i] = 1;
	xyzp->iatclr[i] = FLEXCOL;
  }
}

void RedrawFLR()
{
  int i;

  butje(FLRwin,0,0,FBOXWIDE,FBOXHIGH,4,0,0,1,None,0,0,0,0);
  ULineString(FLRwin,"Selection:",FBOXOFFX,46+1*BUTTN);
  ULineString(FLRwin,"Apply selection:",FBOXOFFX,49+4*BUTTN);
  LineString(FLRwin,"Backbone rigid",FBOXOFFX+20,49+6*BUTTN);
  for (i=0; i<NBUTSF; i++) DrwBut(&flrbut[i]);


}

int ButtonsFLR(k)
int k;
{
  LSSTRU List;
  int ret=0;
  int i,j;

  switch (k) {
  case FRIGD:
                for (i=0; i < *xyzp->iatoms; i++ ) {
		   xyzp->isurf[i] = 0;
                   xyzp->iatclr[i] = FRIGCOL;
                }
		ret = 1;
                break;
  case FFLEX:
                for ( i = 0; i < *xyzp->iatoms; i++ ) {
		   xyzp->isurf[i] = 1;
                   xyzp->iatclr[i] = FLEXCOL;
                }
		if (bckrig) {
		    for (i=0; i < calfptr->ncalf; i++ ) {
			for (j=0; j < 4; j++ ) {
			    if (calfptr->icalf[i][j] >= 0) {
				xyzp->isurf[calfptr->icalf[i][j]-1] = 0;
				xyzp->iatclr[calfptr->icalf[i][j]-1] = FRIGCOL;
			    }
			}
		    }
		}
		ret = 1;
                break;
  case FSELR:
                Selecting = 0;
                for (i=0; i<*xyzp->iatoms; i++ ) {
                        if (xyzp->iaton[i] >= 2) {
			   xyzp->isurf[i] = 0;
                           xyzp->iaton[i] = 1;
			   xyzp->iatclr[i] = FRIGCOL;
			}
                }
		ret = 1;
                break;
  case FSELF:
		Selecting = 0;
                for (i = 0;i < *xyzp->iatoms; i++ ) {
                        if (xyzp->iaton[i] >= 2) {
			   xyzp->isurf[i] = 1;
                           xyzp->iaton[i] = 1;
			   xyzp->iatclr[i] = FLEXCOL;
			}
                }
		ret = 1;
		break;
  case FSEL:
                Selecting = 1;
                ZoomEnable = True;Select = True;
                break;
  case FUSEL:
                ZoomEnable = True;Select = False;
                break;
  case FSELA:
		if (*ipdbon) {
		   bflag = 1; bretval = 565;
		   XDefineCursor(display,win,AtomCursor);
		} else {
		   ActBut(&flrbut[FSELR],0);
		}
                break;
  case FCLOS:
	        XDestroyWindow(display,FLRwin);FLRup = 0;
		return(0);
                break;
  case FBACK:
		TogBut(&flrbut[FBACK]);
		if (bckrig) bckrig = 0;
		else bckrig = 1;
		break;
  case FCONT:
		if (*ipdbon) {
		   bflag = 1; bretval = 566;
		   XDefineCursor(display,win,AtomCursor);
		} else {
		   ActBut(&flrbut[FCONT],0);
		}
		break;
  default: break;
  }

  RedrawFLR();

  update_sel = 1;

  if (ret) {
     return(1);
  } else {
     return(0);
  }

}

void calc_spectrum(int iupd) 
{

  int i, j, spnew;
  double intensity, frq, center, rel_offset;
  double (*lineshape)(double);
  double spec_mx_tmp;

  spec_mx_tmp = spec_mx;

  if (iupd && specup) {
	hwhm = atof(qboxes[QHW].str);
	freq_scale = atof(qboxes[QSSCAL].str);
	min_freq = atoi(qboxes[QMINF].str);
	max_freq = atoi(qboxes[QMAXF].str);
  }

  if (hwhm < 1.0e-10) {
    fprintf(stderr, "The specified HWHM of %f is too small.\n", hwhm);
    fprintf(stderr, "This program is exiting in calc_intensities\n");
    exit(1);
  }

  if (lorentzian) {
    lineshape = lorentz;
  }
  else {
    lineshape = gauss;
  }

  n_freqs = 1 + (max_freq - min_freq)/freq_step;

  spnew = sizeof(double)*2*n_freqs;

  if (spnew > specsize) {
     if (specsize > 0) free(out_spec);
     if ((out_spec = (double *) malloc(spnew)) == NULL) {
	fprintf(stderr, "Memory allocation error for spectrum\n");
	return;
     } else {
	specsize = spnew;
     }
  }

  for (i=0; i < n_freqs; i++) {
    intensity = 0.0;
    frq = min_freq + i*freq_step;
    for (j=0; j < *spnfrq; j++) {
      center = (double) spfrq[j]*freq_scale;
      rel_offset = (frq - center) / hwhm;
      intensity += spint[j] * lineshape(rel_offset);
    }
    out_spec[i] = intensity;
  }

  INTextr();
  if (iupd && (spec_mx_tmp != spec_mx)) spec_mx = spec_mx_tmp;

/*
  for (i=1; i < n_freqs; i++) {
     fprintf(stderr,"%d %11.6f\n",i,out_spec[i]);
  }
*/
  return;
}

void write_spectrum(char *fname, int orient, int opt) {

	specps = 1;
	spout = fopen(fname,"w");
	fprintf(spout,"%%!PS-Adobe-1.0%%\n");
	fprintf(spout,"%%%%Title: Molden\n");
	if (orient) {
	   fprintf(spout,"%%%%BoundingBox: 0 0 612 792\n");
	} else {
	   if (opt) {
	      //fprintf(spout,"%%%%BoundingBox: 40 -250 500 50\n");
	   } else {
	      fprintf(spout,"%%%%BoundingBox: 40 -550 770 50\n");
	   }
	}
	fprintf(spout,"/m { moveto } def\n");
	fprintf(spout,"/l { lineto } def\n");
	fprintf(spout,"/Helvetica-Bold findfont [ 5   0   0  5   0   0] makefont setfont\n");
	fprintf(spout,"%%%%EndProlog\n");
	fprintf(spout,"0 setgray\n");
	if (orient) {
	   fprintf(spout,"90 rotate\n");
	}
	if (opt) {
	   fprintf(spout,"1.75 1.75 scale\n");
	   fprintf(spout,"-20 280 translate\n");
	} else {
	   fprintf(spout,"1.3 2.0 scale\n");
	   fprintf(spout,"10 0 translate\n");
        }
        drwspec();
	fprintf(spout,"showpage\n");
	fclose(spout);
	specps = 0;
}

void wrjdx(filename)
    char *filename;
{
    int i,j,k,ifrq,xmax,xmin;
    double frq,yscale;
    FILE *jdxfile,*molfile,*xyzfile;
    char line[MAXCMD];
    char tline[MAXCMD];
    char *q;

    jdxfile = fopen(filename,"w");
    if (!jdxfile) {
	fprintf(stderr,"Output Error: Unable to create jdx file %s\n",filename);
	return;
    }

    yscale = 1.0 / spec_mx;
    fprintf(jdxfile,"##TITLE=molden generated spectrum\n");
    fprintf(jdxfile,"##JCAMP-DX=4.24\n");
    fprintf(jdxfile,"##DATA TYPE=INFRARED SPECTRUM\n");

    molfile = fopen("mol.mol","r");
    if (molfile) {
	fprintf(jdxfile,"##$MODELS=\n");
	fprintf(jdxfile,"<Models>\n");
	fprintf(jdxfile,"<ModelData id=\"mol\" type=\"MOL\">\n");

	while (fgets(line,MAXCMD,molfile) != NULL) {
    	   fprintf(jdxfile,"%s",line);
	}
    	fclose(molfile);
        fprintf(jdxfile,"</ModelData>\n");

	xyzfile = fopen("mol.xyz","r");
	if (xyzfile) {

	   fprintf(jdxfile,"<ModelData id=\"1\" type=\"XYZVIB\" baseModel=\"mol\" vibrationScale=\".1\">\n");

	   for (i=0; i < FRQ->nfreq; i++) {
		ifrq = i + 1;
#if defined(VMS) || defined(UNDERSC)
		nrmi(&ifrq);
#else
#ifdef CRAY
		NRMI(&ifrq);
#else
		nrmi_(&ifrq);
#endif
#endif
		fgets(line,MAXCMD,xyzfile);
		fprintf(jdxfile,"%s",line);
		fgets(line,MAXCMD,xyzfile);
		fprintf(jdxfile,"%d Freq: %#5.1f %s",ifrq,FRQ->freq[i],line);

		k = 0;
		while (fgets(line,MAXCMD,xyzfile) != NULL) {
		   q = strchr(line,'\n');
		   sprintf(q," %#12.6f %#12.6f %#12.6f\n",
			FRQ->a[k][0]*toangs,FRQ->a[k][1]*toangs,FRQ->a[k][2]*toangs);
		   fprintf(jdxfile,"%s",line);
		   k++;
		}

		rewind(xyzfile);
	   }
    	   fclose(xyzfile);
           fprintf(jdxfile,"</ModelData>\n");
	}
        fprintf(jdxfile,"</Models>\n");

    }

    fprintf(jdxfile,"##$PEAKS=\n");
    fprintf(jdxfile,"<Peaks type=\"IR\" xUnitsExpected=\"1/cm\">\n");
    for (i=0; i < FRQ->nfreq; i++)  {
	ifrq = i + 1;
	if (i>0 && i < FRQ->nfreq-1) {
	   xmin = (int) (FRQ->freq[i] - (FRQ->freq[i] - FRQ->freq[i-1]) / 2.0);
	   xmax = (int) (FRQ->freq[i] + (FRQ->freq[i+1] - FRQ->freq[i]) / 2.0);
	   xmax--;
	} else {
	   if (i == 0) {
		xmin = 0;
	   	xmax = (int) (FRQ->freq[i] + (FRQ->freq[i+1] - FRQ->freq[i]) / 2.0);
	        xmax--;
	   }
	   if (i == FRQ->nfreq-1) {
		xmin = (int) (FRQ->freq[i] - (FRQ->freq[i] - FRQ->freq[i-1]) / 2.0);
	   	xmax = max_freq;
	   }
	}
	fprintf(jdxfile,"<PeakData id=\"%d\" title=\"Freq %#6.1f\" peakShape=\"broad\" model=\"1.%d\" xMax=\"%d\" xMin=\"%d\">\n",ifrq,FRQ->freq[i],ifrq,xmax,xmin);
    }
    fprintf(jdxfile,"</Peaks>\n");

    fprintf(jdxfile,"##XUNITS=1/CM\n");
    fprintf(jdxfile,"##YUNITS=ABSORBANCE\n");
    fprintf(jdxfile,"##XLABEL=Wavenumbers (cm-1)\n");
    fprintf(jdxfile,"##YLABEL=%% Absorbance\n");
    fprintf(jdxfile,"##XFACTOR=1\n");
    fprintf(jdxfile,"##YFACTOR=1\n");
    fprintf(jdxfile,"##DELTAX=1\n");
    fprintf(jdxfile,"##FIRSTX=%d\n",min_freq);
    fprintf(jdxfile,"##LASTX=%d\n",max_freq);
    fprintf(jdxfile,"##FIRSTY=%f\n",spec_mn);
    fprintf(jdxfile,"##MAXX=%d\n",max_freq);
    fprintf(jdxfile,"##MINX=%d\n",min_freq);
    fprintf(jdxfile,"##MAXY=%f\n",spec_mx);
    fprintf(jdxfile,"##MINY=%f\n",spec_mn);
    fprintf(jdxfile,"##NPOINTS=%d\n",n_freqs);
    fprintf(jdxfile,"##XYDATA=(X++(Y..Y))\n");

    for (i=0; i < n_freqs; i += 5) {
	frq = min_freq + i*freq_step;
	fprintf(jdxfile,"%-11.6f",frq);
	for (j=0; j < 5; j++) {
	   if (i+j < n_freqs) {
		fprintf(jdxfile," %6.4f",out_spec[i+j]*yscale);
	   }
	}
	fprintf(jdxfile,"\n");
    }
    fprintf(jdxfile,"##END=\n");
/*
387.000000 0.9245 0.9240 0.9235 0.9231 0.9227
*/

    fclose(jdxfile);


    return;
}

#if defined(VMS) || defined(UNDERSC)
void jdxwr()
#else
#ifdef CRAY
void JDXWR()
#else
void jdxwr_()
#endif
#endif
{
  char *fnam    = "mol.jdx";
  wrjdx(fnam);
}

void write_xmgr(char *fname) {
int i;
double frq;

	spout = fopen(fname,"w");
	for (i=0; i < n_freqs; i++) {
	   frq = min_freq + i*freq_step;
	   fprintf(spout,"%11.6f %11.6f\n",frq,out_spec[i]);
	}
	fclose(spout);
}

void wrtcallb(char *str)
{
	write_spectrum(str,1,0);
	drwspec();
}

void updcallb(char *str)
{
	if (nmrptr->ihsnmr) prep_nmr();
	calc_spectrum(1);
	drwspec();
}

void srccallb(char *str)
{
	PDBquery(str);
}

int ButtonsSPC(i)
int i;
{
  int iupd;
  float tmp;

  switch (i) {
  case 0:	{
	LSSTRU List;
	List.list = pktyp; List.nents = 2;
	if (DoPopUp(winspec,spbut[0].x+20,spbut[0].y,
		&List,&lorentzian,0) == -1) return 0;
	   spbut[0].str = pktyp[lorentzian];
	   DrwBut(&spbut[0]);
        }
        break;
  case 1:	{
	   LSSTRU List; List.nents = 2;

	   if (FRQ->ihasi) {
		if (*ihasex) {
		    List.nents = 1;
		    List.list = uvsptyp;
		} else {
		    List.list = sptyp;
		}

		if (DoPopUp(winspec,spbut[1].x+20,spbut[1].y,
		    &List,&spmode,0) == -1) return 0;
		if (*ihasex) {
		   spbut[1].str = *uvsptyp;
		   spint = FRQ->frint; 
		} else {
		   spbut[1].str = sptyp[spmode];
        	   if (spmode) {
			spint = FRQ->ramint; 
	   	   } else {
			spint = FRQ->frint; 
		   }
		}
	   	
	   	frlist.list.flst = spint;
           	if (FRup) RedrawList(&frlist);
	   	DrwBut(&spbut[1]);

	   } else if (nmrptr->ihsnmr) {

		List.list = nmrsptyp;

		if (DoPopUp(winspec,spbut[1].x+20,spbut[1].y,
		    &List,&spmode,0) == -1) return 0;
		spbut[1].str = nmrsptyp[spmode];
		if (spmode) {
		    NMRnuc = 6;
		    nmrref  = &nmr13Cref;
		    freq_step = nmr13Cstep;
		} else {
		    NMRnuc = 1;
		    nmrref  = &nmr1Href;
		    freq_step = nmr1Hstep;
		}
		sprintf(qboxes[QTMS].str,"%6.2f",*nmrref);
		qboxes[QTMS].curpos = strlen(qboxes[QTMS].str);
		qboxes[QTMS].qflt = nmrref;
	   	DrwBut(&spbut[1]);
		prep_nmr();
		FRQextr();
		sprintf(qboxes[QMINF].str,"%d",min_freq);
		sprintf(qboxes[QMAXF].str,"%d",max_freq);
		qboxes[QMINF].curpos = strlen(qboxes[QMINF].str);
		qboxes[QMAXF].curpos = strlen(qboxes[QMAXF].str);
           }
        }
        break;
  case 2:	{
        XDestroyWindow(display,winspec);
        specup = 0;
	if (nmrptr->ihsnmr) TogUp(&cbut[BFORC]);
	if (peaks != NULL) {
	   free(peaks);
	   peaks = NULL;
	}
	if (inten != NULL) {
	   free(inten);
	   inten = NULL;
	}
	return(0);
        }
        break;
  case 3:
	qboxstr(&qboxes[QSFIL],NULL,1,0,-1,DEFQX,DEFQY,
		QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
		0,0,2000,0,wrtcallb);
        break;
  case 4:
	qboxstr(&qboxes[QSFIL],NULL,1,0,-1,DEFQX,DEFQY,
		QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
		0,0,2000,0,write_xmgr);
        break;
  case 5:
        qboxstr(&qboxes[QSFIL],NULL,1,0,-1,DEFQX,DEFQY,
                QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,
                0,0,2000,0,wrjdx);
        break;
  case 6:
	avch3(); prep_nmr();
        break;
  }

  iupd = 1;
  if (nmrptr->ihsnmr) {
	iupd = 0;
	tmp = atof(qboxes[QTMS].str);
	if (tmp != *nmrref) iupd = 1;
	*nmrref = tmp;
	tmp = atof(qboxes[QFREQ].str);
	if (tmp != NMRbas) iupd = 1;
	NMRbas = tmp;
	if (iupd) prep_nmr();
  }
  calc_spectrum(iupd);
  sprintf(qboxes[QIMAX].str,"%-4.2f",spec_mx);
  qboxes[QIMAX].curpos = strlen(qboxes[QIMAX].str);

  drwspec();
}

void InitDelay()
{
   
  DELup = 1;

  DELAYwin = CreateWindow("Delay Time","-0+0",DELWINW,DELWINH,
	 		 infobg,infofg,(Window)0);
  XSelectInput(display, DELAYwin, EnterWindowMask | 
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask);
  XMapWindow(display,DELAYwin);

  WinObj[29].win = &DELAYwin;
  WinObj[29].subwin = NULL;
  WinObj[29].butarr = delbut;
  WinObj[29].numbut = 3;
  WinObj[29].winup = &DELup;
  WinObj[29].redraw = RedrawDEL;

  DefBut(&delbut[0], DELAYwin, 50, 75, 50, 23,
	"Apply", infobg, -15);
  DefBut(&delbut[1], DELAYwin, 200, 75, 50, 23,
	"Close", infobg, -15);
  DefBut(&delbut[2], DELAYwin, 125, 75, 50, 23,
	"Save", infobg, -15);

  qboxstr(&qboxes[QDEL],&DELAYwin,0,0,190,15,30, 
	250,QBOXHIGH,2,"Delay Time [msec] Next Structure ","1",12,
	QPOSINT,2000,-1,dummyproc);

  qboxes[QDEL].iflt = ideltm;
  sprintf(qboxes[QDEL].str,"%d",*ideltm);
  qboxes[QDEL].curpos = strlen(qboxes[QDEL].str);
  qboxes[QDEL].active = 1;
}

void RedrawDEL()
{

   if (!DELup) return;

   butje(DELAYwin,0,0,DELWINW,DELWINH,4,0,0,1,None,0,0,0,0);

   DrwBut(&delbut[0]);
   DrwBut(&delbut[1]);
   DrwBut(&delbut[2]);
   PromptBox(&qboxes[QDEL]);

}

int ButtonsDEL(i)
int i;
{

   switch(i) {
   case 0:
	*ideltm = atoi(qboxes[QDEL].str);
	break;
   case 1:
	*ideltm = atoi(qboxes[QDEL].str);
	XDestroyWindow(display,DELAYwin);DELup = 0;
	break;
   case 2:
	*ideltm = atoi(qboxes[QDEL].str);
	DelayRemember = 1;
#if defined(VMS) || defined(UNDERSC)
	wrtres();
#else
#ifdef CRAY
	WRTRES();
#else
	wrtres_();
#endif
#endif
	break;
   }
}

#if defined(VMS) || defined(UNDERSC)
void srfclr()
#else
#ifdef CRAY
void SRFCLR()
#else
void srfclr_()
#endif
#endif
{
    int i;

    if (*ipdbon) {
	if (RIBindex[istruct].end[3] < RIBindex[istruct].start[3]) {
	     NSurf[istruct] = RIBindex[istruct].start[2] + 
				RIBindex[istruct].nrna;
	} else {
	     NSurf[istruct] = RIBindex[istruct].start[3] + 
				RIBindex[istruct].ncoil;
	}
    }
    else NSurf[istruct] = 0;
    *natorg = 0;
    if (NSurf[istruct] < 0) NSurf[istruct] = 0;
}

static int cmprot(a,b)
RESROTSTRU *a, *b;
{
    if (a->etot > b->etot) return 1;
    else
       if (a->etot == b->etot) return  0;
       else          return -1;
}

#if defined(VMS) || defined(UNDERSC)
void stowat(ino)
#else
#ifdef CRAY
void STOWAT(ino)
#else
void stowat_(ino)
#endif
#endif
int *ino;
{
   int i,j,k,kk,n,ncon;
   int icnn[MXCON+1];

   if (!*ipdbon) return;

   if (watcoo[istruct] == NULL || 
	(watcoo[istruct] != NULL && *ino > nwater[istruct])) {
      if (watcoo[istruct] != NULL) free(watcoo[istruct]);
      if ((watcoo[istruct] = 
	(double *) malloc((sizeof(double))*(*ino*3))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }

   if (watanz[istruct] == NULL || 
	(watanz[istruct] != NULL && *ino > nwater[istruct])) {
      if (watanz[istruct] != NULL) free(watanz[istruct]);
      if ((watanz[istruct] = 
	(int *) malloc((sizeof(int))*(*ino))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }

   if (watres[istruct] == NULL || 
	(watres[istruct] != NULL && *ino > nwater[istruct])) {
      if (watres[istruct] != NULL) free(watres[istruct]);
      if ((watres[istruct] = 
	(int *) malloc((sizeof(int))*(*ino))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }

   if (watcon[istruct] == NULL || 
	(watcon[istruct] != NULL && *ino > nwater[istruct])) {
      if (watcon[istruct] != NULL) free(watcon[istruct]);
      if ((watcon[istruct] = 
	(int *) malloc((sizeof(int))*(MXCON+1)*(*ino))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }

   if (watqat[istruct] == NULL || 
	(watqat[istruct] != NULL && *ino > nwater[istruct])) {
      if (watqat[istruct] != NULL) free(watqat[istruct]);
      if ((watqat[istruct] = 
	(double *) malloc((sizeof(double))*(*ino))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }

   if (wattyp[istruct] == NULL || 
	(wattyp[istruct] != NULL && *ino > nwater[istruct])) {
      if (wattyp[istruct] != NULL) free(wattyp[istruct]);
      if ((wattyp[istruct] = 
	(short int *) malloc((sizeof(short int))*(*ino))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }

   if (watmap[istruct] == NULL || 
	(watmap[istruct] != NULL && *ino > nwater[istruct])) {
      if (watmap[istruct] != NULL) free(watmap[istruct]);
      if ((watmap[istruct] = 
	(int *) malloc((sizeof(int))*(*xyzp->mxnat))) == NULL) {
	fprintf(stderr, "Memory allocation error for store water\n");
	return;
      }
   }
   n = 0;
   for (i=0; i < *xyzp->iatoms; i++ ) {
	watmap[istruct][i] = -1;
	if (xyzp->ianz[i] < 100 && xyzp->iaton[i] == 1) {
	    watmap[istruct][i] = n;
	    n++;
	}
   }

   n = 0;
   for (i=0; i < *xyzp->iatoms; i++ ) {
	if (xyzp->ianz[i] < 100 && xyzp->iaton[i] == 1) {
	    for (k=0; k < 3; k++) 
		watcoo[istruct][n*3+k] = xyzp->coo[i*3+k];
	    watanz[istruct][n] = xyzp->ianz[i];
	    watqat[istruct][n] = xyzp->qat[i];
	    wattyp[istruct][n] = xyzp->ityp[i];
	    watres[istruct][n] = xyzp->iresid[i];
	    ncon = 0;
	    for (k=0; k < xyzp->iconn[i*(MXCON+1)]; k++) {
		kk = xyzp->iconn[i*(MXCON+1)+1+k];
		if (kk > 0 && kk < *xyzp->mxnat) {
		   kk--;
		   if (watmap[istruct][kk] != -1) {
			icnn[ncon] = watmap[istruct][kk];
			ncon++;
		   }
		}
	    }
	    watcon[istruct][n*(MXCON+1)] = ncon;
	    for (k=0; k < ncon; k++) 
		watcon[istruct][n*(MXCON+1)+k+1] = icnn[k];
	    n++;
	}
   }
   nwater[istruct] = n;
   free(watmap[istruct]);
   watmap[istruct] = NULL;

}

/*
int watcon(coo1,coo2)
double *coo1;
double *coo2;
{
  double v[3],d;
  int i, iflag;

  iflag = 0;

  for (i=0; i<3; i++) v[i] = coo2[i] - coo1[i];
  d = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
  if (d > 0.0) d = sqrt(d);
  if (d*0.52917706 < 1.2) iflag = 1;

  return(iflag);
}
*/

void reswat()
{
   int i,j,k,n,ia,ic,icnn[2],ncon;

   if (!*ipdbon || (*ipdbon && zmpart->ipart) ) return;

   if (watcoo[istruct] == NULL || watanz[istruct] == NULL || 
	watres[istruct] == NULL) return;

   ia = *xyzp->iatoms;
   n = nwater[istruct];
   if (n+ia > *xyzp->mxnat)  {
	n = *xyzp->mxnat - ia;
	fprintf(stderr,"Not enough room to restore all waters !!!!\n");
   }

   for (i=0; i < n; i++ ) {
	for (k=0; k < 3; k++) 
	   xyzp->coo[(i+ia)*3+k] = watcoo[istruct][i*3+k];
	xyzp->iconn[(i+ia)*(MXCON+1)] = watcon[istruct][i*(MXCON+1)];
	for (k=1; k < MXCON+1; k++) 
	   xyzp->iconn[(i+ia)*(MXCON+1)+k] = 
		ia + watcon[istruct][i*(MXCON+1)+k] + 1;
	xyzp->ianz[ia+i] = watanz[istruct][i];
	xyzp->qat[ia+i] = watqat[istruct][i];
	xyzp->ityp[ia+i] = wattyp[istruct][i];
	xyzp->iresid[ia+i] = watres[istruct][i];
	xyzp->iatclr[ia+i] = 1;
	if (*backb && !calfptr->ihets[ABS(watres[istruct][i])] ) {
	   xyzp->iaton[ia+i] = 0;
	} else {
	   xyzp->iaton[ia+i] = 1;
	}
   }
   *xyzp->iatoms = ia + n;
}

void RescoreResrot()
{
   int i,j,l,n,i7=7;
   char wfile[500];

/* fftyp ? , charges ? (only when also doing ligand ?)
   PMF score and ambfor use same array
*/

/*
   if (itypBackup == NULL) {
      if ((itypBackup = (short int *) malloc((sizeof(short int))*(*xyzp->mxnat))) == NULL) {
	fprintf(stderr, "Memory allocation error for itypBackup\n");
	return;
      } else {
          for (i=0; i<*xyzp->mxnat; i++) itypBackup[i] = xyzp->ityp[i];
      }
   }
*/
   *fftyp = 7;
   cell->ichx = 0;

#if defined(VMS) || defined(UNDERSC)
   dotyp(&cell->ichx);
#else
#ifdef CRAY
   DOTYP(&cell->ichx);
#else
   dotyp_(&cell->ichx);
#endif
#endif

   tnk_single = 1;
   for (j=0; j<nresrot; j++) {
	showresrot(j);
	sprintf(wfile, "rescore%03d",j);
	cpstr(wfile,tnkjn,SUBLEN1);
#if defined(VMS) || defined(UNDERSC)
	wrtsng();
#else
#ifdef CRAY
	WRTSNG();
#else
	wrtsng_();
#endif
#endif
	*tnkprg = 0;
	doamb(wfile);
	resrot[j].etot = newen;
   }
   tnk_single = 0;
   for (j=0; j<nresrot; j++) flxen[j] = resrot[j].etot;
#ifdef DOGL
   for (j=0; j<resrot[0].ndrs; j++) ogres(resrot[0].idrs[j],1,0);
   dispsf();
#endif
   RedrawList(&flxlist);
}

void SaveResrot()
{
   int i,j, istat;
   char wfile[500];
   FILE *out;

   istat = 18;
   strcpy(wfile,"resrot");

   out = fopen(wfile,"w");
   if (out != NULL) {
	fprintf(out,"%d %d\n",nresrot,resrot[0].ndrs);
	for (i=0; i<nresrot; i++) {
	   fprintf(out,"ResRot %d etot %8.3f\n",i,resrot[i].etot);
	   for (j=0; j<resrot[0].ndrs; j++) {
		fprintf(out,"%d %d\n",
		resrot[i].idrs[j],resrot[i].rot[j]);
	   }
	}
	fclose(out);
	   
#if defined(VMS) || defined(UNDERSC)
	messg(&istat);
#else
#ifdef CRAY
	MESSG(&istat);
#else
	messg_(&istat);
#endif
#endif
   }
}

void LoadResrot()
{
   int i,itmp,j, istat;
   double etmp;
   char wfile[500];
   char stmp1[6];
   char stmp2[4];
   char stmp3[8];
   FILE *out;

   istat = 19;
   strcpy(wfile,"resrot");

   out = fopen(wfile,"r");
   if (out != NULL) {
	fscanf(out,"%d %d",&nresrot,&resrot[0].ndrs);
        fprintf(stderr,"nresrot %d ndrs %d\n",nresrot,resrot[0].ndrs);
	for (i=0; i<nresrot; i++) {
	   resrot[i].ndrs = resrot[0].ndrs;
	   fscanf(out,"%6s %d %4s %8s",stmp1,&itmp,stmp2,stmp3);
	   sscanf(stmp3,"%lf",&etmp);
           resrot[i].etot = etmp;
	   for (j=0; j<resrot[0].ndrs; j++) {
		fscanf(out,"%d %d\n",
		&resrot[i].idrs[j],&resrot[i].rot[j]);
	   }
	}
	fclose(out);
	for (j=0; j<nresrot; j++) flxen[j] = resrot[j].etot;
	for (j=0; j<resrot[0].ndrs; j++) {
	   for (i=0; i < *xyzp->iatoms; i++) {
		if (xyzp->iresid[i] == resrot[0].idrs[j]) xyzp->iatclr[i] = 1;
	   }
#ifdef DOGL
	   ogres(resrot[0].idrs[j],1,0);
#endif
	}
#ifdef DOGL
	dispsf();
#endif
	RedrawList(&flxlist);

   } else {
	   
#if defined(VMS) || defined(UNDERSC)
	messg(&istat);
#else
#ifdef CRAY
	MESSG(&istat);
#else
	messg_(&istat);
#endif
#endif
   }
}

void initflx()
{
  if (FLXup) return;   

#if defined(VMS) || defined(UNDERSC)
   dfipar();
#else
#ifdef CRAY
   DFIPAR();
#else
   dfipar_();
#endif
#endif

  FLXup = 1;
  pmfrot->ndrs = 0;
  FLXwin = CreateWindow("Scan Rotamer Space","-0+0",FLXWINW,FLXWINH,
	 		 infobg,infofg,(Window)0);
  XSelectInput(display, FLXwin, 
	ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | 
	ButtonMotionMask | LeaveWindowMask | EnterWindowMask);

  XMapWindow(display,FLXwin);

  WinObj[32].win = &FLXwin;
  WinObj[32].subwin = NULL;
  WinObj[32].butarr = flxbut;
  WinObj[32].numbut = 9;
  WinObj[32].winup = &FLXup;
  WinObj[32].redraw = RedrawFLX;

  DefBut(&flxbut[0], FLXwin, 30, 10, 140, 23,
	"Scan Rotamer Space", infobg, -15);
  DefBut(&flxbut[2], FLXwin, 180, 10, 120, 23,
	"Clear Flex. Res.", infobg, -15);
  DefBut(&flxbut[1], FLXwin,  30, 215, 60, 23,
	"Close", infobg, -15);
  DefBut(&flxbut[3], FLXwin,  30, 185, 60, 23,
	"Save", infobg, -15);
  DefBut(&flxbut[4], FLXwin, 120, 185, 60, 23,
	"Load", infobg, -15);
  DefBut(&flxbut[5], FLXwin,  30, 155, 60, 23,
	"Rescore", infobg, -15);
  DefBut(&flxbut[6], FLXwin, 120, 155, 60, 23,
	"Sort", infobg, -15);
  DefBut(&flxbut[7], FLXwin, 30, 130, 20, 20,
	" ", infobg, -15);
  DefBut(&flxbut[8], FLXwin, 180, 130, 20, 20,
	" ", infobg, -15);
  DefList(&flxlist,FLXwin,DIRX,DIRY,DIRW,80,
	NULL,5,NULL,NULL,flxen,NULL,&nresrot,NULL);

  if (*idoh) TogDown(&flxbut[7]);
  else TogUp(&flxbut[7]);

}

void RedrawFLX()
{
   int i;

   if (!FLXup) return;

   butje(FLXwin,0,0,FLXWINW,FLXWINH,4,0,0,1,None,0,0,0,0);

   for (i=0; i < 9; i++) DrwBut(&flxbut[i]);

   LineString(FLXwin, "Include H...H Pot.", 60, 145);
   LineString(FLXwin, "Show Opt.", 200, 145);

   RedrawList(&flxlist);

}

int ButtonsFLX(i)
int i;
{
   int j,k,l;

   switch(i) {
   case 0:
	opt3rot();
	RedrawList(&flxlist);
	break;
   case 1:
	DeAllocRot();
	update_model = 0;
	pmfrot->ndrs = 0;
	XDestroyWindow(display,FLXwin);FLXup = 0;
	break;
   case 2:
	nresrot = 0;
#if defined(VMS) || defined(UNDERSC)
        chkbck(&ZERO);
#else
#ifdef CRAY
	CHKBCK(&ZERO);
#else
	chkbck_(&ZERO);
#endif
#endif
	for (l=0; l<resrot[0].ndrs; l++) {
	   for (i=0; i < *xyzp->iatoms; i++) {
		if (xyzp->iresid[i] == resrot[0].idrs[l]) {
		   xyzp->iatclr[i] = 12;
		}
	   }
#ifdef DOGL
	   ogres(resrot[0].idrs[l],1,0);
#endif
	}
	resrot[0].ndrs = 0;
	pmfrot->ndrs = 0;
	update_model = 0;
#ifdef DOGL
	dispsf();
#endif
	RedrawList(&flxlist);
	break;
   case 3:
	SaveResrot();
	break;
   case 4:
	LoadResrot();
	break;
   case 5:
	RescoreResrot();
	break;
   case 6:
	qsort((RESROTSTRU *) resrot, nresrot, sizeof(RESROTSTRU), cmprot);
	for (j=0; j<nresrot; j++) flxen[j] = resrot[j].etot;
	RedrawList(&flxlist);
	break;
   case 7:
	if (*idoh) {
	   *idoh = 0;
	   TogUp(&flxbut[7]);
	} else {
	   *idoh = 1;
	   TogDown(&flxbut[7]);
	}
	break;
   case 8:
	if (vis) {
	   vis = 0;
	   TogUp(&flxbut[8]);
	} else {
	   vis = 1;
	   TogDown(&flxbut[8]);
	}
	break;
   }
}

void InitPar()
{
  PARup = 1;
  PARwin = CreateWindow("H-bond parameters","-0+0",PARWINW,PARWINH,
	 		 infobg,infofg,(Window)0);
  XSelectInput(display, PARwin, 
	ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | 
	ButtonMotionMask | LeaveWindowMask | EnterWindowMask);

  XMapWindow(display,PARwin);

  WinObj[33].win = &PARwin;
  WinObj[33].subwin = NULL;
  WinObj[33].butarr = parbut;
  WinObj[33].numbut = 3;
  WinObj[33].winup = &PARup;
  WinObj[33].redraw = RedrawPAR;

  DefBut(&parbut[0], PARwin, 25, 210, 70, 23,
	"Close", infobg, -15);

  DefBut(&parbut[1], PARwin, 25, 180, 200, 23,
	"Recalculate H-bonds", infobg, -15);

  DefBut(&parbut[2], PARwin, 230, 180, 60, 23,
	"Reset", infobg, -15);

   qboxstr(&qboxes[QHBMIN],&PARwin,0,0,190,30,15+0*QBOXHIGH,
	255,QBOXHIGH,2,"Min. H-bond distance   (Ang):"," ",
	SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QHBMAX],&PARwin,0,0,190,30,15+1*QBOXHIGH,
	255,QBOXHIGH,2,"Max. H-bond distance   (Ang):"," ",
	SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QHAMIN],&PARwin,0,0,190,30,15+2*QBOXHIGH,
	255,QBOXHIGH,2,"Min. angle Donor-H..Acc(Deg):"," ",
	SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   qboxstr(&qboxes[QHAMAX],&PARwin,0,0,190,30,15+3*QBOXHIGH,
	255,QBOXHIGH,2,"Max. angle Donor-H..Acc(Deg):"," ",
	SUBLEN2,QPOSREAL,2000,-1,
	dummyproc);

   sprintf(qboxes[QHBMIN].str,"%f",hbpars->hdmin*toangs);
   sprintf(qboxes[QHBMAX].str,"%f",hbpars->hdmax*toangs);
   sprintf(qboxes[QHAMIN].str,"%f",hbpars->hamin);
   sprintf(qboxes[QHAMAX].str,"%f",hbpars->hamax);

   qboxes[QHBMIN].curpos = strlen(qboxes[QHBMIN].str);
   qboxes[QHBMAX].curpos = strlen(qboxes[QHBMAX].str);
   qboxes[QHAMIN].curpos = strlen(qboxes[QHAMIN].str);
   qboxes[QHAMAX].curpos = strlen(qboxes[QHAMAX].str);

   qboxes[QHBMIN].active = 1;
   qboxes[QHBMAX].active = 0;
   qboxes[QHAMIN].active = 0;
   qboxes[QHAMAX].active = 0;
}

void RedrawPAR()
{
   int i;

   if (!PARup) return;

   butje(PARwin,0,0,PARWINW,PARWINH,4,0,0,1,None,0,0,0,0);

   for (i=0; i < 3; i++) DrwBut(&parbut[i]);

   PromptBox(&qboxes[QHBMIN]);
   PromptBox(&qboxes[QHBMAX]);
   PromptBox(&qboxes[QHAMIN]);
   PromptBox(&qboxes[QHAMAX]);
}

int ButtonsPAR(i)
int i;
{

   switch(i) {
   case 0:
	update_model = 0;
	hbpars->hdmin = atof(qboxes[QHBMIN].str)/toangs;
	hbpars->hdmax = atof(qboxes[QHBMAX].str)/toangs;
	hbpars->hamin = atof(qboxes[QHAMIN].str);
	hbpars->hamax = atof(qboxes[QHAMAX].str);
	XDestroyWindow(display,PARwin);PARup = 0;
	break;
   case 1:
	update_model = 1;
	hbpars->hdmin = atof(qboxes[QHBMIN].str)/toangs;
	hbpars->hdmax = atof(qboxes[QHBMAX].str)/toangs;
	hbpars->hamin = atof(qboxes[QHAMIN].str);
	hbpars->hamax = atof(qboxes[QHAMAX].str);
#if defined(VMS) || defined(UNDERSC)
	nohcon();
	dohcon(&ZERO);
#else
#ifdef CRAY
	NOHCON();
	DOHCON(&ZERO);
#else
	nohcon_();
	dohcon_(&ZERO);
#endif
#endif
	update_struct();
	return(1);
	break;
   case 2:
	hbpars->hdmin = 1.50/toangs;
	hbpars->hdmax = 3.15/toangs;
	hbpars->hamin = 145.0;
	hbpars->hamax = 215.0;
	sprintf(qboxes[QHBMIN].str,"%f",hbpars->hdmin*toangs);
	sprintf(qboxes[QHBMAX].str,"%f",hbpars->hdmax*toangs);
	sprintf(qboxes[QHAMIN].str,"%f",hbpars->hamin);
	sprintf(qboxes[QHAMAX].str,"%f",hbpars->hamax);
	qboxes[QHBMIN].curpos = strlen(qboxes[QHBMIN].str);
	qboxes[QHBMAX].curpos = strlen(qboxes[QHBMAX].str);
	qboxes[QHAMIN].curpos = strlen(qboxes[QHAMIN].str);
	qboxes[QHAMAX].curpos = strlen(qboxes[QHAMAX].str);
	PromptBox(&qboxes[QHBMIN]);
	PromptBox(&qboxes[QHBMAX]);
	PromptBox(&qboxes[QHAMIN]);
	PromptBox(&qboxes[QHAMAX]);
	break;
   }
   return(0);
}

void UpdateSTRC()
{
   int i;

   if (!STRCup) return;

   DefList(&strclist,STRCwin,STRX,20,STRW,80,
	NULL,5,sndstr[istruct],NULL,NULL,SSon[istruct],&NSurf[istruct],NULL);

}

void inistrc()
{
  int j,tel,act;
  if (!xison) return;

  STRCup = 1;
  STRCwin = CreateWindow("Surfaces","-100+525",STRWINW,STRWINH+BUTTN+5,
	 		 infobg,infofg,(Window)0);
  subSTRC = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],STRCwin);
  XSelectInput(display, STRCwin, 
	SubstructureNotifyMask | ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,STRCwin);

  WinObj[36].win = &STRCwin;
  WinObj[36].subwin = &subSTRC;
  WinObj[36].butarr = strcbut;
  WinObj[36].numbut = STRCBN;
  WinObj[36].winup = &STRCup;
  WinObj[36].redraw = RedrawSTRC;

  DefBut(&strcbut[0], STRCwin, STRX, 110, 90, 23,
	"Set Color", infobg, -15);
  strcbut[0].explstr = "Set Surface Color";

  DefBut(&strcbut[1], STRCwin, STRX+120, 115, 15, 15,
	" ", infobg, -15);
  strcbut[1].explstr = "Render surfaces transparent";

  DefBut(&strcbut[2], STRCwin, STRX+120, 115+BUTTH, 15, 15,
	" ", infobg, -15);
  strcbut[2].explstr = "Render surfaces as lines";

  DefBut(&strcbut[3], STRCwin, STRX, 110+2*BUTTN, 90, 23,
	"Delete Active", infobg, -15);
  strcbut[3].explstr = "Delete Active Surface";

  DefBut(&strcbut[4], STRCwin, STRX, 110+4*BUTTN, 50, 23,
	"Helix", infobg, -15);
  strcbut[4].explstr = "activate Helix";

  DefBut(&strcbut[5], STRCwin, STRX+60, 110+4*BUTTN, 50, 23,
	"Beta", infobg, -15);
  strcbut[5].explstr = "activate Beta sheet";

  DefBut(&strcbut[6], STRCwin, STRX+2*60, 110+4*BUTTN, 50, 23,
	"RNA", infobg, -15);
  strcbut[6].explstr = "activate RNA/DNA";

  DefBut(&strcbut[7], STRCwin, STRX+3*60, 110+4*BUTTN, 50, 23,
	"Coil", infobg, -15);
  strcbut[7].explstr = "activate Coil";

  DefBut(&strcbut[8], STRCwin, STRX, 110+5*BUTTN, 75, 23,
	"Activ. All", infobg, -15);
  strcbut[8].explstr = "Activate All surfaces";

  DefBut(&strcbut[9], STRCwin, STRX+80, 110+5*BUTTN, 90, 23,
	"Deactiv. All", infobg, -15);
  strcbut[9].explstr = "Deactivate All surfaces";

  DefBut(&strcbut[12], STRCwin, STRX+180, 110+5*BUTTN, 45, 23,
	"Invert", infobg, -15);
  strcbut[12].explstr = "Invert Activations";

  DefBut(&strcbut[11], STRCwin, STRX+120, 115+6*BUTTN, 70, 23,
	"Write All", infobg, -15);
  strcbut[11].explstr = "Write all surfaces to molden.ogl";

  DefBut(&strcbut[10], STRCwin, STRX, 115+6*BUTTN, 60, 23,
	"Close", infobg, -15);
  strcbut[10].explstr = "Close window";

  DefBut(&strcbut[13], STRCwin, STRX, 110+BUTTN, 60, 23,
	"Clip", infobg, -15);
  strcbut[13].explstr = "Clip Surface";

  tel = 0;
  act = -1;
  for (j=0; j<MAXSURF; j++) {
	if (SSon[istruct][j]) {
	   tel++; act = j;
	}
  }

  if (tel == 1) {
     if (trns[istruct][act]) {
	   TogDown(&strcbut[1]);
	   TRANSb = 1;
     } else {
	   TogUp(&strcbut[1]);
	   TRANSb = 0;
     }
  }

  if (DoLines) {
	TogDown(&strcbut[2]);
  } else {
	TogUp(&strcbut[2]);
  }

  if (denmode) {
	ActBut(&strcbut[4],2);
	ActBut(&strcbut[5],2);
	ActBut(&strcbut[6],2);
	ActBut(&strcbut[7],2);
  }

  UpdateSTRC();

}

void RedrawSTRC()
{
   int i,j,tel,act;

   if (!STRCup) return;

   butje(STRCwin,0,0,STRWINW,STRWINH+BUTTN+5,4,0,0,1,None,0,0,0,0);

   for (i=0; i < STRCBN; i++) DrwBut(&strcbut[i]);

   tel = 0;
   act = -1;
   for (j=0; j<MAXSURF; j++) {
	if (SSon[istruct][j]) {
	   tel++; act = j;
	}
   }

   if (tel == 1) {
     if (trns[istruct][act]) {
	   TogDown(&strcbut[1]);
	   TRANSb = 1;
     } else {
	   TogUp(&strcbut[1]);
	   TRANSb = 0;
     }
   }

   LineString(STRCwin, "Transparent", STRX+140,128);
   LineString(STRCwin, "Lines", STRX+140,128+BUTTH);
   ULineString(STRCwin, "Activate:", STRX,128+3*BUTTN);

   RedrawList(&strclist);

}

int ButtonsSTRC(i)
int i;
{
   LSSTRU List; int j,k,nsrf;

   switch(i) {
   case 0:
	if (DoPopUp(STRCwin, 
	   strcbut[0].x,strcbut[0].y-100, NULL,&j,0) == -1) break;
	for (k=0; k < NSurf[istruct]; k++) 
	   if (SSon[istruct][k]) SetSurfColor(k,j);
	break;
   case 1:
	TRANSb = ! TogBut(&strcbut[1]);
	for (j=0; j < NSurf[istruct]; j++) 
	   if (SSon[istruct][j]) trns[istruct][j] = TRANSb;
	break;
   case 2:
	DoLines = ! TogBut(&strcbut[2]);
	break;
   case 3:
	DeleteActiveSurfaces();
	break;
   case 4:
	for (j=RIBindex[istruct].start[0]; 
		j <= RIBindex[istruct].end[0]; j++) {
		if (j == -1) break;
		SSon[istruct][j] = 1;
	}
	break;
   case 5:
	for (j=RIBindex[istruct].start[1]; 
		j <= RIBindex[istruct].end[1]; j++) {
		if (j == -1) break;
		SSon[istruct][j] = 1;
	}
	break;
   case 6:
	for (j=RIBindex[istruct].start[2]; 
		j <= RIBindex[istruct].end[2]; j++) {
		if (j == -1) break;
		SSon[istruct][j] = 1;
	}
	break;
   case 7:
	for (j=RIBindex[istruct].start[3]; 
		j <= RIBindex[istruct].end[3]; j++) {
		if (j == -1) break;
		SSon[istruct][j] = 1;
	}
	break;
   case 8:
	for (j=0; j < NSurf[istruct]; j++) SSon[istruct][j] = 1;
	break;
   case 9:
	for (j=0; j < NSurf[istruct]; j++) SSon[istruct][j] = 0;
	break;
   case 10:
	XDestroyWindow(display,STRCwin);STRCup = 0;
	return(0);
	break;
   case 11:
#if defined(VMS) || defined(UNDERSC)
	curs(&ONE);
	wrtall();
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ONE);
	wrtall();
	CURS(&ZERO);
#else
	curs_(&ONE);
	wrtall();
	curs_(&ZERO);
#endif
#endif
	strcpy(molwstr,"Wrote file molden.ogl");
	StatusStr(0,0);
	break;
   case 12:
	for (j=0; j < NSurf[istruct]; j++) {
	   if (SSon[istruct][j]) {
		SSon[istruct][j] = 0;
	   } else {
		SSon[istruct][j] = 1;
	   }
	}
	break;
   case 13:
	IniOmap();
	break;
   }

   dispsf();
   RedrawSTRC();
   return(0);
}

void iniselh()
{
  int j,tel,act;
  if (!xison) return;

  SELHup = 1;
  SELHwin = CreateWindow("Optimize Hydrogens","-100+525",
		SELHWINW,SELHWINH+20, infobg,infofg,(Window)0);
  subSELH = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],SELHwin);
  XSelectInput(display, SELHwin, 
	SubstructureNotifyMask | ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,SELHwin);

  WinObj[40].win = &SELHwin;
  WinObj[40].subwin = &subSELH;
  WinObj[40].butarr = selhbut;
  WinObj[40].numbut = SELHBN;
  WinObj[40].winup = &SELHup;
  WinObj[40].redraw = RedrawSELH;

  DefBut(&selhbut[0], SELHwin, STRX+10, 20, 15, 15,
	" ", infobg, -15);
  selhbut[0].explstr = "Add hydrogens to hetatm's";

  DefBut(&selhbut[1], SELHwin, STRX+10, 20+BUTTH, 15, 15,
	" ", infobg, -15);
  selhbut[1].explstr = "Complete incomplete Residues";

  DefBut(&selhbut[2], SELHwin, STRX+10, 20+2*BUTTH, 15, 15,
	" ", infobg, -15);
  selhbut[2].explstr = "Flip GLN/ASN residues";

  DefBut(&selhbut[3], SELHwin, STRX+10, 20+3*BUTTH, 15, 15,
	" ", infobg, -15);
  selhbut[3].explstr = "For histidines choose HID or HIE";

  DefBut(&selhbut[4], SELHwin, STRX+10, 20+4*BUTTH, 15, 15,
	" ", infobg, -15);
  selhbut[4].explstr = "Optimise OH and SH orientations";

  DefBut(&selhbut[5], SELHwin, STRX+10, 20+5*BUTTH, 15, 15,
	" ", infobg, -15);
  selhbut[5].explstr = "Add Hydrogens to waters";

  DefBut(&selhbut[6], SELHwin, STRX+10, 20+6*BUTTN, 60, 23,
	"Optimise", infobg, -15);
  selhbut[6].explstr = "Optimise Hydrogens";

  HLIG = 1;
  TogDown(&selhbut[0]);

  HINC = 1;
  TogDown(&selhbut[1]);

  HFLP = 1;
  TogDown(&selhbut[2]);

  HHIS = 1;
  TogDown(&selhbut[3]);

  HRES = 1;
  TogDown(&selhbut[4]);

  HWAT = 1;
  TogDown(&selhbut[5]);

}

void RedrawSELH()
{
   int i,j,tel,act;

   if (!SELHup) return;

   butje(SELHwin,0,0,SELHWINW,SELHWINH+20,4,0,0,1,None,0,0,0,0);

   for (i=0; i < SELHBN; i++) DrwBut(&selhbut[i]);

   LineString(SELHwin, "Add hydrogens to ligands", STRX+30,33);
   LineString(SELHwin, "Complete Residues", STRX+30,33+BUTTH);
   LineString(SELHwin, "Flip ASN/GLN", STRX+30,33+2*BUTTH);
   LineString(SELHwin, "Choose HISTIDINE: HID or HIE", 
					STRX+30,33+3*BUTTH);
   LineString(SELHwin, "Optimise OH and SH positions", 
					STRX+30,33+4*BUTTH);
   LineString(SELHwin, "Add Hydrogens to relevant waters ", 
					STRX+30,33+5*BUTTH);

}

int ButtonsSELH(i)
int i;
{
   int j,k;

   switch(i) {
   case 0:
	HLIG = ! TogBut(&selhbut[0]);
	break;
   case 1:
	HINC = ! TogBut(&selhbut[1]);
	break;
   case 2:
	HFLP = ! TogBut(&selhbut[2]);
	break;
   case 3:
	HHIS = ! TogBut(&selhbut[3]);
	break;
   case 4:
	HRES = ! TogBut(&selhbut[4]);
	break;
   case 5:
	HWAT = ! TogBut(&selhbut[5]);
	break;
   case 6:
	XDestroyWindow(display,SELHwin);SELHup = 0;
#if defined(VMS) || defined(UNDERSC)
	curs(&ONE);
	opthyd();
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ONE);
	OPTHYD();
	CURS(&ZERO);
#else
	curs_(&ONE);
	opthyd_();
	curs_(&ZERO);
#endif
#endif
	return(0);
	break;
   }

   dispsf();
   return(0);
}

void InitSRCH(x,y)
int x,y;
{
   char wgeom[64];
   
   SRCHup = 1;

   sprintf(wgeom,"+%d+%d",x,y);

   SRCHwin = CreateWindow("Search PDB Window",wgeom,SRCHWINW,SRCHWINH,
	 		 infobg,infofg,(Window)0);
   subSRCH = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],SRCHwin);
   XSelectInput(display, SRCHwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);
   XMapWindow(display,SRCHwin);

   WinObj[41].win = &SRCHwin;
   WinObj[41].subwin = &subSRCH;
   WinObj[41].butarr = butSRCH;
   WinObj[41].numbut = SRCHBN;
   WinObj[41].winup = &SRCHup;
   WinObj[41].redraw = RedrawSRCH;

   DefBut(&butSRCH[0],SRCHwin, 42, 7, 80, 23, "Search PDB", infobg, ZMBCOL);
   butSRCH[0].explstr = "Search PDB with the entered keywords";

   DefBut(&butSRCH[1],SRCHwin, 10, 35+QBOXHIGH+110+110, 100, 23, 
	"Load PDB code", infobg, ZMBCOL);
   butSRCH[1].explstr = "Load structure of selected PDB code";

   DefBut(&butSRCH[2], SRCHwin, 10, 35+QBOXHIGH+110+110+BUTTN, 70, 23, 
	"Close", infobg, ZMBCOL);
   butSRCH[2].explstr = "Close this window";

   qboxstr(&qboxes[QSRCH],&SRCHwin,1,0,190,10,35,
	275,QBOXHIGH,2,"Query","",25,QSTRING,2000,-1,srccallb);
   qboxes[QSRCH].explstr = "Search string to query the PDB";

   DefList(&srchlist,SRCHwin,6,35+QBOXHIGH+20,SRCHWINW-37,110,
	NULL,9,pdbres,NULL,NULL,NULL,&npdbres,NULL);


}

#define MXPDBL 40
void RedrawSRCH()
{
  int i,l;
  char tmpstr[MXPDBL+7];
  char *sptr = NULL;

  sprintf(stemp,"Matching PDB codes (%d):",npdbres);
  butje(SRCHwin,0,0,SRCHWINW,SRCHWINH,4,0,0,1,None,0,0,0,0);
  ULineString(SRCHwin,stemp,10, 43+QBOXHIGH);
  l = strlen(qrb_title);
  if (l > MXPDBL) {
	i = 0;
	sptr = qrb_title;
	while (sptr < qrb_title + l) {
	   if ((qrb_title+l)-sptr < MXPDBL) {
		strcpy(tmpstr,"       ");
		strcat(tmpstr,sptr);
	   } else {
		if (i == 0) {
		   strcpy(tmpstr,"Title: ");
		   strncat(tmpstr,sptr,MXPDBL);
		} else {
		   strcpy(tmpstr,"       ");
		   strncat(tmpstr,sptr,MXPDBL);
		}
	   }
	   LineString(SRCHwin,tmpstr,10, 43+QBOXHIGH+110+35+i*15);
	   sptr += MXPDBL; i++;
	}
  } else {
	strcpy(tmpstr,"Title: ");
	strcat(tmpstr,qrb_title);
	LineString(SRCHwin,tmpstr,10, 43+QBOXHIGH+110+35);
  }
  sprintf(stemp,"Organism: %s",organism);
  LineString(SRCHwin,stemp,10, 43+QBOXHIGH+110+90);

  for (i=0; i<SRCHBN; i++) DrwBut(&butSRCH[i]);

  PromptBox(&qboxes[QSRCH]);
  RedrawList(&srchlist);
}

int ButtonsSRCH(i)
int i;
{

  switch (i) {
  case 0:
	if (!CheckWGET()) {
	   PDBquery(qboxes[QSRCH].str);
	}
	break;
  case 1:
	if (!CheckWGET()) {
	    GetPDBWWW(pdbres[srchlist.select],strname);
	    if (ParseFile(strname,pdbres[srchlist.select])) return 1;
	}
	break;
  case 2:
	XDestroyWindow(display,SRCHwin);
	SRCHup = 0;
	break;
  }
  return(0);
}

void InitANIM(x,y)
int x,y;
{
   char wgeom[64];
   
   ANIMup = 1;

   sprintf(wgeom,"+%d+%d",x,y);

   ANIMwin = CreateWindow("Animate Variable",wgeom,ANIMWINW,ANIMWINH,
	 		 infobg,infofg,(Window)0);
   subANIM = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],ANIMwin);
   XSelectInput(display, ANIMwin, ExposureMask | ButtonPressMask 
	| ButtonMotionMask | LeaveWindowMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);
   XMapWindow(display,ANIMwin);

   WinObj[42].win = &ANIMwin;
   WinObj[42].subwin = &subANIM;
   WinObj[42].butarr = butANIM;
   WinObj[42].numbut = ANIMBN;
   WinObj[42].winup = &ANIMup;
   WinObj[42].redraw = RedrawANIM;

   DefBut(&butANIM[0],ANIMwin, 10, 7, 70, 23, "-1 frame", infobg, ZMBCOL);
   butANIM[0].explstr = "Move one frame backwards";

   DefBut(&butANIM[1],ANIMwin, 80, 7, 30, 23, "", infobg, ZMBCOL);
   butANIM[1].explstr = "Start/Stop animation of\nvariable";

   DefBut(&butANIM[2],ANIMwin, 110, 7, 70, 23, "+1 frame", infobg, ZMBCOL);
   butANIM[2].explstr = "Move one frame forwards";

   DefBut(&butANIM[3], ANIMwin, 10, 7+BUTTN, 170, 23, 
	"Take current value", infobg, ZMBCOL);
   butANIM[3].explstr = "Take current value and\nclose window";

   DefBut(&butANIM[4], ANIMwin, 10, 7+2*BUTTN, 170, 23, 
	"Rest. value and Close", infobg, ZMBCOL);
   butANIM[4].explstr = "Restore original value of the\nvariable and close this window";

   butANIM[1].pix = rPix;
   butANIM[1].pw  = r_width;
   butANIM[1].ph  = r_height;
}

void RedrawANIM()
{
  int i;

  butje(ANIMwin,0,0,ANIMWINW,ANIMWINH,4,0,0,1,None,0,0,0,0);

  for (i=0; i<ANIMBN; i++) DrwBut(&butANIM[i]);

}

int ButtonsANIM(i)
int i;
{

  switch (i) {
  case 0:
	ANIMNXT = 0;
	butANIM[1].pix = rPix;
	DrwBut(&butANIM[1]);
	animptr.vdirection = -1;
	break;
  case 1:
	if (ANIMNXT) {
	   ANIMNXT = 0;
	   butANIM[1].pix = rPix;
	} else {
	   ANIMNXT = 1;
	   butANIM[1].pix = stopPix;
	}
	DrwBut(&butANIM[1]);
	break;
  case 2:
	ANIMNXT = 0;
	butANIM[1].pix = rPix;
	DrwBut(&butANIM[1]);
	animptr.vdirection = 1;
	break;
  case 3:
	XDestroyWindow(display,ANIMwin);
	ANIMup = 0;
	animptr.varinit = *animptr.variable;
	return(1);
	break;
  case 4:
	XDestroyWindow(display,ANIMwin);
	ANIMup = 0;
	return(1);
	break;
  }
  return(0);
}

void inistr()
{
  if (!xison) return;

  STRup = 1;
  STRwin = CreateWindow("Structures","-80+525",STRWINW,STRWINH,
	 		 infobg,infofg,(Window)0);
  subSTR = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],STRwin);
  XSelectInput(display, STRwin, 
	SubstructureNotifyMask | ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,STRwin);

  WinObj[35].win = &STRwin;
  WinObj[35].subwin = &subSTR;
  WinObj[35].butarr = strbut;
  WinObj[35].numbut = 5;
  WinObj[35].winup = &STRup;
  WinObj[35].redraw = RedrawSTR;

  DefBut(&strbut[0], STRwin, STRX, 110, 90, 23,
	"Delete Active", infobg, -15);
  strbut[0].explstr = "Delete the currently active\ndisplayed structure";

  DefBut(&strbut[1], STRwin, STRX+100, 110, 80, 23,
	"Delete All", infobg, -15);
  strbut[1].explstr = "Delete all structures";

  DefBut(&strbut[2], STRwin, STRX, 80+STRSH, 60, 23,
	"Combine", infobg, -15);
  strbut[2].explstr = "Add structure from the lower list\nto structure from the upper list";

  DefBut(&strbut[3], STRwin, STRX+70, 80+STRSH, 60, 23,
	"Align", infobg, -15);
  strbut[3].explstr = "Align structure from the lower list\nto structure from the upper list";

  DefBut(&strbut[4], STRwin, STRX+140, 80+STRSH, 90, 23,
	"Align+Combine", infobg, -15);
  strbut[4].explstr = "Align and add structure from the lower list\nto structure from the upper list";

  DefList(&strlist,STRwin,STRX,20,STRW,80,
	NULL,5,strfiles,NULL,NULL,NULL,&nstruct,NULL);
  strlist.select = istruct;
  strlist.lpnt = 0;
  DefList(&str2list,STRwin,STRX,STRSH,STRW,65,
	NULL,4,strfiles,NULL,NULL,NULL,&nstruct,NULL);
  str2list.select = 0;
  str2list.lpnt = 0;

}

void RedrawSTR()
{
   int i;

   if (!STRup) return;

   butje(STRwin,0,0,STRWINW,STRWINH,4,0,0,1,None,0,0,0,0);

   for (i=0; i < 5; i++) DrwBut(&strbut[i]);

   RedrawList(&strlist);
   RedrawList(&str2list);

}

int ButtonsSTR(i)
int i;
{
   LSSTRU List; int j;

   switch(i) {
   case 0:
	DeleteOne();
	break;
   case 1:
	DeleteAll();
	break;
   case 2:
	if (str2list.select > 0 && strlist.select < nstruct) 
	   sstruct = str2list.select;
	if (sstruct>0 && sstruct <= nstruct) {
#if defined(VMS) || defined(UNDERSC)
	   curs(&ONE);
#else
#ifdef CRAY
	   CURS(&ONE);
#else
	   curs_(&ONE);
#endif
#endif
	   CombineStructs(sstruct,1,1);
	   update_model = 1;
	   update_struct();
#if defined(VMS) || defined(UNDERSC)
	   curs(&ZERO);
#else
#ifdef CRAY
	   CURS(&ZERO);
#else
	   curs_(&ZERO);
#endif
#endif
	} else {
	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Structure should be in the range\n 1 to # of structures",0)) {}
	}
	break;
   case 3:
	if (str2list.select > 0 && strlist.select < nstruct) 
	   sstruct = str2list.select;
	if (sstruct>0 && sstruct <= nstruct) {
#if defined(VMS) || defined(UNDERSC)
	   curs(&ONE);
#else
#ifdef CRAY
	   CURS(&ONE);
#else
	   curs_(&ONE);
#endif
#endif
	   AlignStructs(sstruct,0);
	   update_model = 1;
	   update_struct();
#if defined(VMS) || defined(UNDERSC)
	   curs(&ZERO);
#else
#ifdef CRAY
	   CURS(&ZERO);
#else
	   curs_(&ZERO);
#endif
#endif
	} else {
	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Structure should be in the range\n 1 to # of structures",0)) {}
	}
	break;
   case 4:
	if (str2list.select > 0 && strlist.select < nstruct) 
	   sstruct = str2list.select;
	if (sstruct>0 && sstruct <= nstruct) {
	   int pdb1,pdb2;

	   pdb1    =  COO[istruct]->pdb;
	   pdb2    =  COO[sstruct]->pdb;

	   if ((pdb1 && pdb2) || (!pdb1 && !pdb2)) {
#if defined(VMS) || defined(UNDERSC)
		curs(&ONE);
#else
#ifdef CRAY
		CURS(&ONE);
#else
		curs_(&ONE);
#endif
#endif
		if (AlignStructs(sstruct,1)) CombineStructs(sstruct,0,1);
		update_model = 1;
		update_struct();
#if defined(VMS) || defined(UNDERSC)
		curs(&ZERO);
#else
#ifdef CRAY
		CURS(&ZERO);
#else
		curs_(&ZERO);
#endif
#endif
	   } else {
	        if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"You can not align a protein and a small molecule\nUse interactive docking under the alignment icon.",0)) 
		break;
	   }
	} else {
	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Structure should be in the range\n 1 to # of structures",0)) 
		break;
	}
	break;
   }
   RedrawSTR();
   return(0);
}

void inichg(iopt)
int iopt;
{
  int i,ne = 0;

  if (!xison) return;

  CHGopt = iopt;
  CHGother = 0;

  if (iopt == 1) {
     for (i=0; i<*xyzp->iatoms; i++) {
	if (xyzp->ianz[i] >= 0 && xyzp->ianz[i] < 99) 
	   ne = ne + xyzp->ianz[i];
     }
  } else {
     for (i=0; i<*xyzp->iatoms; i++) {
	if (xyzp->iresid[i] == CHGopt) 
	   if (xyzp->ianz[i] >= 0 && xyzp->ianz[i] < 99) 
		ne = ne + xyzp->ianz[i];
     }
  }

  if (ne % 2) {
	strcpy(chgtmp,"Hint: The neutral molecule has unpaired electrons");
  } else {
	strcpy(chgtmp,"Hint: The neutral molecule has NO unpaired electrons");
  }

  CHGup = 1;
  CHGwin = CreateWindow("Select Total Charge","-200+200",CHGWINW,CHGWINH,
	 		 infobg,infofg,(Window)0);
  XSelectInput(display, CHGwin, 
	ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | 
	ButtonMotionMask | LeaveWindowMask | EnterWindowMask);

  XMapWindow(display,CHGwin);

  WinObj[34].win = &CHGwin;
  WinObj[34].subwin = NULL;
  WinObj[34].butarr = chgbut;
  WinObj[34].numbut = 3;
  WinObj[34].winup = &CHGup;
  WinObj[34].redraw = RedrawCHG;

  DefBut(&chgbut[0], CHGwin, 110, 20+BUTTN, 70, 23,
	"Charge", infobg, -15);
  chgbut[0].style = 1;

  DefBut(&chgbut[1], CHGwin, 25, 35+3*BUTTN, 70, 23,
	"Apply", infobg, -15);

  DefBut(&chgbut[2], CHGwin, 225, 20+BUTTN, 90, 23,
	"Apply", infobg, -15);
  chgbut[2].style = 1;

  if (iopt == 1) {
     icopt = 3;
  } else {
     int aCHGopt;

     aCHGopt = abs(CHGopt);

     if (aCHGopt < MXHETA) {
	if (!clfstrptr->ihqset[aCHGopt]) LigandQ(CHGopt);
	if (clfstrptr->ihqset[aCHGopt]) {
	   if (clfstrptr->ihetq[aCHGopt] < -3 || 
		clfstrptr->ihetq[aCHGopt] > 3) {
		icopt = 7;
	   } else {
		icopt = clfstrptr->ihetq[aCHGopt] + 3;
	   }
	} else {
	   icopt = 3;
	}
     } else {
	icopt = 3;
     }
  }

  if (icopt > 7) {
	chgbut[0].str = copt[7];
  } else {
	chgbut[0].str = copt[icopt];
  }
  chgbut[2].str = eems[ieemopt];

  qboxstr(&qboxes[QCHRG2],&CHGwin,1,0,190,25,25+2*BUTTN,
	150,QBOXHIGH,2,"Total Charge","",10,QREAL,2000,-1,dummyproc);
  qboxes[QCHRG2].explstr = "Partial charge of selected residue\n";
  qboxes[QCHRG2].active = 0;

}

void RedrawCHG()
{
   int i;

   if (!CHGup) return;

   butje(CHGwin,0,0,CHGWINW,CHGWINH,4,0,0,1,None,0,0,0,0);

   for (i=0; i < 3; i++) DrwBut(&chgbut[i]);

   LineString(CHGwin, chgtmp, 25, 35);
   LineString(CHGwin, "Total Charge: ", 25, 35+BUTTN);
   if (CHGother) PromptBox(&qboxes[QCHRG2]);
}

int ButtonsCHG(i)
int i;
{
   LSSTRU List;

   switch(i) {
   case 0:
	List.list = copt; List.nents = 8;
	if (DoPopUp(CHGwin,
	        chgbut[0].x+35,chgbut[0].y-2*BUTTH,
	        &List,&icopt,1) == -1) break;
	if (icopt <= 6) {
	   chgbut[0].str = copt[icopt];
	   DrwBut(&chgbut[0]);
	} else {
	   CHGother = 1;
	   qboxes[QCHRG2].active = 1;
	   RedrawCHG();
	}
	return(0);
	break;
   case 1:
	XDestroyWindow(display,CHGwin);CHGup = 0;
	*Sincp = ieemopt+1;
	if (CHGother) {
	   if (strlen(qboxes[QCHRG2].str) > 0) {
		*itot = atoi(qboxes[QCHRG2].str);
	   }
	} else {
	   *itot = icopt - 3;
	}

	if (CHGopt == 1) {
	    LigandHydroQ(1,1,1,*itot);
#ifdef DOGL
	    if (*fancy) {
		oghet(0);
	    } else {
		oglines();
	    }
	    update_model = 0;
#else
	    update_model = 1;
#endif
	    update_struct();

	} else {
	    int aCHGopt;

	    aCHGopt = abs(CHGopt);

	    if (aCHGopt < MXHETA) {
		if (CHGother) {
		   if (strlen(qboxes[QCHRG2].str) > 0) {
			clfstrptr->ihetq[aCHGopt] = atoi(qboxes[QCHRG2].str);
		   }
		} else {
		   clfstrptr->ihetq[aCHGopt] = icopt - 3;
		}
	    }

	    if (ieemopt == 4) {
#if defined(VMS) || defined(UNDERSC)
		calgas(&CHGopt,&ZERO,&CHGstat);
#else
#ifdef CRAY
		CALGAS(&CHGopt,&ZERO,&CHGstat);
#else
		calgas_(&CHGopt,&ZERO,&CHGstat);
#endif
#endif
	    } else {
#if defined(VMS) || defined(UNDERSC)
		eem(Sincp,&CHGopt,&CHGstat);
#else
#ifdef CRAY
		EEM(Sincp,&CHGopt,&CHGstat);
#else
		eem_(Sincp,&CHGopt,&CHGstat);
#endif
#endif
	    }
#ifdef DOGL
	    update_model = 0;
#else
	    update_model = 1;
#endif
	    update_struct();
	}
	return(0);
	break;
   case 2:
	{
	List.list = eems; List.nents = 5;

	if (DoPopUp(CHGwin,chgbut[2].x+1,
		chgbut[2].y+BUTTH,&List,&ieemopt,0) == -1) return(0);
	chgbut[2].str = eems[ieemopt];
	DrwBut(&chgbut[2]);
	}
	break;
   }
   return(0);
}

#if defined(VMS) || defined(UNDERSC)
void initsrf()
#else
#ifdef CRAY
void INITSRF()
#else
void initsrf_()
#endif
#endif
{
  if (SRFup) return;   

  SRFup = 1;

  srfsep = 1;
  srftyp = 1;
  SRFwin = CreateWindow("Create Surface","-0+0",SRFWINW,SRFWINH,
	 		 infobg,infofg,(Window)0);
  subSRF = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],SRFwin);
  XSelectInput(display, SRFwin, SubstructureNotifyMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask |
	LeaveWindowMask | PointerMotionMask | EnterWindowMask);
  XMapWindow(display,SRFwin);

  WinObj[31].win = &SRFwin;
  WinObj[31].subwin = &subSRF;
  WinObj[31].butarr = srfbut;
  WinObj[31].numbut = 6;
  WinObj[31].winup = &SRFup;
  WinObj[31].redraw = RedrawSRF;

  DefBut(&srfbut[0], SRFwin, 50, 25, 15, 15,
	" ", infobg, -15);
  srfbut[0].explstr = "Color code the electrostatic potential\ncalculated from point charges onto the surface";

  DefBut(&srfbut[1], SRFwin, 50, 50, 15, 15,
	" ", infobg, -15);
  srfbut[1].explstr = "Use only nearby (fast) or all (slow)\npoint charges to calculate the potential";

  DefBut(&srfbut[2], SRFwin, 50, 130, 100, 23,
	"Create Surface", infobg, -15);
  srfbut[2].explstr = "Create surface of selected residues.\nClick 2nd MB on residue ->Add to Surface";

  DefBut(&srfbut[3], SRFwin, 210, 25, 50, 23,
	"Color", infobg, -15);
  srfbut[3].explstr = "When no potential is mapped\nselect color of surface";

  DefBut(&srfbut[4], SRFwin, 50, 75, 15, 15,
	" ", infobg, -15);
  srfbut[4].explstr = "Use a separate grid for each residue.\nYields higher quality but slower surfaces";

  DefBut(&srfbut[5], SRFwin, 50, 100, 120, 23,
	" ", infobg, -15);
  srfbut[5].explstr = "Use solvent accessible surface or\napproxim. electron density surfaces";

  srfbut[5].str = srf2opt[srftyp];
  srfbut[3].fg = -cursrfcoli;

  if (hlpsrf->srfmap) {
	TogDown(&srfbut[0]);
  } else {
	TogUp(&srfbut[0]);
  }

  if (hlpsrf->srfloc) {
	TogDown(&srfbut[1]);
  } else {
	TogUp(&srfbut[1]);
  }

  if (srfsep) {
	TogDown(&srfbut[4]);
  } else {
	TogUp(&srfbut[4]);
  }
}


void RedrawSRF()
{
   if (!SRFup) return;

   butje(SRFwin,0,0,SRFWINW,SRFWINH,4,0,0,1,None,0,0,0,0);

   DrwBut(&srfbut[0]);
   DrwBut(&srfbut[1]);
   DrwBut(&srfbut[2]);
   DrwBut(&srfbut[3]);
   DrwBut(&srfbut[4]);
   DrwBut(&srfbut[5]);

   LineString(SRFwin, "Map Electrostatic Pot.", 70, 35);
   LineString(SRFwin, "Local potential (fast)", 70, 60);
   LineString(SRFwin, "Each Res. Separate Surf.", 70, 85);
   LineString(SRFwin, "Surface type", 175, 115);

}

int ButtonsSRF(i)
int i;
{
   int j,k,calc, NStmp;

   switch(i) {
   case 0:
	hlpsrf->srfmap = 1 - TogBut(&srfbut[0]);
	break;
   case 1:
	hlpsrf->srfloc = 1 - TogBut(&srfbut[1]);
	break;
   case 2:
	update_model = 0;
	XDestroyWindow(display,SRFwin);SRFup = 0;
	calc = 1;

	if (srftyp) {

	   NStmp = NSurf[istruct];

	   if (hlpsrf->srfmap) {
		molsrf(cursrfcoli,1,1);
	   } else {
		molsrf(cursrfcoli,1,0);
	   }

	} else {

	   NStmp = NSurf[istruct];
	   if (hlpsrf->srfmap) hlpsrf->srfmap = 3;
	   if (srfsep) {
	     if (DEBUG) fprintf(stderr,"surface residues\n");
	     for (j=0; j<calfptr->ncalf; j++) {
		if (calfptr->iams[j]) {
		   if (DEBUG) fprintf(stderr,"%d\n",j);
                   for (k=0; k<*xyzp->iatoms; k++) {
			if (xyzp->iresid[k] == j+1) {xyzp->isurf[k] = 1;}
			else {xyzp->isurf[k] = 0;}
		   }
#if defined(VMS) || defined(UNDERSC)
	   	   asurf(&hlpsrf->srfmap,&calc);csrft(xyzp->isurf);
#else
#ifdef CRAY
	   	   ASURF(&hlpsrf->srfmap,&calc);CSRFT(xyzp->isurf);
#else
	   	   asurf_(&hlpsrf->srfmap,&calc);csrft_(xyzp->isurf);
#endif
#endif
		}
	     }
	     for (j=4; j<hetptr.NHetAtm; j++) {
		if (calfptr->ihets[j]) {
		   if (DEBUG) fprintf(stderr,"%d\n",j);
                   for (k=0; k<*xyzp->iatoms; k++) {
			if (xyzp->iresid[k] == -j) {xyzp->isurf[k] = 1;}
			else {xyzp->isurf[k] = 0;}
		   }
#if defined(VMS) || defined(UNDERSC)
	   	   asurf(&hlpsrf->srfmap,&calc);csrft(xyzp->isurf);
#else
#ifdef CRAY
	   	   ASURF(&hlpsrf->srfmap,&calc);CSRFT(xyzp->isurf);
#else
	   	   asurf_(&hlpsrf->srfmap,&calc);csrft_(xyzp->isurf);
#endif
#endif
		}
	     }
	   } else {
#if defined(VMS) || defined(UNDERSC)
	     alasrf();asurf(&hlpsrf->srfmap,&calc);csrft(xyzp->isurf);
#else
#ifdef CRAY
	     ALASRF();ASURF(&hlpsrf->srfmap,&calc);CSRFT(xyzp->isurf);
#else
	     alasrf_();asurf_(&hlpsrf->srfmap,&calc);csrft_(xyzp->isurf);
#endif
#endif
	   }
	}
	for (j=0; j<calfptr->ncalf; j++) calfptr->iams[j] = 0;
	for (j=0; j<MXHETA; j++) calfptr->ihets[j] = 0;
	for (k=NStmp; k<NSurf[istruct]; k++) 
	    for (j=0; j<4; j++) 
		diffuseColor[istruct][k][j] = cursrfcol[0][j];
	dispsf();
	break;
   case 3:
	if (DoPopUp(SRFwin,
		srfbut[3].x-8,srfbut[3].y+BUTTH,
		NULL,&cursrfcoli,0) == -1) break;
#ifdef DOGL
	if (has_opengl) {
	   cursrfcol[0][0] = ((GLfloat) colorr[cursrfcoli]) / 65535.0 ;
	   cursrfcol[0][1] = ((GLfloat) colorg[cursrfcoli]) / 65535.0 ;
	   cursrfcol[0][2] = ((GLfloat) colorb[cursrfcoli]) / 65535.0 ;
	   cursrfcol[0][3] = 1.0;
	   srfbut[3].fg = -cursrfcoli;
	   DrwBut(&srfbut[3]);
	}
#endif
	break;
   case 4:
	srfsep = 1 - TogBut(&srfbut[4]);
	break;
   case 5:
	{
	LSSTRU List;
	List.list = srf2opt; List.nents = 2; int iii;
	if (DoPopUp(SRFwin,
		srfbut[5].x-8,srfbut[5].y+BUTTH,
		&List,&srftyp,0) == -1) break;
	srfbut[5].str = srf2opt[srftyp];
	DrwBut(&srfbut[5]);
	}
	break;
   }
}

void GenSVG(imxe,svgs)
int *imxe;
SVGFSTRUC **svgs;
{
  char str[500];
  int n,i;

  if (getob()) {
	if (COO[istruct]->fname == NULL) {
	   *svgs = NULL;
	   *imxe = NFLS;
	   return;
	}
	if (strstr(COO[istruct]->fname,".sdf")) {
	   if (!COO[istruct]->svgdone) {
		sprintf(str,"/bin/rm /tmp/b*.svg");
		n = strlen(str);
#if defined(VMS) || defined(UNDERSC)
		exstr(str,&n,&ZERO);
#else
#ifdef CRAY
		EXSTR(str,&n,&ZERO);
#else
		exstr_(str,&n,&ZERO);
#endif
#endif
		if (OBloc == 1) {
		   sprintf(str,
		   "%sobabel -isdf %s --gen2D -m -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
		   exepath[0],COO[istruct]->fname);

		} else if (OBloc == 2) {
		   sprintf(str,
		   "/usr/bin/obabel -isdf %s --gen2D -m -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
		   COO[istruct]->fname);
		} else {
		   sprintf(str,
		   "/usr/local/bin/obabel -isdf %s --gen2D -m -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
		   COO[istruct]->fname);
		}
		n = strlen(str);
		excmd(str,&bcksvg.pid);
		if (COO[istruct]->svgs == NULL && 
			COO[istruct]->ntits == ntits) {
	 	   COO[istruct]->svgs = 
			(SVGFSTRUC *) malloc(sizeof(SVGFSTRUC)*(ntits));
		}

		for (i=bcksvg.CurSVG; i < ntits; i++) {
		   COO[istruct]->svgs[i].ncmd = 0;
		   COO[istruct]->svgs[i].w = 1.0;
		   COO[istruct]->svgs[i].h = 1.0;
		   COO[istruct]->svgs[i].array = NULL;
		}

		GetExact();
#ifdef HASTIMER
		Timer(100,3);
#else
		signal(SIGALRM,handle_svgfile);
		alarm(2);
#endif
		*imxe = 2;
		*svgs = COO[istruct]->svgs;
		bcksvg.UpSVG = 1;
		bcksvg.NUpSVG = ntits;
		bcksvg.istruct = istruct;
	   } else {
		*imxe = 2;
		*svgs = COO[istruct]->svgs;
	   }
	} else if (strstr(COO[istruct]->fname,".mol2")) {
	   if (!COO[istruct]->svgdone) {
		sprintf(str,"/bin/rm /tmp/b*.svg");
		n = strlen(str);
#if defined(VMS) || defined(UNDERSC)
		exstr(str,&n,&ZERO);
#else
#ifdef CRAY
		EXSTR(str,&n,&ZERO);
#else
		exstr_(str,&n,&ZERO);
#endif
#endif
		if (OBloc == 1) {
		   sprintf(str,
		   "%sobabel -imol2 %s --gen2D -m -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
		   exepath[0],COO[istruct]->fname);

		} else if (OBloc == 2) {
		   sprintf(str,
		   "/usr/bin/obabel -imol2 %s --gen2D -m -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
		   COO[istruct]->fname);
		} else {
		   sprintf(str,
		   "/usr/local/bin/obabel -imol2 %s --gen2D -m -d -osvg -xC -xd -O /tmp/b.svg &> /dev/null &",
		   COO[istruct]->fname);
		}

		n = strlen(str);
		excmd(str,&bcksvg.pid);
		if (COO[istruct]->svgs == NULL && 
			COO[istruct]->ntits == ntits) {
	 	   COO[istruct]->svgs = 
			(SVGFSTRUC *) malloc(sizeof(SVGFSTRUC)*(ntits));
		}

		for (i=bcksvg.CurSVG; i < ntits; i++) {
		   COO[istruct]->svgs[i].ncmd = 0;
		   COO[istruct]->svgs[i].w = 1.0;
		   COO[istruct]->svgs[i].h = 1.0;
		   COO[istruct]->svgs[i].array = NULL;
		}

		GetExact();
#ifdef HASTIMER
		Timer(100,3);
#else
		signal(SIGALRM,handle_svgfile);
		alarm(2);
#endif
		*imxe = 2;
		*svgs = COO[istruct]->svgs;
		bcksvg.UpSVG = 1;
		bcksvg.NUpSVG = ntits;
		bcksvg.istruct = istruct;
	   } else {
		*imxe = 2;
		*svgs = COO[istruct]->svgs;
	   }
	} else {
	   *svgs = NULL;
	   *imxe = NFLS;
	}
  } else {
	*svgs = NULL;
	*imxe = NFLS;
  }

}

void initMLT()
{
  int n,i,imxe;
  SVGFSTRUC *svgs;

  COO[istruct]->ntits = ntits;
  COO[istruct]->mlftit = mlftit;

  if (MLTup) {
     if (COO[istruct]->fname != NULL) {
	if (strstr(COO[istruct]->fname,".sdf") ||
	    strstr(COO[istruct]->fname,".mol2")) {
	   getob();
	   if (!COO[istruct]->svgdone) {
		if (rdsvgs()) {
		   GenSVG(&imxe,&COO[istruct]->svgs);
		}
	   }
	   imxe = 2;
	} else {
	   COO[istruct]->svgdone = 1;
	   imxe = NFLS;
	}
     } else {
	imxe = NFLS;
     }
     DefList(&mltlist,MLTwin,DIRX,DIRY,DIRW,DIRH,NULL,
			imxe,COO[istruct]->mlftit,NULL,NULL,NULL,
			&COO[istruct]->ntits,COO[istruct]->svgs);

     RedrawMLT();
     return;   
  }

  if (bcksvg.UpSVG) return;   

  MLTup = 1;
  MLTwide = 0;

  MLTwin = CreateWindow("Multi-mol file","-0+0",MLTWINW,MLTWINH,
	 		 infobg,infofg,(Window)0);
  subMLT = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],MLTwin);
  XSelectInput(display, MLTwin, SubstructureNotifyMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask |
	LeaveWindowMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,MLTwin);

  WinObj[30].win = &MLTwin;
  WinObj[30].subwin = &subMLT;
  WinObj[30].butarr = mltbut;

  if (COO[istruct]->fname != NULL) {
    if (!strstr(COO[istruct]->fname,".sdf") &&
	!strstr(COO[istruct]->fname,".mol2")) {
	Nmltb = 1;
    } else {
	Nmltb = NMLTBUT;
    }
  } else {
    Nmltb = 1;
  }
  WinObj[30].numbut = Nmltb;
  WinObj[30].winup = &MLTup;
  WinObj[30].redraw = RedrawMLT;

  DefBut(&mltbut[0], MLTwin, 35, 420, 50, 23, "Close", infobg, -15);
  mltbut[0].explstr = "Close Window";

  DefBut(&mltbut[1], MLTwin, 35, 250, 160, 23, "Create Fingerprint Index", infobg, -15);
  mltbut[1].explstr = "Prepare for fingerprint searching";

  DefBut(&mltbut[2], MLTwin, 209, 250, 50, 23, "Search", infobg, -15);
  mltbut[2].explstr = "Search fingerprint index for\n similar compounds";

  DefBut(&mltbut[3], MLTwin, 279, 310, 50, 23, "Go->", infobg, -15);
  mltbut[3].explstr = "Search query against fingerprint index";

  DefBut(&mltbut[4], MLTwin, 95, 393, 60, 23, "Save", infobg, -15);
  mltbut[4].explstr = "Save editted .sdf/.mol2 file";
  mltbut[4].style = 1;

  DefBut(&mltbut[5], MLTwin, 35, 393, 50, 23, "AddH", infobg, -15);
  mltbut[5].explstr = "Add hydrogens to .sdf/.mol2 file";
  mltbut[5].style = 1;

  if (!bcksvg.UpSVG && !COO[istruct]->svgdone) {
	if (rdsvgs()) {
	   GenSVG(&imxe,&svgs);
	} else {
	   imxe = 2; 	
	   svgs = COO[istruct]->svgs;
	}
  } else {
	imxe = 2; 	
	svgs = COO[istruct]->svgs;
  }

  DefList(&mltlist,MLTwin,DIRX,DIRY,DIRW,DIRH,NULL,
			imxe,COO[istruct]->mlftit,NULL,NULL,NULL,
			&COO[istruct]->ntits,svgs);
  mltlist.select = mfdata->imol-1;
  if (mltlist.select < 0) mltlist.select = 0;

  qboxstr(&qboxes[QRESF],&MLTwin,0,0,190,35,290,200,35,2,
		"Result file:","res.sdf",0,QSTRING,2000,0,obsrch);

  qboxstr(&qboxes[QQUERY],&MLTwin,0,0,190,35,320,200,35,2,
		"Query file :","",0,QSTRING,2000,0,obsrch);

  qboxstr(&qboxes[QNRES],&MLTwin,0,0,190,35,350,200,35,2,
		"Tanimoto coefficient >=","0.6",4,QPOSREAL,2000,-1,obsrch);

  qboxstr(&qboxes[QSDFO],&MLTwin,0,0,190,160,390,190,QBOXHIGH,2,
		"File:","out",SUBLEN1,QSTRING,2000,0,savsdf); 

  qboxes[QRESF].active = 1;
  WinName(win,mlftit[mltlist.select]);
}


void RedrawMLT()
{
   int i;

   if (!MLTup) return;

   butje(MLTwin,0,0,MLTWINW,MLTWINH,4,0,0,1,None,0,0,0,0);
   butje(MLTwin,0,245,MLTWINW,MLTWIDE,1,0,0,1,None,0,0,0,0);
   butje(MLTwin,0,245+MLTWIDE,MLTWINW,MLTWINH-MLTWIDE,1,0,0,1,None,0,0,0,0);

   RedrawList(&mltlist);

   for (i=0; i < Nmltb; i++) {
	if (!(!MLTwide && i == 3)) DrwBut(&mltbut[i]);
   }

   if (MLTwide) {
	PromptBox(&qboxes[QRESF]);
	PromptBox(&qboxes[QQUERY]);
	PromptBox(&qboxes[QNRES]);
   }

   PromptBox(&qboxes[QSDFO]);
   XFlush(display);
}

int ButtonsMLT(i)
int i;
{
   int j,k;
   char xstr1[MAXCMD];
   char *last1;
   char *dot1;
   int n1,stat;

   switch(i) {
   case 0:
	if (MLTup) {
	    XDestroyWindow(display,MLTwin);
	    MLTup = 0;
	    if (COO[istruct]->fname != NULL) {
		if (strstr(COO[istruct]->fname,".sdf") ||
		    strstr(COO[istruct]->fname,".mol2")) {
		   if (bcksvg.UpSVG) {
			killob();
			bcksvg.UpSVG = 0;
		   }
		}
	    }
	}
	break;
   case 1: 
	stat = 1;
	last1 = COO[istruct]->fname;
	if (last1 != NULL) {
	   dot1 = strrchr(last1,'.');
	   if (dot1 != NULL) {
		n1 = (int) (dot1 - last1);
		strncpy(xstr1,last1,n1);
		xstr1[n1] = '\0';
		strcat(xstr1,".fs");
	   } else {
		stat = 0;
	   }
	} else {
	   stat = 0;
	}

	if (stat) {
	   if (access(xstr1,F_OK) == 0) {
		if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
	"A fingerprint index already exists for this file.\n Refresh index ?",1)) {
		   obfp();
		}
	   } else {
	      obfp();
	   }
	} else {
	   obfp();
	}
	break;
   case 2: 
	stat = 1;
	last1 = COO[istruct]->fname;
	if (last1 != NULL) {
	   dot1 = strrchr(last1,'.');
	   if (dot1 != NULL) {
		n1 = (int) (dot1 - last1);
		strncpy(xstr1,last1,n1);
		xstr1[n1] = '\0';
		strcat(xstr1,".fs");
	   } else {
		stat = 0;
	   }
	} else {
	   stat = 0;
	}

	if (stat) {
	   if (access(xstr1,F_OK) != 0) {
		if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
	"No fingerprint index exists for this file.\n First create index ",1)) { }
	   } else {
		XResizeWindow(display, MLTwin, MLTWINW, MLTWINH+200);
		size_hints.flags =  USSize;
		size_hints.width = MLTWINW;
		size_hints.height = MLTWINH;
		XSetNormalHints(display, MLTwin, &size_hints);
		XResizeWindow(display, MLTwin, MLTWINW,size_hints.height);
		MLTwide = 1;
		RedrawMLT();
	   }
	}
	break;
   case 3: 
	obsrch(xstr1);
	break;
   case 4: {
	int imltopt; LSSTRU List;
	List.list = mltopt; List.nents = 3;
	ParseFields(&COO[istruct]->memfil);
	if (DoPopUp(MLTwin,mltbut[4].x+1,
		mltbut[4].y+BUTTH-50,&List,&imltopt,0) == -1) break;
	switch (imltopt) {
	case 0:
		getstemp(stemp);

		strcat(stemp,".sdf");

		if (strstr(COO[istruct]->fname,".sdf")) {
		   wrtfilmem(stemp,&COO[istruct]->memfil);
		   qboxes[QSDFO].callback = savsdf;
		} else if (strstr(COO[istruct]->fname,".mol2")) {
		   WrtSDFs(stemp,&COO[istruct]->memfil);
		   qboxes[QSDFO].callback = savsdf;
		}

		wrsvgs(stemp);

		break;
	case 1:
		getstemp(stemp);

		strcat(stemp,".mol2");

		if (strstr(COO[istruct]->fname,".sdf")) {
		   WrtMol2s(stemp,&COO[istruct]->memfil);
		   qboxes[QSDFO].callback = savmol2;
		} else if (strstr(COO[istruct]->fname,".mol2")) {
		   wrtfilmem(stemp,&COO[istruct]->memfil);
		   qboxes[QSDFO].callback = savmol2;
		}
		wrsvgs(stemp);
		break;
	case 2:	{
		int imltopt; LSSTRU List;
		List.list = FLDS.FldNames; List.nents = FLDS.nfields;
		if (DoPopUp(MLTwin,mltbut[4].x+1,
			mltbut[4].y+BUTTH-30,&List,&imltopt,0) == -1) break;
		if (FLDS.FldNames[0] != NULL) {
		   char *last1;
		   char *dot1;
		   int n1=0;

		   if (!FLDS.editted) {
			last1 = COO[istruct]->fname;
		   } else {
			strcpy(stemp,qboxes[QSDFO].str);
			dot1 = strrchr(stemp,'.');
			if (dot1 == NULL) strcat(stemp,".");
			last1 = stemp;
		   }

		   if (last1 != NULL) {
			dot1 = strrchr(last1,'.');
			if (dot1 != NULL) {
	   		   n1 = (int) (dot1 - last1);
			   strncpy(stemp,last1,n1);
			   stemp[n1] = '\0';
			   strcat(stemp,"_");
			   strcat(stemp,FLDS.FldNames[imltopt]);
		   	   strcat(stemp,".txt");
			} else {
			   break;
			}
		   } else {
			break;
		   }
		   strcpy(qboxes[QSDFO].str,stemp);
		   PromptBox(&qboxes[QSDFO]); 
		   wrtfields(qboxes[QSDFO].str,&COO[istruct]->memfil,imltopt);
		} else {
		   strcpy(molwstr,"No fields found !");
		   StatusStr(0,1);
		   DoCan(event.xbutton.x_root, event.xbutton.y_root,
			"No Fields found !",0);
		   RedrawMLT();
		}
		}
		break;
	}
	}
	break;
   case 5: 
	if (strstr(COO[istruct]->fname,".sdf")) {
	   int isdfopt; LSSTRU List;
	   List.list = sdfopt; List.nents = 4;
	   if (DoPopUp(MLTwin,mltbut[5].x+1,
		mltbut[5].y+BUTTH-50,&List,&isdfopt,0) == -1) break;
	   RedrawMLT();
	   AddHs(&COO[istruct]->memfil,isdfopt);
	} else {
	    strcpy(cmdstr, "extra options only available for .sdf files !");
	    if (DoCan(event.xbutton.x_root,event.xbutton.y_root,cmdstr,
		0)) {}
	}
	break;
   }
}

void initPHRM()
{
  int n,i;

  PHRMup = 1;

  PHRMwin = CreateWindow("Pharmacophore query editor","-0+0",PHRMWINW,PHRMWINH,
	 		 infobg,infofg,(Window)0);
  subPHRM = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],PHRMwin);

  XSelectInput(display, PHRMwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,PHRMwin);

  WinObj[43].win = &PHRMwin;
  WinObj[43].subwin = &subPHRM;
  WinObj[43].butarr = PHRMbut;
  WinObj[43].numbut = PHRMBUT;
  WinObj[43].winup  = &PHRMup;
  WinObj[43].redraw = RedrawPHRM;

  DefBut(&PHRMbut[0], PHRMwin, 35, 320, 50, 23, "Close", infobg, -15);
  PHRMbut[0].explstr = "Close Window";

  DefBut(&PHRMbut[1], PHRMwin, 90, 320, 50, 23, "Save", infobg, -15);
  PHRMbut[1].explstr = "Save Pharmacophore Query";

  DefBut(&PHRMbut[2], PHRMwin, 145, 320, 50, 23, "Open", infobg, -15);
  PHRMbut[2].explstr = "Open Pharmacophore Query";

  DefBut(&PHRMbut[3], PHRMwin, 300, 40, 50, 23, "Create", infobg, -15);
  PHRMbut[3].explstr = "Add Pharmacophore Feature";

  DefBut(&PHRMbut[4], PHRMwin, 300, 70, 50, 23, "Delete", infobg, -15);
  PHRMbut[4].explstr = "Delete Pharmacophore Feature";

  DefBut(&PHRMbut[5], PHRMwin, 35, 250, 50, 23, "Apply", infobg, -15);
  PHRMbut[5].explstr = "Finalize Pharmacophore Feature";

  DefBut(&PHRMbut[6], PHRMwin, 90, 250, 120, 23, " ", infobg, -15);
  PHRMbut[6].explstr = "Choose Feature Type";

  DefBut(&PHRMbut[7], PHRMwin, 200, 320, 50, 23, "Search", infobg, -15);
  PHRMbut[7].explstr = "Search .sdf file with pharmacophore";

  DefList(&PHRMlist,PHRMwin,DIRX,DIRY,DIRW-20,DIRH,NULL,
			10,pharm.str,NULL,NULL,NULL,
			&pharm.NSelFeat,NULL);

  PHRMlist.select = 0;
  PHRMlist.wwin = 300;

  qboxstr(&qboxes[QPHRMT],&PHRMwin,0,0,190,35,10,200,35,2,
		"Title:","res.json",0,QSTRING,2000,0,dummyproc);
  strcpy(qboxes[QPHRMT].str,mkjson());

  qboxstr(&qboxes[QPHRMR],&PHRMwin,0,0,190,35,285,200,35,2,
		"Radius :","",0,QREAL,2000,-1,PHRMrad);

  qboxes[QRESF].active = 1;
  WinName(win,"Pharmacophore query editor");
}

void RedrawPHRM()
{
   int i;

   if (!PHRMup) return;

   butje(PHRMwin,0,0,PHRMWINW,PHRMWINH,4,0,0,1,None,0,0,0,0);

   RedrawList(&PHRMlist);

   for (i=0; i < PHRMBUT; i++) {
	DrwBut(&PHRMbut[i]);
   }

   PromptBox(&qboxes[QPHRMT]);
   PromptBox(&qboxes[QPHRMR]);

   XFlush(display);
}

int ButtonsPHRM(i)
int i;
{
   int j,k;

   switch(i) {
   case 0:
	if (PHRMup) {
	    XDestroyWindow(display,PHRMwin);
	    dispsf();
	    PHRMup = 0;
	}
	break;
   case 1: 
	WriteJSON(qboxes[QPHRMT].str);
	break;
   case 2: 
	gsel.qbrfile = 1;
	gsel.subopt = 0;
	gsel.flist.select = -1;
	gsel.Callwin = PHRMwin;
	strcpy(gsel.pntr," ");
	strcpy(qboxes[QSUBSTR].str,".json");
	strcpy(gsel.substr,".json");
	getfiles(&gsel,gsel.lastdir);
	FileSelectList(&gsel);

	break;
   case 3: 
	if (FeatSel != -1) {
	    pharm.NSelFeat++;
	    pharm.index[pharm.NSelFeat-1] = FeatSel;
	    pharm.array[FeatSel].incl = 1;
	    pharm.str[pharm.NSelFeat-1] = (char *) malloc(sizeof(char)*17);
	    strcpy(pharm.str[pharm.NSelFeat-1],FeatStr[pharm.array[FeatSel].type]);
	    PHRMbut[6].str = FeatStr[pharm.array[FeatSel].type];
	    sprintf(qboxes[QPHRMR].str,"%f", 
		pharm.array[pharm.index[pharm.NSelFeat-1]].rad*0.52917706);
	    PHRMlist.select = pharm.NSelFeat-1;
	    if (PHRMup) {
		ogfeatures();
		dispsf();
		XMapRaised(display,PHRMwin);
		RedrawPHRM();
	    }
	}
	break;
   case 4:  {
	int n,i;

	n = PHRMlist.select;

	pharm.array[pharm.index[n]].incl = 0;
	for (i=n; i < pharm.NSelFeat-1; i++) {
	   pharm.index[i] = pharm.index[i+1];
	   pharm.str[i]   = pharm.str[i+1];
	}
	pharm.NSelFeat--;
	if (pharm.NSelFeat < 0) pharm.NSelFeat = 0;
	if (pharm.NSelFeat) {
	   if (n > pharm.NSelFeat-1) PHRMlist.select = pharm.NSelFeat - 1;
	} else {
	   PHRMlist.select = 0;
	}
	UpdPHRM();
	
	}
	break;
   case 5: 
	strcpy(pharm.str[PHRMlist.select],
		FeatStr[pharm.array[pharm.index[PHRMlist.select]].type]);
	pharm.array[pharm.index[PHRMlist.select]].rad  = 
		atof(qboxes[QPHRMR].str) / 0.52917706;
	UpdPHRM();
	break;

   case 6: {
	int type,i,ind,fnd;
	float x,y,z;
	LSSTRU List;
	List.list = FeatStr; List.nents = 6;
	if (DoPopUp(PHRMwin,PHRMbut[6].x+20,PHRMbut[6].y,
			&List,&type,0) == -1) break;
	ind = pharm.index[PHRMlist.select];
	if (ind == -1) {
	   DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"First create features only then \n can they be selected !",0);
	   break;
	}
	x = pharm.array[ind].cor[0];
	y = pharm.array[ind].cor[1];
	z = pharm.array[ind].cor[2];

	fnd = 0;

        for (i=0; i<pharm.nfeat; i++) {
	   if ( pharm.array[i].cor[0] == x &&
		pharm.array[i].cor[1] == y &&
		pharm.array[i].cor[2] == z) {
		if (pharm.array[i].type == type) {
		   fnd = 1;
		   PHRMbut[6].str = FeatStr[type];
		   DrwBut(&PHRMbut[6]);
		   pharm.array[ind].incl = 0;
		   pharm.index[PHRMlist.select] = i;
		   pharm.array[pharm.index[PHRMlist.select]].incl = 1;
		}
	   }
	}

	if (!fnd) {
	   DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"Could not find annotated feature of the \n specified kind with those coordinates.",0);
	}

	UpdPHRM();
	}
	break;
   case 7: initPSRCH(qboxes[QPHRMT].str);
	break;

   deafult:
	break;

   }
}

void initPSRCH(query)
char *query;
{
  int n,i;

  PSRCHup = 1;
  PSRCHquery = query;

  PSRCHwin = CreateWindow("Pharmacophore Search Database","-0+0",
	PSRCHWINW,PSRCHWINH, infobg,infofg,(Window)0);

  subPSRCH = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],PSRCHwin);

  XSelectInput(display, PSRCHwin, SubstructureNotifyMask |
	KeyPressMask | ExposureMask | ButtonPressMask | ButtonReleaseMask |
	LeaveWindowMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,PSRCHwin);

  WinObj[44].win = &PSRCHwin;
  WinObj[44].subwin = &subPSRCH;
  WinObj[44].butarr = PSRCHbut;
  WinObj[44].numbut = PSRCHBUT;
  WinObj[44].winup  = &PSRCHup;
  WinObj[44].redraw = RedrawPSRCH;

  DefBut(&PSRCHbut[0], PSRCHwin, 95, 100, 55, 23, "Close", infobg, -15);
  PSRCHbut[0].explstr = "Close Window";

  DefBut(&PSRCHbut[1], PSRCHwin, 35, 100, 55, 23, "Search", infobg, -15);
  PSRCHbut[1].explstr = "Search DB with Pharmacophore Query";

  DefBut(&PSRCHbut[2], PSRCHwin, 35, 40, 150, 23, "Create DB Index", infobg, -15);
  PSRCHbut[2].explstr = "Create search index for DB/sdf file";

  DefBut(&PSRCHbut[3], PSRCHwin, 250, 8, 50, 23, "Open", infobg, -15);
  PSRCHbut[3].explstr = "Open DB/.sdf file";

  qboxstr(&qboxes[QSCSDF],&PSRCHwin,0,0,190,35,10,200,35,2,
		"Database:","",0,QSTRING,2000,0,dummyproc);

  qboxstr(&qboxes[QCRIND],&PSRCHwin,0,0,190,35,70,200,35,2,
		"Results:","",0,QSTRING,2000,0,dummyproc);
  strcpy(qboxes[QCRIND].str,"phrm.sdf");

  qboxes[QSCSDF].active = 1;
  WinName(win,"Pharmacophore Search Database");
}

void RedrawPSRCH()
{
   int i;

   if (!PSRCHup) return;

   butje(PSRCHwin,0,0,PSRCHWINW,PSRCHWINH,4,0,0,1,None,0,0,0,0);

   for (i=0; i < PSRCHBUT; i++) {
	DrwBut(&PSRCHbut[i]);
   }

   PromptBox(&qboxes[QSCSDF]);
   PromptBox(&qboxes[QCRIND]);

   XFlush(display);
}

int ButtonsPSRCH(i)
int i;
{
   int j,k,n;
   char cmdfil[512];
   char *dbtmp;
   char *resf;
   char str[500];
   char line[MAXCMD];
   FILE *f;

   switch(i) {
   case 0:
	if (PSRCHup) {
	    XDestroyWindow(display,PSRCHwin);
	    dispsf();
	    PSRCHup = 0;
	}
	break;
   case 1: 
	if (access(qboxes[QCRIND].str,F_OK) == 0) {
	    fprintf(stderr,"File: %s exists !\nMoved to .org\n",
		qboxes[QCRIND].str);
	    rename(qboxes[QCRIND].str,mkext(qboxes[QCRIND].str,".sdf.org"));
	    resf = mkext(qboxes[QCRIND].str,".svgs");
	    if (access(resf,F_OK) == 0) {
		rename(resf,mkext(resf,".svgs.org"));
	    }
	}
	dbtmp = mkdb();
	if (PHRMloc) {
#if defined(DARWIN)
		strcpy(str,"/tmp/log");
		sprintf(cmdfil,
		"%spharmer dbsearch -dbdir %s -in %s -reduceconfs=1 -out %s > %s",
		exepath[0],dbtmp,PSRCHquery,qboxes[QCRIND].str,str);
#else
		sprintf(cmdfil,
		"%spharmer dbsearch -dbdir %s -in %s -reduceconfs=1 -out %s 2>&1 | tee /tmp/log",
		exepath[0],dbtmp,PSRCHquery,qboxes[QCRIND].str);
#endif
	} else {
		sprintf(cmdfil,
		"/usr/local/bin/pharmer dbsearch -dbdir %s -in %s -reduceconfs=1 -out %s 2>&1 | tee /tmp/log",
		dbtmp,PSRCHquery,qboxes[QCRIND].str);
	}
	n = strlen(cmdfil);
#if defined(VMS) || defined(UNDERSC)
	curs(&ONE);
#else
#ifdef CRAY
	CURS(&ONE);
#else
	curs_(&ONE);
#endif
#endif

#if defined(VMS) || defined(UNDERSC)
	exstr(cmdfil,&n,&ZERO);
#else
#ifdef CRAY
	EXSTR(cmdfil,&n,&ZERO);
#else
	exstr_(cmdfil,&n,&ZERO);
#endif
#endif

#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
	f  = fopen("/tmp/log","r");
	if (f == NULL) {
	   fprintf(stderr,"Error opening log file /tmp/log\n");
	} else {
/*
	   while(1) {
		if (fgets(line,MAXCMD,f) == NULL) break;
		if (strstr(line,"NumResults:")) {
	   	   DoCan(event.xbutton.x_root, event.xbutton.y_root,line,0);
	   	   break;
		}
	   }
*/
	   nshfile++;
	   if (nshfile > MXSHFILS-1) nshfile = MXSHFILS-1;
	   else ShowFile("/tmp/log",NULL,&shfiles[nshfile]);
	}
	qboxes[QREADF].qbinct = 480;
	strcpy(qboxes[QSUBSTR].str,"");

	break;
   case 2: 
	if (strcmp(qboxes[QSCSDF].str,"") == 0) {
	   DoCan(event.xbutton.x_root, event.xbutton.y_root,
		"You have not selected a .sdf file yet !",0);
	   break;
	}
	dbtmp = mkdb();
	if (PHRMloc) {
		sprintf(cmdfil,
		"%spharmer dbcreate -dbdir %s -in %s",exepath[0],
		dbtmp,qboxes[QSCSDF].str);
	} else {
		sprintf(cmdfil,
		"/usr/local/bin/pharmer dbcreate -dbdir %s -in %s",
		dbtmp,qboxes[QSCSDF].str);
	}
	n = strlen(cmdfil);
	if (isdir(dbtmp)) {
	   sprintf(cmdfil,"Directory %s exists !\nIf you want to create a new DB,\nfirst remove the old one !\n",dbtmp);
	   DoCan(event.xbutton.x_root, event.xbutton.y_root,cmdfil,0);
	   break;
	}
#if defined(VMS) || defined(UNDERSC)
	curs(&ONE);
#else
#ifdef CRAY
	CURS(&ONE);
#else
	curs_(&ONE);
#endif
#endif

#if defined(VMS) || defined(UNDERSC)
	exstr(cmdfil,&n,&ZERO);
#else
#ifdef CRAY
	EXSTR(cmdfil,&n,&ZERO);
#else
	exstr_(cmdfil,&n,&ZERO);
#endif
#endif

#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
	break;
   case 3: 
	gsel.qbrfile = 1;
	gsel.subopt = 0;
	gsel.flist.select = -1;
	gsel.Callwin = PSRCHwin;
	strcpy(gsel.pntr," ");
	strcpy(qboxes[QSUBSTR].str,".sdf");
	strcpy(gsel.substr,".sdf");
	getfiles(&gsel,gsel.lastdir);
	FileSelectList(&gsel);
	break;
   default:
	break;
   }
}

#define MXCMD 30
#define MAXNAM 512

int ButtonsQEDIT(i)
int i;
{
   int j,k;
   char *ptr;

   switch(i) {
   case 0:
	if (QEDITup) {
	   shfiles[0].COMMlist.list.list[shfiles[0].COMMlist.select] =
		qboxes[QEDIT].str;
	   RedrawList(&shfiles[0].COMMlist);
	}
	break;

   case 1:
	if (QEDITup) {
	    XDestroyWindow(display,QEDITwin);
	    dispsf();
	    QEDITup = 0;
	}
	break;

   case 2:
	if (shfiles[0].nOpen3Dcomm < MXCMD-1) {
	   ptr = (char *) malloc(sizeof(char)*(MAXNAM+1));
	   strcpy(ptr,"");
	   shfiles[0].Open3Dcomms[shfiles[0].nOpen3Dcomm] = ptr;
	   shfiles[0].COMMlist.list.list[shfiles[0].nOpen3Dcomm] = ptr;
	   qboxes[QEDIT].str = shfiles[0].COMMlist.list.list[
			shfiles[0].nOpen3Dcomm];
	   shfiles[0].COMMlist.select = shfiles[0].nOpen3Dcomm;
	   shfiles[0].nOpen3Dcomm++;
	   RedrawList(&shfiles[0].COMMlist);
	   PromptBox(&qboxes[QEDIT]);
	} else {
	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Exceded MXCMD number of commands",0)) {}
	}
	break;

   case 3:
#ifdef DO_PIPE
	rdqsarc_pipe();
#else
	rdqsarc();
#endif
	break;

   default:
        break;
   }
}

void UpdateQEDIT(SHFILSTRU *sh)
{
  int n;

  n = Gen_Commands(0,&shfiles[0]);
  Gen_Commands(1,&shfiles[0]);
  shfiles[0].COMMlist.list.list = shfiles[0].Open3Dcomms;
  shfiles[0].COMMlist.list.nents = &shfiles[0].nOpen3Dcomm;
  if (QEDITup) RedrawQEDIT(sh);
}

void RedrawQEDIT(SHFILSTRU *sh)
{
   int i;

   if (!QEDIT) return;

   butje(QEDITwin,0,0,QEDITWINW,QEDITWINH,4,0,0,1,None,0,0,0,0);

   RedrawList(&sh->COMMlist);

   for (i=0; i < QEDITBUT; i++) {
	DrwBut(&QEDITbut[i]);
   }

   PromptBox(&qboxes[QEDIT]);

   XFlush(display);
}

void initQEDIT(SHFILSTRU *sh)
{
  int n;

  QEDITup = 1;

  QEDITwin = CreateWindow("open3DQSAR edit commands","-0+0",QEDITWINW,QEDITWINH,
	 		 infobg,infofg,(Window)0);
  subQEDIT = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],QEDITwin);

  XSelectInput(display, QEDITwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,QEDITwin);

  WinObj[58].win = &QEDITwin;
  WinObj[58].subwin = &subQEDIT;
  WinObj[58].butarr = QEDITbut;
  WinObj[58].numbut = QEDITBUT;
  WinObj[58].winup  = &QEDITup;
  WinObj[58].redraw = RedrawQEDIT;
  WinObj[58].sh = sh;

  DefBut(&QEDITbut[0], QEDITwin, 15, QEDITWINH-150, 50, 23, "Save:", infobg, -15);
  QEDITbut[0].explstr = "Edit Command";

  DefBut(&QEDITbut[1], QEDITwin, 15, QEDITWINH-50, 50, 23, "Close", infobg, -15);
  QEDITbut[1].explstr = "Close Window";

  DefBut(&QEDITbut[2], QEDITwin, 15, QEDITWINH-120, 100, 23, "Add Line", infobg, -15);
  QEDITbut[2].explstr = "Add Open3DQSAR command at the end of the list of commands";

  DefBut(&QEDITbut[3], QEDITwin, 150, QEDITWINH-120, 100, 23, "Run Commands", infobg, -15);
  QEDITbut[3].explstr = "Run Open3DQSAR commands";

  qboxstr(&qboxes[QEDIT],&QEDITwin,0,0,190,65,QEDITWINH-150,400,40,2,
		""," ",0,QSTRING,2000,0,dummyproc);

  qboxes[QEDIT].active = 1;

  n = Gen_Commands(0,&shfiles[0]);
  Gen_Commands(1,&shfiles[0]);

  DefList(&sh->COMMlist,QEDITwin,DIRX,DIRY,QEDITWINW-75,QEDITWINH-200, " ",
		15,sh->Open3Dcomms,NULL,NULL,
		NULL,&sh->nOpen3Dcomm,NULL);

  WinName(win,"QSAR Edit interface");
}

void ChangePosNeg(int ipos,int ineg)
{
#ifdef DOGL
   cursrfcol[0][0] = ((GLfloat) colorr[ipos]) / 65535.0;
   cursrfcol[0][1] = ((GLfloat) colorg[ipos]) / 65535.0;
   cursrfcol[0][2] = ((GLfloat) colorb[ipos]) / 65535.0;

   cursrfcol[1][0] = ((GLfloat) colorr[ineg]) / 65535.0;
   cursrfcol[1][1] = ((GLfloat) colorg[ineg]) / 65535.0;
   cursrfcol[1][2] = ((GLfloat) colorb[ineg]) / 65535.0;
#endif
}

void ResetPosNeg()
{
 int i;
 float blue[4] = {0.0,0.0,1.0,0.8};
 float red[4]  = {1.0,0.0,0.0,0.8};

 for (i = 0; i < 4; i++) cursrfcol[0][i] = blue[i];
 for (i = 0; i < 4; i++) cursrfcol[1][i] = red[i];
 
}

void UpdateContours()
{
  double cnt0,cnt1;
  int srft;

  QSAR.cntvdw = atof(qboxes[QQSARVW].str);
  QSAR.cntele = atof(qboxes[QQSAREL].str);

  ChangePosNeg(3,6);

  NSurf[istruct] = QSAR.vdwsrf;

  cnt0 = QSAR.cntvdw;
  *vlcnt = cnt0;
  *vlcnt2 = -cnt0;

#if defined(VMS) || defined(UNDERSC)
  pltmad(sgrd.denn);
#else
#ifdef CRAY
  PLTMAD(sgrd.denn);
#else
  pltmad_(sgrd.denn);
#endif
#endif


  ChangePosNeg(4,1);

  cnt1 = QSAR.cntele;
  *vlcnt = cnt1;
  *vlcnt2 = -cnt1;

#if defined(VMS) || defined(UNDERSC)
  pltmad(sgrd.denn2);
#else
#ifdef CRAY
  PLTMAD(sgrd.denn2);
#else
  pltmad_(sgrd.denn2);
#endif
#endif

  update_model = 1;
  update_res = -1;

  update_struct();

  ResetPosNeg();

}

void initQSAR()
{
  int n,i;

  QSARup = 1;

  QSARwin = CreateWindow("QSAR interface","-0+0",QSARWINW,QSARWINH,
	 		 infobg,infofg,(Window)0);
  subQSAR = CreateWindow("Subwindow","",10,10,
                            colors[0],colors[15],QSARwin);

  XSelectInput(display, QSARwin, KeyPressMask | ExposureMask | ButtonPressMask 
	| ButtonReleaseMask | ButtonMotionMask | LeaveWindowMask |
	SubstructureNotifyMask | PointerMotionMask | EnterWindowMask);

  XMapWindow(display,QSARwin);

  WinObj[46].win = &QSARwin;
  WinObj[46].subwin = &subQSAR;
  WinObj[46].butarr = QSARbut;
  WinObj[46].numbut = QSARBUT;
  WinObj[46].winup  = &QSARup;
  WinObj[46].redraw = RedrawQSAR;

  DefBut(&QSARbut[0], QSARwin, 300, 360, 50, 23, "Close", infobg, -15);
  QSARbut[0].explstr = "Close Window";

  DefBut(&QSARbut[1], QSARwin, 15, 360, 50, 23, "Run", infobg, -15);
  QSARbut[1].explstr = "Run QSAR session";

  DefBut(&QSARbut[2], QSARwin, 250, 10, 100, 23, "Open .SDF file", infobg, -15);
  QSARbut[2].explstr = "Open .SDF file with aligned structures";

  DefBut(&QSARbut[3], QSARwin, 250, 70, 100, 23, "Activities", infobg, -15);
  QSARbut[3].explstr = "Text file with one activiy per line";

  DefBut(&QSARbut[4], QSARwin, 110, 100, 100, 23, "Field", infobg, -15);
  QSARbut[4].explstr = "Choose between Molden or open3DQSAR generated fields";

  QSAR.fldopt = 0;
  QSARbut[4].str = fldopts[QSAR.fldopt];
  QSARbut[4].style  = 1;

  DefBut(&QSARbut[5], QSARwin, 110, 160, 100, 23, "CV on/Off", infobg, -15);
  QSARbut[5].explstr = "Choose between Cross-validation On or Off";

  QSAR.cv = 0;
  QSARbut[5].str = cvopts[QSAR.cv];
  QSARbut[5].style  = 1;

  DefBut(&QSARbut[6], QSARwin, 110, 200, 100, 23, "Cutoff On/Off", infobg, -15);
  QSARbut[6].explstr = "Switch On or Off cutoff for min., max. field value";

  QSAR.cut = 1;
  QSARbut[6].str = cvopts[QSAR.cut];
  QSARbut[6].style  = 1;

  DefBut(&QSARbut[7], QSARwin, 80, 360, 70, 23, "Show Log", infobg, -15);
  QSARbut[7].explstr = "Show contents of qsar.log file";

  QSAR.cutmin = -30.0;
  QSAR.cutmax =  30.0;

  QSAR.cntvdw =  0.003;
  QSAR.cntele =  0.0015;
  strcpy(QSAR.dat,"bind.dat");

  DefBut(&QSARbut[8], QSARwin, 160, 360, 50, 23, "Edit", infobg, -15);
  QSARbut[8].explstr = "Edit commands to be send to Open3DQSAR";

  DefBut(&QSARbut[9], QSARwin, 220, 360, 50, 23, "Save", infobg, -15);
  QSARbut[9].explstr = "Save opengl scene to molden.ogl";

  qboxstr(&qboxes[QQSAR],&QSARwin,0,0,190,15,10,225,35,2,
		"SDF file:"," ",0,QSTRING,2000,0,dummyproc);

  qboxstr(&qboxes[QQSARO],&QSARwin,0,0,190,15,40,225,35,2,
		"output .plt file:","",0,QSTRING,2000,0,dummyproc);

  qboxstr(&qboxes[QQSARB],&QSARwin,0,0,190,15,70,225,35,2,
		"activities:","",0,QSTRING,2000,0,dummyproc);

  qboxstr(&qboxes[QQSARP],&QSARwin,0,0,190,15,130,225,35,2,
		"Principal Components:","5",0,QPOSINT,2000,0,dummyproc);

  qboxstr(&qboxes[QQSARMN],&QSARwin,0,0,190,35,230,195,35,2,
		"Field Cutoff Min.:","-30.0",0,QREAL,2000,0,dummyproc);

  qboxstr(&qboxes[QQSARMX],&QSARwin,0,0,190,35,260,195,35,2,
		"Field Cutoff Max.:","30.0",0,QPOSREAL,2000,0,dummyproc);

  qboxstr(&qboxes[QQSARVW],&QSARwin,0,0,190,15,290,250,35,2,
		"Van der Waals  contour level:","0.003",0,QPOSREAL,2000,0,UpdateContours);

  qboxstr(&qboxes[QQSAREL],&QSARwin,0,0,190,15,320,250,35,2,
		"Electrostatics contour level:","0.003",0,QPOSREAL,2000,0,UpdateContours);

  WinName(win,"QSAR interface");
}

void RedrawQSAR()
{
   int i;

   if (!QSARup) return;

   butje(QSARwin,0,0,QSARWINW,QSARWINH,4,0,0,1,None,0,0,0,0);

   ULineString(QSARwin,"Choose field:",15,115);
   ULineString(QSARwin,"Cross:",15,175);
   ULineString(QSARwin,"Validation",15,188);
   ULineString(QSARwin,"CutOff:",15,215);

   for (i=0; i < QSARBUT; i++) {
	DrwBut(&QSARbut[i]);
   }

   PromptBox(&qboxes[QQSAR]);
   PromptBox(&qboxes[QQSARO]);
   PromptBox(&qboxes[QQSARB]);
   PromptBox(&qboxes[QQSARP]);
   if (QSAR.cut) {
	PromptBox(&qboxes[QQSARMN]);
	PromptBox(&qboxes[QQSARMX]);
   }
   PromptBox(&qboxes[QQSARVW]);
   PromptBox(&qboxes[QQSAREL]);

   XFlush(display);
}

int ButtonsQSAR(i)
int i;
{
   int j,k;

   switch(i) {
   case 0:
	if (QSARup) {
	    XDestroyWindow(display,QSARwin);
	    dispsf();
	    QSARup = 0;
	}
	break;
   case 1: 
	strcpy(QSAR.sdf,qboxes[QQSAR].str);
	if (access(QSAR.sdf,F_OK) != 0) {
	    DoCan(event.xbutton.x_root, event.xbutton.y_root,
		"Non existent .sdf file !\n",0);
	} else {
	   strcpy(QSAR.act,qboxes[QQSARB].str);
	   if (access(QSAR.act,F_OK) != 0) {
	       DoCan(event.xbutton.x_root, event.xbutton.y_root,
		"Non existent .txt file !\n",0);
	   } else {
		strcpy(QSAR.plt,qboxes[QQSARO].str);
		QSAR.pc = atoi(qboxes[QQSARP].str);
		if (QSAR.cut) {
		   QSAR.cutmin = atof(qboxes[QQSARMN].str);
		   QSAR.cutmax = atof(qboxes[QQSARMX].str);
		}
		QSAR.cntvdw = atof(qboxes[QQSARVW].str);
		QSAR.cntele = atof(qboxes[QQSAREL].str);
		UpdateQEDIT(&shfiles[0]);
#ifdef DO_PIPE
		rdqsar_pipe();
#else
		rdqsar();
#endif
	   }
	}
	break;
   case 2: 
	gsel.qbrfile = 1;
	gsel.subopt = 2;
	gsel.flist.select = -1;
	gsel.Callwin = QSARwin;
	strcpy(gsel.pntr," ");
	strcpy(gsel.substr,".sdf");
	strcpy(gsel.label,".SDF file:");
//	getfiles(&gsel,gsel.lastdir);
	getfiles(&gsel,"./");
	FileSelectList(&gsel);

	break;
   case 3: 
	gsel.qbrfile = 1;
	gsel.subopt = 3;
	gsel.flist.select = -1;
	gsel.Callwin = QSARwin;
	strcpy(gsel.pntr," ");
	strcpy(gsel.substr,".txt");
	strcpy(gsel.label,".txt file:");
//	getfiles(&gsel,gsel.lastdir);
	getfiles(&gsel,"./");
	FileSelectList(&gsel);

	break;
   case 4:  { 
	LSSTRU List; List.list = fldopts; List.nents = 2;

	if (DoPopUp(QSARwin, QSARbut[4].x+1,QSARbut[4].y+BUTTH,
					&List,&QSAR.fldopt,0) == -1) break;
	   QSARbut[4].str = fldopts[QSAR.fldopt];
	   UpdateQEDIT(&shfiles[0]);
	}

	break;
   case 5: {
	LSSTRU List; List.list = cvopts; List.nents = 2;

	if (DoPopUp(QSARwin, QSARbut[5].x+1,QSARbut[5].y+BUTTH,
					&List,&QSAR.cv,0) == -1) break;
	   QSARbut[5].str = cvopts[QSAR.cv];
	   UpdateQEDIT(&shfiles[0]);
	}

	break;

   case 6: {
	LSSTRU List; List.list = cvopts; List.nents = 2;

	if (DoPopUp(QSARwin, QSARbut[6].x+1,QSARbut[6].y+BUTTH,
					&List,&QSAR.cut,0) == -1) break;
	   QSARbut[6].str = cvopts[QSAR.cut];
	   UpdateQEDIT(&shfiles[0]);

	}
	break;

   case 7: 
	ShowFile("qsar.log","BGN COMMAND",&shfiles[0]);
	break;

   case 8: 
	{

	strcpy(QSAR.sdf,qboxes[QQSAR].str);
	if (access(QSAR.sdf,F_OK) != 0) {
	    DoCan(event.xbutton.x_root, event.xbutton.y_root,
		"Non existent .sdf file !\n",0);
	} else {
	   strcpy(QSAR.act,qboxes[QQSARB].str);
	   if (access(QSAR.act,F_OK) != 0) {
	       DoCan(event.xbutton.x_root, event.xbutton.y_root,
		"Non existent .txt file !\n",0);
	   } else {
		strcpy(QSAR.plt,qboxes[QQSARO].str);
		QSAR.pc = atoi(qboxes[QQSARP].str);
		if (QSAR.cut) {
		   QSAR.cutmin = atof(qboxes[QQSARMN].str);
		   QSAR.cutmax = atof(qboxes[QQSARMX].str);
		}
		QSAR.cntvdw = atof(qboxes[QQSARVW].str);
		QSAR.cntele = atof(qboxes[QQSAREL].str);
		initQEDIT(&shfiles[0]);
	   }
	}
	}
	break;
   case 9: 
#if defined(VMS) || defined(UNDERSC)
	curs(&ONE);
	wrtall();
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ONE);
	wrtall();
	CURS(&ZERO);
#else
	curs_(&ONE);
	wrtall();
	curs_(&ZERO);
#endif
#endif
	strcpy(molwstr,"Wrote file molden.ogl");
	StatusStr(0,0);
	break;

   deafult:
	break;

   }
}

#if defined(VMS) || defined(UNDERSC)
void dlystr()
#else
#ifdef CRAY
void DLYSTR()
#else
void dlystr_()
#endif
#endif
{

   if (! *ideltm) return;
#ifdef HASTIMER
	Timer(*ideltm,0);
#endif
}

void delayt()
{
   if (! *ideltm) return;
#ifdef HASTIMER
   fprintf(stderr,"ideltm %d\n",*ideltm);
   Timer(*ideltm,1);
#endif
}

void WinName(Window win,char *wname)
{
   if (XStringListToTextProperty(&wname,1,&windowProp)) {
	XSetWMName(display,win, &windowProp);
	XFree(windowProp.value);
   }
}

int AddAce(ires)
int ires;
{
   int hs[3],i,iatje,atm,row,itel;

/* look for N to which cap is to be attached */

   for (i=0; i < 3; i++) hs[i] = -1;

   if (ires == -1) {

	row = GetRow(1);
	if (row < 0) return(0);

	row = izz(row,0)-1;
	if (row < 0) return(0);

	atm = zmptrp->imap[row]-1;
	if (atm < 0) return(0);

   } else {
	atm = calfptr->icalf[ires-1][1]-1;
	if (atm < 0) return(0);
   }

   itel = 0;
   for (i=0; i < xyzp->iconn[atm*(MXCON+1)]; i++) {
	iatje = xyzp->iconn[atm*(MXCON+1)+1+i]-1;
	if (xyzp->ianz[iatje] == 1 && itel < 3) {
		hs[itel] = MapAtom(iatje+1);
		itel++;
	}
   }

   if (hs[0] > hs[1]) {
	itel = hs[0]; hs[0] = hs[1]; hs[1] = itel;
   }

   if (hs[0] > hs[2]) {
	itel = hs[0]; hs[0] = hs[2]; hs[1] = itel;
   }

   if (hs[1] > 0) {
      AddFrag(ACE,6,120.0,0.0,hs[1],1,1,1); 
      zmptrp->bet[hs[1]] = 180.0;
      SetQZME();
   }
   if (hs[2] > 0) {
      DelLine(hs[2],1,0,NULL);
      SetQZME();
   }
   make_aa();
   UpdateZME();

   return(1);
}

int AddCap(ires)
int ires;
{
   int icap,row,orow,iatje,i;

   icap = 0;
   for (i=0; i < calfptr->nchain; i++) {
	if (ires == calfptr->ianf[i]) icap = 1;
	if (ires == calfptr->islu[i]) icap = 2;
   }
   if (icap == 0) {
	strcpy(ZMEerr,"Not end or begin chain !");
	RedrawStatus();
   } else if (icap == 1) {
	if (!AddAce(ires)) return(0);
	SetQZME();
	update_res = -1;
	update_model = 1;
   } else if (icap == 2) {
	row = calfptr->icalf[ires-1][2]-1;
	if (row < 0) return(0);
	orow = -1;
	for (i=0; i < xyzp->iconn[row*(MXCON+1)]; i++) {
	   iatje = xyzp->iconn[row*(MXCON+1)+1+i]-1;
	   if (xyzp->ianz[iatje] == 8) {
		orow = MapAtom(iatje+1);
		break;
	   }
	}
	if (orow < 0) return(0);
	AddFrag(NME,6,109.471,180.0,orow,1,1,1);
	SetQZME();
	update_res = -1;
	update_model = 1;
   }
   return(1);

}

int GetFrag(int iopt, int x, int y)
{
   LSSTRU List; int ifrg; int perio; int ichl; int iamin; int iret; int minone;
   int idomp; 

   if (iopt) {
      List.list = fragmnts; List.nents = nfrags; 
      if (*ipdbon) List.nents = nfrags + 4;
   } else {
      List.list = fragments; List.nents = nfrag; 
   }

   iret = -1;

   if ( ! (ZMEup && ! ZMEsel && ! ZMEmode && ! Selecting)) return(iret);


   if (iopt) {
	if (DoPopUp(win,x,y,&List,&ifrg,0) == -1) return(iret);
   } else {
	if (DoPopUp(ZMEwin,
		ZMEbut[ZMEFRG].x+1,ZMEbut[ZMEFRG].y-7*BUTTH,
		&List,&ifrg,0) == -1) return(iret);
   }
   if (iopt) ifrg++;

   if (ifrg < 21) calfptr->issdon = 0;

   idomp = 0;
   if (ialtyp == NULL) idomp = 1;
   else if (*ialtyp != 1) idomp = 1;
   else idomp = 0;

   if (idomp) map_prop();

   switch (ifrg) {
	case 0: 
	   if (iopt) break;
	   qboxstr(&qboxes[QFRAG],NULL,1,0,-1,DEFQX,DEFQY,
		QBOXWIDE,QBOXHIGH,0,"Filename ? ",NULL,0,0,
		540,0,dummyproc);
	   break;
	case 1: AddXH3(6,1); iret = 1; break;
	case 2: AddFrag(CHCH2,5,120.0,180.0,-1,1,1,1); iret = 1; break;
	case 3: AddFrag(CHO,3,120.0,180.0,-1,1,1,1); iret = 1; break;
	case 4: AddFrag(COOH,4,120.0,180.0,-1,1,1,1); iret = 1; break;
	case 5: AddXH3(7,1); iret = 1; break;
	case 6: AddFrag(OH,2,109.471,180.0,-1,1,1,1); iret = 1; break;
	case 7: AddFrag(CHCH,5,90.0,180.0,-1,1,1,1); iret = 1; break;
	case 8: AddCycloHexane(); iret = 1; break;
	case 9: AddFrag(benzyl,BENZLEN,120.0,180.0,-1,1,1,1); iret = 1; break;
	case 10: AddFrag(cyclopentane,PENT,109.471,-90.0,-1,1,1,1); iret = 1; break;
	case 11: AddFrag(pyrrole,PYRROLE,120.0,180.0,-1,1,1,1); iret = 1; break;
	case 12: AddFrag(CL,1,109.471,180.0,-1,1,1,1); iret = 1; break;
	case 13: AddFrag(BR,1,109.471,180.0,-1,1,1,1); iret = 1; break;
	case 14: AddFrag(I,1,109.471,180.0,-1,1,1,1); iret = 1; break;
	case 15: AddFrag(OCH3,5,109.471,180.0,-1,1,1,1); iret = 1; break;
	case 16: AddFrag(SH,2,109.471,180.0,-1,1,1,1); iret = 1; break;
	case 17: AddFrag(NO2,3,117.38,180.0,-1,1,1,1); iret = 1; break;
	case 18: AddFrag(CH4,5,117.38,180.0,-1,1,1,1); iret = 1; break;
	case 19: 
		if (iopt) {
		   if (!AddAce(-1)) return 0;
		   iret = 1; break;
		}
		RedrawZME(); XFlush(display); XSync(display,False);
		List.list = Periodic; List.nents = 2;
		if (DoPopUp(ZMEwin,
			ZMEbut[ZMEFRG].x+1,ZMEbut[ZMEFRG].y-6*BUTTH,
			&List,&perio,0) == -1) break;
		List.list = ChainLength; List.nents = 10;
		RedrawZME(); XFlush(display); XSync(display,False);
		if (perio == 2) break;
		if (DoPopUp(ZMEwin,
			ZMEbut[ZMEFRG].x+1,ZMEbut[ZMEFRG].y-6*BUTTH,
			&List,&ichl,0) == -1) break;
		*ipdbon = 0;
		scrfrg(perio,ichl); iret = 1; break;
	case 20: 

        /* add FOR cap (iopt==1) or add amino acid */

		if (iopt) {
		   AddFrag(FOR,3,120.0,180.0,-1,1,1,1); 
		   iret = 1; break;
		}
		RedrawZME(); XFlush(display); XSync(display,False);
		List.list = AmiOpt; List.nents = 4;
		if (DoPopUp(ZMEwin,
			ZMEbut[ZMEFRG].x+1,ZMEbut[ZMEFRG].y+7*BUTTH,
			&List,&iamin,0) == -1) break;
		if (iamin == 1 || iamin == 2 || iamin == 3) {
  	   	   if (DoCan(event.xbutton.x_root,
			event.xbutton.y_root,
			"Click on an atom of the residue",0)) {
		   }
		   bflag = 1; 
		   if (iamin == 1) bretval = 321;
		   else bretval = 322;
		   if (iamin == 3) ReplaceAmino = 1;
		} else {
		   List.list = AminoCaps; List.nents = NAminos+4;
		   if (DoPopUp(ZMEwin,
			ZMEbut[ZMEFRG].x+1,ZMEbut[ZMEFRG].y-10*BUTTH,
			&List,&iamin,0) == -1) break;
		   minone = -1;
		   if (iamin == 14) {
			AddAmino(iamin,&minone, -70.0,113.0, 
			NULL,NULL,NULL,NULL,NULL,iconform,1,1); 
		   } else if (iamin == 20) {
			AddFrag(ACE,6,120.0,180.0,-1,1,1,1); 
		   } else if (iamin == 21) {
			AddFrag(FOR,3,120.0,180.0,-1,1,1,1); 
		   } else if (iamin == 22) {
			AddFrag(NME,6,109.471,180.0,-1,1,1,1); 
		   } else if (iamin == 23) {
			AddXH3(7,1);
		   } else {
			AddAmino(iamin,&minone, -119.0,113.0, 
			NULL,NULL,NULL,NULL,NULL,iconform,1,1); 
			calfptr->reson[calfptr->ncalf-1] = 1;
			update_model = 1;
		   }
		}
		iret = 1; break;
	case 21: 
		if (iopt) {
		   AddFrag(NME,6,120.0,180.0,-1,1,1,1); 
		   iret = 1; break;
		}
		if (SEQup) {
		    XMapRaised(display,SEQwin);
		    RedrawSEQ();
		} else {
		    InitSEQ(event.xbutton.x_root,
			event.xbutton.y_root+20);
		}
		iret = 0; break;
	case 22: 
		AddFrag(NH2,3,120.0,180.0,-1,1,1,1); 
		iret = 1; break;
	}

  return(iret);
}

void exit_casel()
{
	DisDir = 0;
	DisAmino = -1;
	CurAmino = -1;
	update_casel = 0;
	strcpy(molwstr,"Exiting Amino Acid range select");
	StatusStr(0,1);
}

void motion_screen(inct,incp)
int *inct;
int *incp;
{

   if (expldat.active) return;

   if (event.xmotion.window == win) {

      while(XCheckTypedWindowEvent(display, win, MotionNotify,&event));

      if ( *ball && (moving || gmoving)) {
        update_model = 0;
	if (XCheckMaskEvent(display,ButtonReleaseMask,&event)) {
	   if ((*fancy || *fullgl) && has_opengl) 
		motion(event.xmotion.x, event.xmotion.y, 1);
	   moving = 0;
	} else {
	   while (XCheckMaskEvent(display,ButtonMotionMask,&event));
	   *incp = (event.xmotion.x - startx);
	   if (btype == 0) { 
		*inct = 421;
	   } else if (btype == 1) {
		*inct = 415;
	   } else if (btype == 2) {
		*inct = 417;
	   } else if (btype == 3) {
		*inct = 422;
	   }
	   doclr();
#if defined(VMS) || defined(UNDERSC)
	   mktrn(inct,incp);
#else
#ifdef CRAY
       	   MKTRN(inct,incp);
#else
       	   mktrn_(inct,incp);
#endif
#endif
	   *incp = (event.xmotion.y - starty);
	   if (btype == 0) { 
		*inct = -421;
	   } else if (btype == 1) {
		*inct = 416;
	   }

#if defined(VMS) || defined(UNDERSC)
	   mktrn(inct,incp);
           if ((*fancy || *fullgl) && has_opengl) 
		motion(event.xmotion.x, event.xmotion.y, 0);
	   else qupd();
#else
#ifdef CRAY
       	   MKTRN(inct,incp);
	   if ((*fancy || *fullgl) && has_opengl) 
		motion(event.xmotion.x, event.xmotion.y, 0);
	   else QUPD();
#else
           mktrn_(inct,incp);
	   if ((*fancy || *fullgl) && has_opengl) 
		motion(event.xmotion.x, event.xmotion.y, 0);
	   else qupd_();
#endif
#endif
	   startx = event.xmotion.x;
	   starty = event.xmotion.y;
	   *inct = 0;
	   XFlush(display);
	   if (!expldat.active) XSync(display, False);
	}
   } else {
	int Ca;

	if (!ZoomSelection && !denmode) {

	     if (*ipdbon) {

	        if (*fancy || *fullgl) {
		   if (update_casel) {
			Ca = FindCa(xyzp->iaton,xyzp->iyp,xyzp->ixp,
			event.xmotion.x,event.xmotion.y,MINDIFF);

			if (Ca >= 0 && DisDir == 0) {
			   if (!calfptr->reson[Ca]) {
				if (Ca + 2  == DisAmino) DisDir = -1;
				if (Ca == DisAmino) DisDir = 1;
			   }
			}

			if (Ca >= 0 && DisDir != 0) {
			   if (Ca+1  == DisAmino + DisDir) {
			      if (calfptr->reson[Ca]) {
				exit_casel();
				Ca = -1;
			      }
			   }
			}

			if (Ca >= 0 && DisDir != 0 && 
				Ca+1 == DisAmino + DisDir &&
				!calfptr->reson[Ca]) {

			   DisAmino = DisAmino + DisDir;
#if defined(VMS) || defined(UNDERSC)
			   actami(&DisAmino,&ZERO,&ONE,&ZERO);
#else
#ifdef CRAY
			   ACTAMI(&DisAmino,&ZERO,&ONE,&ZERO);
#else
			   actami_(&DisAmino,&ZERO,&ONE,&ZERO);
#endif
#endif
#ifdef DOGL
			   ogsarr();
			   ogres(DisAmino,ONE,1);
#else
			   return;
#endif
			}

		   }
		   Ca = FindCa(xyzp->iaton,xyzp->iyp,xyzp->ixp,
			event.xmotion.x,event.xmotion.y,MINDIFF);

		   if (Ca >= 0) {
		           parse_label(Ca,0,xyzp->ixp,xyzp->iyp);
		           if (OMAPup && omapfol && !omaplck) res_dens(Ca,1);
		   } else {
		           Ca = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
				*xyzp->iatoms,
				event.xmotion.x,event.xmotion.y,MINDIFF);
		           if (Ca>=0) parse_labelp(xyzp->iresid[Ca]-1,Ca,
				xyzp->ixp,xyzp->iyp);
		           else parse_labelp(RESUND,0,xyzp->ixp,xyzp->iyp);
		           if (OMAPup && omapfol && !omaplck && Ca > 0) 
				res_dens(Ca,0);
		   }

	        } else {

		   if ((event.xmotion.state & ControlMask) && 
		       (event.xmotion.state & ShiftMask) ) {
		   } else {
			Ca = FindCaP(event.xmotion.x,event.xmotion.y,MINDIFF);

			if (Ca >= 0) {
			   parse_labelp(Ca,0,xyzp->ixp,xyzp->iyp);
			} else {
		   	   Ca = FindSel(xyzp->iaton,xyzp->iyp,xyzp->ixp,0,
				*xyzp->iatoms,
				event.xmotion.x,event.xmotion.y,MINDIFF);
		   	   if (Ca>=0) parse_labelp(xyzp->iresid[Ca]-1,Ca,
				xyzp->ixp,xyzp->iyp);
		   	   else parse_labelp(RESUND,0,xyzp->ixp,xyzp->iyp);
			}
		   }
	        }
	     }

	}
      }
   }

}

void ressel()
{
      int i,j,ires;


	for (ires = 1; ires < calfptr->ncalf+1; ires++ ) {
	   if (calfptr->iams[ires-1]) {
#if defined(VMS) || defined(UNDERSC)
		getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
		GETPDB(&ires,ipdb,ihpdb);
#else
		getpdb_(&ires,ipdb,ihpdb);
#endif
#endif
		for (i=0; i<MXSYM; i++) {
		   if (ipdb[i] > 0) xyzp->iaton[ipdb[i]-1] = 2;
		}

		for (i=0; i<3*MXHSYM; i++) {
		   if (ihpdb[i] > 0) xyzp->iaton[ihpdb[i]-1] = 2;
		}
	   }

	}
}

void clrsave()
{
   int i;

   for (i=0; i<count; i++) 
	if (savecom[i].points != NULL) {
	    free(savecom[i].points);
	    savecom[i].points = NULL;
	}
   cnt = 0;
   count = 0;
   scount = 0;
}

#if defined(VMS) || defined(UNDERSC)
void setsup()
#else
#ifdef CRAY
void SETSUP()
#else
void setsup_()
#endif
#endif
{
   update_sel = 1;
}

static FILE *out;
static int dowrt = 0;
static char ogfil[MAXNAM];
static double z0[] = {0.0,0.0,0.0};
static double zx[] = {1.0,0.0,0.0};
static double zy[] = {0.0,1.0,0.0};

void launchViewer(opt)
int opt;
{
    int pid;

#ifdef DARWIN
    pid = fork();
#else
    pid = vfork();
#endif
    switch(pid) {
    case -1:
          fprintf(stderr,"Couldnt Fork\n");
          break;
    case 0:       /*child */
#ifdef __CYGWIN__
	  if (opt) {
             execlp("./mogl","mogl","-r","-b","0",ogfil,NULL);
	  } else {
             execlp("./mogl","mogl",ogfil,NULL);
	  }
#else
	  if (opt) {
             execlp("moldenogl","moldenogl","-r","-b","0",ogfil,NULL);
	  } else {
             execlp("moldenogl","moldenogl",ogfil,NULL);
	  }
#endif
	  _exit(0);
          break;
    default:      /*parent*/
          break;
    }
}

#if defined(VMS) || defined(UNDERSC)
void oginsp(double *r, double *adjus, int *natoms, int *nat, int *iatclr, int *icol,
#else
#ifdef CRAY
void OGINSP(double *r, double *adjus, int *natoms, int *nat, int *iatclr, int *icol,
#else
void oginsp_(double *r, double *adjus, int *natoms, int *nat, int *iatclr, int *icol,
#endif
#endif

       double *xsym, double *ysym, double *zsym, double *vdwr, 
       int *mopt, int *conn, int *nconn, int *iconn, int *ofil)
{

    dowrt = 1;
    out = fopen(ogfil,"w");

    if (out == NULL) {
          fprintf(stderr,"Unable to open file %s\n",ogfil);
	  dowrt = 0;
	  return;
    }

    fprintf(out,"[MOLDENOGL]\n");
    ogwrmol(r,adjus,natoms,nat,xsym,ysym,zsym,vdwr);

}

#if defined(VMS) || defined(UNDERSC)
void ognorm(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGNORM(double *v1, double *v2, double *v3)
#else
void ognorm_(double *v1, double *v2, double *v3)
#endif
#endif
{
    if (dowrt) fprintf(out,"%f %f %f\n",*v1,*v2,*v3);
}

#if defined(VMS) || defined(UNDERSC)
void ogvert(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGVERT(double *v1, double *v2, double *v3)
#else
void ogvert_(double *v1, double *v2, double *v3)
#endif
#endif
{
    if (dowrt) fprintf(out,"%f %f %f\n",*v1,*v2,*v3);
}

#if defined(VMS) || defined(UNDERSC)
void ogcol(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGCOL(double *v1, double *v2, double *v3)
#else
void ogcol_(double *v1, double *v2, double *v3)
#endif
#endif
{
    if (dowrt) fprintf(out,"%f %f %f\n",*v1,*v2,*v3);
}

void ogwrmol(double *r, double *adjus, int *natoms, int *nat, 
        double *xsym, double *ysym, double *zsym, double *vdwr)
{
      int i,j,k,ia,ja,nconn;
      double dmaxsq, dijsq, st, tmp1[3], tmp2[3];
      int iconn[30];

      if (!dowrt) return;

      if (*adjus != 1.0) {
         fprintf(out,"[MOLECULE] AU CONN\n");
      } else {
         fprintf(out,"[MOLECULE] CONN\n");
      }

      fprintf(out,"%f %f %f\n",r[0],r[1],r[2]);
      fprintf(out,"%d\n",*natoms);
      for (i=0; i<*natoms; i++) {

         ia = nat[i];
	 tmp1[0] = -1.0 * ysym[i] / r[0];
	 tmp1[1] = -1.0 * xsym[i] / r[0];
	 tmp1[2] = -1.0 * zsym[i] / r[0];


         nconn = 0;
         for (j=0; j<*natoms; j++) {

            ja = nat[j];
	    tmp2[0] = -1.0 * ysym[j] / r[0];
	    tmp2[1] = -1.0 * xsym[j] / r[0];
	    tmp2[2] = -1.0 * zsym[j] / r[0];

            dmaxsq = (vdwr[ia] + vdwr[ja]);
            dmaxsq = dmaxsq * dmaxsq;

            dijsq = 0.0;

            st = (xsym[i] - xsym[j])*(*adjus);
	    st *= st;
	    dijsq = dijsq + st;

	    st = (ysym[i] - ysym[j])*(*adjus);
	    st *= st;
	    dijsq = dijsq + st;

	    st = (zsym[i] - zsym[j])*(*adjus);
	    st *= st;
	    dijsq = dijsq + st;

            if (i != j && dijsq < dmaxsq) {
		iconn[nconn] = j+1;
		nconn++;
            }

         }
         fprintf(out,"%d %f %f %f %d",nat[i],xsym[i],ysym[i],zsym[i],nconn);
	 for (k=0; k<nconn; k++)
	   fprintf(out," %d",iconn[k]);
         fprintf(out,"\n");
      }

}

#if defined(VMS) || defined(UNDERSC)
void oginid(double *r, double *adjus, int *natoms, int *nat, int *icol,
#else
#ifdef CRAY
void OGINID(double *r, double *adjus, int *natoms, int *nat, int *icol,
#else
void oginid_(double *r, double *adjus, int *natoms, int *nat, int *icol,
#endif
#endif
       double *xsym, double *ysym, double *zsym, double *vdwr,
       double *cnst, int *nnpts1, int *nnpts2, int *iorb, double *dens)
{

   dowrt = 1;
   out = fopen(ogfil,"w");

   if (out == NULL) {
       fprintf(stderr,"Unable to open file %s\n",ogfil);
       dowrt = 0;
       return;
   }

   fprintf(out,"[MOLDENOGL]\n");
   ogwrmol(r,adjus,natoms,nat,xsym,ysym,zsym,vdwr);
   BuildList(r,cnst,nnpts1,nnpts2,iorb,dens);

   if (dowrt) fclose(out);
   dowrt = 0;

   if (!has_opengl) launchViewer(1);

}

#if defined(VMS) || defined(UNDERSC)
void ogspst()
#else
#ifdef CRAY
void OGSPST()
#else
void ogspst_()
#endif
#endif
{

    if (dowrt) fclose(out);
    dowrt = 0;

    if (!has_opengl) launchViewer(1);

}

#if defined(VMS) || defined(UNDERSC)
void parogf(str,nlen)
#else
#ifdef CRAY
void PAROGF(str,nlen)
#else
void parogf_(str,nlen)
#endif
#endif

#ifdef VMS
struct dsc$descriptor_s *str;
#else
#ifdef CRAY
_fcd str;
#else
char *str;
#endif
#endif
int *nlen;

{
  int i;

  if (*nlen >= MAXNAM) { 
	fprintf(stderr,"filename too long !\n");
	*nlen = MAXNAM - 1;
  }
#ifdef VMS
  for (i=0; i<*nlen; i++)
         ogfil[i] = str->dsc$a_pointer[i];
#else
#ifdef CRAY
   strncpy(ogfil,_fcdtocp(str),*nlen);
#else
   for (i=0; i<*nlen+1; i++) ogfil[i] = '\0';
   strncpy(ogfil,str,*nlen);
#endif
#endif

}

#if defined(VMS) || defined(UNDERSC)
void viewer()
#else
#ifdef CRAY
void VIEWER()
#else
void viewer_()
#endif
#endif
{
   if (!has_opengl) launchViewer(0);
}

void BuildList(r,cnst,nnpts1,nnpts2,iorb,dens)
double *r;
double *cnst;
int *nnpts1;
int *nnpts2;
int *iorb;
double *dens;
{

     int i,j,noff1,noff2,npts1,npts2;
     double v[3], rpts;
     double vec1[3], vn1[3];
     float hinv1,hinv2;

/*
     a grid of n*n points has n-1*n-1 squares
     and twice as much triangular polygons
     so 2*(npts-1)**2
     npts is 80 at maximum so lets make it 12800
*/

      npts1 = *nnpts1;
      npts2 = *nnpts2;
      noff1 = npts1/2;
      noff2 = npts2/2;
      rpts = (double) (npts1-1);
      hinv1 = r[1]/ (npts2*r[0]);
      hinv2 = 1.0/ npts1;

      if (dowrt) {
	if (*iorb) {
	   fprintf(out,"[ELEVATIONGRID] \"Orbital %d\"\n",*iorb);
	} else {
	   fprintf(out,"[ELEVATIONGRID] \"Density\"\n");
	}
      }

      for (i=0; i<npts1-1; i++) {
         for (j=0; j<npts2-1; j++) {
/*
        first triangle
*/
            vec1[0] = (double) (j-noff2);
            vec1[1] = (double) (i-noff1);
            vec1[2] = dens[j+i*npts2]*(*cnst)*rpts;

	    znorm(rpts,*cnst,dens,vn1,npts1,npts2,i,j);

#if defined(VMS) || defined(UNDERSC)
            ognorm(&vn1[0],&vn1[1],&vn1[2]);
#else
#ifdef CRAY
            OGNORM(&vn1[0],&vn1[1],&vn1[2]);
#else
            ognorm_(&vn1[0],&vn1[1],&vn1[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
	    ogvert(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
	    OGVERT(&v[0],&v[1],&v[2]);
#else
	    ogvert_(&v[0],&v[1],&v[2]);
#endif
#endif

            vec1[0] = (double) (j+1-noff2);
            vec1[1] = (double) (i-noff1);
            vec1[2] = dens[j+1+i*npts2]*(*cnst)*rpts;

	    znorm(rpts,*cnst,dens,vn1,npts1,npts2,i,j+1);

#if defined(VMS) || defined(UNDERSC)
            ognorm(&vn1[0],&vn1[1],&vn1[2]);
#else
#ifdef CRAY
            OGNORM(&vn1[0],&vn1[1],&vn1[2]);
#else
            ognorm_(&vn1[0],&vn1[1],&vn1[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
	    ogvert(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
	    OGVERT(&v[0],&v[1],&v[2]);
#else
	    ogvert_(&v[0],&v[1],&v[2]);
#endif
#endif

            vec1[0] = (double) (j+1-noff2);
            vec1[1] = (double) (i+1-noff1);
            vec1[2] = dens[j+1+(i+1)*npts2]*(*cnst)*rpts;

	    znorm(rpts,*cnst,dens,vn1,npts1,npts2,i+1,j+1);

#if defined(VMS) || defined(UNDERSC)
            ognorm(&vn1[0],&vn1[1],&vn1[2]);
#else
#ifdef CRAY
            OGNORM(&vn1[0],&vn1[1],&vn1[2]);
#else
            ognorm_(&vn1[0],&vn1[1],&vn1[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
	    ogvert(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
	    OGVERT(&v[0],&v[1],&v[2]);
#else
	    ogvert_(&v[0],&v[1],&v[2]);
#endif
#endif

            vec1[0] = (double) (j-noff2);
            vec1[1] = (double) (i+1-noff1);
            vec1[2] = dens[j+(i+1)*npts2]*(*cnst)*rpts;

	    znorm(rpts,*cnst,dens,vn1,npts1,npts2,i+1,j);

#if defined(VMS) || defined(UNDERSC)
            ognorm(&vn1[0],&vn1[1],&vn1[2]);
#else
#ifdef CRAY
            OGNORM(&vn1[0],&vn1[1],&vn1[2]);
#else
            ognorm_(&vn1[0],&vn1[1],&vn1[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
	    ogvert(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
	    OGVERT(&v[0],&v[1],&v[2]);
#else
	    ogvert_(&v[0],&v[1],&v[2]);
#endif
#endif

         }
      }


}

void crossprd(v1,v2,d)
double *v1;
double *v2;
double *d;
{
/*

       calculates cross product:  (v1) x (v2) = d
                                   ---     ---    -
*/
      int i;
      double dlen;

      d[0] = v2[1]*v1[2]-v2[2]*v1[1];
      d[1] = v2[2]*v1[0]-v2[0]*v1[2];
      d[2] = v2[0]*v1[1]-v2[1]*v1[0];
      dlen = sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);

      if (dlen > 0 ) for (i=0; i<3; i++) d[i] = d[i] / dlen;
}

void CROSS(v1,v2,v3)
double *v1;
double *v2;
double *v3;
{

      v3[0] = v2[1]*v1[2]-v2[2]*v1[1];
      v3[1] = v2[2]*v1[0]-v2[0]*v1[2];
      v3[2] = v2[0]*v1[1]-v2[1]*v1[0];

}

void improduct(double *a, double *b, double *c)
{
      int i;

      *c = 0.0;

      for (i=0; i<3; i++) *c = *c + a[i]*b[i];
}

void crpsin(a,b,c,d)
double *a;
double *b;
double *c;
double *d;
{
/*

       calculates cross product:  (b-a) x (c-a) = d
                                   ---     ---    -
*/
      int i;
      double v1[3],v2[3],dlen;

      for (i=0; i<3; i++) {
         v1[i] = b[i]-a[i];
         v2[i] = c[i]-a[i];
      }

      d[0] = v2[1]*v1[2]-v2[2]*v1[1];
      d[1] = v2[2]*v1[0]-v2[0]*v1[2];
      d[2] = v2[0]*v1[1]-v2[1]*v1[0];
      dlen = sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);

      if (dlen > 0 ) for (i=0; i<3; i++) d[i] = d[i] / dlen;
}

double vln( double *a)
{
      double vl;
      double tot;

      tot = a[0]*a[0]+a[1]*a[1]+a[2]*a[2];

      vl = 0.0;
      if (tot > 0.0) vl = sqrt(tot);

      return(vl);

}

void znorm(double rpts, double cnst, double *dens, double *vn,
	   int npts1, int npts2, int i, int j)
{
     double vl,z1[3],z2[3],z3[3],nx[3],ny[3];
     int k;

     if (j+1 < npts2) {
         z1[0] = 1.0; z1[1] = 0.0;
         z1[2] = cnst*rpts*(dens[j+1+i*npts2]-dens[j+i*npts2]);
         crpsin(z0,z1,zy,z2);
     } else {
         for (k=0; k<3; k++) z2[k] = z0[k];
     }

     if (j-1 >= 0) {
         z1[0] = -1.0; z1[1] = 0.0;
         z1[2] = cnst*rpts*(dens[j-1+i*npts2]-dens[j+i*npts2]);
         crpsin(z0,zy,z1,z3);
     } else {
         for (k=0; k<3; k++) z3[k] = z0[k];
     }

     for (k=0; k<3; k++) nx[k] = z3[k] + z2[k];
     vl = vln(nx);
     for (k=0; k<3; k++) nx[k] = nx[k] / vl;

     if (i+1 < npts1) {
         z1[0] = 0.0; z1[1] = 1.0;
         z1[2] = cnst*rpts*(dens[j+(i+1)*npts2]-dens[j+i*npts2]);
         crpsin(z0,z1,zx,z2);
     } else {
         for (k=0; k<3; k++) z2[k] = z0[k];
     }

     if (i-1 >= 0) {
         z1[0] = 0.0; z1[1] = -1.0;
         z1[2] = cnst*rpts*(dens[j+(i-1)*npts2]-dens[j+i*npts2]);
         crpsin(z0,zx,z1,z3);
     } else {
         for (k=0; k<3; k++) z3[k] = z0[k];
     }

     for (k=0; k<3; k++) ny[k] = z3[k] + z2[k];
     vl = vln(ny);
     for (k=0; k<3; k++) ny[k] = ny[k] / vl;

     for (k=0; k<3; k++) vn[k] = ny[k] - nx[k];
     vl = vln(vn);
     for (k=0; k<3; k++) vn[k] = vn[k] / vl;

}

#if defined(VMS) || defined(UNDERSC)
void initog(int *iwrt)
#else
#ifdef CRAY
void INITOG(int *iwrt)
#else
void initog_(int *iwrt)
#endif
#endif
{
 int i;

 /* just dummy */

  i = *iwrt;

}

#if defined(VMS) || defined(UNDERSC)
void ogbeg(isurf,iorb,cntval)
#else
#ifdef CRAY
void OGBEG(isurf,iorb,cntval)
#else
void ogbeg_(isurf,iorb,cntval)
#endif
#endif
int *isurf;
int *iorb;
double *cntval;
{
      int surf,surfabs;
      double cval;

      if (!dowrt) return;

      surf = *isurf;
      surfabs = abs(surf);

      cval = *cntval;
      if (surfabs == 2) cval = cval * -1.0;

      if (surfabs == 3) {
	   fprintf(out,"[SURFACE] MAPPED \"Density %3d isocontour %7.4f\"\n",*iorb,cval);
      } else {
	if (surf<0) {
	   fprintf(out,"[SURFACE] TRANS COLOR 1.0 1.0 0.0 \"Density %3d isocontour %7.4f\"\n",*iorb,cval);
	} else {
	   fprintf(out,"[SURFACE] \"Orbital %3d isocontour %7.4f\"\n",*iorb,cval);
	}
      }

}

#if defined(VMS) || defined(UNDERSC)
void ogend()
#else
#ifdef CRAY
void OGEND()
#else
void ogend_()
#endif
#endif
{
      int i;

      i = 0;
}


void initnthe() 
{
   int i,j;

   for (i=0; i<MAXSTRUCT; i++) scl[i] = 1.0;
}

double dveclen(double *a)
{
      double vl;
      double tot;

      tot = a[0]*a[0]+a[1]*a[1]+a[2]*a[2];

      vl = 0.0;
      if (tot > 0.0) vl = (double) sqrt(tot);

      return(vl);

}

int getusr(tmps)
char* tmps;
{

   char *tmpf;
   int i,j,status;

   strcpy(tmps,"");
   tmpf = getenv("APPDATA");
   if (tmpf != NULL) {
	strcat(tmps,tmpf);
	j = strlen(tmps);
	for (i=0; i<j; i++)
	   if (tmps[i] == '\\') tmps[i] = '/';
	strcat(tmps,"/Molden");
	if (access(tmps,F_OK) != 0) {
	    status = mkdir(tmps, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	    if (status == -1) {
		fprintf(stderr,"Directory %s not created\n",tmps);
		return(0);
	    }
	}
	strcat(tmps,"/srf");
   }
   return(1);
}

#ifdef DOGL

#ifndef __glut_h__
/* Mouse buttons. */
#define GLUT_LEFT_BUTTON                0
#define GLUT_MIDDLE_BUTTON              1
#define GLUT_RIGHT_BUTTON               2

/* Mouse button  state. */
#define GLUT_DOWN                       0
#define GLUT_UP                         1

/* glutGetModifiers return mask. */
#define GLUT_ACTIVE_SHIFT               1
#define GLUT_ACTIVE_CTRL                2
#define GLUT_ACTIVE_ALT                 4

#endif

#define TRDEF 0.6

static float ribcol[7][4] =
{
  {0.0,0.0,1.0,0.6},
  {1.0,0.0,1.0,0.6},
  {0.0,1.0,0.0,0.6},
  {0.6,0.6,0.6,0.6},
  {0.5,1.0,0.5,0.6},
  {1.0,1.0,1.0,0.6},
  {1.0,0.5,0.5,0.6}
};
 
static int started_ogl = 0;
static int ecol = 2;
static int gbgcol = 6;
static double tr_val = TRDEF;
static int hires = 1;
static int perspon = 1;
static int lines = 0;
static int PERSP = 0;
static int AXES = 0;
static int l1on = 0;
static int l2on = 0;
static int l3on = 1;
static int stacks = 10;
static int DoCap = 0;
static GLfloat fdens = 0.03;
static int DoLights = 0;
static int DoNorms = 0;
static int ColBG = -1;

/* Some <math.h> files do not define M_PI... */
#ifndef M_PI
#define M_PI 3.141592654
#endif
#define TORAD M_PI/180.0

static float materialColor[8][4] =
{
  {0.8, 0.8, 0.8, 1.0},
  {0.8, 0.0, 0.0, 1.0},
  {0.0, 0.8, 0.0, 1.0},
  {0.0, 0.0, 0.8, 1.0},
  {0.0, 0.8, 0.8, 1.0},
  {0.8, 0.0, 0.8, 1.0},
  {0.8, 0.8, 0.0, 1.0},
  {1.0, 0.5, 0.5, 1.0},
};

static float AmbientNul[4] = {0.1,0.1,0.1,0.0};

static float light0_position[MAXSTRUCT][4];
static float light1_position[MAXSTRUCT][4];
static float light2_position[MAXSTRUCT][4];
static float light0_position_def[] = {-2.0, -2.0, 0.0, 1.0};
static float light1_position_def[] = {4.0, 4.0, 4.0, 1.0};
static float light2_position_def[] = {0.0, 0.0, 4.0, 1.0};

static int molon = 1;
static int AmbAndDiff = 0;
static int mmoving = 0;
static int mstartx, mstarty;

static int smoving = 0;
static int sstarty;

#define MXMOL 1000
static GLuint theSurf[MAXSTRUCT][MAXSURF];
static GLuint theMol[MAXSTRUCT][MXMOL];
static GLuint theLines[MAXSTRUCT];
static GLuint theFLines[MAXSTRUCT];
static GLuint thePoints[MAXSTRUCT];
static GLuint theForces[MAXSTRUCT];
static GLuint theSArrow[MAXSTRUCT];
static GLuint theFeat[MAXSTRUCT];
static GLuint theAFeat[MAXSTRUCT];
static GLuint theDipole[MAXSTRUCT];
static GLuint theIntSurf[MAXSTRUCT];
static GLuint theIntSurf2[MAXSTRUCT];
static GLuint theLigSurf[MAXSTRUCT];
static GLuint theBox[MAXSTRUCT];
static GLuint theNorm;
static GLuint theAxes;
static GLuint theBack;
static GLuint theElem_20[MXEL];
static GLuint theElem_20_bs[MXEL];
static GLuint theElem_12[MXEL];
static GLuint theElem_12_bs[MXEL];
static GLuint theElsm;
static GLuint theRes[MAXSTRUCT][NUMCAL];
static GLuint theBck[MAXSTRUCT][NUMCAL];
static GLuint theMon[MAXSTRUCT];
static GLuint theSel[MAXSTRUCT];
static GLUquadricObj *cyl;
static GLUquadricObj *sphere;
static GLUquadricObj *disk;

#define ROTINCR 5.0
static GLfloat xrot = -45.0;
static GLfloat yrot = 240.0;

void ResetRes()
{
   int j;

   for (j=0; j<NUMCAL; j++) {
        glDeleteLists(theRes[istruct][j],1);
	theRes[istruct][j] = -1;
	theBck[istruct][j] = -1;
   }
}

void MoveOne(i)
int i;
{
	int j,k;

	SSdone[i]    = SSdone[i+1];
	NSurf[i]     = NSurf[i+1];
	NMols[i]     = NMols[i+1];
	CMols[i]     = CMols[i+1];

	theLines[i]  = theLines[i+1];
	theFLines[i] = theFLines[i+1];
	thePoints[i] = thePoints[i+1];
	theForces[i] = theForces[i+1];
	theSArrow[i] = theSArrow[i+1];
	theFeat[i]   = theFeat[i+1];
	theAFeat[i]  = theAFeat[i+1];
	theDipole[i] = theDipole[i+1];
	theIntSurf[i] = theIntSurf[i+1];
	theIntSurf2[i] = theIntSurf2[i+1];
	theLigSurf[i] = theLigSurf[i+1];
	theBox[i]    = theBox[i+1];
	theMon[i]    = theMon[i+1];
	theSel[i]    = theSel[i+1];

	for (j=0;j < MAXSURF;j++) {
	   theSurf[i][j] = theSurf[i+1][j];
	   SSon[i][j]    = SSon[i+1][j];
	   SStyp[i][j]   = SStyp[i+1][j];
	   Schain[i][j]   = Schain[i+1][j];
	   sndstr[i][j]  = sndstr[i+1][j];
	   srfvert[i][j] = srfvert[i+1][j];
	   clp[i][j]    = clp[i+1][j];
	   trns[i][j]    = trns[i+1][j];
	   for (k=0;k < 4;k++)  
		diffuseColor[i][j][k] = diffuseColor[i+1][j][k];
	}

	for (j=0;j < NUMCAL;j++) { 
	   theRes[i][j] = theRes[i+1][j];
	   theBck[i][j] = theBck[i+1][j];
	}

	for (j=0;j < MAXMOL;j++)  
	   theMol[i][j] = theMol[i+1][j];

	for (j=0;j < 4;j++) {
	   light0_position[i][j] = light0_position[i+1][j];
	   light1_position[i][j] = light1_position[i+1][j];
	   light2_position[i][j] = light2_position[i+1][j];
	}  

	nwater[i] = nwater[i+1];
	watcoo[i] = watcoo[i+1];
	watanz[i] = watanz[i+1];
	watres[i] = watres[i+1];
	watcon[i] = watcon[i+1];
	watqat[i] = watqat[i+1];
	wattyp[i] = wattyp[i+1];
	watmap[i] = watmap[i+1];

	RedrawSTRC();
}

void RibClear(ist)
int ist;
{
   int j;

   for (j=0; j<4; j++) {
	RIBindex[ist].start[j] = -1;
	RIBindex[ist].end[j] = -1;
   }

   RIBindex[ist].nhelx = 0;
   RIBindex[ist].nbeta = 0;
   RIBindex[ist].nrna = 0;
   RIBindex[ist].ncoil = 0;
}

void initOne(i) 
int i;
{
   int j,k;

   SSdone[i] = -1;
   NSurf[i] = 0;
   NMols[i] = -1;
   CMols[i] = 0;
   theLines[i] = -1;
   theFLines[i] = -1;
   thePoints[i] = -1;
   theForces[i] = -1;
   theSArrow[i] = -1;
   theFeat[i]   = -1;
   theAFeat[i]  = -1;
   theDipole[i] = -1;
   theIntSurf[i] = -1;
   theIntSurf2[i] = -1;
   theLigSurf[i] = -1;
 
   for (j=0; j<4; j++) {
      light0_position[i][j] = light0_position_def[j];
      light1_position[i][j] = light1_position_def[j];
      light2_position[i][j] = light2_position_def[j];
   }
   for (j=0; j<MAXSURF; j++) {
	theSurf[i][j] = -1;
	sndstr[i][j] = NULL;
	srfvert[i][j] = NULL;
	nvert[i][j] = 0;
	nvrtmx[i][j] = 0;
	Schain[i][j] = -1;
	clp[i][j] = 0;
	trns[i][j] = 0;
	for (k=0; k<4; k++) {
	   diffuseColor[i][j][k] = diffColor[j][k];
	   specularColor[j][k] = specColor[k];
	}
   }
   for (j=0; j<MAXMOL; j++) theMol[i][j] = -1;
   for (j=0; j<NUMCAL; j++) {
      theRes[i][j] = -1;
      theBck[i][j] = -1;
   }

   RibClear(i);

   nwater[i] = 0;
   watcoo[i] = NULL;
   watanz[i] = NULL;
   watres[i] = NULL;
   watcon[i] = NULL;
   watqat[i] = NULL;
   wattyp[i] = NULL;
   watmap[i] = NULL;
}

void initthe() 
{
   int i;

   for (i=0; i<MAXSTRUCT; i++) initOne(i);
}

void deletebox()
{
   if (theBox[istruct] > 0) 
	glDeleteLists(theBox[istruct],1);
   theBox[istruct] = -1;
}

void srfprop()
{
	SetSurfColor(omapsrf,7);
        clp[istruct][omapsrf] = 1;
	trns[istruct][omapsrf] = 1;
	if (omapPandN) {
	   trns[istruct][omapsrf] = 0;
	   SetSurfColor(omapsrf,6);
	   SetSurfColor(omapsrf+1,5);
           clp[istruct][omapsrf+1] = 1;
	   trns[istruct][omapsrf+1] = 0;
	}
	TRANS = 0;
}

void DeleteSurface(isrf)
int isrf;
{
   int i,j,k,NStmp;


   if (omapsrf < 0) return;

   NStmp = NSurf[istruct];

   glDeleteLists(theSurf[istruct][isrf],1);
   free(sndstr[istruct][isrf]);
   free(srfvert[istruct][isrf]);

   for (j=0; j<4; j++) {
	if (isrf < RIBindex[istruct].start[j]) {
			RIBindex[istruct].start[j]--;
			RIBindex[istruct].end[j]--;
	} else if (isrf >= RIBindex[istruct].start[j] 
		        && isrf <= RIBindex[istruct].end[j]) {
			RIBindex[istruct].end[j]--;
			if (RIBindex[istruct].start[j] == 
				RIBindex[istruct].end[j]) {
			   RIBindex[istruct].start[j] = -1;
			   RIBindex[istruct].end[j] = -1;
			}
	}
		
   }

   for (j=isrf; j<NSurf[istruct]-1; j++) {
	for (k=0; k<3; k++) 
	   diffuseColor[istruct][j][k] = diffuseColor[istruct][j+1][k];
	theSurf[istruct][j] = theSurf[istruct][j+1];
	SSon[istruct][j] = SSon[istruct][j+1];
	clp[istruct][j] = clp[istruct][j+1];
	trns[istruct][j] = trns[istruct][j+1];
	SStyp[istruct][j] = SStyp[istruct][j+1];
	Schain[istruct][j] = Schain[istruct][j+1];
	sndstr[istruct][j] = sndstr[istruct][j+1];
	srfvert[istruct][j] = srfvert[istruct][j+1];
	nvert[istruct][j] = nvert[istruct][j+1];
	nvrtmx[istruct][j] = nvrtmx[istruct][j+1];
   }
   NSurf[istruct]--;
   if (NSurf[istruct] < 0) NSurf[istruct] = 0;


   for (j=NSurf[istruct]; j < NStmp; j++) { 
	theSurf[istruct][j] = -1;
	SSon[istruct][j] = 0;
	clp[istruct][j] = 0;
	trns[istruct][j] = 0;
	srfvert[istruct][j] = NULL;
	nvert[istruct][j] = 0;
	nvrtmx[istruct][j] = 0;
	sndstr[istruct][j] = NULL;
   }
}

void DeleteActiveSurfaces()
{
  int i,j,k,NStmp;

  i = 0;

  NStmp = NSurf[istruct];

  while (i<NSurf[istruct]) {

	if (SSon[istruct][i]) {

	   glDeleteLists(theSurf[istruct][i],1);
	   free(sndstr[istruct][i]);
	   free(srfvert[istruct][i]);

	   for (j=0; j<4; j++) {
		if (i < RIBindex[istruct].start[j]) {
			RIBindex[istruct].start[j]--;
			RIBindex[istruct].end[j]--;
		} else if (i >= RIBindex[istruct].start[j] 
		        && i <= RIBindex[istruct].end[j]) {
			RIBindex[istruct].end[j]--;
			if (RIBindex[istruct].start[j] == 
				RIBindex[istruct].end[j]) {
			   RIBindex[istruct].start[j] = -1;
			   RIBindex[istruct].end[j] = -1;
			}
		}
		
	   }

	   for (j=i; j<NSurf[istruct]-1; j++) {
		for (k=0; k<3; k++) 
		   diffuseColor[istruct][j][k] = 
			 diffuseColor[istruct][j+1][k];
		theSurf[istruct][j] = theSurf[istruct][j+1];
		SSon[istruct][j] = SSon[istruct][j+1];
		clp[istruct][j] = clp[istruct][j+1];
		trns[istruct][j] = trns[istruct][j+1];
		SStyp[istruct][j] = SStyp[istruct][j+1];
		Schain[istruct][j] = Schain[istruct][j+1];
		sndstr[istruct][j] = sndstr[istruct][j+1];
		srfvert[istruct][j] = srfvert[istruct][j+1];
		nvert[istruct][j] = nvert[istruct][j+1];
		nvrtmx[istruct][j] = nvrtmx[istruct][j+1];
	   }
	   NSurf[istruct]--;
	   if (NSurf[istruct] < 0) NSurf[istruct] = 0;

	} else {
	   i++;
	}
  }

  for (j=NSurf[istruct]; j < NStmp; j++) { 
	theSurf[istruct][j] = -1;
	SSon[istruct][j] = 0;
	clp[istruct][j] = 0;
	trns[istruct][j] = 0;
	srfvert[istruct][j] = NULL;
	nvert[istruct][j] = 0;
	nvrtmx[istruct][j] = 0;
	sndstr[istruct][j] = NULL;
  }
}

void bckgrad() 
{

    glDisable(GL_LIGHTING);           
    glDisable(GL_DEPTH_TEST);         
    glDepthMask(GL_FALSE);            

    glDisable(GL_POLYGON_STIPPLE);    
    glDisable(GL_BLEND);              

    glMatrixMode(GL_MODELVIEW);       
    glPushMatrix();
    glLoadIdentity();                 

    glMatrixMode (GL_PROJECTION);     
    glPushMatrix();
    glLoadIdentity();
    gluOrtho2D(0.0, 1.0, 0.0, 1.0);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();                 

    if (StarNet) {
	theBack = glGenLists(1);
	glNewList(theBack, GL_COMPILE_AND_EXECUTE);
    }

    glBegin(GL_QUADS);
      glColor3fv(&gradcol[1][0]);
      glVertex2f(0.0f, 0.0f);
      glColor3fv(&gradcol[0][0]);
      glVertex2f(0.0f, 1.0f);
      glColor3fv(&gradcol[0][0]);
      glVertex2f(1.0f, 1.0f);
      glColor3fv(&gradcol[1][0]);
      glVertex2f(1.0f, 0.0f);
    glEnd();

    if (StarNet) glEndList();

    glPopMatrix();                     

    glMatrixMode (GL_PROJECTION);
    glPopMatrix();                     

    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();                     

    glEnable(GL_DEPTH_TEST);           
    glDepthMask(GL_TRUE);              
    glEnable(GL_LIGHTING);             
}

static GLuint base;

void makeRasterFont(Display *dpy)
{
    Font id;
    GLuint first, last;
    
    if (labinfo == NULL) {
	id = mfinfo->fid;
	first = (GLuint) mfinfo->min_char_or_byte2;
	last = (GLuint) mfinfo->max_char_or_byte2;
    } else {
	id = labinfo->fid;
	first = (GLuint) labinfo->min_char_or_byte2;
	last = (GLuint) labinfo->max_char_or_byte2;
    }

    last++;

    base = glGenLists((GLsizei) last);
    if (base == 0) {
        fprintf(stderr,"out of display lists\n");
        exit(0);
    }
    glXUseXFont(id, (int) first, (int) last, (int) base);
}

void initPrintStrings(int front)
{
	/*glXMakeCurrent(display,win,cx);*/
	if (front) glDrawBuffer(GL_FRONT);
	glDisable(GL_LIGHTING);           
	glDisable(GL_DEPTH_TEST);         
	glDepthMask(GL_FALSE);            
	glPushAttrib( GL_TRANSFORM_BIT | GL_VIEWPORT_BIT );

	glMatrixMode( GL_PROJECTION );
	glPushMatrix();
	glLoadIdentity();
	glMatrixMode( GL_MODELVIEW );
	glPushMatrix();
}

void endPrintStrings()
{
	glPopMatrix();
	glMatrixMode( GL_PROJECTION );
	glPopMatrix();

	glPopAttrib();

	glFlush();
	glDrawBuffer(GL_BACK);
	glEnable(GL_DEPTH_TEST);           
	glDepthMask(GL_TRUE);              
	glEnable(GL_LIGHTING);             
}

void printString(int x, int y, int init, char *s)
{
   GLfloat r,g,b;
   glDisable(GL_FOG);	  
   if (init) initPrintStrings(1);

	glLoadIdentity();

	y = height  - y;

	glViewport( x - 1, y - 1, 0, 0 );

	r = ((GLfloat) colorr[*ifntcl]) / 65535.0 ;
	g = ((GLfloat) colorg[*ifntcl]) / 65535.0 ;
	b = ((GLfloat) colorb[*ifntcl]) / 65535.0 ;

	glColor3f(r,g,b);
	glRasterPos4f( 0, 0, 1, 1 );

	glPushAttrib(GL_LIST_BIT);
	glListBase((GLuint) base);
	glCallLists((GLsizei) strlen(s), GL_UNSIGNED_BYTE, (unsigned *) s);
	glPopAttrib();

   if (init) endPrintStrings();
   glEnable(GL_FOG);	  
}


static void
setColor(int c)
{
      GLfloat ambientColor[4] = {0.0, 0.0, 0.0, 0.0};
      GLfloat mat_specular[4] = {0.8, 0.8, 0.8, 1.0 };

      glMaterialfv(GL_FRONT_AND_BACK,
        GL_AMBIENT, ambientColor);
      glMaterialfv(GL_FRONT_AND_BACK,
        GL_DIFFUSE, &materialColor[c][0]);
      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
      glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 130);
}


void setAtomColor(int c)
{
      GLfloat tmp_Color[4];
      int i;
      GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };

      tmp_Color[0] = ((GLfloat) colorr[c+1]) / 65535.0 ; 
      tmp_Color[1] = ((GLfloat) colorg[c+1]) / 65535.0 ; 
      tmp_Color[2] = ((GLfloat) colorb[c+1]) / 65535.0 ; 
      tmp_Color[3] = 0.5;

      if (AmbAndDiff) {
         glMaterialfv(GL_FRONT_AND_BACK,
           GL_AMBIENT_AND_DIFFUSE, tmp_Color);
      } else {
         glMaterialfv(GL_FRONT_AND_BACK,
           GL_AMBIENT, AmbientNul);
         glMaterialfv(GL_FRONT_AND_BACK,
           GL_DIFFUSE, tmp_Color);
      }
      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
      glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 100);

}


void ogrod(int ic, float *p1, float *p2, double rad, int hiresol, int dsk)
{
      int i;
      double cosa;
      float angle, vl;
      float v1[3], v2[3], v3[3], p3[3];
      float todeg;

      
      todeg = 45.0 / atan(1.0);

      for (i=0; i<3; i++) {
         v1[i] = p2[i] - p1[i];
         v2[i] = 0.0;
         p3[i] = v1[i]/2.0 + p1[i];
      }
      v2[2] = 1.0;

      improd(v1,v2,&cosa);

      if (fabs(cosa) == 1.0) {

         for (i=0; i<3; i++) v3[i] = 0.0;
         v3[1] = 1.0;
         angle = 0.0;
	 if (cosa < 0) angle = 180.0;

      } else {

         angle = (float) acos(cosa)*todeg;
         cross(v2,v1,v3);
         vl = veclen(v3);
         for (i=0; i<3; i++) v3[i] = v3[i] / vl;

      }


      glPushMatrix();
      glTranslatef(p1[0],p1[1],p1[2]);
      glRotatef(angle,v3[0],v3[1],v3[2]);
      setAtomColor(ic);
      vl = veclen(v1);
      if (hiresol) {
	 gluCylinder( cyl, rad, rad, vl, 15, 1 );
      } else {
	 gluCylinder( cyl, rad, rad, vl, 6, 1 );
	 gluQuadricOrientation(disk, (GLenum)GLU_INSIDE);
	 if (dsk) gluDisk(disk, 0, rad, 6, 1);
         glTranslatef(0.0,0.0,vl);
	 if (dsk == 2) gluDisk(disk, 0, rad, 6, 1);
	 gluQuadricOrientation(disk, (GLenum)GLU_OUTSIDE);
      }
      glPopMatrix();

}

void ogarrow(int ic, float *p1, float *p2, double rad)
{
      int i;
      double cosa, radf;
      float angle, vl, conelen;
      float v1[3], v2[3], v3[3], p3[3];
      float todeg;

      
      radf = 0.5*rad;
      conelen = 0.3;
      todeg = 45.0 / atan(1.0);

      for (i=0; i<3; i++) {
         v1[i] = p2[i] - p1[i];
         v2[i] = 0.0;
         p3[i] = v1[i]/2.0 + p1[i];
      }
      v2[2] = 1.0;

      improd(v1,v2,&cosa);

      if (fabs(cosa) == 1.0) {

         for (i=0; i<3; i++) v3[i] = 0.0;
         v3[1] = 1.0;
         angle = 0.0;
	 if (cosa < 0) angle = 180.0;

      } else {

         angle = (float) acos(cosa)*todeg;
         cross(v2,v1,v3);
         vl = veclen(v3);
         for (i=0; i<3; i++) v3[i] = v3[i] / vl;

      }


      glPushMatrix();
      glTranslatef(p1[0],p1[1],p1[2]);
      glRotatef(angle,v3[0],v3[1],v3[2]);
      if (ic >= 0) setAtomColor(ic);
      vl = veclen(v1);
      v3[0] = 0.0; v3[1] = 0.0; v3[2] = vl - conelen;
      if (v3[2] <= 0.0) v3[2] = conelen;
      gluCylinder( cyl, radf, radf, v3[2], 15, 1 );
      glTranslatef(v3[0],v3[1],v3[2]);
      gluCylinder( cyl, rad, 0.0, conelen, 15, 1 );
      glPopMatrix();

}
#define NSELE 4
int SelElem[NSELE] = {0,5,6,7};

void ogsetel20(int j)
{
      double rad;

      theElem_20[j] = glGenLists(1);
      glNewList(theElem_20[j], GL_COMPILE);
      rad = elmptr->vdwr[j]*1.4/0.52917706;
      gluSphere(sphere, rad, 20, 20);
      glEndList();
}

void ogsetel20_bs(int j)
{
      double rad;

      theElem_20_bs[j] = glGenLists(1);
      glNewList(theElem_20_bs[j], GL_COMPILE);
      rad = elmptr->vdwr[j]*0.5/0.52917706;
      gluSphere(sphere, rad, 20, 20);
      glEndList();
}

void ogsetel12(int j)
{
      double rad;

      theElem_12[j] = glGenLists(1);
      glNewList(theElem_12[j], GL_COMPILE);
      rad = elmptr->vdwr[j]*1.4/0.52917706;
      gluSphere(sphere, rad, 12, 12);
      glEndList();
}

void ogsetel12_bs(int j)
{
      double rad;

      theElem_12_bs[j] = glGenLists(1);
      glNewList(theElem_12_bs[j], GL_COMPILE);
      rad = elmptr->vdwr[j]*0.5/0.52917706;
      gluSphere(sphere, rad, 12, 12);
      glEndList();
}

void ogelem()
{
    int i;
    double rad;

    for (i=0; i<MXEL; i++) {
      theElem_20[i] = -1;
      theElem_20_bs[i] = -1;
      theElem_12[i] = -1;
      theElem_12_bs[i] = -1;
    }

    for (i=0; i<NSELE; i++) {

      ogsetel20(SelElem[i]);
      ogsetel20_bs(SelElem[i]);
      ogsetel12(SelElem[i]);
      ogsetel12_bs(SelElem[i]);

    }

    theElsm = glGenLists(1);
    glNewList(theElsm, GL_COMPILE);
    rad = 0.13/0.52917706;
    gluSphere(sphere, rad, 12, 12);
    glEndList();

}

void ogChkElem()
{
    int i,ia;
    int ElPres[MXEL];

    for (i=0; i<MXEL; i++) ElPres[i] = 0;
    for (i=0; i < *xyzp->iatoms; i++) {
	ia = xyzp->ianz[i]-1;
	ElPres[ia] = 1;
    }

    for (i=0; i<MXEL; i++) {

      if (ElPres[i]) {
	ogsetel20(i);
	ogsetel20_bs(i);
	ogsetel12(i);
	ogsetel12_bs(i);
      }

    }

}

void ogfstsph(int ic, int ia, float *p1, int type)
{

      glPushMatrix();
      glTranslatef(p1[0],p1[1],p1[2]);
      setAtomColor(ic);
      if (type && ! (*ivdwpl == 2)) {
	 glCallList(theElsm);
      } else {
         if (*ivdwpl == 2) {
	   if (*ipdbon && *xyzp->iatoms > 500 && !has_shader) {
	    glCallList(theElem_12_bs[ia]);
	   } else {
	    glCallList(theElem_20_bs[ia]);
	   }
	 } else {
	   if (*ipdbon && *xyzp->iatoms > 500 && !has_shader) {
	    glCallList(theElem_12[ia]);
	   } else {
	    glCallList(theElem_20[ia]);
	   }
	 }
      }
      glPopMatrix();

}

void ogsphere(int ic, float *p1, double rad, int hiresol)
{

      glPushMatrix();
      glTranslatef(p1[0],p1[1],p1[2]);
      setAtomColor(ic);
      if (hiresol) {
	 if (*ipdbon && *xyzp->iatoms > 500 && !has_shader) {
	    gluSphere(sphere, rad, 12, 12);
	 } else {
	    gluSphere(sphere, rad, 20, 20);
	 }
      } else {
	 if (*ipdbon) {
	    gluSphere(sphere, rad, 5, 5);
	 } else {
	    gluSphere(sphere, rad, 10, 10);
	 }
      }
      glPopMatrix();

}

void ogatbnd(iatom,dijsq)
int iatom;
double *dijsq;
{
    double roddef, colv[3];
    float tmp1[3],tmp2[3], tmp3[3];
    int i,j,k,l,m,n, ia,ja,ic,jc,it,ir,jr,ido, dsurf, dcell, doclr;
    int cell_up, cell_low;
    int issolv, ncon, lowres;

    for (l=0; l<3; l++) 
	tmp1[l] = (float) xyzp->coo[iatom*3+l];
    *dijsq = tmp1[0]*tmp1[0] + tmp1[1]*tmp1[1] + tmp1[2]*tmp1[2];

    if (xyzp->iaton[iatom] <= 0 || iatom < 0) return;
    cell_low = cell_up = 0;
    if (cellpnt->iclon) {
	cell_low = cellpnt->iclpnt[0]-1;
	cell_up = cell_low + 7;
    }

    lowres = 0;
    if (*ipdbon && !*backb && *xyzp->iatoms > 500 && !has_shader) lowres = 1;

    doclr = 0;
    if (xyzp->iatclr != NULL && !*atcol) doclr = 1;

    if (xyzp->iaton[iatom] >= 1  && !(xyzp->iresid[iatom] <= 0 
	&& xyzp->iresid[iatom] >= -3 && xyzp->ianz[iatom] == 100)) {

	 dsurf = 0;
	 if (iatom > *natorg-1 && *natorg != 0) dsurf = 1;

	 dcell = 0;
 	 if (dsurf && (iatom <= cell_up && iatom >= cell_low)) dcell = 1;

         ia = xyzp->ianz[iatom];

	 if (doclr) {
            ic = xyzp->iatclr[iatom]-1;
	 } else {
	    ic = 0;
	    if (ia >=1 ) ic = elmptr->icol[ia-1]-1;
	 }

	 if (!(dsurf && !dcell)) {

	 if (*ivdwpl == 1 && *fancy && !dsurf) {

 	   if (cellpnt->iclon && iatom <= cell_up && iatom >= cell_low) {
		ogfstsph(ic,ia-1,tmp1,0);
		roddef = elmptr->vdwr[ia-1]/0.52917706;
		for (k=0; k<xyzp->iconn[iatom*(MXCON+1)]; k++) {
		   m = xyzp->iconn[iatom*(MXCON+1)+k+1];
		   j = ABS(m) - 1;
		   if (j > iatom) {
			for (l=0; l<3; l++) 
			   tmp3[l] = (float) xyzp->coo[j*3+l];
			ogrod(ic,tmp1,tmp3,roddef,1,0);
		   }
		}
	   } else {
		if (idorad) {
		   roddef = xyzp->qat[iatom]/0.52917706;
		} else {
		   roddef = elmptr->vdwr[ia-1]*1.4/0.52917706;
		}
		ogfstsph(ic,ia-1,tmp1,0);
	   }

	 } else {

	   issolv = 0;
	   it = xyzp->iconn[iatom*(MXCON+1)];
	   if (*ipdbon && xyzp->iresid[iatom] == -(calfptr->ishoh) && it) issolv = 1;

           roddef = 0.13/0.52917706;

           if (!issolv && *fancy) {
              if ((lowres && !it) || !lowres) {
		ogfstsph(ic,ia-1,tmp1,1);
	      } else {
		if ( *ivdwpl == 2) {
	   	   ogfstsph(ic,ia-1,tmp1,0);
		}
	      }
	   }

	   ir = xyzp->iresid[iatom];

           for (k=0; k<xyzp->iconn[iatom*(MXCON+1)]; k++) {

	    m = xyzp->iconn[iatom*(MXCON+1)+k+1];
            j = ABS(m) - 1;
	    if (j < 0 || j > *xyzp->mxnat) return;

	    if (xyzp->iconn[iatom*(MXCON+1)+k+1] < 0) 
		    roddef = (0.13/0.52917706)/4.0;
            ja = xyzp->ianz[j];

	    if (doclr) {
               jc = xyzp->iatclr[j]-1;
	    } else {
               jc = elmptr->icol[ja-1]-1;
	    }
            for (l=0; l<3; l++) 
		tmp2[l] = (float) xyzp->coo[j*3+l];

	    jr = xyzp->iresid[j];
            ido = 1;

            if (ic == jc && ir == jr) {
               if (j > iatom) {
                  for (l=0; l<3; l++) tmp3[l] = tmp2[l];
		  ido = 2;
               } else {
                  ido = 0;
               }
            } else {
               for (l=0; l<3; l++) 
                  tmp3[l] = (tmp2[l] - tmp1[l])/2.0 + tmp1[l];
            }
  
            if (ido) {
		if (*fancy) {
		   if (issolv)
		      ogrod(ic,tmp1,tmp3,roddef,0,0);
	   	   else
		      if (lowres) ogrod(ic,tmp1,tmp3,roddef,0,ido);
		      else ogrod(ic,tmp1,tmp3,roddef,1,0);
		} else {
		   colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
		   colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
		   colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
		   if (m < 0) {
			glEnd();
			glLineStipple(4,0xAAAA);
			glEnable(GL_LINE_STIPPLE);
			glBegin(GL_LINES);
		   }
		   glColor4d(colv[0],colv[1],colv[2],tr_val);
		   glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
		   glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
		   if (m < 0) {
			glEnd();
			glDisable(GL_LINE_STIPPLE);
			glBegin(GL_LINES);
			isdraw = 1;
		   }
		}
	    }

	   } /* end for k */
	 } /* end if (*ivdwpl && !dsurf)*/
	 } 
     } /* end if (xyzp->iaton[i] >= 1 */
}

#if defined(VMS) || defined(UNDERSC)
void ogmon()
#else
#ifdef CRAY
void OGMON()
#else
void ogmon_()
#endif
#endif
{
    int i,i1,i2,j,l,doclr,ia,ic;
    double roddef, colv[3];
    float tmp1[3],tmp2[3], tmp3[3];

/* consider making this routine do the same for solid and fullgl stick */

    if (! (*fancy || *fullgl)) return;
    if (!xison) return;

      roddef = (0.13/0.52917706)/4.0;
      doclr = 0;
      if (xyzp->iatclr != NULL && !*atcol) doclr = 1;

      if (!glIsList(theMon[istruct])) glDeleteLists(theMon[istruct],1);

      theMon[istruct] = glGenLists(1);
      glNewList(theMon[istruct], GL_COMPILE_AND_EXECUTE);

      if (*fancy) {
        glDisable(GL_COLOR_MATERIAL);
      } else {
	glDisable(GL_LIGHTING);
	glLineWidth(1.0);
	glLineStipple(4,0xAAAA);
	glEnable(GL_LINE_STIPPLE);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_COLOR_MATERIAL);
	glBegin(GL_LINES);
      }


      for (i=0; i<monptr->ndm; i++) {

	 i1 = monptr->idmon[i][0] - 1;
	 i2 = monptr->idmon[i][1] - 1;

	 for (l=0; l<3; l++) 
	    tmp1[l] = (float) xyzp->coo[i1*3+l];
	 for (l=0; l<3; l++) 
	    tmp2[l] = (float) xyzp->coo[i2*3+l];
	 for (l=0; l<3; l++) 
	    tmp3[l] = (tmp2[l] - tmp1[l])/2.0 + tmp1[l];

         ia = xyzp->ianz[i1];
	 if (doclr) {
            ic = xyzp->iatclr[i1]-1;
	 } else {
            ic = elmptr->icol[ia-1]-1;
	 }

         if (*fancy) {
		ogrod(ic,tmp1,tmp3,roddef,0,0);
	 } else {
		colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
		colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
		colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
		glColor4d(colv[0],colv[1],colv[2],tr_val);
		glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
		glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	 }

         ia = xyzp->ianz[i2];
	 if (doclr) {
            ic = xyzp->iatclr[i2]-1;
	 } else {
            ic = elmptr->icol[ia-1]-1;
	 }

         if (*fancy) {
		ogrod(ic,tmp2,tmp3,roddef,0,0);
	 } else {
		colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
		colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
		colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
		glColor4d(colv[0],colv[1],colv[2],tr_val);
		glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
		glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	 }

      }

      if (! *fancy) {
	glEnd();
	glDisable(GL_LINE_STIPPLE);
	glDisable(GL_COLOR_MATERIAL);
	glEnable(GL_LIGHTING);
      }

      glEndList();
}

void ogunsel()
{
 int j;

    for (j=0; j < *zmptrp->nz; j++) 
         if (xyzp->iaton[j] >= 2) xyzp->iaton[j] = 1;
    for (j=0; j < *xyzp->iatoms; j++) 
         if (xyzp->iaton[j] >= 2) xyzp->iaton[j] = 1;
    update_sel = 1;
}

void ogsel()
{
  int i,ia;
  float tmp[3];
  GLdouble srad;

  theSel[istruct] = glGenLists(1);
  glNewList(theSel[istruct], GL_COMPILE_AND_EXECUTE);

  for (i=0; i<*xyzp->iatoms; i++) {
        tmp[0] = (float) (xyzp->coo[i*3]);
        tmp[1] = (float) (xyzp->coo[i*3+1]);
        tmp[2] = (float) (xyzp->coo[i*3+2]);
        ia = xyzp->ianz[i];
        if (xyzp->iaton[i] >= 2)  {
           if (ZMEup || aflag || cflag || ATMup || SelDel || ONIup || 
		scoup || NMRup) {
	      srad = elmptr->vdwr[ia-1];
	      if (*ivdwpl == 1) {
		srad = 3.0*srad;
              } else if (*ivdwpl == 2) {
		srad = (0.6/0.52917706)*srad;
              } else {
		srad = (0.16/0.52917706);
	      }
	      ogsphere(rimcols[xyzp->iaton[i]]-1,tmp,srad,1);
	   }
	}
  }

  glEndList();
  update_sel = 0;
}

void updfog(iset)
int iset;
{
   int l;

   if (posz > 0.0) posz = sqrt(posz);
   scl[istruct] = posz;
   if (scl[istruct] == 0.0) scl[istruct] = 1.0;
   posz = -1.6*posz;
   for (l=0; l<3; l++)
	light2_position[istruct][l] = light2_position_def[l]*scl[istruct]*5.0;
   if (iset) poszset = 1;
}

void ogbck(isec)
int isec;
{
      int i,j,ires;
      double dijsq;

	if (!(has_opengl && (*fancy || *fullgl) )) return;

	if (*fancy) ogChkElem();
	for (ires = 1; ires < calfptr->ncalf+1; ires++ ) {
	   if (calfptr->isal[ires-1] == isec) {
#if defined(VMS) || defined(UNDERSC)
		getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
		GETPDB(&ires,ipdb,ihpdb);
#else
		getpdb_(&ires,ipdb,ihpdb);
#endif
#endif
		theBck[istruct][ires-1] = glGenLists(1);
		glNewList(theBck[istruct][ires-1], GL_COMPILE);
		
		for (i=0; i<3; i++) {
		   if (ipdb[i] > 0) {
			xyzp->iaton[ipdb[i]-1] = 1;
			ogatbnd(ipdb[i]-1,&dijsq);
		   }
		}
		glEndList();
	   }

	}
}

void ogres_(ires,iopt,iupd)
int *ires;
int *iopt;
int *iupd;
{
     ogres(*ires,*iopt,*iupd);
}

void ogres(ires,iopt,iupd)
int ires;
int iopt;
int iupd;
{
      int i,j;
      double dijsq;

      if (!((*fancy || *fullgl) && has_opengl)) {
	update_struct();
	return;
      }

      if (!calfptr->reson[ires-1]) return;
/*
      glDeleteLists(theRes[istruct][ires-1],1);
      theRes[istruct][ires-1] = -1;
*/
 
#if defined(VMS) || defined(UNDERSC)
      getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
      GETPDB(&ires,ipdb,ihpdb);
#else
      getpdb_(&ires,ipdb,ihpdb);
#endif
#endif

      if (!glIsList(theRes[istruct][ires-1])) 
		theRes[istruct][ires-1] = glGenLists(1);
      glNewList(theRes[istruct][ires-1], GL_COMPILE);

      if (*fancy) {
        glDisable(GL_COLOR_MATERIAL);
      } else {
	glDisable(GL_LIGHTING);
	glLineWidth(2.0);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_COLOR_MATERIAL);
	glBegin(GL_LINES);
      }

      for (i=0; i<MXSYM; i++) {
	if (ipdb[i] > 0) {
	   ogatbnd(ipdb[i]-1,&dijsq);
	   if (!iopt && (!addfile || !poszset) ) if (dijsq > posz) posz = dijsq;
	}
      }
      for (i=0; i<3*MXHSYM; i++) {
	if (ihpdb[i] > 0) {
	   ogatbnd(ihpdb[i]-1,&dijsq);
	   if (!iopt && (!addfile || !poszset) ) if (dijsq > posz) posz = dijsq;
	}
      }

      if (! *fancy) {
	glEnd();
	glDisable(GL_COLOR_MATERIAL);
	glEnable(GL_LIGHTING);
      }

      glEndList();
      if (iupd) dispsf();
}


void oghet(int iopt)
{
    double dijsq;
    int i, ioff, num_atoms;

    theMol[istruct][NMols[istruct]] = glGenLists(1);
    glNewList(theMol[istruct][NMols[istruct]], GL_COMPILE);
    glDisable(GL_COLOR_MATERIAL);

    ioff = 0;
    num_atoms = *xyzp->iatoms;

    if (!iopt && (*irtcel && *ialtyp) && *iscst < num_atoms) 
	num_atoms = *iscst;

    if (iopt) {
	ioff = *iscst;
        num_atoms = *nscnd;
    }

    for (i=ioff; i<ioff+num_atoms; i++) {
       if (xyzp->iresid[i] < -3) {
	ogatbnd(i,&dijsq);
	if (!iopt && (!addfile || !poszset) ) if (dijsq > posz) posz = dijsq;
       }
    } 

    glEndList();
}

void ogpdb(int iopt)
{
    double roddef, dijsq;
    float tmp1[3];
    int ires, i,j,k,l,m, doclr, ioff, num_atoms;
    int cell_low, cell_up;

    if (!(*fancy || *fullgl) ) return;

    glXMakeCurrent(display, win, cx);
    if (!iopt && !addfile) posz = 0.0;

    glPopMatrix();
    glPushMatrix();

    if (NMols[istruct] >= MXMOL - 1) return;

    if (NMols[istruct] != -1 && !iopt) {
       NMols[istruct] = -1;
       NMols[istruct]++;
       glDeleteLists(theMol[istruct][NMols[istruct]],1);
       theMol[istruct][NMols[istruct]] = -1;
    } else NMols[istruct]++;

    if (*xyzp->iatoms == 0) return;

    if (iopt) {
	glDeleteLists(theMol[istruct][1],1);
	theMol[istruct][1] = -1;
	NMols[istruct] = 1;
    }

/* do residues */

    for (ires=0;ires < calfptr->ncalf;ires++) {
	l = calfptr->icalf[ires][0];
	for (i=0; i<3; i++) 
	   tmp1[i] = (float) xyzp->coo[l*3+i];
	dijsq = tmp1[0]*tmp1[0] + tmp1[1]*tmp1[1] + tmp1[2]*tmp1[2];
	if (!iopt && (!addfile || !poszset) ) if (dijsq > posz) posz = dijsq;
    }

    if (!iopt) {
	for ( ires = 1; ires < calfptr->ncalf+1; ires++ ) {
	   ogres(ires,iopt,0);
	}
    }


/* do other non amino atoms */

    oghet(iopt);

    if (!iopt && (!addfile || !poszset) ) updfog(1);

    dispsf();
}


void ogmoll(int iopt)
{
    double dijsq;
    int i,j,k,l, doclr, ioff, num_atoms;
    int cell_low, cell_up;

    if (!(*fancy || *fullgl)) return;

    if (*fancy) ogChkElem();

    if (*ipdbon) {
	ogpdb(iopt);
	return;
    }

    glXMakeCurrent(display, win, cx);
    if (!iopt && !addfile) posz = 0.0;

    glPopMatrix();
    glPushMatrix();
    if (NMols[istruct] >= MXMOL - 1) return;

    if (NMols[istruct] != -1 && !iopt) {
       NMols[istruct] = -1;
       NMols[istruct]++;
       glDeleteLists(theMol[istruct][NMols[istruct]],1);
       theMol[istruct][NMols[istruct]] = -1;
    } else NMols[istruct]++;

    if (*xyzp->iatoms == 0) return;

    if (iopt) {
	glDeleteLists(theMol[istruct][1],1);
	theMol[istruct][1] = -1;
	NMols[istruct] = 1;
    }

    theMol[istruct][NMols[istruct]] = glGenLists(1);
    glNewList(theMol[istruct][NMols[istruct]], GL_COMPILE);
    glDisable(GL_COLOR_MATERIAL);


    ioff = 0;
    num_atoms = *xyzp->iatoms;
    if (!iopt && (*irtcel && *ialtyp) && *iscst < num_atoms) 
	num_atoms = *iscst;
    if (iopt) {
	ioff = *iscst;
        num_atoms = *nscnd;
    }
    for (i=ioff; i<ioff+num_atoms; i++) {
       ogatbnd(i,&dijsq);
       if (!iopt && (!addfile || !poszset) ) if (dijsq > posz) posz = dijsq;
    } 

    glEndList();

    if (!iopt && (!addfile || !poszset) ) updfog(1);

    dispsf();
}

void ogmlxyz()
{
    double roddef, dmaxsq, dijsq, dsq, adj;
    float tmp1[3],tmp2[3], tmp3[3];
    int i,j,k,l, ia, ic, ja, ido;


    if (!*ifdogl) return;

#if defined(VMS) || defined(UNDERSC)
    dodcnt(rotptr->td);
#else
#ifdef CRAY
    DODCNT(rotptr->td);
#else
    dodcnt_(rotptr->td);
#endif
#endif

    adj = *adjuss;
    glXMakeCurrent(display, win, cx);
    posz = 0.0;
    dijsq = 0.0;

    roddef = (0.13/adj);

    glPopMatrix();
    glPushMatrix();

    glDeleteLists(theMol[istruct][0],1);
    theMol[istruct][0] = -1;
    NMols[istruct] = 1;

    theMol[istruct][0] = glGenLists(1);
    glNewList(theMol[istruct][0], GL_COMPILE);
    glDisable(GL_COLOR_MATERIAL);

    for (i=0; i< NAT->natoms; i++) {

         ia = NAT->nat[i];
         ic = elmptr->icol[ia-1]-1;


         for (l=0; l<3; l++) 
            tmp1[l] = (float) XYZ->xyz[i][l];

	 dijsq = tmp1[0]*tmp1[0] + tmp1[1]*tmp1[1] + tmp1[2]*tmp1[2];
	 if (dijsq > 0.0) dijsq = sqrt(dijsq);
	 if (dijsq > posz) posz = dijsq;


	 if (*ivdwpl) {

	   roddef = elmptr->vdwr[ia-1]*1.4/adj;
           ogsphere(ic,tmp1,roddef,hires);

	 } else {

           roddef = (0.13/adj);

           ogsphere(ic,tmp1,roddef,0);

           for (j=0; j< NAT->natoms; j++) {

            ja = NAT->nat[j];
            for (l=0; l<3; l++) 
	       tmp2[l] = (float) XYZ->xyz[j][l];

	    dsq = 0;
            for (l=0; l<3; l++) {
                tmp3[l] = (tmp2[l] - tmp1[l]);
		dsq = dsq + tmp3[l]*tmp3[l];
	    }
            dmaxsq = (elmptr->vdwr[ia-1] + elmptr->vdwr[ja-1])/adj;
            dmaxsq = dmaxsq * dmaxsq;

	    if (dsq < dmaxsq) ido = 1;
	    else ido = 0;

            if (ja == ia) {
               if (j > i) {
                  for (l=0; l<3; l++) tmp3[l] = tmp2[l];
               } else {
                  ido = 0;
               }
            } else {
               for (l=0; l<3; l++) 
                  tmp3[l] = (tmp2[l] - tmp1[l])/2.0 + tmp1[l];
            }
  
            if (ido) ogrod(ic,tmp1,tmp3,roddef,1,0);

	   } /* end for k */
	 } /* end if (*ivdwpl)*/
    } /* end for (i=0; i<*natoms; i++) { */


    glEndList();

    updfog(0);

    dispsf();
}

void oglines()
{
    double dmaxsq, dijsq, colv[3];
    float tmp1[3],tmp2[3], tmp3[3];
    int i,j,k,l,m, ia, ic, ja, ido, doclr, dsurf ;


    if (!addfile) posz = 0.0;

    doclr = 0;
    if (xyzp->iatclr != NULL && !*atcol) doclr = 1;

    if (NMols[istruct] >= MXMOL - 1) return;
    if (*xyzp->iatoms == 0) return;

    if (theLines[istruct] > 0) glDeleteLists(theLines[istruct],1);
    theLines[istruct] = -1;
    theLines[istruct] = glGenLists(1);

    if (theFLines[istruct] > 0) glDeleteLists(theFLines[istruct],1);
    theFLines[istruct] = -1;
    theFLines[istruct] = glGenLists(1);

    if (thePoints[istruct] > 0) glDeleteLists(thePoints[istruct],1);
    thePoints[istruct] = -1;
    thePoints[istruct] = glGenLists(1);

/*
theLines is intended as lines in combination with solid atoms
the lines would be used to display a mesh surface
*/

    glNewList(theLines[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glLineWidth(2.0);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_COLOR_MATERIAL);
    glBegin(GL_LINES);

    for (i=0; i<*xyzp->iatoms; i++) {

	if (xyzp->iaton[i] >= 1  && 
	   !(xyzp->iresid[i] <= 0 && xyzp->iresid[i] >= -3 && xyzp->ianz[i] == 100)) {

	 dsurf = 0;
	 if (i >= *natorg && *natorg != 0) dsurf = 1;

	 if (dsurf) {

            ia = xyzp->ianz[i];
	    if (doclr || *doesp) {
               ic = xyzp->iatclr[i]-1;
	    } else {
               ic = elmptr->icol[ia-1]-1;
            }
            for (l=0; l<3; l++) 
               tmp1[l] = (float) xyzp->coo[i*3+l];


           for (k=0; k<xyzp->iconn[i*(MXCON+1)]; k++) {

	    
            m = xyzp->iconn[i*(MXCON+1)+k+1];
            j = ABS(m) - 1;
            ja = xyzp->ianz[j];

            for (l=0; l<3; l++) 
	       tmp2[l] = (float) xyzp->coo[j*3+l];


            ido = 1;
            if (ja == ia) {
               if (j > i) {
                  for (l=0; l<3; l++) tmp3[l] = tmp2[l];
               } else {
                  ido = 0;
               }
            } else {
               for (l=0; l<3; l++) 
                  tmp3[l] = (tmp2[l] - tmp1[l])/2.0 + tmp1[l];
            }
 
            if (ido) {
	       colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	       colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	       colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
	       if (m < 0) {
		   glEnd();
		   glLineStipple(4,0xAAAA);
		   glEnable(GL_LINE_STIPPLE);
		   glBegin(GL_LINES);
	       }
	       glColor4d(colv[0],colv[1],colv[2],tr_val);
	       glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	       glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	       if (m < 0) {
		   glEnd();
		   glDisable(GL_LINE_STIPPLE);
		   glBegin(GL_LINES);
	       }

	    }

	   }
	 }
	}
    }

    glEnd();

    for (i=0; i<*xyzp->iatoms; i++) {

	if (xyzp->iaton[i] >= 1  && 
	   !(xyzp->iresid[i] <= 0 && xyzp->iresid[i] >= -3 && xyzp->ianz[i] == 100) && xyzp->iconn[i*(MXCON+1)] == 0 && ! *fancy) {

            ia = xyzp->ianz[i];
	    if (doclr || *doesp) {
               ic = xyzp->iatclr[i]-1;
	    } else {
               ic = elmptr->icol[ia-1]-1;
            }

	    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

            for (l=0; l<3; l++) {
               tmp1[l] = (float) xyzp->coo[i*3+l];
	    }
            glBegin(GL_LINES);
	    glColor4d(colv[0],colv[1],colv[2],tr_val);
	    for (j=0; j<6; j++) {
		glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
           	for (l=0; l<3; l++) {
		   tmp3[l] = (float)(tmp1[l] + CV[j][l]);
		}
		glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	    }
            glEnd();
	}
    }

    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glEndList();

/*
theFLines is intended as lines replacing the solid atoms (non residues) in full opengl
*/

    glNewList(theFLines[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glEnable(GL_COLOR_MATERIAL);
    glLineWidth(2.0);
    glEnable(GL_LINE_SMOOTH);
    glBegin(GL_LINES);

    for (i=0; i<*xyzp->iatoms; i++) {

	if (xyzp->iaton[i] >= 1  && 
	   !(xyzp->iresid[i] <= 0 && xyzp->iresid[i] >= -3 && xyzp->ianz[i] == 100)) {

	 dsurf = 0;
	 if (i >= *natorg && *natorg != 0) dsurf = 1;

	 if (!dsurf && xyzp->iresid[i] < 0) { 
/* if we go for the option below: in line mode replacing an amino acid
   would cause the old amino acid to be still there (TheFlines displaylist). 
   The display of the replaced residue is done by ogres, which puts it into 
   TheRes display list.
   In solid mode this displaylist TheFlines is not visualized */
/*	 if (!dsurf) { */
            ia = xyzp->ianz[i];
	    if (doclr || *doesp) {
               ic = xyzp->iatclr[i]-1;
	    } else {
               ic = elmptr->icol[ia-1]-1;
            }
            for (l=0; l<3; l++) 
               tmp1[l] = (float) xyzp->coo[i*3+l];


           for (k=0; k<xyzp->iconn[i*(MXCON+1)]; k++) {

	    
            m = xyzp->iconn[i*(MXCON+1)+k+1];
            j = ABS(m) - 1;
            ja = xyzp->ianz[j];

            for (l=0; l<3; l++) 
	       tmp2[l] = (float) xyzp->coo[j*3+l];


            ido = 1;
            if (ja == ia) {
               if (j > i) {
                  for (l=0; l<3; l++) tmp3[l] = tmp2[l];
               } else {
                  ido = 0;
               }
            } else {
               for (l=0; l<3; l++) 
                  tmp3[l] = (tmp2[l] - tmp1[l])/2.0 + tmp1[l];
            }
 
            if (ido) {
	       colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	       colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	       colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
	       if (m < 0) {
		   glEnd();
		   glLineStipple(4,0xAAAA);
		   glEnable(GL_LINE_STIPPLE);
		   glBegin(GL_LINES);
	       }
	       glColor4d(colv[0],colv[1],colv[2],tr_val);
	       glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	       glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	       if (m < 0) {
		   glEnd();
		   glDisable(GL_LINE_STIPPLE);
		   glBegin(GL_LINES);
	       }

	    }

	   }
	 }
	}
    }

    glEnd();
    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glEndList();

    glNewList(thePoints[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glPointSize(2.5);
    glEnable(GL_COLOR_MATERIAL);
    glBegin(GL_POINTS);

    for (i=0; i<*xyzp->iatoms; i++) {

        for (l=0; l<3; l++) 
            tmp1[l] = (float) xyzp->coo[i*3+l];
	dijsq = tmp1[0]*tmp1[0] + tmp1[1]*tmp1[1] + tmp1[2]*tmp1[2];
	if (dijsq > posz) posz = dijsq;

	if (xyzp->iaton[i] >= 1  && 
	   !(xyzp->iresid[i] <= 0 && xyzp->iresid[i] >= -3 && 
	     xyzp->ianz[i] == 100)) {

           m = xyzp->iconn[i*(MXCON+1)];

	   if (!m || (m == 1 && xyzp->iconn[i*(MXCON+1)+1] < 0)) {

               ia = xyzp->ianz[i];
	       if (doclr || *doesp) {
                  ic = xyzp->iatclr[i]-1;
	       } else {
                  ic = elmptr->icol[ia-1]-1;
               }

	       colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	       colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	       colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
	       glColor4d(colv[0],colv[1],colv[2],tr_val);
	       glVertex3d(tmp1[0],tmp1[1],tmp1[2]);

	   }
	}
    }


    glEnd();
    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glEndList();

    if (!addfile) updfog(0);
}

void tofloat(double d[3], float f[3])
{
  int i;

  for (i=0; i<3; i++) f[i] = (float) d[i];

}

void ogbox()
{
    double tmp1[3],tmp2[3], tmp3[3],roddef;
    float tmp1f[3],tmp2f[3], tmp3f[3];
    double o[3] = { 0.0,0.0,0.0 };
    double x[3] = { 1.0,0.0,0.0 };
    double y[3] = { 0.0,1.0,0.0 };
    double z[3] = { 0.0,0.0,1.0 };
    double xy[3] = { 1.0,1.0,0.0 };
    double xz[3] = { 1.0,0.0,1.0 };
    double yz[3] = { 0.0,1.0,1.0 };
    double xyz[3] = { 1.0,1.0,1.0 };

    if (!has_box) return;

    roddef = 0.20/0.52917706;

    if (theBox[istruct] > 0) glDeleteLists(theBox[istruct],1);
    theBox[istruct] = -1;
    theBox[istruct] = glGenLists(1);

    glNewList(theBox[istruct], GL_COMPILE_AND_EXECUTE);
    if (*fancy) {
        glDisable(GL_COLOR_MATERIAL);
    } else {
	glDisable(GL_LIGHTING);
	glLineWidth(2.0);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_COLOR_MATERIAL);
	glBegin(GL_LINES);
    }

    rotbck_(&o[0],&o[1],&o[2],tmp1);
    rotbck_(&x[0],&x[1],&x[2],tmp2);
    tofloat(tmp1,tmp1f);

    if (*fancy) {
	tofloat(tmp2,tmp2f);
	ogrod(0,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,0.0,0.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&y[0],&y[1],&y[2],tmp2);

    if (*fancy) {
	tofloat(tmp2,tmp2f);
	ogrod(2,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(0.0,1.0,0.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&z[0],&z[1],&z[2],tmp2);

    if (*fancy) {
	tofloat(tmp2,tmp2f);
	ogrod(3,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(0.0,0.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&x[0],&x[1],&x[2],tmp1);
    rotbck_(&xy[0],&xy[1],&xy[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&y[0],&y[1],&y[2],tmp1);
    rotbck_(&xy[0],&xy[1],&xy[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&x[0],&x[1],&x[2],tmp1);
    rotbck_(&xz[0],&xz[1],&xz[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&z[0],&z[1],&z[2],tmp1);
    rotbck_(&xz[0],&xz[1],&xz[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&z[0],&z[1],&z[2],tmp1);
    rotbck_(&yz[0],&yz[1],&yz[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&y[0],&y[1],&y[2],tmp1);
    rotbck_(&yz[0],&yz[1],&yz[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&xyz[0],&xyz[1],&xyz[2],tmp1);
    rotbck_(&xy[0],&xy[1],&xy[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&xyz[0],&xyz[1],&xyz[2],tmp1);
    rotbck_(&xz[0],&xz[1],&xz[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    rotbck_(&xyz[0],&xyz[1],&xyz[2],tmp1);
    rotbck_(&yz[0],&yz[1],&yz[2],tmp2);

    if (*fancy) {
	tofloat(tmp1,tmp1f);
	tofloat(tmp2,tmp2f);
	ogrod(14,tmp1f,tmp2f,roddef,1,0);
    } else {
	glColor4d(1.0,1.0,1.0,tr_val);
	glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	glVertex3d(tmp2[0],tmp2[1],tmp2[2]);
    }

    glEnd();
    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glEndList();

}

void ogfeatures()
{
    int i,col;
    double colv[3];
    float tmp[3],tmp0[3],tmp1[3];
    GLdouble srad;

    if (theFeat[istruct] > 0) glDeleteLists(theFeat[istruct],1);
    theFeat[istruct] = -1;
    theFeat[istruct] = glGenLists(1);
    glNewList(theFeat[istruct], GL_COMPILE);

    for (i=0; i< pharm.nfeat; i++) {
        tmp[0] = (pharm.array[i].cor[0]);
        tmp[1] = (pharm.array[i].cor[1]);
        tmp[2] = (pharm.array[i].cor[2]);
	col = FeatCol[pharm.array[i].type];
	if (pharm.array[i].type == 0) {
		srad = 0.2;
		ogsphere(col,tmp,srad,1);
		tmp0[0] = tmp[0] + pharm.array[i].vec1[0];
		tmp0[1] = tmp[1] + pharm.array[i].vec1[1];
		tmp0[2] = tmp[2] + pharm.array[i].vec1[2];
		ogsphere(col,tmp0,srad,1);
		tmp1[0] = tmp[0] + pharm.array[i].vec2[0];
		tmp1[1] = tmp[1] + pharm.array[i].vec2[1];
		tmp1[2] = tmp[2] + pharm.array[i].vec2[2];
		ogsphere(col,tmp1,srad,1);

	        colv[0] = ((GLdouble) colorr[col+1]) / 65535.0 ; 
	        colv[1] = ((GLdouble) colorg[col+1]) / 65535.0 ; 
	        colv[2] = ((GLdouble) colorb[col+1]) / 65535.0 ; 
		glDisable(GL_LIGHTING);
		glLineWidth(2.0);
		glEnable(GL_LINE_SMOOTH);
		glEnable(GL_COLOR_MATERIAL);
		glBegin(GL_LINES);
	        glColor4d(colv[0],colv[1],colv[2],tr_val);
	        glVertex3d(tmp0[0],tmp0[1],tmp0[2]);
	        glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
		glEnd();
		glEnable(GL_LIGHTING);
		glDisable(GL_COLOR_MATERIAL);

	} else if (pharm.array[i].type == 1 || pharm.array[i].type == 2) {
		srad = 0.2;
		ogsphere(col,tmp,srad,1);
		tmp0[0] = tmp[0] + pharm.array[i].vec1[0];
		tmp0[1] = tmp[1] + pharm.array[i].vec1[1];
		tmp0[2] = tmp[2] + pharm.array[i].vec1[2];
		ogsphere(col,tmp0,srad,1);

	        colv[0] = ((GLdouble) colorr[col+1]) / 65535.0 ; 
	        colv[1] = ((GLdouble) colorg[col+1]) / 65535.0 ; 
	        colv[2] = ((GLdouble) colorb[col+1]) / 65535.0 ; 
		glDisable(GL_LIGHTING);
		glLineWidth(2.0);
		glEnable(GL_LINE_SMOOTH);
		glEnable(GL_COLOR_MATERIAL);
		glBegin(GL_LINES);
	        glColor4d(colv[0],colv[1],colv[2],tr_val);
	        glVertex3d(tmp[0],tmp[1],tmp[2]);
	        glVertex3d(tmp0[0],tmp0[1],tmp0[2]);
		glEnd();
		glEnable(GL_LIGHTING);
		glDisable(GL_COLOR_MATERIAL);

	} else {
		srad = 0.2;
		ogsphere(col,tmp,srad,1);
	}
    }

    glEndList();

    if (theAFeat[istruct] > 0) glDeleteLists(theAFeat[istruct],1);
    theAFeat[istruct] = -1;
    theAFeat[istruct] = glGenLists(1);
    glNewList(theAFeat[istruct], GL_COMPILE);

    for (i=0; i< pharm.nfeat; i++) {
	if (pharm.array[i].incl) {
           tmp[0] = (pharm.array[i].cor[0]);
           tmp[1] = (pharm.array[i].cor[1]);
           tmp[2] = (pharm.array[i].cor[2]);
	   col = FeatCol[pharm.array[i].type];
	   srad = (pharm.array[i].rad);
	   ogsphere(col,tmp,srad,1);
	}
    }

    glEndList();
}

void ogforces()
{
    double colv[3], roddef;
    float tmp1[3],tmp2[3], tmp3[3];
    int i,j,k,l,ic;

    roddef = (0.13/0.52917706);

    if (theForces[istruct] > 0) glDeleteLists(theForces[istruct],1);
    theForces[istruct] = -1;
    theForces[istruct] = glGenLists(1);
    glNewList(theForces[istruct], GL_COMPILE);

    ic = 0;

    for (i=0; i<*xyzp->iatoms; i++) {

	if (xyzp->iaton[i] >= 1  && 
	   !(xyzp->iresid[i] <= 0 && xyzp->iresid[i] >= -3 && xyzp->ianz[i] == 100)) {



           for (k=0; k<3; k++) 
             tmp1[k] = (float) xyzp->coo[i*3+k];

           for (k=0; k<3; k++) 
             tmp3[k] = (float) fcptr->fc[i][k];

 
	   colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	   colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	   colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
/*
	   glColor4d(colv[0],colv[1],colv[2],tr_val);
	   glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
	   glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
*/
           ogarrow(ic,tmp1,tmp3,roddef);


	}
    }


    glEndList();

}

void ogsarr()
{
    double colv[3], roddef;
    float tmp1[3],tmp3[3];
    int k,l,m;

    roddef = (0.8/0.52917706);
    l = calfptr->icalf[DisAmino-1][0]-1;
    m = calfptr->icalf[DisAmino+DisDir-1][0]-1;

    if (theSArrow[istruct] > 0) glDeleteLists(theSArrow[istruct],1);
    theSArrow[istruct] = -1;
    theSArrow[istruct] = glGenLists(1);
    glNewList(theSArrow[istruct], GL_COMPILE);

    for (k=0; k<3; k++) 
             tmp1[k] = (float) xyzp->coo[l*3+k];

    for (k=0; k<3; k++) 
             tmp3[k] = (float) xyzp->coo[m*3+k];

    colv[0] = ((GLdouble) colorr[1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[1]) / 65535.0 ; 

    ogarrow(0,tmp1,tmp3,roddef);

    glEndList();

}

void ogdipole()
{
    double colv[3], tmp2[3], roddef;
    float tmp1[3], tmp3[3];
    int i,k,ic;

    roddef = (0.13/0.52917706);

    glDeleteLists(theDipole[istruct],1);

    theDipole[istruct] = -1;
    theDipole[istruct] = glGenLists(1);

    glNewList(theDipole[istruct], GL_COMPILE);

    ic = 2;

#if defined(VMS) || defined(UNDERSC)
    cntvec(
#else

#ifdef CRAY
    CNTVEC(
#else
    cntvec_(
#endif
#endif
	tmp2,xyzp->coo,xyzp->ianz,xyzp->iatoms);

    for (k=0; k<3; k++) 
        tmp1[k] = (float) tmp2[k];

    for (k=0; k<3; k++) 
        tmp3[k] = (float) (qdpptr->dipo[k] + tmp2[k]);

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    ogarrow(ic,tmp1,tmp3,roddef);

    glEndList();

}

void ogaxes()
{
    double roddef;
    int i,ic=-1;

    roddef = (0.13/0.52917706);

    glDeleteLists(theAxes,1);

    theAxes = -1;
    theAxes = glGenLists(1);

    glNewList(theAxes, GL_COMPILE);

    
    ogsphere(1,&AxesXYZ[0][0],0.5*roddef,0);

    for (i=1; i<4; i++) {
	glMaterialfv(GL_FRONT_AND_BACK,
           GL_AMBIENT_AND_DIFFUSE, &AxesCol[i][0]);
	ogarrow(ic,&AxesXYZ[0][0],&AxesXYZ[i][0],roddef);
    }

    glEndList();

}

#if defined(VMS) || defined(UNDERSC)
void ogbegg(isurf,iopt,ityp,iorb,cntval,mapped,name)
#else
#ifdef CRAY
void OGBEGG(isurf,iopt,ityp,iorb,cntval,mapped,name)
#else
void ogbegg_(isurf,iopt,ityp,iorb,cntval,mapped,name)
#endif
#endif
int *isurf;
int *mapped;
int *iopt;
int *ityp;
int *iorb;
double* cntval;
char *name;
{
      int itrns,isf,i,n,len,two;
      double cval;
      char *endquote;
      char *srftyp[] = { "orbital", "normal density", "laplacian",
			 "mapped surface",
			 "elec. pot.","diff. density","ELF",
			 "unknown"};

      if (xison) {
	glXMakeCurrent(display, win, cx);
	glPopMatrix();
	glPushMatrix();
      }

      itrns = 0;
      if (*isurf < 0) {
	  itrns = 1;
      }
      TRANS = itrns;
      isf = abs(*isurf); isf--;

      cval = *cntval;

      NSurf[istruct]++;

      if (TRANS) {
         trns[istruct][NSurf[istruct]-1] = 1;
      }
      two = 1;

      if (*iopt) {
	switch(*ityp) {
	case 0:
	  sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(31);
	  sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"Orbital %3d isocontour %7.4f",*iorb,cval);
	  break;
	default:
	  len = strlen(srftyp[*ityp]) + 20;
	  sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(len);
	  sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"%s isocontour %7.4f",srftyp[*ityp],cval);
	  break;
	}
        if (*ityp == 1 || *ityp == 3) two = 0;
      } else {
	  endquote = strchr(name,'\"');
	  if (endquote != NULL) endquote[0] = '\0';
	  sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(strlen(name)+1);
	  strcpy(sndstr[istruct][NSurf[istruct]-1], name);
      }

      allocvert(MXVERT4,1);

      if (!xison) return;

      if (theSurf[istruct][NSurf[istruct]-1] > 0) 
	glDeleteLists(theSurf[istruct][NSurf[istruct]-1],1);
      theSurf[istruct][NSurf[istruct]-1] = glGenLists(1);

      if (denmode) {
	  n = NSurf[istruct] - 2;
	  if (NSurf[istruct] > 1 && (two && isf) ) n--;

	  for (i=0; i<=n; i++) SSon[istruct][i] = 0;
      }

      if (isf > 1) isf = 1;

      SSon[istruct][NSurf[istruct]-1] = 1;
      clp[istruct][NSurf[istruct]-1] = 0;
      trns[istruct][NSurf[istruct]-1] = itrns;

      if (!STRCup && denmode) inistrc();
      RedrawSTRC();

      for (i=0; i<3; i++) {
	diffuseColor[istruct][NSurf[istruct]-1][i] = cursrfcol[isf][i];
	specularColor[NSurf[istruct]-1][i] = specColor[i];
      }

      glNewList(theSurf[istruct][NSurf[istruct]-1], GL_COMPILE);

      SStyp[istruct][NSurf[istruct]-1] = 0;
      Schain[istruct][NSurf[istruct]-1] = -1;
      if (*mapped) {
        glColorMaterial(GL_FRONT_AND_BACK,GL_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);
	SStyp[istruct][NSurf[istruct]-1] = 1;
      }

      glBegin(GL_TRIANGLES);
}

#if defined(VMS) || defined(UNDERSC)
void ogendd(ichain)
#else
#ifdef CRAY
void OGENDD(ichain)
#else
void ogendd_(ichain)
#endif
#endif
int *ichain;
{
      glEnd();
      glDisable(GL_COLOR_MATERIAL);
      glEndList();
      if (*ichain != -1) Schain[istruct][NSurf[istruct]-1] = *ichain;
}

void allocvert(siz,first)
int siz;
int first;
{
   VRTSTRU *spnt;
   VRTSTRU tmp;
   int i;

   spnt = srfvert[istruct][NSurf[istruct]-1];

   if (first) {
	nvert[istruct][NSurf[istruct]-1] = 0;
	nvrtmx[istruct][NSurf[istruct]-1] = 0;
   }

   srfvert[istruct][NSurf[istruct]-1] = 
	(VRTSTRU *) malloc((sizeof tmp)*siz);


   if (srfvert[istruct][NSurf[istruct]-1] == NULL) {
	srfvert[istruct][NSurf[istruct]-1] = spnt;
	dovrt = 0;
	fprintf(stderr,"failed to allocate memory to store vertices \n");
   } else {
	if (spnt != NULL) {
	    if (!first) {
		for (i=0; i<nvert[istruct][NSurf[istruct]-1]-1; i++) 
		    srfvert[istruct][NSurf[istruct]-1][i] = spnt[i];
	    }
	    free(spnt);
	}
	nvrtmx[istruct][NSurf[istruct]-1] = siz;
   }
}

void putvrt(v1,v2,v3,type)
double *v1;
double *v2;
double *v3;
int type;
{
      int isrf,siz;

      if (!dovrt) return;

      isrf = NSurf[istruct]-1;

      nvert[istruct][isrf]++;

      if (nvert[istruct][isrf] > nvrtmx[istruct][isrf]) {
	  switch (nvrtmx[istruct][isrf]) {
	  case 0:
		siz = MXVERT;
		break;
	  case MXVERT:
		siz = MXVERT2;
		break;
	  case MXVERT2:
		siz = MXVERT3;
		break;
	  case MXVERT3:
		siz = MXVERT4;
		break;
	  case MXVERT4:
		siz = MXVERT5;
		break;
	  case MXVERT5:
		siz = MXVERT6;
		break;
	  case MXVERT6:
		siz = MXVERT7;
		break;
	  case MXVERT7:
		siz = MXVERT8;
		break;
	  case MXVERT8:
		siz = MXVERT9;
		break;
	  case MXVERT9:
		siz = MXVERT10;
		break;
	  case MXVERT10:
		siz = MXVERT11;
		break;
	  case MXVERT11:
		siz = MXVERT12;
		break;
	  default:
		siz = 0;
	  }
	  if (siz) allocvert(siz,0);
	  else dovrt = 0;
		
      }
      if (dovrt) {
	srfvert[istruct][isrf][nvert[istruct][isrf]-1].vert[0] = (float) *v1;
	srfvert[istruct][isrf][nvert[istruct][isrf]-1].vert[1] = (float) *v2;
	srfvert[istruct][isrf][nvert[istruct][isrf]-1].vert[2] = (float) *v3;
	srfvert[istruct][isrf][nvert[istruct][isrf]-1].type = type;
      }
}

#if defined(VMS) || defined(UNDERSC)
void ogcoll(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGCOLL(double *v1, double *v2, double *v3)
#else
void ogcoll_(double *v1, double *v2, double *v3)
#endif
#endif
{


      putvrt(v1,v2,v3,0);

      glColor4d(*v1,*v2,*v3,tr_val);
}


void ogelev(name)
char *name;
{
      int i;
      char *endquote;

      glPopMatrix();
      glPushMatrix();

      NSurf[istruct]++;
      endquote = strchr(name,'\"');
      if (endquote != NULL) endquote[0] = '\0';
      sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(strlen(name)+1);
      strcpy(sndstr[istruct][NSurf[istruct]-1],name);
      allocvert(MXVERT,1);

      theSurf[istruct][NSurf[istruct]-1] = glGenLists(1); 
      glNewList(theSurf[istruct][NSurf[istruct]-1], GL_COMPILE);

      for (i=0; i<4; i++)
	diffuseColor[istruct][NSurf[istruct]-1][i] = materialColor[ecol][i];
      SStyp[istruct][NSurf[istruct]-1] = 2;
      Schain[istruct][NSurf[istruct]-1] = -1;

      glBegin(GL_QUADS);
}

#if defined(VMS) || defined(UNDERSC)
void ogribb(iscnd)
#else
#ifdef CRAY
void OGRIBB(iscnd)
#else
void ogribb_(iscnd)
#endif
#endif
int *iscnd;
{
      int i;

      if (NSurf[istruct] >= MAXSURF) return;

      NSurf[istruct]++;
      if (sndstr[istruct][NSurf[istruct]-1] != NULL) 
	free(sndstr[istruct][NSurf[istruct]-1]);

      switch (*iscnd) {
	case 0:
		RIBindex[istruct].nhelx++;
		sndstr[istruct][NSurf[istruct]-1] =
			(char *) malloc(10);
		sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"Helix %d",RIBindex[istruct].nhelx);
		break;
	case 1:
		RIBindex[istruct].nbeta++;
		sndstr[istruct][NSurf[istruct]-1] =
			(char *) malloc(9);
		sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"Beta %d",RIBindex[istruct].nbeta);
		break;
	case 2:
		RIBindex[istruct].nrna++;
		sndstr[istruct][NSurf[istruct]-1] =
			(char *) malloc(8);
		sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"RNA %d",RIBindex[istruct].nrna);
		break;
	case 3:
		RIBindex[istruct].ncoil++;
		sndstr[istruct][NSurf[istruct]-1] =
			(char *) malloc(9);
		sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"Coil %d",RIBindex[istruct].ncoil);
		break;
      }

      if (theSurf[istruct][NSurf[istruct]-1] > 0) 
	glDeleteLists(theSurf[istruct][NSurf[istruct]-1],1);
      theSurf[istruct][NSurf[istruct]-1] = glGenLists(1); 
      allocvert(MXVERT,1);
      glEnable(GL_COLOR_MATERIAL);
      glNewList(theSurf[istruct][NSurf[istruct]-1], GL_COMPILE);
      SStyp[istruct][NSurf[istruct]-1] = 2;
      Schain[istruct][NSurf[istruct]-1] = -1;

      glBegin(GL_QUADS);
}

void putbyte(outf,val)
FILE *outf;
unsigned char val;
{
        unsigned char buf[1];

        buf[0] = val;
        fwrite(buf,1,1,outf);
}

void putshort(outf,val)
FILE *outf;
unsigned short val;
{
        unsigned char buf[2];

        buf[0] = (val>>8);
        buf[1] = (val>>0);
        fwrite(buf,2,1,outf);
    }

static int putlong(outf,val)
FILE *outf;
unsigned long val;
{
	unsigned char buf[4];

	buf[0] = (val>>24);
	buf[1] = (val>>16);
	buf[2] = (val>>8);
	buf[3] = (val>>0);
	return fwrite(buf,4,1,outf);
}

int WOGLGIF(filename)
    char *filename;
{
  int   ColorMapSize, BitsPerPixel;
  int   i,j,nc;
  int   numcols;
  Byte *imag;
  Byte  rmap[256],gmap[256],bmap[256];

  int rowlen;
  GLubyte *rgbbuf;
  GLint viewport[4];

  GIFFile = fopen(filename,"w+b");
  if (!GIFFile) {
	fprintf(stderr,"Output Error: Unable to create GIF file %s\n",filename);
	return(0);
  }

  glGetIntegerv(GL_VIEWPORT, viewport);

  rowlen = viewport[2];
  if (width < rowlen) rowlen = width;

  glPixelStorei(GL_PACK_ROW_LENGTH,rowlen);
  glPixelStorei(GL_PACK_ALIGNMENT,1);

  rgbbuf = (GLubyte *)malloc(3*rowlen*height*sizeof(GLubyte));
  if (!rgbbuf) {
       fprintf(stderr,"moldenogl: couldn't allocate memory\n");
       fclose(GIFFile);
       return(1);
  }
  glReadBuffer(GL_FRONT);
  glReadPixels(0,0,width,height,GL_RGB,GL_UNSIGNED_BYTE,rgbbuf);

  numcols = 256;
  imag = (Byte *) malloc((size_t) (width * height));

  if (!imag) {
	fprintf(stderr,"Unable to malloc in WriteGIF()");
	return(1);
  }

  clmap[0] = (unsigned char *) rmap;
  clmap[1] = (unsigned char *) gmap;
  clmap[2] = (unsigned char *) bmap;

  if (quant((Byte *) rgbbuf, width, height, imag, numcols) ) {
	free(imag);  return(1); 
  }
  
  for (i=0; i<numcols; i++) { 
	pix2col[i] = red[i] = green[i] = blue[i] = 0;
  }

  nc = 0;

  for (i=0; i<numcols; i++) {
    for (j=0; j<i; j++) {
      if (rmap[i] == rmap[j] && gmap[i] == gmap[j] && 
	  bmap[i] == bmap[j]) break;
    }

    if (j==i) {
      pix2col[i] = nc;
      red[nc]   = rmap[i];
      green[nc] = gmap[i];
      blue[nc]  = bmap[i];
      nc++;
    }
    else pix2col[i] = pix2col[j];
  }

  for (BitsPerPixel=1; BitsPerPixel<8; BitsPerPixel++)
    if ( (1<<BitsPerPixel) >= nc) break;
  
  ColorMapSize = 1 << BitsPerPixel;
	
  fwrite("GIF87a", (size_t) 1, (size_t) 6, GIFFile);
  fputc(width&0xff,GIFFile);  fputc((width>>8)&0xff,GIFFile);
  fputc(height&0xff,GIFFile);  fputc((height>>8)&0xff,GIFFile);

  fputc(0xf0|(BitsPerPixel-1),GIFFile);

  fputc(0, GIFFile);
  fputc(0, GIFFile);

  for (i=0; i<ColorMapSize; i++) { 
      fputc(red[i], GIFFile);
      fputc(green[i], GIFFile);
      fputc(blue[i], GIFFile);
  }

  fputc( ',', GIFFile );

  fputc(0x00,GIFFile); fputc(0x00,GIFFile);
  fputc(0x00,GIFFile); fputc(0x00,GIFFile);
  fputc(width&0xff,GIFFile); fputc((width>>8)&0xff,GIFFile);
  fputc(height&0xff,GIFFile); fputc((height>>8)&0xff,GIFFile);
  fputc(0x00,GIFFile); fputc(BitsPerPixel,GIFFile);

  compress(BitsPerPixel, nc, imag, 2);

  fputc(';',GIFFile);
  fclose(GIFFile);
  free(rgbbuf);
  free(imag);

  return(0);
}

void save_rgb(rgbfile)
char *rgbfile;
{
	FILE *of;
        char iname[80];
        int i, k, x, y, rowlen;
	int Xsize, Ysize;
	GLubyte *rgbbuf;
	GLint viewport[4];

        of = fopen(rgbfile,"w");

        if (!of) {
            fprintf(stderr,"moldenogl: can't open output file\n");
            return;
        }

	glGetIntegerv(GL_VIEWPORT, viewport);
	Xsize = width;
	Ysize = height;

	rowlen = viewport[2];
	if (width < rowlen) rowlen = width;

	glPixelStorei(GL_PACK_ROW_LENGTH,rowlen);
	glPixelStorei(GL_PACK_ALIGNMENT,1);

	rgbbuf = (GLubyte *)malloc(3*rowlen*height*sizeof(GLubyte));
	if (!rgbbuf) {
	   fprintf(stderr,"moldenogl: couldn't allocate memory\n");
	   fclose(of);
	   return;
	}
	glReadBuffer(GL_FRONT);
	glReadPixels(viewport[0],viewport[1],Xsize,Ysize,GL_RGB,GL_UNSIGNED_BYTE,rgbbuf);

        putshort(of,474);	/* MAGIC		*/
        putbyte(of,0);		/* STORAGE is VERBATIM	*/
        putbyte(of,257);	/* BPC is 257          	*/
        putshort(of,3);		/* DIMENSION is 3	*/
        putshort(of,Xsize);	/* XSIZE               	*/
        putshort(of,Ysize);	/* YSIZE               	*/
        putshort(of,3);		/* ZSIZE               	*/
        putlong(of,0);		/* PIXMIN is 0         	*/
        putlong(of,255);	/* PIXMAX is 255       	*/
        for(i=0; i<4; i++)	/* DUMMY 4 bytes 	*/
            putbyte(of,0);
        strcpy(iname,"Moldenogl");
        fwrite(iname,80,1,of);	/* IMAGENAME  		*/
        putlong(of,0);		/* COLORMAP is 0 	*/

        for(i=0; i<404; i++)
            putbyte(of,0);

/* red */
        k=0;
        for(i=0;i< Xsize*Ysize; i++){
         fwrite( &rgbbuf[k] ,sizeof(*rgbbuf), 1, of);
         k=k+3;
        }

/* green */
        k=0;
        for(i=0;i< Xsize*Ysize; i++){
         fwrite( &rgbbuf[k+1] ,sizeof(*rgbbuf), 1, of);
         k=k+3;
        }

/* blue */
        k=0;
        for(i=0;i< Xsize*Ysize; i++){
         fwrite( &rgbbuf[k+2] ,sizeof(*rgbbuf), 1, of);
         k=k+3;
        }

        fclose(of);
	free(rgbbuf);
}

unsigned char bmp_header[]=
{ 'B','M', 0,0,0,0, 0,0, 0,0, 54,0,0,0,
  40,0,0,0, 0,0,0,0, 0,0,0,0, 1,0, 24,0, 0,0,0,0, 0,0,0,0,
  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0 };

static void WLSBL(val,arr)
    int val;
    unsigned char* arr;
{
    arr[0] = (char) (val&0xff);
    arr[1] = (char) ((val>>8) &0xff);
    arr[2] = (char) ((val>>16)&0xff);
    arr[3] = (char) ((val>>24)&0xff);
}

void save_bmp(rgbfile)
char *rgbfile;
{ int i,j;
  FILE *fp;
  GLubyte *rgbbuf;
  GLubyte rgbtmp[3];
  GLint viewport[4];
  int Xsize, Ysize, rowlen;
  int pad;

  fp = fopen(rgbfile,"wb");

  if (!fp) {
       fprintf(stderr,"moldenogl: can't open output file\n");
       return;
  }

  glGetIntegerv(GL_VIEWPORT, viewport);

  Xsize = width;
  Ysize = height;

  rowlen = viewport[2];
  if (width < rowlen) rowlen = width;

  glPixelStorei(GL_PACK_ROW_LENGTH,rowlen);
/*  glPixelStorei(GL_PACK_ROW_LENGTH,Ysize);*/
  glPixelStorei(GL_PACK_ALIGNMENT,1);

  rgbbuf = (GLubyte *)malloc(3*rowlen*Ysize*sizeof(GLubyte));
  if (!rgbbuf) {
	fprintf(stderr,"moldenogl: couldn't allocate memory\n");
	fclose(fp);
	return;
  }
  glReadBuffer(GL_FRONT);
  glReadPixels(viewport[0],viewport[1],Xsize,Ysize,GL_RGB,GL_UNSIGNED_BYTE,rgbbuf);

/* The number of bytes on a screenline should be wholly devisible by 4 */

  pad = (Xsize*3)%4;
  if (pad) pad = 4 - pad;

  WLSBL((int) (3*Xsize+pad)*Ysize+54,bmp_header+2);
  WLSBL((int) Xsize,bmp_header+18);
  WLSBL((int) Ysize,bmp_header+22);
  WLSBL((int) 3*Xsize*Ysize,bmp_header+34);

  fwrite(bmp_header,1,54,fp);

  for (i=0;i<Ysize;i++) {
    for (j=0;j<Xsize;j++) {
	rgbtmp[0] = rgbbuf[(j+rowlen*i)*3+2];
	rgbtmp[1] = rgbbuf[(j+rowlen*i)*3+1];
	rgbtmp[2] = rgbbuf[(j+rowlen*i)*3+0];
	fwrite(rgbtmp,3,1,fp);
    }
    rgbtmp[0] = (char) 0;
    for (j=0;j<pad;j++) fwrite(rgbtmp,1,1,fp);
  }
  fclose(fp);
  free(rgbbuf);
}


void empty_ribb()
{
  int i,j;
  int SSont[MAXSURF],NStmp;

  for (i=0; i < 4; i++) {
	for (j=RIBindex[istruct].start[i]; 
		j <= RIBindex[istruct].end[i]; j++) {
		if (j >= 0) SSon[istruct][j] = -1;
	}
  }

  NStmp = 0;
  for (i=0; i < NSurf[istruct]; i++) 
	if (SSon[istruct][i] != -1) {
		SSont[NStmp] = SSon[istruct][i];
		NStmp++;
	}

  for (i=0; i < NSurf[istruct]; i++) 
	SSon[istruct][i] = 0;

  for (i=0; i < 4; i++) {
	for (j=RIBindex[istruct].start[i]; 
		j <= RIBindex[istruct].end[i]; j++) {
		if (j >= 0) SSon[istruct][j] = 1;
	}
  }

  DeleteActiveSurfaces();

  for (i=0; i < NSurf[istruct]; i++) 
	SSon[istruct][i] = SSont[i];

  RIBindex[istruct].nhelx = 0;
  RIBindex[istruct].nbeta = 0;
  RIBindex[istruct].nrna = 0;
  RIBindex[istruct].ncoil = 0;

  SSdone[istruct] = -1;

}

void empty_model(sel,updis)
int sel;
int updis;
{
  int i;

  if (!has_opengl) return;

  if (theMol[sel][0] != -1)
	glDeleteLists(theMol[sel][0],1);
  theMol[sel][0] = (GLuint) -1;
  for (i=0; i<NSurf[sel]; i++) {
      if (theSurf[sel][i] != -1)
	glDeleteLists(theSurf[sel][i],1);
      theSurf[sel][i] = -1;
      if (sndstr[sel][i] != NULL) free(sndstr[sel][i]);
      sndstr[sel][i] = NULL;
      if (srfvert[sel][i] != NULL) free(srfvert[sel][i]);
      srfvert[sel][i] = NULL;
      nvert[sel][i] = 0;
      nvrtmx[sel][i] = 0;
      Schain[sel][i] = -1;
      clp[sel][i] = -1;
      trns[sel][i] = -1;
      if (!addfile) SSon[sel][i] = 0;
  }

  RIBindex[sel].nhelx = 0;
  RIBindex[sel].nbeta = 0;
  RIBindex[sel].nrna = 0;
  RIBindex[sel].ncoil = 0;

  for (i=0; i<4; i++) {
	RIBindex[sel].start[i] = -1;
	RIBindex[sel].end[i] = -1;
  }

  if (*ipdbon) {
      for (i=0; i<calfptr->ncalf; i++) {
	if (theRes[sel][i] != -1)
	   glDeleteLists(theRes[sel][i],1);
	theRes[sel][i] = -1;
	if (theBck[sel][i] != -1)
	   glDeleteLists(theBck[sel][i],1);
	theBck[sel][i] = -1;
      }
  }
  if (theLines[sel] != -1)
      glDeleteLists(theLines[sel],1);
  theLines[sel] = -1;

  if (theFLines[sel] != -1)
      glDeleteLists(theFLines[sel],1);
  theFLines[sel] = -1;

  if (thePoints[sel] != -1)
      glDeleteLists(thePoints[sel],1);
  thePoints[sel] = -1;

  if (theForces[sel] != -1)
      glDeleteLists(theForces[sel],1);
  theForces[sel] = -1;

  if (theSArrow[sel] != -1)
      glDeleteLists(theSArrow[sel],1);
  theSArrow[sel] = -1;

  if (theFeat[sel] != -1)
      glDeleteLists(theFeat[sel],1);
  theFeat[sel] = -1;

  if (theIntSurf[sel] != -1)
      glDeleteLists(theIntSurf[sel],1);
  theIntSurf[sel] = -1;

  if (theIntSurf2[sel] != -1)
      glDeleteLists(theIntSurf2[sel],1);
  theIntSurf2[sel] = -1;

  if (theLigSurf[sel] != -1)
      glDeleteLists(theLigSurf[sel],1);
  theLigSurf[sel] = -1;

  if (theMon[sel] != -1)
      glDeleteLists(theMon[sel],1);
  theMon[sel] = -1;

  if (theSel[sel] != -1)
      glDeleteLists(theSel[sel],1);
  theSel[sel] = -1;

  if (theBox[sel] != -1)
      glDeleteLists(theBox[sel],1);
  theBox[sel] = -1;

  SSdone[sel] = -1;
  NSurf[sel] = 0;

  if (updis) {
     if ((((*fancy || *fullgl) && !denmode) || (*ifdogl && denmode)) 
	&& has_opengl) dispsf();
  }
  RedrawSTRC();
}

void setcl(i)
int i;
{
  if (glIsEnabled(GL_COLOR_MATERIAL)) {
	glColor4f(diffuseColor[istruct][i][0], diffuseColor[istruct][i][1],
	diffuseColor[istruct][i][2],(GLfloat) tr_val);
  }

  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, &diffuseColor[istruct][i][0]);
  if (denmode) glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientDColor);
  else glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientColor);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, &specularColor[i][0]);
  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 100.0);
}

#if defined(VMS) || defined(UNDERSC)
void setcll()
#else
#ifdef CRAY
void SETCLL()
#else
void setcll_()
#endif
#endif
{
  int isrf,i;
  float grcol[4] = {0.6,0.6,0.6,0.6};
  float spcol[4] = {0.8,0.8,0.8,1.0};

  glEnd();
  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, grcol);
  if (denmode) glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientDColor);
  else glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientColor);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, spcol);
  glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 100);
  isrf = NSurf[istruct]-1;
  nvert[istruct][isrf]++;
  srfvert[istruct][isrf][nvert[istruct][isrf]-1].type = 2;
  glBegin(GL_QUADS);
  glColor4d(grcol[0], grcol[1], grcol[2], grcol[3]);
}

void pldst()
{
  int i,i1,i2,ixt,iyt,i8;
  char s[9];

  i8 = 8;
  XSetForeground(display, gc, colors[15]);

  for (i=0; i<monptr->ndm; i++) {
	i1 = monptr->idmon[i][0] - 1;
	i2 = monptr->idmon[i][1] - 1;
	ixt = (xyzp->ixp[i1] + xyzp->ixp[i2])/2;
	iyt = (xyzp->iyp[i1] + xyzp->iyp[i2])/2;
	sprintf(s,"%8.3f",monptr->rdm[i]);

#if defined(VMS) || defined(UNDERSC)
	drwstr(&ixt,&iyt,s,&i8,&MONE);
#else
#ifdef CRAY
	DRWSTR(&ixt,&iyt,s,&i8,&MONE);
#else
	drwstr_(&ixt,&iyt,s,&i8,&MONE);
#endif
#endif
  }
}

void prtMat(Mat)
GLdouble *Mat;
{
     fprintf(stderr,"modelV:\n");
     fprintf(stderr,"%f %f %f %f\n",Mat[0],Mat[1],Mat[2],Mat[3]);
     fprintf(stderr,"%f %f %f %f\n",Mat[4],Mat[5],Mat[6],Mat[7]);
     fprintf(stderr,"%f %f %f %f\n",Mat[8],Mat[9],Mat[10],Mat[11]);
     fprintf(stderr,"%f %f %f %f\n",Mat[12],Mat[13],Mat[14],Mat[15]);
}

static GLdouble InvModelMat[16];

void InvRotMat()
{
  GLdouble modelMatrix[16];

  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glRotatef(45.0,0.0,1.0,0.0);
  glGetDoublev(GL_MODELVIEW_MATRIX,InvModelMat);
  //invmat(modelMatrix,InvModelMat);
  glPopMatrix();
}

void ModelMatInv()
{
  GLdouble modelMatrix[16];

  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glGetDoublev(GL_MODELVIEW_MATRIX,modelMatrix);
  invmat(modelMatrix,InvModelMat);
  glPopMatrix();
}

void SetGLSLVar()
{

  if (has_shader) {
#ifdef GL_COLOR_ATTACHMENT0_EXT
	if (DoShadow) {
	    glUseProgramObjectARB(program[11]);
	} else {
#endif
	    glUseProgramObjectARB(program[0]);
	    if (*shade) {
		glUniform1iARB(dofog, 1);
	    } else {
		glUniform1iARB(dofog, 0);
	    }
	    if (DoBlur) {
		glUniform1iARB(doblur, 1);
	    } else glUniform1iARB(doblur, 0);
	    if (DoSSAO) {
		glUniform1iARB(dossao, 1);
	    } else glUniform1iARB(dossao, 0);
	    if (DoShad) {
		glUniform1iARB(DoShadLoc, 1);
	    } else glUniform1iARB(DoShadLoc, 0);
	    if (TRANS) {
		glUniform1iARB(dotrns, 1);
	    } else glUniform1iARB(dotrns, 0);
#ifdef GL_COLOR_ATTACHMENT0_EXT
	}
#endif
  }
}

void trnsproj0()
{
  double sc;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  if (*persp) {
	glFrustum(-0.2*Aspect,0.2*Aspect,-0.2,0.2,0.3,600.0);
  } else {
	glOrtho(1.0*Aspect,-1.0*Aspect,1.0,-1.0,-10.0,300.0);
  }

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  if (*persp) {
	glTranslatef( 1.0*posptr->yv, -1.0*posptr->xv, -2.0*posptr->zv);
  } else {
	sc = -1.0 / scalptr->scal;
	glScalef(sc,sc,-1.0*sc);
	glTranslatef( 1.0*posptr->yv, -1.0*posptr->xv, 0.0);
  }
  glEnable(GL_NORMALIZE);
}

void trnsproj1()
{
#ifdef GL_COLOR_ATTACHMENT0_EXT
  if (DoShadow) glRotatef(25.0,0.0,1.0,0.0);
#endif

  glMultMatrixd((const GLdouble *) RR);

  if (denmode) glTranslatef(-rotptr->td[0] ,-rotptr->td[1],-rotptr->td[2]);
  else glTranslatef(-rotptr->t[0] ,-rotptr->t[1],-rotptr->t[2]);
}

void dispsf()
{
  int i,j,j1,Ca,sizt,idres,ilptr;
  int zero = 0;
  double ca,sa,x,y,z,tn[3];
  GLdouble modelMatrix[16];
  GLdouble projMatrix[16];
  GLint viewport[4];
  GLdouble tmp1[3],tmp2[3],xt,yt,zt,srad;

  float tmp[3];
  float axes_light[] = {0.0, 0.0, -4.0, 1};

  glXMakeCurrent(display, win, cx);

  glDisable(GL_CULL_FACE);
  glClearDepth(1);
  if (DoShadow) {
	glClearColor(0.0, 0.0, 0.0, 1.0);
  } else {
	glClearColor(gradcol[0][0],gradcol[0][1],gradcol[0][2],1.0);
  }

#ifdef GL_COLOR_ATTACHMENT0_EXT
  if ((DoBlur || DoSSAO) && has_fbo) {
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[0]);
	glDrawBuffers(2,buffers);
  }

/*
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
*/


  if (DoShadow && has_fbo) {
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[0]);
	glDrawBuffers(1,buffers);
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
  }

#endif

#ifdef GL_ARB_shader_objects
  if (has_shader) glUseProgramObjectARB(0);
#endif
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

#ifdef GL_COLOR_ATTACHMENT0_EXT
  if (!DoShadow) glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
#endif

  for (i=0; i < 3; i++) {
     RR[i][1] = rotptr->rx[i];
     RR[i][0] = -rotptr->ry[i];
     RR[i][2] = rotptr->rz[i];
  }

  if (!DoShadow) if (BGmode) bckgrad();

#ifdef GL_COLOR_ATTACHMENT0_EXT
  if (DoSSAO && has_fbo) {
	   glDrawBuffer(GL_COLOR_ATTACHMENT2_EXT);
	   glClearColor(0.0, 0.0, 0.0, 1.0);
	   glClear(GL_COLOR_BUFFER_BIT);
	   glDrawBuffers(3,buffers);
  }
#endif

  if (AXES) {

/* create the projection and model matrix for the axes */

     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
     glLightfv(GL_LIGHT2, GL_POSITION, axes_light);
     glScalef(1.0,1.0,-1.0);
     glTranslatef(-0.8 ,-0.8, 0.0);
     glScalef(0.1,0.1,0.1);
     glMultMatrixd((const GLdouble *) RR);
     glCallList(theAxes);

     glGetDoublev(GL_MODELVIEW_MATRIX,modelMatrix);
     glGetDoublev(GL_PROJECTION_MATRIX,projMatrix);
     glGetIntegerv(GL_VIEWPORT,viewport);

     for (i=1; i<4; i++) {
        if (gluProject((GLdouble) AxesXYZ[i][0],(GLdouble) AxesXYZ[i][1],(GLdouble) AxesXYZ[i][2],modelMatrix,projMatrix,viewport,&xt,&yt,&zt)) {
           AxesProj[i][0] = (height - (int) yt);
           AxesProj[i][1] = (int) xt;
	}
     }
/* 
   remark: there is a difference between lighting in xwindow and OpenGL
           the opengl z-axis is pointing the opposite direction of the
           xwindows z-axis (with respect to shading
   The glScalef(1.0,1.0,-1.0); has to do with that
*/
  }

SHADOW:

  trnsproj0();
  glMatrixMode(GL_MODELVIEW);

/*  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION, &gradcol[1][0]);*/
  glLightfv(GL_LIGHT0, GL_POSITION, light0_position[istruct]);
  if (DoLights) {
     glPushMatrix();
     glTranslatef(light0_position[istruct][0],light0_position[istruct][1],
		  light0_position[istruct][2]);
     gluSphere(sphere, 1, 10, 10);
     glPopMatrix();
  }

  glLightfv(GL_LIGHT1, GL_POSITION, light1_position[istruct]);
  if (DoLights) {
     glPushMatrix();
     glTranslatef(light1_position[istruct][0],light1_position[istruct][1],
		  light1_position[istruct][2]);
     gluSphere(sphere, 1, 10, 10);
     glPopMatrix();
  }

  glLightfv(GL_LIGHT2, GL_POSITION, light2_position[istruct]);
  if (DoLights) {
     glPushMatrix();
     glTranslatef(light2_position[istruct][0],light2_position[istruct][1],
		  light2_position[istruct][2]);
     gluSphere(sphere, 1, 10, 10);
     glPopMatrix();
  }


/*  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION, &AxesCol[0][0]);*/

  trnsproj1();

#ifdef GL_COLOR_ATTACHMENT0_EXT
  if (DoShadow) {
     setTextureMatrix();
  } else if (DoShad) {
     glPushMatrix();
     glMatrixMode(GL_TEXTURE);
     glActiveTextureARB(GL_TEXTURE7);
     glLoadIdentity();
     glMultMatrixd(TexMat);
     glMatrixMode(GL_MODELVIEW);
     glPopMatrix();
  }
#endif

  glGetDoublev(GL_MODELVIEW_MATRIX,modelMatrix);
  glGetDoublev(GL_PROJECTION_MATRIX,projMatrix);
  glGetIntegerv(GL_VIEWPORT,viewport);
  if (viewport[2] != width || viewport[3] != height) {
	glViewport(0,0,width,height);
	viewport[2] = width; viewport[3] = height;
  }

  for (i=0; i<*xyzp->iatoms; i++) {
        tmp1[0] = (GLdouble) (xyzp->coo[i*3]);
        tmp1[1] = (GLdouble) (xyzp->coo[i*3+1]);
        tmp1[2] = (GLdouble) (xyzp->coo[i*3+2]);
        if (gluProject(tmp1[0],tmp1[1],tmp1[2],modelMatrix,projMatrix,viewport,&xt,&yt,&zt)) {
           xyzp->ixp[i] = (height - (int) yt);
           xyzp->iyp[i] = (int) xt;
           xyzp->rzp[i] = (double) zt;
	   if (*persp && zt > 1.0) xyzp->rzp[i] = -1.0;
	}
  }

  for (i=0; i< pharm.nfeat; i++) {
        tmp1[0] = (GLdouble) (pharm.array[i].cor[0]);
        tmp1[1] = (GLdouble) (pharm.array[i].cor[1]);
        tmp1[2] = (GLdouble) (pharm.array[i].cor[2]);
        if (gluProject(tmp1[0],tmp1[1],tmp1[2],modelMatrix,projMatrix,viewport,&xt,&yt,&zt)) {
           pharm.ixp[i] = (height - (int) yt);
           pharm.iyp[i] = (int) xt;
           pharm.rzp[i] = (double) zt;
	}
  }

  EnableFog();

  if (update_sel) {
     ogsel();
  } else {
     glCallList(theSel[istruct]);
  }

  if (has_shader) {
#ifdef GL_COLOR_ATTACHMENT0_EXT
	if (DoShadow) {
#ifdef GL_ARB_shader_objects
	    glUseProgramObjectARB(program[11]);
#endif
	} else {
#endif
#ifdef GL_ARB_shader_objects
	    glUseProgramObjectARB(program[0]);
	    if (*shade) {
		glUniform1iARB(dofog, 1);
	    } else {
		glUniform1iARB(dofog, 0);
	    }
	    if (DoBlur) {
		glUniform1iARB(doblur, 1);
	    } else glUniform1iARB(doblur, 0);
	    if (DoSSAO) {
		glUniform1iARB(dossao, 1);
	    } else glUniform1iARB(dossao, 0);
	    if (DoShad) {
		glUniform1iARB(DoShadLoc, 1);
	    } else glUniform1iARB(DoShadLoc, 0);
	    if (!*fancy) glUseProgramObjectARB(0);
#endif
#ifdef GL_COLOR_ATTACHMENT0_EXT
	}
#endif
  }

#ifdef GL_COLOR_ATTACHMENT0_EXT
#ifdef GL_ARB_shader_objects
  if (!DoShadow && DoShad) {

     if (*fancy) {
	glUseProgramObjectARB(program[0]);
	glUniform1iARB(DoShadLoc,0);
     }
  }
#endif
#endif

  if (*ipdbon && (*fancy || *fullgl)) {
	for (i=0; i<calfptr->ncalf; i++) {
          if (calfptr->reson[i]) {glCallList(theRes[istruct][i]);}
	  else {
	     int isa;

	     isa = calfptr->isal[i];
	     if (isa >= 0 && isa < MXHETA) {
		if (!calfptr->ihet[calfptr->isal[i]]) 
		   glCallList(theBck[istruct][i]);
	     }
	  }
	}
  }

  glDisable(GL_COLOR_MATERIAL);


  if (*fancy || denmode) {
	glCallList(theMol[istruct][0]);
	if (*irtcel && *ialtyp) glCallList(theMol[istruct][1]);
  } 

  if (*fancy || *fullgl) {
	if (monptr->ndm) glCallList(theMon[istruct]);
  }

  if (PHRMup) glCallList(theFeat[istruct]);

  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

  if (has_shader) glUseProgramObjectARB(0);


  if (PHRMup) glCallList(theAFeat[istruct]);

  glCallList(theLines[istruct]);
  if (DoNorms) glCallList(theNorm);
  if (DoIntSurf) {
	if (!IntSurfDone) {
	   if (*ipdbon) {
		ogIntSurf();
	   } else {
		ogLigSurf();
	   }
	}
	glCallList(theIntSurf[istruct]);
	glCallList(theIntSurf2[istruct]);
	glCallList(theLigSurf[istruct]);
  }

  if (!*fancy && !denmode && *fullgl) {
	glCallList(theFLines[istruct]);
	glCallList(thePoints[istruct]);
  }

  SetGLSLVar();

  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

  if (*forces_yes_no) glCallList(theForces[istruct]);
  if (update_casel) glCallList(theSArrow[istruct]);
  if (qdpptr->idipon) glCallList(theDipole[istruct]);

  if (theBox[istruct] != -1) glCallList(theBox[istruct]);

  for (i=0; i<NSurf[istruct]; i++) {

    if (OMAPtype) {
       glPopMatrix();
       glPushMatrix();
    }
    if (SSon[istruct][i]) {
      if (DoLines && Schain[istruct][i] == -1) {
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	glLineWidth(2.0);
      } else {
	if (!DoShadow) glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
      }

      if (clp[istruct][i]) {
	 glEnable(GL_CLIP_PLANE0);
	 glEnable(GL_CLIP_PLANE1);
	 glEnable(GL_CLIP_PLANE2);
	 glEnable(GL_CLIP_PLANE3);
	 glEnable(GL_CLIP_PLANE4);
	 glEnable(GL_CLIP_PLANE5);

	 if (OMAPtype) {
	   theEQ1[3] =  (scalptr->scali*(-2.0*omaprat[0] + 1.0) + 2.0*posptr->zv );
	   theEQ2[3] =  (scalptr->scali*(2.0*omaprat[1] - 1.0) - 2.0*posptr->zv );
	 } else {
	   theEQ1[3] =  EQ[0];
	   theEQ2[3] =  (-EQ[0] + slab[0]);
	 }

	 theEQ3[3] =  EQ[1];
	 theEQ4[3] =  (-EQ[1] + slab[1]);

	 theEQ5[3] =  EQ[2];
	 theEQ6[3] =  (-EQ[2] + slab[2]);

	 glClipPlane(GL_CLIP_PLANE0,theEQ1);
	 glClipPlane(GL_CLIP_PLANE1,theEQ2);
	 glClipPlane(GL_CLIP_PLANE2,theEQ3);
	 glClipPlane(GL_CLIP_PLANE3,theEQ4);
	 glClipPlane(GL_CLIP_PLANE4,theEQ5);
	 glClipPlane(GL_CLIP_PLANE5,theEQ6);
      }

      if (trns[istruct][i]) {
//      if (trns[istruct][i] && Schain[istruct][i] == -1) {
         glEnable(GL_BLEND);
         glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
	 diffuseColor[istruct][i][3] = tr_val;
#ifdef GL_ARB_shader_objects
	 glUseProgramObjectARB(program[0]);
	 dotrns   = glGetUniformLocationARB(program[0], "dotrns");
	 glUniform1iARB(dotrns, 1);
	 if (DoShadow) glUseProgramObjectARB(program[11]);
#endif
      } else {
	 diffuseColor[istruct][i][3] = 1.0;
         glDisable(GL_BLEND);
#ifdef GL_ARB_shader_objects

	 glUseProgramObjectARB(program[0]);
	 glUniform1iARB(dotrns, 0);
	 if (DoShadow) glUseProgramObjectARB(program[11]);
#endif
      }

      setcl(i);
      
#ifdef GL_ARB_shader_objects
      if (has_shader) {
	glUseProgramObjectARB(program[0]);
	if (SStyp[istruct][i] == 1) {
		glUniform1iARB(colmat, 1);
	} else {
		glUniform1iARB(colmat, 0);
	}
	if (DoShadow) glUseProgramObjectARB(program[11]);
      }
#endif
      
      if (OMAPtype) {
	  trnsproj0();
	  trnsproj1();
      }

      glCallList(theSurf[istruct][i]);

#ifdef GL_ARB_shader_objects
      if (has_shader && SStyp[istruct][i] == 1) {
		glUseProgramObjectARB(program[0]);
		glUniform1iARB(colmat, 0);
		if (DoShadow) glUseProgramObjectARB(program[11]);
      }
#endif

      if (clp[istruct][i]) {
	 glDisable(GL_CLIP_PLANE0);
	 glDisable(GL_CLIP_PLANE1);
	 glDisable(GL_CLIP_PLANE2);
	 glDisable(GL_CLIP_PLANE3);
	 glDisable(GL_CLIP_PLANE4);
	 glDisable(GL_CLIP_PLANE5);
      }
    }

  }

//  if (theBox[istruct] != -1) glCallList(theBox[istruct]);

  if (DoDockCenter) {
     ogDockSphere();
  }

#ifdef GL_COLOR_ATTACHMENT0_EXT
  if (has_fbo) {

     if (DoShadow) {
	if (DoMIPMAP) glGenerateMipmapEXT(GL_TEXTURE_2D);
	blurShadowMap();

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,0);
	glClearColor(gradcol[0][0],gradcol[0][1],gradcol[0][2],1.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glDisable(GL_CULL_FACE);
	glUseProgramObjectARB(0);
	if (BGmode) bckgrad();
	//glEnable(GL_NORMALIZE);
	glShadeModel(GL_SMOOTH);
	glActiveTexture(GL_TEXTURE7);
	glBindTexture(GL_TEXTURE_2D,fbo.texid[0]);
	//glLightfv(GL_LIGHT2, GL_POSITION, lightPos);
	glEnable(GL_CULL_FACE);
	//glEnable(GL_POLYGON_OFFSET_FILL);
	//glPolygonOffset(-1.2, 4);
	glCullFace(GL_BACK);
	DoShadow = 0;
	goto SHADOW;
     }


     if (DoBlur) DepthBlur();

     if (DoSSAO) SSAO();
  }

  if (DoShad) DoShadow = 1;
#endif

#ifdef GL_ARB_shader_objects
  if (has_shader) glUseProgramObjectARB(0);
#endif

  glFlush();
  glXWaitGL();
  if (StarNetOld) glXSwapBuffers(display, win);
  if (!gmoving && !mmoving && !smoving) {
    glXWaitGL();
    if (StarNetOld) XSetForeground(display, gc, colors[*ifntcl]);
    if (!StarNetOld) initPrintStrings(0);
    for (i=0; i<*xyzp->iatoms; i++) {
        j = i + 1;
	idres = 0;
	ilptr = qdpptr->iqon;
	if (xyzp->iresid[i] > 0) {
	   if (calfptr->lab[xyzp->iresid[i]-1] > 0) {
		idres = 1;
		ilptr = calfptr->lab[xyzp->iresid[i]-1];
		ilptr--;ilptr--;
	   }
	} else {
	   if (clfstrptr->labhet[ABS(xyzp->iresid[i])] > 0) {
		idres = 1;
		ilptr = clfstrptr->labhet[ABS(xyzp->iresid[i])];
		ilptr--;ilptr--;
	   }
	}
        if ((*dolabs || idres == 1) && !denmode) {
          if (xyzp->iaton[i] >= 1 && xyzp->rzp[i] > 0.0 )  {
#if defined(VMS) || defined(UNDERSC)
   	   pllab(&xyzp->ixp[i],&xyzp->iyp[i],&xyzp->ianz[i],&j,
#else
#ifdef CRAY
   	   PLLAB(&xyzp->ixp[i],&xyzp->iyp[i],&xyzp->ianz[i],&j,
#else
   	   pllab_(&xyzp->ixp[i],&xyzp->iyp[i],&xyzp->ianz[i],&j,
#endif
#endif
		&xyzp->qat[i],&zero,&ilptr,&xyzp->iresid[i],&zero);
          }
        }
    }
    if (*dolabs && !denmode) {
#if defined(VMS) || defined(UNDERSC)
     plalab(&qdpptr->iqon);
#else
#ifdef CRAY
     PLALAB(&qdpptr->iqon);
#else
     plalab_(&qdpptr->iqon);
#endif
#endif
    }

    if (!denmode && *ipdbon) 
#if defined(VMS) || defined(UNDERSC)
     reslab();
#else
#ifdef CRAY
     RESLAB();
#else
     reslab_();
#endif
#endif

    pldst();

    if (AXES) {
	for (i=1; i<4; i++) {
#if defined(VMS) || defined(UNDERSC)
	   drwstr(&AxesProj[i][0],&AxesProj[i][1],AxesStr[i],&ONE,&MONE);
#else
#ifdef CRAY
	   DRWSTR(&AxesProj[i][0],&AxesProj[i][1],AxesStr[i],&ONE,&MONE);
#else
	   drwstr_(&AxesProj[i][0],&AxesProj[i][1],AxesStr[i],&ONE,&MONE);
#endif
#endif
	}
    }

    if (cellpnt->iclon) {
	for (i=0; i<4; i++) {
	   j = cellpnt->iclpnt[i] - 1;
	   j1 = j + 1;
#if defined(VMS) || defined(UNDERSC)
	   drwstr(&xyzp->ixp[j],&xyzp->iyp[j],CellStr[i],&TWO,&j1);
#else
#ifdef CRAY
	   DRWSTR(&xyzp->ixp[j],&xyzp->iyp[j],CellStr[i],&TWO,&j1);
#else
	   drwstr_(&xyzp->ixp[j],&xyzp->iyp[j],CellStr[i],&TWO,&j1);
#endif
#endif
	}
    }
    if (!StarNetOld) endPrintStrings();
  }

  if (FeatSel != -1 && PHRMup) {
     if (pharm.array[FeatSel].incl == 1) {
	DrCircle(pharm.iyp[FeatSel],pharm.ixp[FeatSel],
		pharm.array[FeatSel].rad,50);
     } else {
	DrCircle(pharm.iyp[FeatSel],pharm.ixp[FeatSel],
		0.2,50);
     }
  }

  if (has_fbo) {
	if ( !(DoBlur || DoSSAO)) glXSwapBuffers(display, win);
  } else {
	if (!StarNetOld) glXSwapBuffers(display, win);
  }

  if (!gmoving && !mmoving && !smoving) {
    if (*doesp && !denmode) {
	glFlush();
	glXWaitGL();
	PlotColIndex();
	XFlush(display);
	glXWaitX();
    }
  }

  glXMakeCurrent(display,win,cx);

  rsold = RESUND;

  if (DEBUG) fprintf( stderr, "dispsf \n");

}


void Reshape(update)
int update;
{
  int i,dx,dy;
  GLint loc;

  gmoving = 0;
  Aspect = (float) width / (float) height;
  glViewport(0, 0, width, height);

#ifdef GL_ARB_shader_objects
  if (has_shader && has_fbo) {
	glUseProgramObjectARB(program[1]);
	loc   = glGetUniformLocationARB(program[1], "Width");
	glUniform1iARB(loc, width);
	loc   = glGetUniformLocationARB(program[1], "Height");
	glUniform1iARB(loc, height);

#ifdef GL_COLOR_ATTACHMENT0_EXT
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[0]);

	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, fbo.depth[0]);
	glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24,
		width, height);

	glBindTexture(GL_TEXTURE_2D, fbo.texid[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type, 
		    width, height, 0, GL_RGBA, GL_FLOAT, NULL);

	glBindTexture(GL_TEXTURE_2D, fbo.texid1[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type, 
		    width, height, 0, GL_RGBA, GL_FLOAT, NULL);

	glBindTexture(GL_TEXTURE_2D, fbo.texid2[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type, 
		    width, height, 0, GL_RGBA, GL_FLOAT, NULL);

	glBindTexture(GL_TEXTURE_2D, fbo.texid3[0]);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24,  
		width, height, 0,
		GL_DEPTH_COMPONENT, GL_FLOAT, NULL);

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[1]);

	glBindTexture(GL_TEXTURE_2D, fbo.texid[1]);
	glTexImage2D(GL_TEXTURE_2D, 0, fbo_type, 
		    width, height, 0, GL_RGBA, GL_FLOAT, NULL);

	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);

	for (i = 2; i < NUM_FBOS; i++) {
	   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[i]);

	  glBindTexture(GL_TEXTURE_2D, fbo.texid[i]);
	  glTexImage2D(GL_TEXTURE_2D, 0, fbo_type, 
		    width, height, 
			0, GL_RGBA, GL_FLOAT, NULL);
	}
#endif

	glUseProgramObjectARB(program[3]);
	loc   = glGetUniformLocationARB(program[3], "Width");
	glUniform1iARB(loc, width*2);

	glUseProgramObjectARB(program[4]);
	loc   = glGetUniformLocationARB(program[4], "Height");
	glUniform1iARB(loc, height*2);

	glUseProgramObjectARB(program[7]);
	loc   = glGetUniformLocationARB(program[7], "Width");
	glUniform1iARB(loc, width*2);
	loc   = glGetUniformLocationARB(program[7], "Height");
	glUniform1iARB(loc, height*2);

	glUseProgramObjectARB(program[8]);
	loc   = glGetUniformLocationARB(program[8], "width");
	glUniform1iARB(loc, width);
	loc   = glGetUniformLocationARB(program[8], "height");
	glUniform1iARB(loc, height);

#ifdef GL_COLOR_ATTACHMENT0_EXT
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo.frame[0]);
	glUseProgramObjectARB(program[0]);
	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
#endif

  }
#endif
  if (update) {
	dispsf();
	update_model = 0;
  } else {
	update_model = 1;
  }
}


void Reshapi()
{
  int dx,dy;

/*
  dx = dy = 0;
  Vsize = width;
  if (height > width) Vsize = height;
  if (height > width) dx = (GLint) -(height - width)/2;
  else dy = (GLint) ABS(height - width)/2;

  glViewport(dx, dy, Vsize, Vsize);
*/
  glViewport(0, 0, width, height);
}


void Key( unsigned char key)
{
   int i,j;

   if (gmoving) return;

   update_model = 0;

   switch (key) {
   case 'x':
      light0_position[istruct][0] += 0.5;
      break;
   case 'X':
      light0_position[istruct][0] -= 0.5;
      break;
   case 'y':
      light0_position[istruct][1] += 0.5;
      break;
   case 'Y':
      light0_position[istruct][1] -= 0.5;
      break;
   case 'z':
      light0_position[istruct][2] += 0.5;
      break;
   case 'Z':
      light0_position[istruct][2] -= 0.5;
      break;
   case 'i':
      light1_position[istruct][0] += 0.5;
      break;
   case 'I':
      light1_position[istruct][0] -= 0.5;
      break;
   case 'j':
      light1_position[istruct][1] += 0.5;
      break;
   case 'J':
      light1_position[istruct][1] -= 0.5;
      break;
   case 'k':
      light1_position[istruct][2] += 0.5;
      break;
   case 'K':
      light1_position[istruct][2] -= 0.5;
      break;
   case '<':
   case ',':
      light2_position[istruct][2] -= 0.5;
      break;
   case '>':
   case '.':
      light2_position[istruct][2] += 0.5;
      break;
   case 'B':
      if (DoIntSurf) {
	DoIntSurf = 0;
      } else {
	DoIntSurf = 1;
	if (*ipdbon) {
	   XDefineCursor(display,win,AtomCursor);
	   bflag = 1; bretval = 563;
	   DCKBYPASS = 1;
	}
      }
      break;
   case 'l':
      if (DoLines) {
	DoLines = 0;
      } else {
	DoLines = 1;
      }
      break;
   case 'Q':
   case 'q':
      if (DoNorms) {
	DoNorms = 0;
      } else {
	DoNorms = 1;
      }
      break;
   case 'P':
   case 'p':
      if (*persp) *persp = 0;
      else *persp = 1;
      TogBut(&cbut[BPERSP]);
      break;
   case 'T':
   case 't':
      if (STRCup) TRANSb = ! TogBut(&strcbut[1]);
      else if (TRANSb) TRANSb = 0;
      else TRANSb = 1;
      for (j=0; j < NSurf[istruct]; j++) 
	   if (SSon[istruct][j]) trns[istruct][j] = TRANSb;
      break;
   case '+':
   case '=':
      if (AXES) AXES = 0;
      else AXES = 1;
      break;
   case 'U':
   case 'u':
      if (idorad) idorad = 0;
      else idorad = 1;
      update_model = 1;
      break;
   case '1':
      if (l1on) {
	l1on = 0;
	glDisable(GL_LIGHT0);
      } else {
	l1on = 1;
	glEnable(GL_LIGHT0);
      }
      break;
   case '2':
      if (l2on) {
	l2on = 0;
	glDisable(GL_LIGHT1);
      } else {
	l2on = 1;
	glEnable(GL_LIGHT1);
      }
      break;
   case '3':
      if (l3on) {
	l3on = 0;
	glDisable(GL_LIGHT2);
      } else {
	l3on = 1;
	glEnable(GL_LIGHT2);
      }
      break;
   case '0':
      if (DoLights) {
	DoLights = 0;
      } else {
	DoLights = 1;
      }
      break;
   case 'b':
      if (DoBlur) {
	DoBlur = 0;
      } else {
	DoBlur = 1;
      }
      break;
   case 'S':
      if (DoSSAO) {
	DoSSAO = 0;
      } else {
	DoSSAO = 1;
      }
      break;
   case 'N':
   case 'n':
      CMols[istruct]++;
      if (CMols[istruct] >= NMols[istruct]) CMols[istruct] = 0;
      break;
   case 'w':
      if (hires) hires = 0;
      else hires = 1;
      update_model = 1;
      break;
   case 'G':
      EQ[0] += 10.0;
      break;
   case 'g':
      EQ[0] -= 10.0;
      break;
   case 'D':
      break;
   case 'd':
      break;
   case 'R':
   case 'r':
      if (has_shader) {
	if (DoShad) DoShad = 0;
	else {
	  DoShad = 1;
	  DoShadow = 1;
	  DoSSAO = 0;
	  DoBlur = 0;
	  for (i=0; i<4; i++) lightPos[i] = light2_position[istruct][i];
	  lightPos[0] = 20.0;
	  lightPos[2] = 0.0;
	}
      }
      break;
   }
   SetGLSLVar();
   update_struct();
}

void EnableFog()
{
      int i,fstart, fend;

      if (!*shade || denmode) {
          glDisable(GL_FOG);	  
      } else {
         glEnable(GL_FOG);
         glFogi (GL_FOG_MODE, GL_LINEAR);
         glFogfv (GL_FOG_COLOR, fogColor);
	 for (i=0; i<4; i++) {
	    fog.fogcolor[i] = fogColor[i];
	 }
         glHint (GL_FOG_HINT, GL_DONT_CARE);
	 fstart = posptr->zv;
	 fend = fstart + scalptr->scali*2.0*(*uscl);
	 fog.fstart = fstart;
	 fog.fend = fend;
	 fog.fscale = 1.0 / (fend - fstart);;
	 glFogf (GL_FOG_START, fstart);
	 glFogf (GL_FOG_END, fend);
       }
}

extern void
motion(int x, int y, int iopt)
{
 int i;

  if (iopt) {
     gmoving = 0;
     mmoving = 0;
     smoving = 0;
#if defined(VMS) || defined(UNDERSC)
     qupd();
#else
#ifdef CRAY
     QUPD();
#else
     qupd_();
#endif
#endif
     return;
  }

  if (mmoving) {
    posx = posx + (x - mstartx) / 600.0;
    posy = posy - (y - mstarty) / 600.0;
    mstartx = x;
    mstarty = y;
  }
  if (smoving) {
    posz = posz - (y - sstarty) / 60.0;
    /*
    if (posz < 0.005 && !PERSP) posz = 0.005;
    */
    sstarty = y;
  }
#if defined(VMS) || defined(UNDERSC)
  qupd();
#else
#ifdef CRAY
  QUPD();
#else
  qupd_();
#endif
#endif
}

void mouseu(int button, int state, int x, int y)
{

  if (button == GLUT_LEFT_BUTTON || button == GLUT_MIDDLE_BUTTON) {
      gmoving = 0;
      mmoving = 0;
      smoving = 0;
  }
}

void moused(int button, unsigned int state, int x, int y)
{

  if (button == GLUT_LEFT_BUTTON || button == GLUT_MIDDLE_BUTTON) {
      if (state & ShiftMask) {
         mmoving = 1;
         mstartx = x;
         mstarty = y;
      } else if (state & ControlMask) {
         smoving = 1;
         sstarty = y;
      } else {
         gmoving = 1;
      }
  }
}

void setobg()
{
   float colv[4];
   int i;
   colv[0] = ((GLfloat) colorr[OBGcolor]) / 65535.0 ;
   colv[1] = ((GLfloat) colorg[OBGcolor]) / 65535.0 ;
   colv[2] = ((GLfloat) colorb[OBGcolor]) / 65535.0 ;

   for (i=0; i<3; i++) gradcol[0][i] = colv[i];

   glClearColor(colv[0],colv[1],colv[2],1.0);

/*
   fogColor[0] = ((GLfloat) colorr[OBGcolor]) / 65535.0 ;
   fogColor[1] = ((GLfloat) colorg[OBGcolor]) / 65535.0 ;
   fogColor[2] = ((GLfloat) colorb[OBGcolor]) / 65535.0 ;
*/
   fogColor[0] = ((GLfloat) colorr[0]) / 65535.0 ;
   fogColor[1] = ((GLfloat) colorg[0]) / 65535.0 ;
   fogColor[2] = ((GLfloat) colorb[0]) / 65535.0 ;
}

void initOpengl()
{

    int i,bgmenu,animmenu,trmenu,capmenu;

/*
4th value of a position determines if we are using a positional light (1.0)
                                                or a directional light (0.0)
*/
    static float lmodel_ambient[] = {0.2, 0.2, 0.2, 0.2};
    static float light0_ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float light0_diffuse[] = {1.0, 1.0, 1.0, 1.0};
    static float light0_specular[] = {1.0, 1.0, 1.0, 0.0};
    static float light1_ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float light1_diffuse[] = {1.0, 1.0, 1.0, 1.0};
    static float light1_specular[] = {1.0, 1.0, 1.0, 0.0};
    static float light2_ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float light2_diffuse[] = {0.8, 0.8, 0.8, 1.0};
    static float light2_specular[] = {0.8, 0.8, 0.8, 0.0};
    int argc = 2;
#ifdef WIN32
    char *argv[] = {"mogl","yes"};
#else
    char *argv[] = {"moldenogl","yes"};
#endif

    if (started_ogl) return;
    started_ogl = 1;

    glXMakeCurrent(display, win, cx);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glEnable(GL_DEPTH_TEST);

    if (l1on) glEnable(GL_LIGHT0);
    else glDisable(GL_LIGHT0);
    if (l2on) glEnable(GL_LIGHT1);
    else glDisable(GL_LIGHT1);
    if (l3on) glEnable(GL_LIGHT2);
    else glDisable(GL_LIGHT2);

    glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0_position[0]);

    glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);
    glLightfv(GL_LIGHT1, GL_POSITION, light1_position[0]);

    glLightfv(GL_LIGHT2, GL_AMBIENT, light2_ambient);
    glLightfv(GL_LIGHT2, GL_DIFFUSE, light2_diffuse);
    glLightfv(GL_LIGHT2, GL_SPECULAR, light2_specular);
    glLightfv(GL_LIGHT2, GL_POSITION, light2_position[0]);

    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 0.0);
    glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 1.0);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);

    glEnable(GL_NORMALIZE);
    glShadeModel(GL_SMOOTH);
    glHint(GL_POLYGON_SMOOTH_HINT,GL_NICEST);
    glLineWidth(1.0);

    OBGcolor = *ibgclo;
    BGmode = *ibgmod;
    setobg();

    PERSP = perspon;

#if defined(DARWIN) || defined(__CYGWIN__)
    *fullgl = 1;
    *ifogl = 1;
#endif

    glClearIndex(0.0);
    glClearDepth(1);

    glPushMatrix();
    glLoadIdentity();

    cyl = gluNewQuadric();
    sphere = gluNewQuadric();
    disk = gluNewQuadric();

    ogaxes();

    Reshapi();

    InvRotMat();
}


void ogind()
{
 int i;


    oglines();
    if (*forces_yes_no) ogforces();
    ogfeatures();

    if (denmode) {
	ogmlxyz();
	update_model = 0;
    }
    else {
	if (*irtcel && *ialtyp) {
	   if (NMols[istruct] != 1) ogmoll(0);
	   ogmoll(1);
	}
	else {
	   ogmoll(0);
	}
    }

    if (*ipdbon && SSdone[istruct] == 0) {
       empty_ribb();
#if defined(VMS) || defined(UNDERSC)
       ribgl(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
#else
#ifdef CRAY
       RIBGL(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
#else
       ribgl_(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
#endif
#endif
       SSdone[istruct] = 1;

       for (i=0; i<4; i++) 
	if (!monoscr && calfptr->ihet[i] == 1) sndon(i,0,0);

    }

    glXWaitGL();
    dispsf();
}

void DelHet(het)
int het;
{
 int i,j,k,istart,iend,fnd,ndel;
 int tmpres,kcon, ab, noab;

    fnd = 0;
    istart = 0;
    iend = -1;

    for (j=0; j < *xyzp->iatoms; j++) {
	if (xyzp->iresid[j] == het) {
	   if (!fnd) {
	      istart = j; 
	      fnd = 1;
	   }
	   iend = j;
	}
    }

    if (iend == -1 ) return;
    ndel = iend - istart + 1;
    
    for (j=istart; j < *xyzp->iatoms - ndel; j++) {
	xyzp->iatclr[j] = xyzp->iatclr[j+ndel];
	tmpres = xyzp->iresid[j+ndel];
	if (tmpres < het) tmpres++;
	xyzp->iresid[j] = tmpres;
	xyzp->iaton[j] = xyzp->iaton[j+ndel];
	xyzp->ianz[j] = xyzp->ianz[j+ndel];
	xyzp->ipdbt[j] = xyzp->ipdbt[j+ndel];
	xyzp->ityp[j] = xyzp->ityp[j+ndel];
	if (qdpptr->ihasq) xyzp->qat[j] = xyzp->qat[j+ndel];
	for (k=0; k < 3; k++) {
	   xyzp->coo[j*3+k] = xyzp->coo[(j+ndel)*3+k];
	}
	kcon = 0;
	for (k=0; k < xyzp->iconn[(j+ndel)*(MXCON+1)]; k++) {
	   noab = xyzp->iconn[(j+ndel)*(MXCON+1)+k+1];
	   ab = ABS(noab) - 1;
	   if (ab > istart + ndel) {
		if (noab > 0) {
		   xyzp->iconn[j*(MXCON+1)+kcon+1] = noab - ndel;
		} else {
		   xyzp->iconn[j*(MXCON+1)+kcon+1] = noab + ndel;
		}
		kcon++;
	   } else if (ab < istart) {
		xyzp->iconn[j*(MXCON+1)+kcon+1] = noab;
		kcon++;
	   }
	}
	xyzp->iconn[j*(MXCON+1)] = kcon;
    }

    for (j=0; j < istart; j++) {
	kcon = 0;
	for (k=0; k < xyzp->iconn[j*(MXCON+1)]; k++) {
	   noab = xyzp->iconn[j*(MXCON+1)+k+1];
	   ab = ABS(noab) - 1;
	   if (ab > istart + ndel) {
		if (noab > 0) {
		   xyzp->iconn[j*(MXCON+1)+kcon+1] = noab - ndel;
		} else {
		   xyzp->iconn[j*(MXCON+1)+kcon+1] = noab + ndel;
		}
		kcon++;
	   } else if (ab < istart) {
		xyzp->iconn[j*(MXCON+1)+kcon+1] = noab;
		kcon++;
	   }
	}
	xyzp->iconn[j*(MXCON+1)] = kcon;
    }

    for (j=0; j < calfptr->ncalf; j++) {
	for (k=0; k < 4; k++) 
	   if (calfptr->icalf[j][k] >= istart) 
		calfptr->icalf[j][k] = calfptr->icalf[j][k] - ndel;
    }

    for (j=ABS(het); j < hetptr.NHetAtm; j++) {
	hetptr.Allocated[j] = hetptr.Allocated[j+1];
	hetptr.HetAtm[j] = hetptr.HetAtm[j+1];
	calfptr->ihet[j] = calfptr->ihet[j+1];
    }
    if (hetptr.Allocated[hetptr.NHetAtm-1]) 
	free(hetptr.HetAtm[hetptr.NHetAtm-1]);
    hetptr.NHetAtm--;

    *xyzp->iatoms = *xyzp->iatoms - ndel;
    if (*natorg > 0) *natorg = *natorg - ndel;
    *zmptrp->ihaszm = 0;
    ZMEAA = 0;
    update_model = 1;
}

#if defined(VMS) || defined(UNDERSC)
void ognrm(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGNRM(double *v1, double *v2, double *v3)
#else
void ognrm_(double *v1, double *v2, double *v3)
#endif
#endif
{

      putvrt(v1,v2,v3,0);

      glNormal3d(*v1,*v2,*v3);
}

#if defined(VMS) || defined(UNDERSC)
void ogvrt(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGVRT(double *v1, double *v2, double *v3)
#else
void ogvrt_(double *v1, double *v2, double *v3)
#endif
#endif
{
      putvrt(v1,v2,v3,1);

      glVertex3d(*v1,*v2,*v3);
}

void chkrib(iop)
int iop;
{
   int i,j;

   for (i=RIBindex[istruct].end[iop]; 
	i >= RIBindex[istruct].start[iop]; i--) {
	if (nvert[istruct][i] <= 0) {
		free(sndstr[istruct][i]);
		free(srfvert[istruct][i]);
		glDeleteLists(theSurf[istruct][i],1);
		for (j=i; j < RIBindex[istruct].end[iop]; j++) {
		   sndstr[istruct][j] = sndstr[istruct][j+1];
		   srfvert[istruct][j] = srfvert[istruct][j+1];
		   nvrtmx[istruct][j] = nvrtmx[istruct][j+1];
		   nvert[istruct][j] = nvert[istruct][j+1];
		   theSurf[istruct][j] = theSurf[istruct][j+1];
		   Schain[istruct][j] = Schain[istruct][j+1];
		}
		j = RIBindex[istruct].end[iop];
		sndstr[istruct][j] = NULL;
		srfvert[istruct][j] = NULL;
		nvrtmx[istruct][j] = 0;
		nvert[istruct][j] = 0;
		theSurf[istruct][j] = -1;
		NSurf[istruct]--;
		if (NSurf[istruct] < 0) NSurf[istruct] = 0;
		RIBindex[istruct].end[iop]--;
		switch (iop) {
		case 0: 
			RIBindex[istruct].nhelx--;
			break;
		case 1: 
			RIBindex[istruct].nbeta--;
			break;
		case 2: 
			RIBindex[istruct].nrna--;
			break;
		case 3: 
			RIBindex[istruct].ncoil--;
			break;
		default:
			break;
		}
	}
   }

}

void chncol(ich,col,iupd)
int ich;
int col;
int iupd;
{
   int i;

   for (i=0; i < NSurf[istruct]; i++) 
	if (Schain[istruct][i] == ich+1) SetSurfColor(i,col+1);
   if (iupd) dispsf();
}

#if defined(VMS) || defined(UNDERSC)
void ribpnt(int *iopt, int *isnd)
#else
#ifdef CRAY
void RIBPNT(int *iopt, int *isnd)
#else
void ribpnt_(int *iopt, int *isnd)
#endif
#endif
{
    if (*iopt) {
	RIBindex[istruct].start[*isnd] =  NSurf[istruct];
    } else {
	RIBindex[istruct].end[*isnd] = NSurf[istruct]-1;
	chkrib(*isnd);
    }
}

#if defined(VMS) || defined(UNDERSC)
void sribcol(int *iribc)
#else
#ifdef CRAY
void SRIBCOL(int *iribc)
#else
void sribcol_(int *iribc)
#endif
#endif
{
	int i;

	for (i=0; i<3; i++) 
		diffuseColor[istruct][NSurf[istruct]-1][i] = ribcol[*iribc][i];
}

#if defined(VMS) || defined(UNDERSC)
void bldlst()
#else
#ifdef CRAY
void BLDLST()
#else
void bldlst_()
#endif
#endif
{

     int i,j,k,npts1,npts2;
     double v[3], rpts,vl, g[3], c[3];
     double vec1[3], vn1[3],sc;
     float hinv1,hinv2;

/*
     a grid of n*n points has n-1*n-1 squares
     and twice as much triangular polygons
     so 2*(npts-1)**2
     npts is 80 at maximum so lets make it 12800
*/

      if (!*ifdogl) return;

#if defined(VMS) || defined(UNDERSC)
      curs(&ONE);
      cvtcom();
#else
#ifdef CRAY
      CURS(&ONE);
      CVTCOM();
#else
      curs_(&ONE);
      cvtcom_();
#endif
#endif
      update_model = 1;
      NSurf[istruct]++;
      if (theSurf[istruct][NSurf[istruct]-1] > 0) 
	glDeleteLists(theSurf[istruct][NSurf[istruct]-1],1);
      theSurf[istruct][NSurf[istruct]-1] = -1;
      theSurf[istruct][NSurf[istruct]-1] = glGenLists(1);

      if (NSurf[istruct] > 1) {

	  for (i=0; i<= NSurf[istruct] - 2; i++) 
		SSon[istruct][i] = 0;
      }

      SSon[istruct][NSurf[istruct]-1] = 1;
      clp[istruct][NSurf[istruct]-1] = 0;
      trns[istruct][NSurf[istruct]-1] = 0;

      if (*ipsi) {
	  sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(21);
	  sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"Orbital %3d in plane",*ipsi);
      } else {
	  sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(17);
	  sprintf(sndstr[istruct][NSurf[istruct]-1], 
			"Density in plane");
      }
      allocvert(MXVERT,1);

      if (!STRCup) inistrc();
      RedrawSTRC();

      diffuseColor[istruct][NSurf[istruct]-1][0] = 0.0;
      diffuseColor[istruct][NSurf[istruct]-1][1] = 1.0;
      diffuseColor[istruct][NSurf[istruct]-1][2] = 0.0;
      diffuseColor[istruct][NSurf[istruct]-1][3] = 0.8;

      for (i=0; i<3; i++) {
	specularColor[NSurf[istruct]-1][i] = specColor[i];
      }

      glNewList(theSurf[istruct][NSurf[istruct]-1], GL_COMPILE);
      SStyp[istruct][NSurf[istruct]-1] = 2;
      Schain[istruct][NSurf[istruct]-1] = -1; 

      glBegin(GL_QUADS);

      npts1 = hlpsrf->nps1;
      npts2 = hlpsrf->nps2;
      sc = -1.0*(*scle);
/*
      rpts = (double) (npts1-1);
*/
      rpts = (double) (npts1);
      hinv1 = 1.0/ npts2;
      hinv2 = 1.0/ npts1;

      for (i=0; i<npts1-1; i++) {
         for (j=0; j<npts2-1; j++) {
/*
        first triangle
*/
            vec1[0] = (double) (j);
            vec1[1] = (double) (i);
            vec1[2] = sgrd.dens[j+i*npts2]*sc*rpts;

	    znorm(rpts,sc,sgrd.dens,vn1,npts1,npts2,i,j);

#if defined(VMS) || defined(UNDERSC)
            rtgbck(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm(&g[0],&g[1],&g[2]);
#else
#ifdef CRAY
            RTGBCK(&vn1[0],&vn1[1],&vn1[2],g);
            OGNRM(&g[0],&g[1],&g[2]);
#else
            rtgbck_(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm_(&g[0],&g[1],&g[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
            rttbck(&v[0],&v[1],&v[2],c);
	    ogvrt(&c[0],&c[1],&c[2]);
#else
#ifdef CRAY
            RTTBCK(&v[0],&v[1],&v[2],c);
	    OGVRT(&c[0],&c[1],&c[2]);
#else
            rttbck_(&v[0],&v[1],&v[2],c);
	    ogvrt_(&c[0],&c[1],&c[2]);
#endif
#endif

            vec1[0] = (double) (j+1);
            vec1[1] = (double) (i);
            vec1[2] = sgrd.dens[j+1+i*npts2]*sc*rpts;

	    znorm(rpts,sc,sgrd.dens,vn1,npts1,npts2,i,j+1);

#if defined(VMS) || defined(UNDERSC)
            rtgbck(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm(&g[0],&g[1],&g[2]);
#else
#ifdef CRAY
            RTGBCK(&vn1[0],&vn1[1],&vn1[2],g);
            OGNRM(&g[0],&g[1],&g[2]);
#else
            rtgbck_(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm_(&g[0],&g[1],&g[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
            rttbck(&v[0],&v[1],&v[2],c);
	    ogvrt(&c[0],&c[1],&c[2]);
#else
#ifdef CRAY
            RTTBCK(&v[0],&v[1],&v[2],c);
	    OGVRT(&c[0],&c[1],&c[2]);
#else
            rttbck_(&v[0],&v[1],&v[2],c);
	    ogvrt_(&c[0],&c[1],&c[2]);
#endif
#endif

            vec1[0] = (double) (j+1);
            vec1[1] = (double) (i+1);
            vec1[2] = sgrd.dens[j+1+(i+1)*npts2]*sc*rpts;

	    znorm(rpts,sc,sgrd.dens,vn1,npts1,npts2,i+1,j+1);

#if defined(VMS) || defined(UNDERSC)
            rtgbck(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm(&g[0],&g[1],&g[2]);
#else
#ifdef CRAY
            RTGBCK(&vn1[0],&vn1[1],&vn1[2],g);
            OGNRM(&g[0],&g[1],&g[2]);
#else
            rtgbck_(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm_(&g[0],&g[1],&g[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
            rttbck(&v[0],&v[1],&v[2],c);
	    ogvrt(&c[0],&c[1],&c[2]);
#else
#ifdef CRAY
            RTTBCK(&v[0],&v[1],&v[2],c);
	    OGVRT(&c[0],&c[1],&c[2]);
#else
            rttbck_(&v[0],&v[1],&v[2],c);
	    ogvrt_(&c[0],&c[1],&c[2]);
#endif
#endif

            vec1[0] = (double) (j);
            vec1[1] = (double) (i+1);
            vec1[2] = sgrd.dens[j+(i+1)*npts2]*sc*rpts;

	    znorm(rpts,sc,sgrd.dens,vn1,npts1,npts2,i+1,j);

#if defined(VMS) || defined(UNDERSC)
            rtgbck(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm(&g[0],&g[1],&g[2]);
#else
#ifdef CRAY
            RTGBCK(&vn1[0],&vn1[1],&vn1[2],g);
            OGNRM(&g[0],&g[1],&g[2]);
#else
            rtgbck_(&vn1[0],&vn1[1],&vn1[2],g);
            ognrm_(&g[0],&g[1],&g[2]);
#endif
#endif

	    v[0] = vec1[0]*hinv1;
	    v[1] = vec1[1]*hinv2;
	    v[2] = vec1[2]*hinv1;
#if defined(VMS) || defined(UNDERSC)
            rttbck(&v[0],&v[1],&v[2],c);
	    ogvrt(&c[0],&c[1],&c[2]);
#else
#ifdef CRAY
            RTTBCK(&v[0],&v[1],&v[2],c);
	    OGVRT(&c[0],&c[1],&c[2]);
#else
            rttbck_(&v[0],&v[1],&v[2],c);
	    ogvrt_(&c[0],&c[1],&c[2]);
#endif
#endif

         }
      }

      glEnd();
      glDisable(GL_BLEND);
      glDisable(GL_COLOR_MATERIAL);
      glDisable(GL_CULL_FACE);
      glEndList();
      dispsf();
#if defined(VMS) || defined(UNDERSC)
      curs(&ZERO);
#else
#ifdef CRAY
      CURS(&ZERO);
#else
      curs_(&ZERO);
#endif
#endif

}

static int surf_info = 1;


void WrtAtm(inp,iatom,SrfArr,lwrit,nc)
FILE *inp;
int iatom;
int SrfArr;
int *lwrit;
int *nc;
{
   int ir;
   float r;

   ir = xyzp->iresid[iatom];

   switch (xyzp->ianz[iatom]) {
	case 1:
	    r = 1.0;
	    break;
	case 5:
	    r = 1.75;
	    break;
	case 6:
	    r = 1.85;
	    break;
	case 8:
	    r = 1.6;
	    break;
	case 15:
	    r = 2.0;
	    break;
	case 16:
	    r = 2.0;
	    break;
	default:
	    r = 1.5;
   }

   if (!SrfArr || (SrfArr && ( (ir > 0 && calfptr->iams[ir-1]) ||
			       (ir < 0 && calfptr->ihets[ABS(ir)]))) ) {
	lwrit[*nc] = iatom; *nc = *nc + 1;
	fprintf(inp,"%d %f %8.3f %8.3f %8.3f\n", iatom,r,
		xyzp->coo[iatom*3  ]*toangs,
		xyzp->coo[iatom*3+1]*toangs,
		xyzp->coo[iatom*3+2]*toangs);
   }
}

void molsrf(SurfCol,SrfArr,MapSrf)
int SurfCol;
int SrfArr;
int MapSrf;
{
   char cmdfil[MAXCMD];
   char cmdtmp[MAXCMD] = "surf ";
   char tmps[MAXCMD] = "";
   char fn[] = "/tmp/fileXXXXXX";
   char *tmpf, *p, *q;
   int i,j, iat, ir, irt, ires, nc, co, kk, io, fft,pid;
   double g[3], c[3], col[3], pot;
   FILE *out, *inp;

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   if (MapSrf && *fftyp != 3 ) {
	fft = *fftyp;
	for (i=0; i<*xyzp->iatoms; i++) 
	   xyzp->lwrit[i] = (int) xyzp->ityp[i];
	
	*fftyp = 3;
#if defined(VMS) || defined(UNDERSC)
	dotyp(&ZERO);
#else
#ifdef CRAY
	DOTYP(&ZERO);
#else
	dotyp_(&ZERO);
#endif
#endif
	for (i=0; i<*xyzp->iatoms; i++) 
	   xyzp->ityp[i] = (short int) xyzp->lwrit[i];
	*fftyp = fft;
   }

   inp = NULL;

#ifdef __CYGWIN__
   if (getusr(tmps)) tmpf = tmps;
#else
   tmpf = mktemp(fn);
#endif


   inp = fopen(tmpf,"w");
   if (inp == NULL) return;

   nc = 0;

   if (*ipdbon && !(calfptr->ncalf == 0)) {
	for (ires = 1; ires < calfptr->ncalf+1; ires++ ) {
#if defined(VMS) || defined(UNDERSC)
	   getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
	   GETPDB(&ires,ipdb,ihpdb);
#else
   	   getpdb_(&ires,ipdb,ihpdb);
#endif
#endif
		
	   for (i=0; i<MXSYM; i++) {
		if (ipdb[i] > 0) {
		   WrtAtm(inp,ipdb[i]-1,SrfArr,xyzp->lwrit,&nc);
		}
	   }

	   for (i=0; i<MXHSYM*3; i++) {
		if (ihpdb[i] > 0) {
		   WrtAtm(inp,ihpdb[i]-1,SrfArr,xyzp->lwrit,&nc);
		}
	   }

	}

	for (j=4; j<hetptr.NHetAtm; j++) {
	   if (calfptr->ihets[j]) {
        	for (i=0; i<*xyzp->iatoms; i++) {
		   if (xyzp->iresid[i] == -j) 
			WrtAtm(inp,i,0,xyzp->lwrit,&nc);
		}
	   }
	}

   } else {
	for (i=0; i<*xyzp->iatoms; i++) 
		WrtAtm(inp,i,0,xyzp->lwrit,&nc);
   }

   fclose(inp);

#ifdef __CYGWIN__
   sprintf(cmdfil,"%ssurf.exe",exepath[0]);
#else
   sprintf(cmdfil,"%ssurf",exepath[0]);
#endif


   if (! (access(cmdfil,F_OK) == 0 && !isdir(cmdfil))) {
#ifdef __CYGWIN__
	sprintf(cmdfil,"%ssurf/surf.exe",exepath[0]);
#else
	sprintf(cmdfil,"%ssurf/surf",exepath[0]);
#endif
	if (!(access(cmdfil,F_OK) == 0)) {
	   sprintf(cmdfil,"surf");
	}
   }

   if (surf_info) {
      fprintf(stderr,"\nThis surface is made with SURF from UNC-Chapel Hill.\n");
      fprintf(stderr,"  The reference is:\n\n");
      fprintf(stderr,"A. Varshney, F. P. Brooks, W. V. Wright, \n");
      fprintf(stderr,"Linearly Scalable Computation \n");
      fprintf(stderr,"of Smooth Molecular Surfaces, \n");
      fprintf(stderr,"IEEE Comp. Graphics and Applications, \n");
      fprintf(stderr,"v. 14 (1994) pp. 19-25.\n\n");
      surf_info = 0;
   }

#ifdef __CYGWIN__
   if (p = strstr(cmdfil,".exe")) p[0] = '\0';


    pid = vfork();
    switch(pid) {
    case -1:
          fprintf(stderr,"Couldnt Fork\n");
          break;
    case 0:       /*child */
	  execlp(cmdfil,"surf","-W","1",tmpf,NULL);
	  _exit(0);
          break;
    default:      /*parent*/
	  wait(&pid);
          break;
    }
#else
   strcpy(cmdtmp,cmdfil);
   strcat(cmdtmp," -W 1 ");
   strcat(cmdtmp,tmpf);

   system(cmdtmp);
#endif

   strcpy(cmdtmp,tmpf);
   strcat(cmdtmp,".tri");

   if ((out = fopen(cmdtmp, "r")) == NULL) {
      fprintf(stderr,"Can not open triangle file !: %s\n",cmdtmp);
#if defined(VMS) || defined(UNDERSC)
      curs(&ZERO);
#else
#ifdef CRAY
      CURS(&ZERO);
#else
      curs_(&ZERO);
#endif
#endif
      return;
   }

   SetSurfColor(NSurf[istruct],SurfCol);

   theSurf[istruct][NSurf[istruct]] = glGenLists(1);
   SSon[istruct][NSurf[istruct]] = 1;
   clp[istruct][NSurf[istruct]] = 0;
   trns[istruct][NSurf[istruct]] = 0;

   glNewList(theSurf[istruct][NSurf[istruct]], GL_COMPILE);
   NSurf[istruct]++;

   sndstr[istruct][NSurf[istruct]-1] = (char *) malloc(21);
   sprintf(sndstr[istruct][NSurf[istruct]-1], "Solvent Acc. Surface");
   allocvert(MXVERT,1);


   SStyp[istruct][NSurf[istruct]-1] = 0;
   Schain[istruct][NSurf[istruct]-1] = -1;

/* if color per triangle */

   if (MapSrf) {
        glColorMaterial(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);
        glEnable(GL_COLOR_MATERIAL);
	SStyp[istruct][NSurf[istruct]-1] = 1;
   }

   glBegin(GL_TRIANGLES);

   irt = -1;
   if (out != NULL) {
	   while (fscanf(out,"%d",&iat) != EOF) {

	     if (MapSrf) {
		iat = xyzp->lwrit[iat];
		ir = xyzp->iresid[iat];
		if (ir != irt || irt == -1) {
			nc = 0;

			if (ir < -3) {

			   for (i=0; i < *xyzp->iatoms; i++) {
			       if (xyzp->iresid[i] == ir) {
				   xyzp->icont[nc] = i+1;
				   nc++;
			       }
			   }

			} else {
#if defined(VMS) || defined(UNDERSC)
			   getpdb(&ir,ipdb,ihpdb);
#else
#ifdef CRAY
			   GETPDB(&ir,ipdb,ihpdb);
#else
			   getpdb_(&ir,ipdb,ihpdb);
#endif
#endif
		
			   for (i=0; i<MXSYM; i++)
				if (ipdb[i] > 0) {
				   xyzp->icont[nc] = ipdb[i];
				   nc++;
				}

			   for (i=0; i<MXHSYM*3; i++) 
				if (ihpdb[i] > 0) {
				   xyzp->icont[nc] = ihpdb[i];
				   nc++;
				}
			   if (ir > 1) {
			    /* n,h backbone previous residue */
			    xyzp->icont[nc] = calfptr->icalf[ir-2][1];
			    nc++;
			    xyzp->icont[nc] = calfptr->icalf[ir-2][3];
			    nc++;
			   }
			   if (ir < calfptr->ncalf) {
			    /* c=o backbone next residue */
			    co = calfptr->icalf[ir][2];
			    if (co > 0) {
			    xyzp->icont[nc] = co;
			    nc++;
			    for (i=0; i < xyzp->iconn[(co-1)*(MXCON+1)]; i++) {
				kk = xyzp->iconn[(co-1)*(MXCON+1)+i+1];
				if (xyzp->ianz[kk-1] == 8) io = kk;
			    }	
			    xyzp->icont[nc] = io;
			    nc++;
			    }
			   }
			}
			*xyzp->ncont = nc;

		   irt = ir;
		}
	     }

	     for (i=0; i < 3; i++ ) {

		fscanf(out,"%lf %lf %lf %lf %lf %lf",
		  &c[0],&c[1],&c[2],&g[0],&g[1],&g[2]);

		for (j=0; j < 3; j++ ) c[j] = c[j]/toangs;

		if (MapSrf) {
#if defined(VMS) || defined(UNDERSC)
		   clmond(c,&pot,&ONE,
			xyzp->coo,xyzp->qat,xyzp->icont,xyzp->ncont);
		   parcol(&pot,col);
		   ogcoll(&col[0],&col[1],&col[2]);
#else
#ifdef CRAY
		   CLMOND(c,&pot,&ONE,
			xyzp->coo,xyzp->qat,xyzp->icont,xyzp->ncont);
		   PARCOL(&pot,col);
		   OGCOLL(&col[0],&col[1],&col[2]);
#else
		   clmond_(c,&pot,&ONE,
			xyzp->coo,xyzp->qat,xyzp->icont,xyzp->ncont);
		   parcol_(&pot,col);
		   ogcoll_(&col[0],&col[1],&col[2]);
#endif
#endif
		}
#if defined(VMS) || defined(UNDERSC)
		ognrm(&g[0],&g[1],&g[2]);
		ogvrt(&c[0],&c[1],&c[2]);
#else
#ifdef CRAY
		OGNRM(&g[0],&g[1],&g[2]);
		OGVRT(&c[0],&c[1],&c[2]);
#else
		ognrm_(&g[0],&g[1],&g[2]);
		ogvrt_(&c[0],&c[1],&c[2]);
#endif
#endif
	     }

	   }
	   glEnd();
	   if (MapSrf) {
		glDisable(GL_COLOR_MATERIAL);
	   }
	   glEndList();
	   fclose(out);
	   unlink(tmpf);
	   unlink(cmdtmp);
	   dispsf();
	   UpdateSTRC();
   }


#if defined(VMS) || defined(UNDERSC)
   curs(&ZERO);
#else
#ifdef CRAY
   CURS(&ZERO);
#else
   curs_(&ZERO);
#endif
#endif
}

#else

/* =====================================
 * backup functions for no openGL 
 * =====================================
*/

void chncol(ich,col,iupd)
int ich;
int col;
int iupd;
{
  int i;
      i = 0;
}

void ogforces()
{
  int i;
      i = 0;
}

void wrtall()
{
  int i;
      i = 0;
}

void DeleteActiveSurfaces()
{
  int i;
      i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void bldlst()
#else
#ifdef CRAY
void BLDLST()
#else
void bldlst_()
#endif
#endif
{
  int i;

  i = 0;
}

void molsrf(SurfCol,SrfArr,MapSrf)
int SurfCol;
int SrfArr;
int MapSrf;
{
  int dummy;

  dummy = 0;
}

#if defined(VMS) || defined(UNDERSC)
void ogbegg(isurf,iopt,ityp,iorb,cntval,mapped,name)
#else
#ifdef CRAY
void OGBEGG(isurf,iopt,ityp,iorb,cntval,mapped,name)
#else
void ogbegg_(isurf,iopt,ityp,iorb,cntval,mapped,name)
#endif
#endif
int *isurf;
int *iorb;
int *ityp;
int *iopt;
double *cntval;
int *mapped;
char *name;
{
  int i;

  i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void ogcoll(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGCOLL(double *v1, double *v2, double *v3)
#else
void ogcoll_(double *v1, double *v2, double *v3)
#endif
#endif
{
  int i;

  i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void ognrm(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGNRM(double *v1, double *v2, double *v3)
#else
void ognrm_(double *v1, double *v2, double *v3)
#endif
#endif
{
  int i;

  i = 0;
      
}

#if defined(VMS) || defined(UNDERSC)
void ogvrt(double *v1, double *v2, double *v3)
#else
#ifdef CRAY
void OGVRT(double *v1, double *v2, double *v3)
#else
void ogvrt_(double *v1, double *v2, double *v3)
#endif
#endif
{
  int i;

  i = 0;
      
}

#if defined(VMS) || defined(UNDERSC)
void sribcol(int *iribc)
#else
#ifdef CRAY
void SRIBCOL(int *iribc)
#else
void sribcol_(int *iribc)
#endif
#endif
{

  int i;

  i = 0;
      
}

#if defined(VMS) || defined(UNDERSC)
void ogribb(iscnd)
#else
#ifdef CRAY
void OGRIBB(iscnd)
#else
void ogribb_(iscnd)
#endif
#endif
int *iscnd;
{
      int i;

      i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void ogmon()
#else
#ifdef CRAY
void OGMON()
#else
void ogmon_()
#endif
#endif
{
      int i;

      i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void ogendd(ichain)
#else
#ifdef CRAY
void OGENDD(ichain)
#else
void ogendd_(ichain)
#endif
#endif
int *ichain;
{
      int i;

      i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void ribpnt(int *iopt, int *isnd)
#else
#ifdef CRAY
void RIBPNT(int *iopt, int *isnd)
#else
void ribpnt_(int *iopt, int *isnd)
#endif
#endif
{
      int i;

      i = 0;
}

#if defined(VMS) || defined(UNDERSC)
void setcll()
#else
#ifdef CRAY
void SETCLL()
#else
void setcll_()
#endif
#endif
{
      int i;

      i = 0;
}

void dispsf()
{
  int i;

  i = 0;
}

void ogind()
{
  int i;

  i = 0;
}

void ogmoll(int iopt)
{
  int i;

  i = 0;
}

void  Key(unsigned char key)
{
  int i;

  i = 0;
}

void moused(int button, unsigned int state, int x, int y)
{
  int i;

  i = 0;
}

void ResetRes()
{
  int i;

  i = 0;
}

void mouseu(int button, int state, int x, int y)
{
  int i;

  i = 0;
}

void motion(int x, int y, int iopt)
{
  int i;

  i = 0;
}

void Reshape(int update)
{
  int i;

  i = 0;
}

void empty_model(sel,updis)
int sel;
int updis;
{
  int i;

      i = 0;
}

void DelHet(int het)
{
  int i;

      i = 0;
}

void ogfeatures()
{
}

#endif

#include <math.h>

static union
{   double d;
    struct
    {
#ifdef LITTLE_ENDIAN
      int j, i;
#else
      int i, j;
#endif
    } n;
} _eco;

#define EXPA (1048576/M_LN2)
#define EXPC 60801

#define EXP(y) (_eco.n.i = EXPA*(y) + (1072693248 - EXPC), _eco.d)

#if defined(VMS) || defined(UNDERSC)
double fexp(y)
#else
#ifdef CRAY
double FEXP(y)
#else
double fexp_(y)
#endif
#endif
double *y;
{
  return (EXP(*y));
}
/*
typedef struct {
  int ptr;
  float depth;
} DepthIndex;

DepthIndex dpt[NUMAT];
*/

static int
compare(const void *a, const void *b)
{
  DepthIndex *p1 = (DepthIndex *) a;
  DepthIndex *p2 = (DepthIndex *) b;
  float diff = p2->depth - p1->depth;

  if (diff > 0.0) {
    return -1;
  } else if (diff < 0.0) {
    return 1;
  } else {
    return 0;
  }
}

static int compi(const void *a, const void *b)
{
  IntIndex *p1 = (IntIndex *) a;
  IntIndex *p2 = (IntIndex *) b;
/*
  return (p1->depth > p2->depth) - (p2->depth > p1->depth);
  return (p1->depth > p2->depth) ? 1 : ((p1->depth < p2->depth) ? -1 : 0);
*/
  return (p2->depth > p1->depth) ? 1 : ((p2->depth < p1->depth) ? -1 : 0);
}

static int SI(const void *a, const void *b)
{
  return (*(int*)a - *(int*)b);
}

void ActualiseBackbone(int iset)
{
   int j;

   if (*backb) {
	TogDown(&cbut[BBACKB]);
	ActBut(&cbut[BFORC],1);
	ActBut(&cbut[BINCRF],1);
	ActBut(&cbut[BHBOND],1);
	ActBut(&cbut[BDECRF],1);
	ActBut(&cbut[BUNSC],1);
	preset(iset);
   } else {
	TogUp(&cbut[BBACKB]);
	ActBut(&cbut[BFORC],0);
	ActBut(&cbut[BINCRF],0);
	ActBut(&cbut[BDECRF],0);
	ActBut(&cbut[BUNSC],0);
	ActBut(&cbut[BHBOND],0);
	if (iset) {
	   for (j=0; j < MXHETA; j++) 
		calfptr->ihet[j] = 0;
	   for (j=0; j < calfptr->ncalf; j++) 
		calfptr->reson[j] = 1;
	   for (j=0; j < *xyzp->iatoms; j++ ) 
		xyzp->iaton[j] = 1;
	}
	update_sel = 1;
   }
}

void DoBackbone()
{
   int j;

   TogBut(&cbut[BBACKB]);
   if (!*backb) {
	*backb = 1; 
	*ionoff = 1;
	ActBut(&cbut[BFORC],1);
	ActBut(&cbut[BINCRF],1);
	ActBut(&cbut[BHBOND],1);
	ActBut(&cbut[BDECRF],1);
	ActBut(&cbut[BUNSC],1);
	preset(1);
   } else {
	*backb = 0;
	ActBut(&cbut[BFORC],0);
	ActBut(&cbut[BINCRF],0);
	ActBut(&cbut[BDECRF],0);
	ActBut(&cbut[BUNSC],0);
	ActBut(&cbut[BHBOND],0);
	for (j=0; j < MXHETA; j++) 
	   calfptr->ihet[j] = 0;
	for (j=0; j < calfptr->ncalf; j++) 
	   calfptr->reson[j] = 1;
	for (j=0; j < *xyzp->iatoms; j++ ) 
	   xyzp->iaton[j] = 1;
	update_sel = 1;
   }
}

#if defined(VMS) || defined(UNDERSC)
void srti(n,iror,inat)
#else
#ifdef CRAY
void SRTI(n,iror,inat)
#else
void srti_(n,iror,inat)
#endif
#endif
int *n;
int *iror;
int *inat;
{
   int i,j;

   for (i=0; i<*n; i++) {
	intptr[i].depth = (int) iror[i];
	intptr[i].ptr = i; 
   }
   qsort(intptr,*n, sizeof(IntIndex), compi);
   for (i=0; i<*n; i++) inat[i] = intptr[i].ptr;
}

#if defined(VMS) || defined(UNDERSC)
void rqsrt(n,rzp,inat)
#else
#ifdef CRAY
void RQSRT(n,rzp,inat)
#else
void rqsrt_(n,rzp,inat)
#endif
#endif
int *n;
double *rzp;
int *inat;
{
   int i,j;

   for (i=0; i<*n; i++) {
	dptptr[i].depth = (float) rzp[i];
	dptptr[i].ptr = i + 1; 
   }
   qsort(dptptr,*n, sizeof(DepthIndex), compare);
   for (i=0; i<*n; i++) inat[i] = dptptr[i].ptr;
}

void SaveResXYZ(ires)
int ires;
{
   int i,j;


   if (ResChanged == NULL) {
      if ((ResChanged = (int *) malloc((sizeof(int))*NUMCAL)) == NULL) {
	fprintf(stderr, "Memory allocation error for ResChanged\n");
	return;
      } else {
          for (i=0; i<NUMCAL; i++) ResChanged[i] = 0;
      }
   }

   CurrRes = ires;

   if (!ResChanged[ires-1]) {
#if defined(VMS) || defined(UNDERSC)
      getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
      GETPDB(&ires,ipdb,ihpdb);
#else
      getpdb_(&ires,ipdb,ihpdb);
#endif
#endif
      for (i=0; i<MXSYM; i++) for (j=0; j<3; j++)
	if (ipdb[i] > 0) xyzpdb[i][j] = xyzp->coo[(ipdb[i]-1)*3+j];

      for (i=0; i<MXHSYM*3; i++) for (j=0; j<3; j++)
	if (ihpdb[i] > 0) xyzhpdb[i][j] = xyzp->coo[(ihpdb[i]-1)*3+j];

      ResChanged[ires-1] = 1;
   }


}

double rmsdres()
{
   int i,j, numatoms;
   int tmpipdb[MXSYM], tmpihpdb[MXHSYM*3];
   double rmsd,rmsdh, rtmp;


   for (i=0; i<MXSYM; i++) tmpipdb[i] = 0;
   for (i=0; i<MXHSYM*3; i++) tmpihpdb[i] = 0;

#if defined(VMS) || defined(UNDERSC)
   getpdb(&CurrRes,tmpipdb,tmpihpdb);
#else
#ifdef CRAY
   GETPDB(&CurrRes,tmpipdb,tmpihpdb);
#else
   getpdb_(&CurrRes,tmpipdb,tmpihpdb);
#endif
#endif

   rmsd = 0;
   numatoms = 0;

   for (i=0; i<MXSYM; i++) {
        if (tmpipdb[i]) {
           numatoms++;
           fprintf(stderr,"%d org %f %f %f rot %f %f %f \n",i+1,xyzpdb[i][0]*toangs,xyzpdb[i][1]*toangs,xyzpdb[i][2]*toangs,xyzp->coo[(tmpipdb[i]-1)*3]*toangs,xyzp->coo[(tmpipdb[i]-1)*3+1]*toangs,xyzp->coo[(tmpipdb[i]-1)*3+2]*toangs);
           for (j=0; j<3; j++) { 
	      rtmp = (xyzpdb[i][j] - xyzp->coo[(tmpipdb[i]-1)*3+j]);
	      rmsd = rmsd + rtmp*rtmp;
	   }
	}
   }

   rmsd = toangs*sqrt(rmsd/((float) numatoms));
   fprintf(stderr,"RMSD current rotamer with starting geometry: %f\n",rmsd); 

   numatoms = 0;
   rmsdh = 0;

   for (i=0; i<MXHSYM*3; i++) {
        if (tmpihpdb[i]) {
           numatoms++;
           for (j=0; j<3; j++) {
	      rtmp = (xyzhpdb[i][j] - xyzp->coo[(tmpihpdb[i]-1)*3+j]);
	      rmsdh = rmsdh + rtmp*rtmp;
	   }
	}
   }

   rmsdh = toangs*sqrt(rmsdh/((float) numatoms));
   fprintf(stderr,"RMSDH current rotamer with starting geometry: %f\n",rmsdh); 

   return(rmsd);
}

void zmt2cor(ires,iopt)
int ires;
int iopt;
{

   update_model = 1;
#if defined(VMS) || defined(UNDERSC)
   dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
   doclr();
   if (iopt) conpdb();
#ifdef DOGL
   ogres(ires,ONE,1);
   update_model = 0;
#endif
   qupd();
   curs(&ZERO);
#else
#ifdef CRAY
   DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
   doclr();
   if (iopt) CONPDB();
#ifdef DOGL
   ogres(ires,ONE,1);
   update_model = 0;
#endif
   QUPD();
   CURS(&ZERO);
#else
   dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
   doclr();
   if (iopt) conpdb_();
#ifdef DOGL
   ogres(ires,ONE,1);
   update_model = 0;
#endif
   qupd_();
   curs_(&ZERO);
#endif
#endif
   presetp();
   *Sinct = 0;
}

void scanrot(ires,aminotyp)
int ires;
int aminotyp;
{
   int i,OptRot;
   double rmsd,rtmp;


   SaveResXYZ(ires);

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   rmsd = 1000000.0;
   OptRot = -1;

   if (ZMEup) {
      for (i=0; i<aminozmt[aminotyp].nrots; i++) {

        if (aminozmt[aminotyp].chis[0] != -1) 
	  zmptrp->bet[aaptr[ires-1].chi1] = aminozmt[aminotyp].rots[i].rots[0];
        if (aminozmt[aminotyp].chis[1] != -1) 
  	  zmptrp->bet[aaptr[ires-1].chi2] = aminozmt[aminotyp].rots[i].rots[1];
        if (aminozmt[aminotyp].chis[2] != -1) 
	  zmptrp->bet[aaptr[ires-1].chi3] = aminozmt[aminotyp].rots[i].rots[2];
        if (aminozmt[aminotyp].chis[3] != -1) 
	  zmptrp->bet[aaptr[ires-1].chi4] = aminozmt[aminotyp].rots[i].rots[3];
        SetQZME();

        FindZRange(ires);

#if defined(VMS) || defined(UNDERSC)
        dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
#else
#ifdef CRAY
        DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
#else
        dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
#endif
#endif
        rtmp = rmsdres();
        if (rtmp < rmsd) {
	  rmsd = rtmp;
	  OptRot = i;
        }

     }

     fprintf(stderr,"\nBest Rotamer fit: %d\n",OptRot+1);

     if (aminozmt[aminotyp].chis[0] != -1) 
	zmptrp->bet[aaptr[ires-1].chi1] = 
		aminozmt[aminotyp].rots[OptRot].rots[0];
     if (aminozmt[aminotyp].chis[1] != -1) 
	zmptrp->bet[aaptr[ires-1].chi2] = 
		aminozmt[aminotyp].rots[OptRot].rots[1];
     if (aminozmt[aminotyp].chis[2] != -1) 
	zmptrp->bet[aaptr[ires-1].chi3] = 
		aminozmt[aminotyp].rots[OptRot].rots[2];
     if (aminozmt[aminotyp].chis[3] != -1) 
	zmptrp->bet[aaptr[ires-1].chi4] = 
		aminozmt[aminotyp].rots[OptRot].rots[3];

     SetQZME();

     if (ZME_window_pos >= calfptr->ncalf) ZME_window_pos = 0;
     if (calfptr->ncalf < ZME_window_high) RedrawZME();
     else UpdateZME();
     RedrawScroll(&zscroll);

     FindZRange(ires);
     zmt2cor(ires,0);

   } else {

     pmfrot->ndrs = 1;
     pmfrot->idrs[0] = ires;
     AllocRot();

     for (i=0; i<RDrots[aminotyp].nrots; i++) {
	rotset(ires,i);
        rtmp = rmsdres();
        if (rtmp < rmsd) {
	  rmsd = rtmp;
	  OptRot = i;
        }
     }
     rotset(ires,OptRot);
     DeAllocRot();
#ifdef DOGL
     ogres(ires,ONE,1);
#endif
   }
}


void bestrot(int print);

void onerot(ires,print)
int ires;
int print;
{

#if defined(VMS) || defined(UNDERSC)
   dfipar();
#else
#ifdef CRAY
   DFIPAR();
#else
   dfipar_();
#endif
#endif

   pmfrot->ndrs = 1;
   pmfrot->idrs[0] = ires;
   (void) bestrot(print);
}

void setrot(irs,irot)
int irs;
int irot;
{
	int aminotyp;

	aminotyp = calfptr->iamino[irs-1]-1;
        if (aminozmt[aminotyp].chis[0] != -1) 
   	   zmptrp->bet[aaptr[irs-1].chi1] = 
			aminozmt[aminotyp].rots[irot].rots[0];
        if (aminozmt[aminotyp].chis[1] != -1) 
	   zmptrp->bet[aaptr[irs-1].chi2] = 
			aminozmt[aminotyp].rots[irot].rots[1];
        if (aminozmt[aminotyp].chis[2] != -1) 
	   zmptrp->bet[aaptr[irs-1].chi3] = 
			aminozmt[aminotyp].rots[irot].rots[2];
        if (aminozmt[aminotyp].chis[3] != -1) 
	   zmptrp->bet[aaptr[irs-1].chi4] = 
			aminozmt[aminotyp].rots[irot].rots[3];

}

void bestrot(int print)
{
   int i,l,l1,irs,aminotyp,OptRot[MXDRES];
   double scor,rtmp;

/* assign atom types */

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
   dfiass();
#else
#ifdef CRAY
   CURS(&ONE);
   DFIASS();
#else
   curs_(&ONE);
   dfiass_();
#endif
#endif

/* 
   Calculate (once) the static interaction between flexible residues 
   (all rotamers) and the non-flexible-residues 
*/

   if (!ZMEup) {
      DeAllocRot();
      AllocRot();
   }

/*   fprintf(stderr,"ndrs %d\n",pmfrot->ndrs);*/

   for (l=0; l<pmfrot->ndrs; l++) {

      scor = 1000000.0;
      OptRot[l] = -1;

      irs = pmfrot->idrs[l];
      aminotyp = calfptr->iamino[irs-1]-1;

      if (print) {
	 fprintf(stderr,"%s %d\n",AminoAcids[aminotyp],calfptr->irsnr[irs-1]);
      }

      if (ZMEup) {
       for (i=0; i<aminozmt[aminotyp].nrots; i++) {

	 setrot(irs,i);

         SetQZME();

         FindZRange(irs);

	 pmfrot->lrots[l] = i + 1;
	 l1 = l + 1;

/*
dfirot: rotamer with all non flexible sidechains and 
        rotamer with backbone part of flexible sidechains and 
        internal rotamer energy (fixed or self pmf ?)
*/

#if defined(VMS) || defined(UNDERSC)
         dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
         dfirot(&l1);
#else
#ifdef CRAY
         DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
         DFIROT(&l1);
#else
         dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
         dfirot_(&l1);
#endif
#endif

         rtmp = pmfrot->estat[i][l];
	 if (print) {
	     fprintf(stderr,"\nRotamer %d %f\n",i,rtmp);
	 }
         if (rtmp < scor) {
	     scor = rtmp;
	     OptRot[l] = i;
         }

       }

      } else {

       for (i=0; i<RDrots[aminotyp].nrots; i++) {

	 rotset(irs,i);

	 pmfrot->lrots[l] = i + 1;
	 l1 = l + 1;


#if defined(VMS) || defined(UNDERSC)
         dfirot(&l1);
#else
#ifdef CRAY
         DFIROT(&l1);
#else
         dfirot_(&l1);
#endif
#endif

         rtmp = pmfrot->estat[i][l];
	 if (print) {
	     fprintf(stderr,"\nRotamer %d %f\n",i,rtmp);
	 }
         if (rtmp < scor) {
	     scor = rtmp;
	     OptRot[l] = i;
         }

       }
      }
   }

   if (print) {
	fprintf(stderr,"\nBest Rotamer fit: %d\n",OptRot[0]+1);
   }

   for (l=0; l<pmfrot->ndrs; l++) {

      irs = pmfrot->idrs[l];

      if (ZMEup) {
	setrot(irs,OptRot[l]);
      } else {
	rotset(irs,OptRot[l]);
      }

   }

   if (ZMEup) {
	SetQZME();

	if (ZME_window_pos >= calfptr->ncalf) ZME_window_pos = 0;
	if (calfptr->ncalf < ZME_window_high) RedrawZME();
	else UpdateZME();
	RedrawScroll(&zscroll);

	if (pmfrot->ndrs == 1) FindZRange(pmfrot->idrs[0]);

#if defined(VMS) || defined(UNDERSC)
	dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	doclr();
#ifdef DOGL
	for (l=0; l<pmfrot->ndrs; l++)
	   ogres(pmfrot->idrs[l],ONE,ONE);
	update_model = 0;
#endif
	qupd();
	curs(&ZERO);
#else
#ifdef CRAY
	DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	doclr();
#ifdef DOGL
	for (l=0; l<pmfrot->ndrs; l++)
	   ogres(pmfrot->idrs[l],ONE,ONE);
	update_model = 0;
#endif
	QUPD();
	CURS(&ZERO);
#else
	dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	doclr();
#ifdef DOGL
	for (l=0; l<pmfrot->ndrs; l++)
	   ogres(pmfrot->idrs[l],ONE,ONE);
	update_model = 0;
#endif
	qupd_();
	curs_(&ZERO);
#endif
#endif
	presetp();
   } else {
	for (l=0; l<pmfrot->ndrs; l++) {
#if defined(VMS) || defined(UNDERSC)
	   actami(&pmfrot->idrs[l],&ZERO,&ONE,&ZERO);
#else
#ifdef CRAY
	   ACTAMI(&pmfrot->idrs[l],&ZERO,&ONE,&ZERO);
#else
	   actami_(&pmfrot->idrs[l],&ZERO,&ONE,&ZERO);
#endif
#endif
	   rsold = RESUND;
#ifdef DOGL
	   ogres(pmfrot->idrs[l],ONE,ONE);
#endif
	}
#ifdef DOGL
	update_model = 0;
#endif
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
	presetp();
   }

}

void prresrot(eupl)
double eupl;
{
   int i,j;

   fprintf(stderr,"nresrot %d eupl %f\n",nresrot,eupl);
   for (i=0; i<MXROTRES; i++) {
      fprintf(stderr,"ResRot %d ",i);
      for (j=0; j<resrot[0].ndrs; j++) {
          fprintf(stderr,"res%2d %d rot %d, ",
		j,resrot[i].idrs[j],resrot[i].rot[j]);
      }
      fprintf(stderr," etot %8.3f\n",resrot[i].etot);
   }
}

void showresrot(sol)
int sol;
{
   int l;


   if (ZMEup) {

	for (l=0; l<resrot[sol].ndrs; l++) {
	   setrot(resrot[sol].idrs[l],resrot[sol].rot[l]);
	}

	zmpart->imx = resrot[sol].mx;
	zmpart->imn = resrot[sol].mn;

	SetQZME();

	if (ZME_window_pos >= calfptr->ncalf) ZME_window_pos = 0;
	if (calfptr->ncalf < ZME_window_high) RedrawZME();
	else UpdateZME();
	RedrawScroll(&zscroll);

#if defined(VMS) || defined(UNDERSC)

	dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	doclr();
#ifdef DOGL
	for (l=0; l<resrot[sol].ndrs; l++)
	ogres(resrot[sol].idrs[l],ONE,0);
	update_model = 0;
#endif
	qupd();
	curs(&ZERO);

#else

#ifdef CRAY

	DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	doclr();
#ifdef DOGL
	for (l=0; l<resrot[sol].ndrs; l++)
	ogres(resrot[sol].idrs[l],ONE,0);
	update_model = 0;
#endif
	QUPD();
	CURS(&ZERO);

#else

	dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
	doclr();
#ifdef DOGL
	for (l=0; l<resrot[sol].ndrs; l++)
	ogres(resrot[sol].idrs[l],ONE,0);
	update_model = 0;
#endif
	qupd_();
	curs_(&ZERO);

#endif

#endif
   } else {

	for (l=0; l<resrot[sol].ndrs; l++) {
	   rotset(resrot[sol].idrs[l],resrot[sol].rot[l]);
	}

	doclr();
#if defined(VMS) || defined(UNDERSC)
	qupd();
	curs(&ZERO);
#else
#ifdef CRAY
	QUPD();
	CURS(&ZERO);
#else
	qupd_();
	curs_(&ZERO);
#endif
#endif
#ifdef DOGL
	for (l=0; l<resrot[sol].ndrs; l++)
	   ogres(resrot[sol].idrs[l],ONE,0);
	update_model = 0;
#endif
   }
   presetp();
}


void opt3rot()
{
   int i,j,k,l,l1,m,n,mx,mn,aminotyp,debug;
   int irs0,irs[6],rots[6],j0,j1,j2,j3,j4,j5;
   double etot,eupl;

   debug = 0;

   if (pmfrot->ndrs == 0) return;

   DeAllocRot();
   AllocRot();
/* assign atom types */

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
   dfiass();
#else
#ifdef CRAY
   CURS(&ONE);
   DFIASS();
#else
   curs_(&ONE);
   dfiass_();
#endif
#endif

/* 
   Calculate (once) the static interaction between flexible residues 
   (all rotamers) and the non-flexible-residues 
*/

   fprintf(stderr,"ndrs %d\n",pmfrot->ndrs);

   zmpart->idcur = 0;
   for (l=0; l<pmfrot->ndrs; l++) {

      irs0 = pmfrot->idrs[l];
      aminotyp = calfptr->iamino[irs0-1]-1;

      if (ZMEup) {
	for (i=0; i<aminozmt[aminotyp].nrots; i++) {

	 setrot(irs0,i);

         SetQZME();

         FindZRange(irs0);

	 pmfrot->lrots[l] = i + 1;
	 l1 = l + 1;

/*
dfirot: rotamer with all non flexible sidechains and 
        rotamer with backbone part of flexible sidechains and 
        internal rotamer energy (fixed or self pmf ?)
*/

#if defined(VMS) || defined(UNDERSC)
         dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
         dfirot(&l1);
#else
#ifdef CRAY
         DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
         DFIROT(&l1);
#else
         dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
         dfirot_(&l1);
#endif
#endif

	}
      } else {

	for (i=0; i< RDrots[aminotyp].nrots; i++) {

	 rotset(irs0,i);

	 pmfrot->lrots[l] = i + 1;
	 l1 = l + 1;

#if defined(VMS) || defined(UNDERSC)
         dfirot(&l1);
#else
#ifdef CRAY
         DFIROT(&l1);
#else
         dfirot_(&l1);
#endif
#endif

	}
      }
   }

   if (ZMEup) {
	mx = -1; mn = *zmptrp->mxzat;
   }

   for (l=0; l<6; l++) rots[l] = 1;
   for (l=0; l<pmfrot->ndrs; l++) {
      if (pmfrot->ndrs >= l+1) {
	irs[l] = pmfrot->idrs[l];
	if (ZMEup) {
	   rots[l] = aminozmt[calfptr->iamino[irs[l]-1]-1].nrots;
	   FindZRange(irs[l]);
	   if (zmpart->imx > mx) mx = zmpart->imx;
	   if (zmpart->imn < mn) mn = zmpart->imn;
	} else {
	   rots[l] = RDrots[calfptr->iamino[irs[l]-1]-1].nrots;
	}
      }
   }
   if (ZMEup) {
	zmpart->imx = mx; zmpart->imn = mn;
   }

   nresrot = 1;
   resrot[0].etot = 100000.0;
   eupl = 100000.0;

/*
   fprintf(stderr,"rots[0] %d rots[1] %d\n",rots[0],rots[1]);
*/

   for (j0=0; j0<rots[0]; j0++) {
	if (ZMEup) {
	   setrot(irs[0],j0);
	} else {
	   rotset(irs[0],j0);
	}

	for (j1=0; j1<rots[1]; j1++) {
	   if (ZMEup) {
		if (pmfrot->ndrs > 1) setrot(irs[1],j1);
	   } else {
		if (pmfrot->ndrs > 1) rotset(irs[1],j1);
	   }

	   for (j2=0; j2<rots[2]; j2++) {
		if (ZMEup) {
		   if (pmfrot->ndrs > 2) setrot(irs[2],j2);
		} else {
		   if (pmfrot->ndrs > 2) rotset(irs[2],j2);
		}

		for (j3=0; j3<rots[3]; j3++) {
		   if (ZMEup) {
			if (pmfrot->ndrs > 3) setrot(irs[3],j3);
		   } else {
			if (pmfrot->ndrs > 3) rotset(irs[3],j3);
		   }

		   for (j4=0; j4<rots[4]; j4++) {
			if (ZMEup) {
			   if (pmfrot->ndrs > 4) setrot(irs[4],j4);
			} else {
			   if (pmfrot->ndrs > 4) rotset(irs[4],j4);
			}

			for (j5=0; j5<rots[5]; j5++) {
			   if (ZMEup) {
				if (pmfrot->ndrs > 5) setrot(irs[5],j5);
				SetQZME();
#if defined(VMS) || defined(UNDERSC)
				dumzm(xyzp->coo,xyzp->ianz,xyzp->iatoms);
				dfiflx(&etot);
#else
#ifdef CRAY
				DUMZM(xyzp->coo,xyzp->ianz,xyzp->iatoms);
				DFIFLX(&etot);
#else
				dumzm_(xyzp->coo,xyzp->ianz,xyzp->iatoms);
				dfiflx_(&etot);
#endif
#endif
			   } else {
				if (pmfrot->ndrs > 5) rotset(irs[5],j5);
#if defined(VMS) || defined(UNDERSC)
				dfiflx(&etot);
#else
#ifdef CRAY
				DFIFLX(&etot);
#else
				dfiflx_(&etot);
#endif
#endif
			   }


/* sum in static contributions */

			   etot = etot + pmfrot->estat[j0][0];
			   if (pmfrot->ndrs > 1)  
				etot = etot + pmfrot->estat[j1][1];
			   if (pmfrot->ndrs > 2)  
				etot = etot + pmfrot->estat[j2][2];
			   if (pmfrot->ndrs > 3)  
				etot = etot + pmfrot->estat[j3][3];
			   if (pmfrot->ndrs > 4)  
				etot = etot + pmfrot->estat[j4][4];
			   if (pmfrot->ndrs > 5)  
				etot = etot + pmfrot->estat[j5][5];
/*
   fprintf(stderr,"\nRotcomb res1 %d rot %d, res2 %d rot %d, res3 %d rot %d etot %8.3f eupl %8.3f\n",pmfrot->idrs[0],j0,pmfrot->idrs[1],j1,pmfrot->idrs[2],j2,etot,eupl);
*/

/* 
   copy rotamer sequence with corres. energy to results array 
   when its energy etot is smaller than the higest energy of the current
   array (eupl)
   Since the first element is set at the start to a HIGH value, the condition
   etot < eupl will always be satisfied untill the HIGH value is in the last 
   element of the array and then will disappear.
*/


			   if (etot < eupl) {
			     for (n=0; n < nresrot; n++) {
			      if (etot < resrot[n].etot) {
				for (k=nresrot-1; k >= n; k--) {
				   if (k+1 <MXROTRES) {
					resrot[k+1] = resrot[k];
				   }
				}
		   		resrot[n].ndrs = pmfrot->ndrs;
		   		resrot[n].etot = etot;
		   		resrot[n].idrs[0] = pmfrot->idrs[0];
		   		resrot[n].idrs[1] = pmfrot->idrs[1];
		   		resrot[n].idrs[2] = pmfrot->idrs[2];
		   		resrot[n].idrs[3] = pmfrot->idrs[3];
		   		resrot[n].idrs[4] = pmfrot->idrs[4];
		   		resrot[n].idrs[5] = pmfrot->idrs[5];
		   		resrot[n].rot[0] = j0;
		   		resrot[n].rot[1] = j1;
		   		resrot[n].rot[2] = j2;
		   		resrot[n].rot[3] = j3;
		   		resrot[n].rot[4] = j4;
		   		resrot[n].rot[5] = j5;
		   		resrot[n].mx = zmpart->imx;
		   		resrot[n].mn = zmpart->imn;
				if (nresrot < MXROTRES ) nresrot++;
			        eupl = resrot[nresrot-1].etot;
				break;
			      }
			     }
			   }
                	   if (debug) prresrot(eupl);
			}
		    }
		}
	    }
	}
   }


   fprintf(stderr,"\nRotOpt:\n");
   for (j=0; j<resrot[0].ndrs; j++) {
          fprintf(stderr,"%2d res %d rot %d, \n",
		j,resrot[0].idrs[j],resrot[0].rot[j]);
   }
   fprintf(stderr," etot %8.3f\n",resrot[0].etot);

   for (j=0; j<nresrot; j++) flxen[j] = resrot[j].etot;

   showresrot(0);
   zmpart->idcur = 1;
}

#define MAGIC 1993
#define MAXFNAME 512
#define TOANGS 0.52917706e0
#define MAXFRM 100000

/* little <-> big endian swap */

void bswp(void *v) {
  int *P;

  P = (int *) v;
  *P = (*P&0xff000000)>>24 | (*P&0x00ff0000)>> 8  |
       (*P&0x0000ff00)<< 8 | (*P&0x000000ff)<<24 ;

}

void bswp8(void *v) {
  int *P;
  int b1, b2;

  P = (int *) v;

  b1 = P[0];
  b1 = (b1&0xff000000)>>24 | (b1&0x00ff0000)>>8  |
       (b1&0x0000ff00)<<8  | (b1&0x000000ff)<<24;

  b2 = P[1];
  b2 = (b2&0xff000000)>>24 | (b2&0x00ff0000)>>8  |
       (b2&0x0000ff00)<<8  | (b2&0x000000ff)<<24;

  P[0] = b2;
  P[1] = b1;
}

int trint(FILE *fptr, int *i)
{
   if (fread(i, 4, 1, fptr) != 1) return -1;
   if (strx.swap) bswp(i);
   return 0;
}

int trdble(FILE *fptr, double *r)
{
   float dum;

   if (strx.prec == sizeof(float)) {
	if (fread(&dum, (size_t) strx.prec, 1, fptr) != (size_t) 1) return -1;
	if (strx.swap) bswp(&dum);
	*r = (double) dum;
   } else if (strx.prec == sizeof(double)) {
	if (fread(r, (size_t) strx.prec, 1, fptr) != (size_t) 1) return -1;
	if (strx.swap) bswp8(r);
   }
   return 0;
}

int trstr(FILE *fptr, char *str)
{
   int nstr;

   if (trint(fptr,&nstr) < 0) return -1;

   if (fread(str,1,(size_t) nstr,fptr) != (size_t) nstr) return -1;
   str[nstr] = '\n';
   return nstr;
}

int cntstr(FILE *fptr, char *str)
{
   int nstr,tup,pad;

   if (trint(fptr, &nstr) < 0) return -1;

   tup = nstr/sizeof(int);
   pad = nstr - tup*sizeof(int);
   if (pad) nstr = (tup+1)*sizeof(int);

   if (fread(str,1,(size_t) nstr,fptr) != (size_t) nstr) return -1;
   str[nstr] = '\n';
   return nstr;
}

#if defined(VMS) || defined(UNDERSC)
void gettrr(int *step,int *istat)
#else
#ifdef CRAY
void GETTRR(int *step,int *istat)
#else
void gettrr_(int *step,int *istat)
#endif
#endif
{
   int iframe,debug,istp1,istp2;
   char filename[MAXFNAME];

   debug = 0;

   strcpy(filename,grostr[0]);
   *istat = 0;

   if (init_trr(filename) < 0) {
        *istat = -1;
   } else {

	geo1ptr->gcvav = 1;
	geo1ptr->ifmxav = 0;
	geo1ptr->ifrmav = 0;
	geo1ptr->idmxav = 0;
	geo1ptr->idrmav = 0;
	geo1ptr->ieav = 0;
	geo1ptr->ngeoms = 0;
	geo1ptr->nepnts = 0;
	geo1ptr->dmaxt = 0.0;
	geo1ptr->fmaxt = 0.0;
	geo1ptr->drmst = 0.0;
	geo1ptr->frmst = 0.0;
	iframe = 1;
	while(!gfrm(&iframe,step,0)) {
	   if (iframe == 1) istp1 = *step;
	   if (iframe == 2) istp2 = *step;
	   iframe++;
	}
	geo1ptr->ngeoms = strx.nframes = iframe;
	if (debug) fprintf(stderr,"# frames %d\n",strx.nframes);
 	*step = istp2 - istp1;
   }
 
}

void cltrr()
{
   fclose(strx.fptr);
}

int init_trr(char *fileroot)
{
   char filename[MAXFNAME];

/* uses the xdr trajectory reading routines for the .trr file:
   xdr trajectory file */

   strx.box = strx.vir = strx.pres = strx.x = strx.natoms = strx.swap = 0;
   strx.fpos = (long *) malloc(sizeof(long)*MAXFRM); 
   memset(strx.fpos,-1,sizeof(long)*MAXFRM);

   sprintf(filename,"%s.trr",fileroot);

   strx.fptr = fopen(filename, "rb");
   if (strx.fptr == NULL) {
	fprintf(stderr,"Didnt find trajectory file: %s\n\n",filename);
	return -1;
   }
   return 0;
}

int header_trr(int *step)
{
   char sdummy[80];
   int magic;
   int dummy;
   double rdum;

   if (trint(strx.fptr,&magic) < 0) return -1;
   if (magic != MAGIC) {
	bswp(&magic);
	if (magic != MAGIC) {
	   fprintf(stderr,"Magic number mismatch\n");
	   return -1;
	}
	strx.swap = 1;
   }

   if (trint(strx.fptr,&dummy) < 0) return -1;
   if (trstr(strx.fptr,sdummy) < 0) return -1;
   if (trint(strx.fptr,&dummy) < 0) return -1;
   if (trint(strx.fptr,&dummy) < 0) return -1;
   if (trint(strx.fptr,&strx.box) < 0) return -1;
   if (trint(strx.fptr,&strx.vir) < 0) return -1;
   if (trint(strx.fptr,&strx.pres) < 0) return -1;
   if (trint(strx.fptr,&dummy) < 0) return -1;
   if (trint(strx.fptr,&dummy) < 0) return -1;
   if (trint(strx.fptr,&strx.x) < 0) return -1;
   if (trint(strx.fptr,&strx.v) < 0) return -1;
   if (trint(strx.fptr,&strx.f) < 0) return -1;
   if (trint(strx.fptr,&strx.natoms) < 0) return -1;
   if (trint(strx.fptr,step) < 0) return -1;
   if (trint(strx.fptr,&dummy) < 0) return -1;

/*
   fprintf(stderr,"box %d vir %d pres %d x %d v %d f %d natoms %d\n",
       strx.box,strx.vir,strx.pres,strx.x,strx.v,strx.f,strx.natoms);
*/

   if (strx.x) strx.prec = strx.x/(strx.natoms*3);
   else if (strx.v) strx.prec = strx.v/(strx.natoms*3);
   else if (strx.f) strx.prec = strx.f/(strx.natoms*3);

   if (trdble(strx.fptr,&rdum) < 0) return -1;
   if (trdble(strx.fptr,&rdum) < 0) return -1;

   return 0;
}

#if defined(VMS) || defined(UNDERSC)
void gtfrm(int *frame)
#else
#ifdef CRAY
void GTFRM(int *frame)
#else
void gtfrm_(int *frame)
#endif
#endif
{
   int idum,step;

   idum = 0;

   if (gfrm(frame,&step,1)) idum = 1;
}

int gfrm(int *frame,int *step,int set)
{
   int i,j,frame_done,ioff;
   double v[3][3],rdum,vdum[3];
/*
should set coordinate atom first read of trr (to set fpos)
because only after rdgro, coordinates are converted to bohr
we need them in angs after rdgro and in bohr after gfrm
*/

   if (!strx.fptr) return -1;

   if (strx.fpos[(*frame)-1] == -1) {
	strx.fpos[(*frame)-1] = ftell(strx.fptr);
        frame_done = 0;
   } else {
	fseek(strx.fptr, strx.fpos[(*frame)-1], SEEK_SET);
        frame_done = 1;
   }

   if (header_trr(step) < 0) return -1;

   if (strx.box) {
      for (i=0; i < 3; i++) {
	for (j=0; j < 3; j++) {
	   if (trdble(strx.fptr,&v[i][j]) < 0) return -1;
	   v[i][j] = v[i][j]*10.0/TOANGS;
	}
      }
      if (cellpnt->iclon) {
	ioff = cellpnt->iclpnt[0];
	if (set) {
	   for (i=0; i < 3; i++)
	      for (j=0; j < 3; j++) xyzp->coo[(i+ioff)*3+j] = v[i][j];
	   for (j=0; j < 3; j++) xyzp->coo[(ioff+3)*3+j] = v[0][j] + v[1][j];
	   for (j=0; j < 3; j++) xyzp->coo[(ioff+4)*3+j] = v[1][j] + v[2][j];
	   for (j=0; j < 3; j++) xyzp->coo[(ioff+5)*3+j] = v[0][j] + v[2][j];
	   for (j=0; j < 3; j++) xyzp->coo[(ioff+6)*3+j] = v[0][j] + v[1][j] + v[2][j];
	}
      }
   }
   if (strx.vir) {
      for (i=0; i < 9; i++)
	if (trdble(strx.fptr,&rdum) < 0) return -1;
   }
   if (strx.pres) {
      for (i=0; i < 9; i++)
	if (trdble(strx.fptr,&rdum) < 0) return -1;
   }

   if (strx.x) {
      for (i=0; i < strx.natoms; i++) {
	for (j=0; j < 3; j++) {
	   if (trdble(strx.fptr,&vdum[j]) < 0) return -1;
	   if (set) xyzp->coo[i*3+j] = vdum[j]*10.0/TOANGS;
	}
      }
   }      

   if (frame_done) return 0;

   if (strx.v) {
      for (i=0; i < strx.natoms; i++) {
	for (j=0; j < 3; j++) {
	   if (trdble(strx.fptr,&vdum[j]) < 0) return -1;
	}
      }
   }      

   if (strx.f) {
      for (i=0; i < strx.natoms; i++) {
	for (j=0; j < 3; j++) {
	   if (trdble(strx.fptr,&vdum[j]) < 0) return -1;
	}
      }
   }      

   return 0;
}

void cledr()
{
   fclose(stre.fptr);
}

#if defined(VMS) || defined(UNDERSC)
void getene(int *nstep,int *istat)
#else
#ifdef CRAY
void GETENE(int *nstep,int *istat)
#else
void getene_(int *nstep,int *istat)
#endif
#endif
{
   int i,iframe,iold,step,istp1,istp2,nestp,nepnts,nepntst;
   double ener,eprepos,rfrac;
   char filename[MAXFNAME];

/* preposterous value */

   eprepos = 1.54321e-20;
   strcpy(filename,grostr[0]);
   *istat = 0;

   geo1ptr->ieav = 0;

MOREMEM:

   if (init_edr(filename) < 0) {
        *istat = -1;
   } else {

	geo1ptr->nepnts = 0;
	for (i=0;i<geo1ptr->mxpnt;i++) geop->epoints[i] = eprepos;
	iframe = 0;
	while(!efrm(&step,&ener)) {
	   if (iframe == 0) istp1 = step;
	   if (iframe == 1) {
		istp2 = step;
		nestp = istp2 - istp1;
		rfrac = (double) nestp / (double) *nstep;
	   }
	   iframe++;
	   nepntst = nepnts = (int) (((double)(iframe-1))*rfrac);
	   if (nepnts <= geo1ptr->mxpnt) geop->epoints[nepnts] = ener;
	}
	if (nepntst > geo1ptr->mxpnt) {
	   
	   nepntst++;
#if defined(VMS) || defined(UNDERSC)
	   allgeo(&nepntst,&ZERO);
#else
#ifdef CRAY
	   ALLGEO(&nepntst,&ZERO);
#else
	   allgeo_(&nepntst,&ZERO);
#endif
#endif
	   rewind(stre.fptr);
	   goto MOREMEM;
	}
	geo1ptr->nepnts = nepnts+1;
	geo1ptr->ieav = 1;
	iold = 0;
	for (i=0;i<geo1ptr->nepnts;i++) {
	   if (geop->epoints[i] == eprepos) 
		geop->epoints[i] = geop->epoints[iold];
	   else iold = i;
	}
	(void) cledr();
#if defined(VMS) || defined(UNDERSC)
	gmmcnv(geop->formax,geop->forrms,geop->dismax,geop->disrms,
		geop->epoints,geop->isav);
#else
#ifdef CRAY
	GMMCNV(geop->formax,geop->forrms,geop->dismax,geop->disrms,
		geop->epoints,geop->isav);
#else
	gmmcnv_(geop->formax,geop->forrms,geop->dismax,geop->disrms,
		geop->epoints,geop->isav);
#endif
#endif
	
   }
 
}

int init_edr(char *fileroot)
{
   char filename[MAXFNAME];
   char sdummy[80];
   int i,nre;

   sprintf(filename,"%s.edr",fileroot);

   stre.fptr = fopen(filename, "rb");
   if (!stre.fptr) {
	fprintf(stderr,"Didnt find energy file: %s\n\n",filename);
	return -1;
   }

   if (trint(stre.fptr,&nre) < 0) return -1;

   for (i=0;i<nre;i++) {
	if (cntstr(stre.fptr,sdummy) < 0) return -1;
	if (strstr(sdummy,"Total Energy")) stre.etot = i;
   }

   return 0;
}

int header_edr(int *step,int *nre)
{
   int i;
   int dummy, nblock;
   double rdum;

/* edr does not work with magic number ? */

/* t, step, nre, ndisre, nblock, esize, dsize dum */

   if (trdble(stre.fptr,&rdum) < 0) return -1;
   if (trint(stre.fptr,step) < 0) return -1;
   if (trint(stre.fptr,nre) < 0) return -1;
   if (trint(stre.fptr,&dummy) < 0) return -1;
   if (trint(stre.fptr,&nblock) < 0) return -1;
   for (i=0;i<nblock;i++)
	if (trint(stre.fptr,&dummy) < 0) return -1;
   if (trint(stre.fptr,&dummy) < 0) return -1;
   if (trint(stre.fptr,&dummy) < 0) return -1;
   if (trint(stre.fptr,&dummy) < 0) return -1;

   return 0;
}


int efrm(int *step,double *ener)
{
   int i,nre;
   double rdum;

   if (header_edr(step,&nre) < 0) return -1;

   for (i=0; i < nre; i++) {
	if (trdble(stre.fptr,&rdum) < 0) return -1;
	if (i == stre.etot) *ener = rdum;
	if (trdble(stre.fptr,&rdum) < 0) return -1;
	if (trdble(stre.fptr,&rdum) < 0) return -1;
	if (trdble(stre.fptr,&rdum) < 0) return -1;
   }

   return 0;
}

void SetExplButton(win,x,y)
Window win;
int x,y;
{
   BSTRU *arr; int nbut,fnd,i,j; Window sub;
   QBOXSTRU *qbptr[5] = {IANZbox,BLbox,ALPHbox,BETbox,IZbox};
   int *winup = NULL;

   if (animptr.on || *movie || tnkfrk) return;
   if (expldat.active) return;

   fnd = 0;
   for (i = 0; i < NOBJS; i++) {
	if (WinObj[i].win != NULL && WinObj[i].subwin != NULL &&
	    WinObj[i].butarr != NULL) {
	   if (win == *WinObj[i].win) {
		arr = WinObj[i].butarr; nbut = WinObj[i].numbut;
		sub = *WinObj[i].subwin;
		winup = WinObj[i].winup;
		fnd = 1;
	   }
	}
   }
   if (!fnd) return;

   fnd = 0;

   i = Clickwin(arr,nbut,x,y,0);

   if (i >= 0) {

	if (arr[i].explstr != NULL && arr[i].active) {

		expldat.button = i;
		expldat.win = sub;
		expldat.winup = winup;
		expldat.barr = arr;
		expldat.borq = 0;
		fnd = 1;
	}

   } else {
	i = CheckBox(qboxes,NQBOX,win,x,y);
	if (i >= 0) {
	   if (qboxes[i].explstr != NULL) {
		expldat.button = i;
		expldat.win = sub;
		expldat.winup = winup;
		expldat.qarr = qboxes;
		expldat.borq = 1;
		fnd = 1;
	   }
	}
	if (!fnd && win == ZMEwin) {
	   for (j=0; j < 5; j++) {
	     if (!fnd) {
		int n;
		n = *zmptrp->nz;
		if (j == 4) n = *zmptrp->nz*4;
		i = CheckBox(qbptr[j],n,win,x,y);
		if (i >= 0) {
		   if ((qbptr[j])[i].explstr != NULL &&
			!(qbptr[j])[i].expldone) {
			expldat.button = i;
			expldat.win = sub;
			expldat.winup = winup;
			expldat.qarr = qbptr[j];
			expldat.borq = 1;
			fnd = 1;
		   }
		}
	     }
	   }
	}
   }

   if (fnd) {
#ifdef HASTIMER
	Timer(1500,2);
#else
	signal(SIGALRM,handle_explalarm);
	alarm(2);
#endif
   } else {
	signal(SIGALRM,SIG_IGN);
   }
}

#if defined(VMS) || defined(UNDERSC)
void chktmp()
#else
#ifdef CRAY
void CHKTMP()
#else
void chktmp_()
#endif
#endif
{
#ifdef __CYGWIN__
int status;

   if (access("/cygdrive/c/tmp",F_OK) != 0) {
	status = mkdir("/cygdrive/c/tmp", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	if (status == -1) fprintf(stderr,"Directory C:\\tmp not found\n");
   }

#endif

}

struct stat s_buf;

int dos2u(path)
char *path;
{
	FILE *in, *out;
	int ch, rval = 0;
	char temppath [16];
	struct utimbuf { time_t actime, modtime; } ut_buf;

	strcpy (temppath, "./clntmp");
	strcat (temppath, "XXXXXX");
	mktemp (temppath);

	if ((in=fopen (path, "r")) == (FILE *) 0) return 1;

	if ((out=fopen (temppath, "w")) == (FILE *) 0) {
	   fclose (in);
	   return 1;
	}

	while ((ch = getc(in)) != EOF) {
	   if ( (ch != '\015' && ch != '\032') &&
		(putc (ch, out) == EOF) ) {
		rval = 1;
		break;
	   }
	}

	if (fclose(in) == EOF) rval = 1;
	if (fclose(out) == EOF) rval = 1;

	ut_buf.actime = s_buf.st_atime;
	ut_buf.modtime = s_buf.st_mtime;
	if (utime(temppath, &ut_buf) == -1) rval = 1;

	if (unlink(path) == -1) rval = 1;

	if (rval) {
	   unlink(temppath);
	   return 1;
	}

	if (link(temppath,path) == -1) {
	   fprintf (stderr, "Problems renaming '%s' to '%s'\n", temppath, path);
	} else {
	   unlink (temppath);
	}
	return 0;
}

void mvhlpat(nlines,nato1)
int nlines;
int *nato1;
{
    int i,j,k,iat1;

/*
Nato1 is the first atom that is not a real atom, but a fake help
atom for Xwindows secondary structure visualisation.
These fake atoms are going to move nlines up. In the freed space
added atoms of a ligand can be placed.
Of course nlines have to be added to iatoms.
iatoms = real atoms + fake atoms
*/
    iat1  = *xyzp->iatoms;

    *nato1 = iat1;
    for (j=iat1-1; j >= 0; j--) {
 	if (xyzp->ianz[j] != 100) {
		*nato1 = j+1;
		break;
	}
    }

    for (j=iat1-1; j >= *nato1; j--) {
	xyzp->iatclr[j+nlines] = xyzp->iatclr[j];
	xyzp->iresid[j+nlines] = xyzp->iresid[j];
	xyzp->iaton[j+nlines] = xyzp->iaton[j];
	xyzp->ianz[j+nlines] = xyzp->ianz[j];
	for (k=0; k < 3; k++) 
	   xyzp->coo[(j+nlines)*3+k] = xyzp->coo[j*3+k];
	for (k=0; k < xyzp->iconn[j*(MXCON+1)]; k++) {
	   xyzp->iconn[(j+nlines)*(MXCON+1)+k+1] = 
		xyzp->iconn[j*(MXCON+1)+k+1] + nlines;
	}
	xyzp->iconn[(j+nlines)*(MXCON+1)] = xyzp->iconn[j*(MXCON+1)];
    }
}

#define STR1COL 0
#define STR2COL 11

int AlignStructs(str2,copy)
int str2;
int copy;
{

  int i,j,k,l,nlines,ires,memstat,istmp;
  int iat1,iat2,itot,nato1,nato2,nres1,nres2,nhet1,nhet2;
  double d;
  COOSTRU *xyzp1;
  COOSTRU *xyzp2;
  CALFSTRU *calf1;
  CALFSTRU *calf2;

    xyzp1   = xyzp;
    xyzp2   = &COO[str2]->coo;
    calf1   = calfptr;
    calf2   = &COO[str2]->calf;

    iat1    = *xyzp->iatoms;
    iat2    = COO[str2]->iatoms;
    nato1   = *natorg;
    if (nato1 < iat1) nato1 = iat1;
    nato2   = COO[str2]->natorg;
    if (nato2 < iat2) nato2 = iat2;
    nres1   = calfptr->ncalf;
    nres2   = COO[str2]->calf.ncalf;
    nhet1   = hetptr.NHetAtm-4;
    nhet2   = COO[str2]->hetatm.NHetAtm-4;

    if (nres1 <= 0 || nres2 <= 0) {

/* small molecule alignment */

	if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
" - Use the standard rotation, translation and zoom in/out.\n\
 - Use the Esc to switch between rotation of part or the whole structure\n\
 - Use the Tab to enter the select mode; select 3 couples of atoms to align\n\
   A couple= atom structure1 (red), atom structure2 (white)",1)) {
	   *iscst = iat1; *nscnd = iat2; *ialtyp = 3;
	   CombineStructs(str2,1,1);
	   doalign = 1; *irtcel = 2; *irtval = 2; *atcol = 0;
	   TogDown(&cbut[BATCOL]);
#if defined(VMS) || defined(UNDERSC)
	   aln2ml(ialtyp,&idum1);
#else
#ifdef CRAY
	   ALN2ML(ialtyp,&idum1);
#else
	   aln2ml_(ialtyp,&idum1);
#endif
#endif
	   return(0);
	}
	return(0);
    }

/* protein alignment */

   if (copy) {
	if ((COOt = (double *) malloc((sizeof d)*(*xyzp2->mxnat)*3)) == NULL) {
	   memstat = 0;
	} else {
	   for (i=0; i < iat2; i++ ) {
		for (k=0; k < 3; k++) {
		   COOt[i*3+k] = xyzp2->coo[i*3+k];
		}
	   }
	}
   } else {
	COOt = xyzp2->coo;
   }

#if defined(VMS) || defined(UNDERSC)
    curs(&ONE);
    supimp( xyzp1->coo,COOt,&iat1,&iat2, 
    	calf1->iamino,calf2->iamino,calf1->icalf,calf2->icalf,
    	&calf1->ncalf,&calf2->ncalf,calf1->isal,calf2->isal);
    curs(&ZERO);
#else
#ifdef CRAY
    CURS(&ONE);
    SUPIMP( xyzp1->coo,COOt,&iat1,&iat2, 
    	calf1->iamino,calf2->iamino,calf1->icalf,calf2->icalf,
    	&calf1->ncalf,&calf2->ncalf,calf1->isal,calf2->isal);
    CURS(&ZERO);
#else
    curs_(&ONE);
    supimp_( xyzp1->coo,COOt,&iat1,&iat2, 
    	 calf1->iamino,calf2->iamino,calf1->icalf,calf2->icalf,
    	&calf1->ncalf,&calf2->ncalf,calf1->isal,calf2->isal);
    curs_(&ZERO);
#endif
#endif
    if (!copy) {
#if defined(VMS) || defined(UNDERSC)
	cntvec(
#else

#ifdef CRAY
	CNTVEC(
#else
	cntvec_(
#endif
#endif
	   COO[str2]->rot.t,xyzp2->coo,xyzp2->ianz,xyzp2->iatoms);
        istmp = istruct;
        istruct = str2;
	NewActiveStruct();
#ifdef DOGL
        RibClear(istruct);
        NSurf[istruct] = 0;
#if defined(VMS) || defined(UNDERSC)
        ribgl(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
        chkbck(&ONE);
#else
#ifdef CRAY
        RIBGL(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
        CHKBCK(&ONE);
#else
        ribgl_(calfptr->ianf,&calfptr->nchain,&calfptr->ncalf,xyzp->iatoms);
        chkbck_(&ONE);
#endif
#endif

        SSdone[istruct] = 1;
        for (i=0; i<4; i++) 
    	    if (calfptr->ihet[i]) sndon(i,0,0);
#endif
        istruct = istmp;
	NewActiveStruct();
    }
    return(1);

}

void CreateCombString(char *combstr,int *str1, int str2)
{
   char xstr1[MAXCMD];
   char xstr2[MAXCMD];
   char *last1, *last2;
   char *dot1, *dot2;
   int n1=0,n2=0;

   last1 = rindex(COO[*str1]->fname,'/');
   if (last1 != NULL) {
	last1++;
	dot1 = strchr(last1,'.');
	if (dot1 != NULL) {
	   n1 = (int) (dot1 - last1);
	   strncpy(xstr1,last1,n1);
	   xstr1[n1] = '\0';
	}
   }

   last2 = rindex(COO[str2]->fname,'/');
   if (last2 != NULL) {
	last2++;
	dot2 = strchr(last2,'.');
	if (dot2 != NULL) {
	   n2 = (int) (dot2 - last2);
	   strncpy(xstr2,last2,n2);
	   xstr2[n2] = '\0';
	}
   }

   if (n1 != 0 && n2 != 0) {
	sprintf(combstr,"%s+%s",xstr1,xstr2);
   } else {	
	if (COO[*str1]->pdbcode != NULL && 
		COO[str2]->pdbcode != NULL) {
	   sprintf(combstr,"%s+%s",
	   COO[*str1]->pdbcode,COO[str2]->pdbcode);
	} else { 
	   sprintf(combstr,"%s+%s",
	   COO[*str1]->fname,COO[str2]->fname);
	}
   }
}

void New_Entry(int *str1,int str2,int nalloc,int qsar)
{

     *str1 = istruct;
     ZMEAA = 0;
     aflag = 0; bflag = 0; cflag = 0; dflag = 0;
     LastAmino = -1;
     CurAmino = -1;
     do3dx = 0; *do3d = 1;
     FRQ->ihasi = 0;
     HETLABSTRU hetlab = {.NHetLab = 0};

     if (*multstruct) {

	if (nstruct == MAXSTRUCT) {

	    if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
		"Reached maximum number supported structures",0)) {}

	} else {

	    if (nstruct == 0 && nfilesstart != 0) {
		SaveFirstStruct();
		nstruct++;
	    }

	    AllocateStructure(&COO[nstruct]);

	    if (nstruct != 0) SaveActiveStruct();

	    if (COO[nstruct] == NULL) {
		   if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
			     "Failed to allocate memory for structure",0)) {}
	    } else {
		   char combstr[MAXCMD];

		   if (qsar) {
			strcpy(combstr,"QSAR output");
		   } else {
			if (*str1 != 0) CreateCombString(combstr,str1,str2);
		   }
		   AllocateSubStructures(combstr,nalloc);
	    }
	}
     }
     ntits = 0;
     *backb = 0;
     if (str1 != NULL) if (COO[*str1]->backb) *backb = 1;
     if (COO[str2]->backb) *backb = 1;
     empty_model(istruct,1);
     COO[istruct]->pdbcode = NULL;
     COO[istruct]->hetatm.NHetAtm = 0;

}

void CombineStructs(str2,notaligned,new_struct)
int str2;
int notaligned;
int new_struct;
{

  int i,j,k,l,nlines,ires,pdb1,pdb2,nchstr1,str1;
  int iat1,iat2,itot,nato1,nato2,nres1,nres2,nhet1,nhet2;
  double tmp1[3],tmp2[3],tmp3[3],rad1,rad2,vl;
  COOSTRU *xyzpn;
  COOSTRU *xyzp1;
  COOSTRU *xyzp2;
  CALFSTRU *calf1;
  CALFSTRU *calf2;
  CALFSTRU *calfn;

  if (new_struct) New_Entry(&str1,str2,0,0);

  if (new_struct) {
    xyzp1   = &COO[str1]->coo;
    xyzp2   = &COO[str2]->coo;
    xyzpn   = xyzp;
    calf1   = &COO[str1]->calf;
    calf2   = &COO[str2]->calf;
    calfn   = calfptr;
    pdb1    =  COO[str1]->pdb;
    pdb2    =  COO[str2]->pdb;

    iat1    = COO[str1]->iatoms;
    iat2    = COO[str2]->iatoms;
  } else {

    xyzp1   = xyzp;
    xyzp2   = &COO[str2]->coo;
    xyzpn   = xyzp;
    calf1   = calfptr;
    calf2   = &COO[str2]->calf;
    pdb1    =  *ipdbon;
    pdb2    =  COO[str2]->pdb;

    iat1    = *xyzp->iatoms;
    iat2    = COO[str2]->iatoms;
  }

  if (notaligned) {
     COOt = xyzp2->coo;
  }


    nato1 = iat1;
    for (j=iat1-1; j >= 0; j--) {
 	if (xyzp1->ianz[j] != 100) {
		nato1 = j+1;
		break;
	}
    }

    nato2 = iat2;
    for (j=iat2-1; j >= 0; j--) {
 	if (xyzp2->ianz[j] != 100) {
		nato2 = j+1;
		break;
	}
    }

    if (pdb1) {
	nres1   = COO[str1]->calf.ncalf;
	nhet1   = COO[str1]->hetatm.NHetAtm-4;
    } else {
	nres1   = 0;
	nhet1   = 1;
    }

    if (pdb2) {
	nres2   = COO[str2]->calf.ncalf;
	nhet2   = COO[str2]->hetatm.NHetAtm-4;
    } else {
	nres2   = 0;
	nhet2   = 1;
    }

    itot = iat1 + iat2;
  
    if (itot > *xyzp->mxnat - 500) {
	itot = itot + 500;
#if defined(VMS) || defined(UNDERSC)
	allcoo(&itot,&ZERO);
#else
#ifdef CRAY
	ALLCOO(&itot,&ZERO);
#else
	allcoo_(&itot,&ZERO);
#endif
#endif
    }

    if (nres1 <= 0 && nres2 <= 0 && notaligned) {
#if defined(VMS) || defined(UNDERSC)
	cntvec(
#else

#ifdef CRAY
	CNTVEC(
#else
	cntvec_(
#endif
#endif
	tmp1,xyzp1->coo,xyzp1->ianz,xyzp1->iatoms);
	getrad(tmp1,xyzp1->coo,xyzp1->iatoms,&rad1);
#if defined(VMS) || defined(UNDERSC)
	cntvec(
#else

#ifdef CRAY
	CNTVEC(
#else
	cntvec_(
#endif
#endif
	tmp2,COOt,xyzp2->ianz,xyzp2->iatoms);
	getrad(tmp2,COOt,xyzp2->iatoms,&rad2);
	for (j=0; j<3; j++) tmp3[j] = tmp2[j] - tmp1[j];
	vl = dveclen(tmp3);
	if (vl > rad1 + 5.0) {
	   if (!DoCan(event.xbutton.x_root,event.xbutton.y_root,
	      "Molecules very far apart !.\n Move to visible range ?",1)) {
		for (j=0; j<3; j++) {
		    tmp3[j] = -tmp3[j]*(rad1+rad2)/vl - tmp3[j];
		}
		for (j=0; j< *xyzp2->iatoms ; j++) 
#if defined(VMS) || defined(UNDERSC)
		   trcoo(tmp3,&COOt[j*3]);
#else

#ifdef CRAY
		   TRCOO(tmp3,&COOt[j*3]);
#else
		   trcoo_(tmp3,&COOt[j*3]);
#endif
#endif
#if defined(VMS) || defined(UNDERSC)
		cntvec(
#else

#ifdef CRAY
		CNTVEC(
#else
		cntvec_(
#endif
#endif
		   tmp2,COOt,xyzp2->ianz,xyzp2->iatoms);
		for (j=0; j<3; j++) {
		    rotptr->t[j] = (tmp1[j] + tmp2[j])/2.0;
		}
	
	   }
	}
    }

    for (j=0; j < iat1; j++) {
	xyzpn->iatclr[j] = xyzp1->iatclr[j];

	xyzpn->iresid[j] = xyzp1->iresid[j];
	xyzpn->iaton[j] = xyzp1->iaton[j];
	xyzpn->ianz[j] = xyzp1->ianz[j];
	xyzpn->ipdbt[j]  = xyzp1->ipdbt[j];
	xyzpn->ityp[j]   = xyzp1->ityp[j];
	xyzpn->qat[j]    = xyzp1->qat[j];
	for (k=0; k < 3; k++) 
	   xyzpn->coo[j*3+k] = xyzp1->coo[j*3+k];
	for (k=0; k < xyzp1->iconn[j*(MXCON+1)]; k++) {
	   xyzpn->iconn[j*(MXCON+1)+k+1] = 
		xyzp1->iconn[j*(MXCON+1)+k+1];
	}
	xyzpn->iconn[j*(MXCON+1)] = xyzp1->iconn[j*(MXCON+1)];
    }

/* 
    MOVE FAKE ATOMS for secundary structure visualisation xwindows 
    of the FIRST structure.
    They only should have connections amongst themselves 
*/

    nlines = nato2;

    for (j=0; j < iat1; j++) xyzpn->iatclr[j] = STR1COL + 1;

    for (j=iat1-1; j >= nato1; j--) {
	xyzpn->iatclr[j+nlines] = xyzp1->iatclr[j];
	xyzpn->iresid[j+nlines] = xyzp1->iresid[j];
	xyzpn->iaton[j+nlines] = xyzp1->iaton[j];
	xyzpn->ianz[j+nlines] = xyzp1->ianz[j];
	for (k=0; k < 3; k++) 
	   xyzpn->coo[(j+nlines)*3+k] = xyzp1->coo[j*3+k];
	for (k=0; k < xyzp1->iconn[j*(MXCON+1)]; k++) {
	   xyzpn->iconn[(j+nlines)*(MXCON+1)+k+1] = 
		xyzp1->iconn[j*(MXCON+1)+k+1] + nlines;
	}
	xyzpn->iconn[(j+nlines)*(MXCON+1)] = xyzp1->iconn[j*(MXCON+1)];
    }

/* 
   COPY FAKE ATOMS for secundary structure visualisation xwindows 
   of the SECOND structure TO the FIRST structure.
*/

    nlines = iat1;
    for (j=nato2; j < iat2; j++) {
	xyzpn->iatclr[j+nlines] = xyzp2->iatclr[j];
	xyzpn->iresid[j+nlines] = xyzp2->iresid[j];
	xyzpn->iaton[j+nlines] = xyzp2->iaton[j];
	xyzpn->ianz[j+nlines] = xyzp2->ianz[j];
	for (k=0; k < 3; k++) 
	   xyzpn->coo[(j+nlines)*3+k] = COOt[j*3+k];
	for (k=0; k < xyzp2->iconn[j*(MXCON+1)]; k++) {
	   xyzpn->iconn[(j+nlines)*(MXCON+1)+k+1] = 
		xyzp2->iconn[j*(MXCON+1)+k+1] + nlines;
	}
	xyzpn->iconn[(j+nlines)*(MXCON+1)] = xyzp2->iconn[j*(MXCON+1)];
    }

/* 
   COPY REAL ATOMS of the SECOND structure TO the FIRST structure.
*/
    nlines = nato1;
    for (j=0; j < nato2; j++) {
	ires = xyzp2->iresid[j];
	if (pdb1 && pdb2) {
	   if (ires > 0) {
		xyzpn->iresid[j+nlines] = nres1 + xyzp2->iresid[j];
	   } else if (ires < -3) {
		xyzpn->iresid[j+nlines] = xyzp2->iresid[j] - (nhet1);
	   } else {
		xyzpn->iresid[j+nlines] = xyzp2->iresid[j];
   	   }
	} else {
	   if (pdb1) {
		xyzpn->iresid[j+nlines] = -COO[str1]->hetatm.NHetAtm;
	   } else {
		xyzpn->iresid[j+nlines] = -4;
	   }
	}

/*
	xyzpn->iatclr[j+nlines] = xyzp2->iatclr[j];
*/
	xyzpn->iatclr[j+nlines] = STR2COL + 1;
	xyzpn->iaton[j+nlines]  = xyzp2->iaton[j];
	xyzpn->ianz[j+nlines]   = xyzp2->ianz[j];
	xyzpn->ipdbt[j+nlines]  = xyzp2->ipdbt[j];
	xyzpn->ityp[j+nlines]   = xyzp2->ityp[j];
	xyzpn->qat[j+nlines]    = xyzp2->qat[j];

	for (k=0; k < 3; k++) 
	   xyzpn->coo[(j+nlines)*3+k] = COOt[j*3+k];
	for (k=0; k < xyzp2->iconn[j*(MXCON+1)]; k++) {
	   i = xyzp2->iconn[j*(MXCON+1)+k+1];
	   if (i >= 0) {
	      xyzpn->iconn[(j+nlines)*(MXCON+1)+k+1] = 
		xyzp2->iconn[j*(MXCON+1)+k+1] + nlines;
	   } else {
	      xyzpn->iconn[(j+nlines)*(MXCON+1)+k+1] = 
		xyzp2->iconn[j*(MXCON+1)+k+1] - nlines;
	   }
	}
	xyzpn->iconn[(j+nlines)*(MXCON+1)] = xyzp2->iconn[j*(MXCON+1)];
    }
    *natorg = nato1 + nato2;
    *xyzp->iatoms = iat1 + iat2;
   
    calfn->ncalf = nres1 + nres2;
    for (i=0; i < nres1; i++) {
	   calfn->reson[i] = calf1->reson[i];
	   calfn->isal[i] = calf1->isal[i];
	   calfn->irsnr[i] = calf1->irsnr[i];
	   calfn->iamino[i] = calf1->iamino[i];
	   calfn->iams[i] = 0;
           for (j=0; j < 6; j++) 
		calfn->icalf[i][j] = calf1->icalf[i][j];
    }
    for (i=0; i < nres2; i++) {
	if (nres1+i < NUMCAL) {
	   calfn->reson[nres1+i] = calf2->reson[i];
	   calfn->isal[nres1+i] = calf2->isal[i];
	   calfn->irsnr[nres1+i] = calf2->irsnr[i] + nres1;
	   calfn->iamino[nres1+i] = calf2->iamino[i];
	   calfn->iams[nres1+i] = 0;
           for (j=0; j < 6; j++) 
		calfn->icalf[nres1+i][j] = calf2->icalf[i][j] + nato1;
	}
    }
    if (calfn->ncalf >= NUMCAL) calfn->ncalf = NUMCAL-1;

    for (i=0; i < calf1->nchain; i++) {
	calfn->ianf[i] = calf1->ianf[i];
	calfn->islu[i] = calf1->islu[i];
    }
    for (i=0; i < calf2->nchain; i++) {
	calfn->ianf[calf1->nchain+i] = calf2->ianf[i] + nres1;
	calfn->islu[calf1->nchain+i] = calf2->islu[i] + nres1;
    }
    nchstr1 = calf1->nchain;
    calfn->nchain = calf1->nchain + calf2->nchain;

    if (pdb1 && pdb2) {
	for (j=0; j<nhet1+4; j++) {
	   if (j < MXHETA) {
	      if (new_struct) {
		int n;
		hetptr.Allocated[j] = 1;
		n = strlen(COO[str1]->hetatm.HetAtm[j]);
		hetptr.HetAtm[j] = (char *) malloc(n+1);
		strcpy(hetptr.HetAtm[j],COO[str1]->hetatm.HetAtm[j]);
	      } else {
	        hetptr.Allocated[j] = COO[str1]->hetatm.Allocated[j];
	        hetptr.HetAtm[j] = COO[str1]->hetatm.HetAtm[j];
	      }
	      calfn->ihet[j] = calf1->ihet[j];
	   }
	}
	hetptr.NHetAtm = nhet1+4;
	for (j=0; j<nhet2; j++) {
	   if (hetptr.NHetAtm+j < MXHETA) {
	      if (new_struct) {
		int n;
		hetptr.Allocated[hetptr.NHetAtm+j] = 1;
		n = strlen(COO[str2]->hetatm.HetAtm[4+j]);
		hetptr.HetAtm[hetptr.NHetAtm+j] = (char *) malloc(n+1);
		strcpy(hetptr.HetAtm[hetptr.NHetAtm+j],
			COO[str2]->hetatm.HetAtm[4+j]);
	      } else {
	        hetptr.Allocated[hetptr.NHetAtm+j] = 
			COO[str2]->hetatm.Allocated[4+j];
	        hetptr.HetAtm[hetptr.NHetAtm+j] = COO[str2]->hetatm.HetAtm[4+j];
	      }
	      calfn->ihet[hetptr.NHetAtm+j] = calf2->ihet[4+j];
	   }
	}
	hetptr.NHetAtm = nhet1 + nhet2 + 4;
	if (hetptr.NHetAtm >= MXHETA) hetptr.NHetAtm = MXHETA-1;
	*ipdbon = 1; 

    } else {
	int n;

	hetptr.Allocated[hetptr.NHetAtm] = 0;
	n = strlen(COO[str2]->fname);
	hetptr.HetAtm[hetptr.NHetAtm] = (char *) malloc(n+1);
	hetptr.HetAtm[hetptr.NHetAtm] = COO[str2]->fname;
	calfn->ihet[hetptr.NHetAtm] = 1;

	if ( pdb1 || pdb2) {
	   hetptr.NHetAtm = nhet1 + 1 + 4;
	} else {
	   hetptr.NHetAtm++;
	}
    }

    alnptr->nalign = 2;
    alnptr->istst[0] = iat1;
    alnptr->istst[1] = iat2;
    alnptr->istres[0] = nres1;
    alnptr->istres[1] = calfn->ncalf;
    alnptr->istch[0] = nchstr1;
    alnptr->istch[1] = calfn->nchain;
    alnptr->istcol[0] = STR1COL;
    alnptr->istcol[1] = STR2COL;

#ifdef DOGL
    RibClear(istruct);
    NSurf[istruct] = 0;
#if defined(VMS) || defined(UNDERSC)
    ribgl(calfn->ianf,&calfn->nchain,&calfn->ncalf,xyzpn->iatoms);
    chkbck(&ONE);
#else
#ifdef CRAY
    RIBGL(calfn->ianf,&calfn->nchain,&calfn->ncalf,xyzpn->iatoms);
    CHKBCK(&ONE);
#else
    ribgl_(calfn->ianf,&calfn->nchain,&calfn->ncalf,xyzpn->iatoms);
    chkbck_(&ONE);
#endif
#endif

    SSdone[istruct] = 1;
    for (i=0; i<4; i++) 
	if (calfn->ihet[i]) sndon(i,0,0);

    ColorByStruct();
    ActualiseBackbone(0);
    dispsf();
#endif
    if (!notaligned) {
	if (COOt != NULL) free(COOt);
    } else {
	vl = dst_coo(xyzp1,xyzp2,nato1,nato2);
	fprintf(stderr,"RMSD %.3f\n",vl);
    }

}

void AddAtom(i,j,k,bl,alpha,dih,ires)
int i,j,k,ires;
double bl,alpha,dih;
{
	int iret;

#if defined(VMS) || defined(UNDERSC)
	atadd(&i,&j,&k,&ONE,&bl,&alpha,&dih,&iret,
#else
#ifdef CRAY
	ATADD(&i,&j,&k,&ONE,&bl,&alpha,&dih,&iret,
#else
	atadd_(&i,&j,&k,&ONE,&bl,&alpha,&dih,&iret,
#endif
#endif
	 xyzp->ianz,xyzp->iaton,xyzp->iatclr,xyzp->iconn,xyzp->iresid,
	 xyzp->ityp,xyzp->ipdbt,&calfptr->ncalf,calfptr->icalf,xyzp->coo);
	if (iret != 0 && iret < *xyzp->mxnat) 
 		xyzp->iresid[iret-1] = ires;
}

void LigandHydro(het)
int het;
{

  int i,j,k,l,nc,xc,ir,ix,iy,iz,size,j1,is,nsp2,ic0,ic1;
  int nat,fnd,istart,iend,itot;
  int ic[3];
  int *sp,*icn;
  float aret,da1,da2,da3;
  double bl,alpha,dih;
  int asel[6],anum,iret;

  size = *xyzp->mxnat;
  sp = (int *) malloc((sizeof i)*size);

  icn = (int *) malloc((sizeof i)*size*(MXCON+1));

  for (j=0; j < *xyzp->iatoms; j++)
     for (k=0; k < MXCON+1; k++)
	icn[k+j*(MXCON+1)] = xyzp->iconn[k+j*(MXCON+1)];

  for (j=0; j < *xyzp->iatoms; j++) {
     sp[j] = 0;
     j1 = j + 1;

/* Oxygen */

     if (xyzp->ianz[j] == 8) {

	for (k=0; k < 3; k++) ic[k] = -1;

	nc = icn[j*(MXCON+1)];

	if (nc == 1) {
	   for (k=0; k < nc; k++) 
		ic[k] = icn[j*(MXCON+1)+k+1];

	   ix = ic[0];
	   xc = icn[(ix-1)*(MXCON+1)];

	   if (xc > 0 && xc <= 4) {
		l = 0;
		for (k=0; k < xc; k++) {
		   iy = icn[(ix-1)*(MXCON+1)+k+1];
		   if (iy != j1) {
			ic[l] = iy;
			l++;
		   }
		}
		alpha = 0.0;
		for (k=0; k < l; k++) {
		   asel[0] = j1;
		   asel[1] = ix;
		   asel[2] = ic[k];
		   anum = 3;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
		   alpha = alpha + aret;
		}

		alpha = alpha / (double) l;

		da1 = ABS(alpha-109.47);
		da2 = ABS(alpha-120.0);

		if (da1 < da2) {
		   sp[j] = 3;

		   AddAtom(ic[0],ix,j1,1.090,109.47,180.0,xyzp->iresid[j]);

		} else {

		   sp[j] = 2;
		}
	   }

	} else if (nc == 2) {
	   sp[j] = 3;
	   
	}
     }

/* Carbon */

     if (xyzp->ianz[j] == 6) {
	ix = -1;
	iy = -1;
	for (k=0; k < 3; k++) ic[k] = -1;

	nc = icn[j*(MXCON+1)];
	if (nc <= 3) {
	   for (k=0; k < nc; k++) 
		ic[k] = icn[j*(MXCON+1)+k+1];

	}

	if (nc == 1) {

	    ix = ic[0];
	    xc = icn[(ix-1)*(MXCON+1)];

	    if (xc > 0 && xc <= 4) {
		l = 0;
		for (k=0; k < xc; k++) {
		   iy = icn[(ix-1)*(MXCON+1)+k+1];
		   if (iy != j1) {
			ic[l] = iy;
			l++;
		   }
		}
		alpha = 0.0;
		for (k=0; k < l; k++) {
		   asel[0] = j1;
		   asel[1] = ix;
		   asel[2] = ic[k];
		   anum = 3;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
		   alpha = alpha + aret;
		}

		alpha = alpha / (double) l;

		da1 = ABS(alpha-109.47);
		da2 = ABS(alpha-120.0);
		da3 = ABS(alpha-180.0);

/*
fprintf(stderr,"%d da1 %f da2 %f da3 %f l %d alpha %f\n",j1,da1,da2,da3,l,alpha);
*/

		if ((da1 < da2 && da1 < da3) || xc == 4) {
		   sp[j] = 3;

		   AddAtom(ic[0],ix,j1,1.090,109.47,180.0,xyzp->iresid[j]);
		   AddAtom(ic[0],ix,j1,1.090,109.47,60.0,xyzp->iresid[j]);
		   AddAtom(ic[0],ix,j1,1.090,109.47,-60.0,xyzp->iresid[j]);

		} else if (da2 < da1 && da2 < da3) {

		   sp[j] = 2;

/* defer adding hydrogens until second round */

		} else {

		   sp[j] = 1;

		   AddAtom(ic[0],ix,j1,1.090,179.9,0.0,xyzp->iresid[j]);

		}
	    }

        }

	if (nc == 2) {

/* calc angle */

	   asel[0] = ic[0];
	   asel[1] = j1;
	   asel[2] = ic[1];
	   anum = 3;

#if defined(VMS) || defined(UNDERSC)
	   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
	   TOMOLD(&aret,asel,&anum);
#else
	   tomold_(&aret,asel,&anum);
#endif
#endif
	   da1 = ABS(aret-109.47);
	   da2 = ABS(aret-120.0);
	   da3 = ABS(aret-180.0);
/*
 C, 2 connections:

 ang = 109.47 Sp3 => add 2 Hyd.
 ang = 120.0  Sp2 => add 1 Hyd.
 ang = 180.0  Sp  => add 0 Hyd.
*/

	   if (da1 < da2 && da1 < da3) {
		sp[j] = 3;

		AddAtom(ic[0],ic[1],j1,1.090,109.47,120.0,xyzp->iresid[j]);
		AddAtom(ic[0],ic[1],j1,1.090,109.47,-120.0,xyzp->iresid[j]);

	   } else if (da2 < da1 && da2 < da3) {

		sp[j] = 2;

/* defer adding hydrogens to second round */

	   } else {
		sp[j] = 1;
	   }
	}

	if (nc == 3) {

/* calc dihedral */

	   asel[0] = ic[0];
	   asel[1] = j+1;
	   asel[2] = ic[1];
	   asel[3] = ic[2];
	   anum = 4;

#if defined(VMS) || defined(UNDERSC)
	   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
	   TOMOLD(&aret,asel,&anum);
#else
	   tomold_(&aret,asel,&anum);
#endif
#endif

/*

 C, 3 connections:

 dih = 120.0  Sp3 => add 1 Hyd.
 dih = 180.0  Sp2 => add 0 Hyd.
*/

	   is = SIGN(aret);
	   aret = ABS(aret);
	   da1 = ABS(180.0 - aret);
	   da2 = ABS(120.0 - aret);
	   if (da1 < da2) {
		sp[j] = 2;
	   } else {
		sp[j] = 3;

		AddAtom(ic[0],ic[1],j1,1.090,109.47,is*120.0,xyzp->iresid[j]);
	   }
	}
     }
  }

/*
   Second round 
*/

  for (j=0; j < *xyzp->iatoms; j++) {
     j1 = j + 1;

     if (xyzp->ianz[j] == 8 && sp[j] == 2) {
	for (k=0; k < 3; k++) ic[k] = -1;

	nc = icn[j*(MXCON+1)];

	if (nc == 1) {
	   for (k=0; k < nc; k++) 
		ic[k] = icn[j*(MXCON+1)+k+1];

	   ix = ic[0];
	   xc = icn[(ix-1)*(MXCON+1)];

	   nsp2 = 0; if (sp[ix-1] == 2) nsp2 = 1;
	   if (xc > 0 && xc <= 4) {
		l = 0;
		for (k=0; k < xc; k++) {
		   iy = icn[(ix-1)*(MXCON+1)+k+1];
		   if (iy != j1) {
			if (sp[iy-1] == 2) nsp2++;
			ic[l] = iy;
			l++;
		   }
		}
		if (l == 2 && nsp2 == 3) {
		   sp[j] = 3;

		   AddAtom(ic[0],ix,j1,1.090,109.47,180.0,xyzp->iresid[j]);
		}
	    }
	}
     }

     if (xyzp->ianz[j] == 6 && sp[j] == 2) {
	ix = -1;
	iy = -1;
	for (k=0; k < 3; k++) ic[k] = -1;

	nc = icn[j*(MXCON+1)];
	if (nc <= 3) {
	   for (k=0; k < nc; k++) 
		ic[k] = icn[j*(MXCON+1)+k+1];

	}

	if (nc == 1) {

	    ix = ic[0];
	    xc = icn[(ix-1)*(MXCON+1)];

	    if (xc > 0 && xc <= 4) {
		l = 0;
		nsp2 = sp[ix-1];
		for (k=0; k < xc; k++) {
		   iy = icn[(ix-1)*(MXCON+1)+k+1];
		   if (iy != j1) {
			if (sp[iy-1] == 2) nsp2++;
			ic[l] = iy;
			l++;
		   }
		}
		alpha = 0.0;
		for (k=0; k < l; k++) {
		   asel[0] = j1;
		   asel[1] = ix;
		   asel[2] = ic[k];
		   anum = 3;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
		   alpha = alpha + aret;
		}

		alpha = alpha / (double) l;

		da1 = ABS(alpha-109.47);
		da2 = ABS(alpha-120.0);
		da3 = ABS(alpha-180.0);

		if (da2 < da1 && da2 < da3) {

		   if (nsp2 >= 2) {

			sp[j] = 3;

		        AddAtom(ic[0],ix,j1,1.090,109.47,180.0,
				xyzp->iresid[j]);
		        AddAtom(ic[0],ix,j1,1.090,109.47,60.0,
				xyzp->iresid[j]);
		        AddAtom(ic[0],ix,j1,1.090,109.47,-60.0,
				xyzp->iresid[j]);

		   } else {

			sp[j] = 2;

		        AddAtom(ic[0],ix,j1,1.090,120.0,0.0,
				xyzp->iresid[j]);
		        AddAtom(ic[0],ix,j1,1.090,120.0,180.0,
				xyzp->iresid[j]);

		   }

		}

	    }

        }

	if (nc == 2) {

/* calc angle */

	   asel[0] = ic[0];
	   asel[1] = j1;
	   asel[2] = ic[1];
	   anum = 3;

#if defined(VMS) || defined(UNDERSC)
	   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
	   TOMOLD(&aret,asel,&anum);
#else
	   tomold_(&aret,asel,&anum);
#endif
#endif
	   da1 = ABS(aret-109.47);
	   da2 = ABS(aret-120.0);
	   da3 = ABS(aret-180.0);
/*
 C, 2 connections:

 ang = 109.47 Sp3 => add 2 Hyd.
 ang = 120.0  Sp2 => add 1 Hyd.
 ang = 180.0  Sp  => add 0 Hyd.
*/

	   if (da2 < da1 && da2 < da3) {

	    ic0 = 1; ic1 = 1;
	    ix = ic[0];
	    iy = ic[1];

	    xc = icn[(ix-1)*(MXCON+1)];

	    if (xc > 0 && xc <= 3) {
		l = 0;
		nsp2 = sp[ix-1];
		for (k=0; k < xc; k++) {
		   iz = icn[(ix-1)*(MXCON+1)+k+1];
		   if (iz != j1) {
			if (sp[iz-1] == 2) nsp2++;
			ic[l] = iz;
			l++;
		   }
		}

		for (k=0; k < l; k++) {

		   asel[0] = ic[k];
		   asel[1] = ix;
		   asel[2] = j1;
		   asel[3] = iy;
		   anum = 4;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
		   da1 = ABS(aret-180.0);
		   da2 = ABS(aret-0.0);
		   if (da2 < da1) da1 = da2; 
		   if (da1 > 10.0) ic0 = 0;
		}

	    } else { 
		ic0 = 0;
	    }

	    xc = icn[(iy-1)*(MXCON+1)];

	    if (xc > 0 && xc <= 3) {
		l = 0;
		nsp2 = sp[iy-1];
		for (k=0; k < xc; k++) {
		   iz = icn[(iy-1)*(MXCON+1)+k+1];
		   if (iz != j1) {
			if (sp[iz-1] == 2) nsp2++;
			ic[l] = iz;
			l++;
		   }
		}

		for (k=0; k < l; k++) {

		   asel[0] = ic[k];
		   asel[1] = iy;
		   asel[2] = j1;
		   asel[3] = ix;
		   anum = 4;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
		   da1 = ABS(aret-180.0);
		   da2 = ABS(aret-0.0);
		   if (da2 < da1) da1 = da2; 
		   if (da1 > 10.0) ic1 = 0;
		}

	    } else { 
		ic1 = 0;
	    }

	    if (ic0 || ic1) {

		sp[j] = 2;

		AddAtom(ix,iy,j1,1.090,120.0,180.0,xyzp->iresid[j]);

	    } else {

		sp[j] = 3;

		AddAtom(ix,iy,j1,1.090,109.47,120.0,xyzp->iresid[j]);
		AddAtom(ix,iy,j1,1.090,109.47,-120.0,xyzp->iresid[j]);

	    }

	   }
	}

     }
  }

/*
   Third round 
*/

  for (j=0; j < *xyzp->iatoms; j++) {
     j1 = j + 1;

     if (xyzp->ianz[j] == 7) {

	ix = -1;
	iy = -1;
	for (k=0; k < 3; k++) ic[k] = -1;

	nc = icn[j*(MXCON+1)];
	if (nc <= 3) {
	   for (k=0; k < nc; k++) 
		ic[k] = icn[j*(MXCON+1)+k+1];

	}

	if (nc == 1) {

	    ix = ic[0];
	    xc = icn[(ix-1)*(MXCON+1)];

	    if (xc > 0 && xc <= 4) {
		l = 0;
		for (k=0; k < xc; k++) {
		   iy = icn[(ix-1)*(MXCON+1)+k+1];
		   if (iy != j1) {
			ic[l] = iy;
			l++;
		   }
		}
		alpha = 0.0;
		for (k=0; k < l; k++) {
		   asel[0] = j1;
		   asel[1] = ix;
		   asel[2] = ic[k];
		   anum = 3;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
		   alpha = alpha + aret;
		}

		alpha = alpha / (double) l;

		da1 = ABS(alpha-109.47);
		da2 = ABS(alpha-120.0);
		da3 = ABS(alpha-180.0);

		if ((da1 < da2 && da1 < da3) || xc == 4) {
		   sp[j] = 3;

		   AddAtom(ic[0],ix,j1,1.090,109.47,180.0,xyzp->iresid[j]);
		   AddAtom(ic[0],ix,j1,1.090,109.47,60.0,xyzp->iresid[j]);

		} else if (da2 < da1 && da2 < da3) {

		   sp[j] = 2;

		   AddAtom(ic[0],ix,j1,1.090,120.0,180.0,xyzp->iresid[j]);


		} else {

		   sp[j] = 1;


		}
	    }

        }

	if (nc == 2) {

/* calc angle */

	   asel[0] = ic[0];
	   asel[1] = j1;
	   asel[2] = ic[1];
	   anum = 3;

#if defined(VMS) || defined(UNDERSC)
	   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
	   TOMOLD(&aret,asel,&anum);
#else
	   tomold_(&aret,asel,&anum);
#endif
#endif
	   da1 = ABS(aret-109.47);
	   da2 = ABS(aret-120.0);
	   da3 = ABS(aret-180.0);
/*
 N, 2 connections:

 ang = 109.47 Sp3 => add 1 Hyd.
 ang = 120.0  Sp2 => add 0 Hyd.
 ang = 180.0  Sp  => add 0 Hyd.
*/

	   if (da1 < da2 && da1 < da3) {
		sp[j] = 3;

		AddAtom(ic[0],ic[1],j1,1.090,109.47,120.0,xyzp->iresid[j]);

	   } else if (da2 < da1 && da2 < da3) {

		sp[j] = 2;


	   } else {
		sp[j] = 1;
	   }
	}
     }
  }

  *zmptrp->ihaszm = 0;
  ZMEAA = 0;
  free(sp);
  free(icn);
}

#if defined(VMS) || defined(UNDERSC)
void chkmpi()
#else
#ifdef CRAY
void CHKMPI()
#else
void chkmpi_()
#endif
#endif
{
 FILE *pip;
 char line[256];
 char *p;
 char *pth;
 int ns = 10000;
 int ts;

#ifndef __CYGWIN__
 if ((pip = popen("/usr/bin/locate mpirun 2>&1","r")) ) {
	while ( fgets(line,sizeof line, pip) ) {
	   ts = strlen(line);
	   if ((p = strrchr(line, '/'))) {
		p++;
		if (strlen(p) == 7 && ts < ns ) {
		   if (strlen(line) < MAXCMD) {
			strcpy(mpicmd,line);
			if ((p = strrchr(mpicmd,'\n'))) *p = '\0';
			ns = ts;
		   }
		}
	   }
	}
	pclose(pip);
	strcpy(line," ");
	if (getexe(0,1,line)) {
	    hasmpi = 1;
	    strcpy(mpilib,mpicmd);
	    if ((p = strrchr(mpilib, '/'))) {
		p--;p--;p--;
		*p= '\0';
		strcat(mpilib,"lib");
		pth = getenv("LD_LIBRARY_PATH");
		if (pth != NULL) {
		   strcpy(npth,pth);
		   strcat(npth,":");
		   strcat(npth,mpilib);
		}

	    }

	    if ((pip = popen("grep -c processor /proc/cpuinfo","r")) ) {
		while ( fgets(line,sizeof line, pip) ) {
		    maxproc = atoi(line);
		    useproc = maxproc;
		}
		pclose(pip);
	    }
	}
 }
#endif

 if (hasmpi) {
	ntnkb++;
	ntnkb++;
 }

}

void UpdHet2(nlin)
int nlin;
{
   int i,j,ir;

   for (i=0; i < hetlab.NHetLab; i++ )  
	hetlab.iat[i] = hetlab.iat[i] + nlin;

}

void UpdHet()
{
   int i,j,ir;
   HETLABSTRU thetlab;

   thetlab.NHetLab = 0;
   for (j=0; j<*zmptrp->nz; j++) {
	for (i=0; i < hetlab.NHetLab; i++ ) {
	   if (hetlab.iat[i] == zmptrp->imap[j]) {
		thetlab.iat[thetlab.NHetLab] = j+1;
		thetlab.HetLab[thetlab.NHetLab] = hetlab.HetLab[i];
		thetlab.NHetLab++;
	   }
	}
   }
   hetlab = thetlab;

}

#if defined(VMS) || defined(UNDERSC)
void gethet(int *iat,int *status,char *str)
#else
#ifdef CRAY
void GETHET(int *iat,int *status,char *str)
#else
void gethet_(int *iat,int *status,char *str)
#endif
#endif
{
   int i,n;

   *status = 0;
   if (clfstrptr->ihashz) {
	for (i=0; i < hetlab.NHetLab; i++ ) {
	   if (hetlab.iat[i] == *iat) {
		n = strlen(hetlab.HetLab[i]);
		strncpy(str,hetlab.HetLab[i],n);
		*status = 1;
	   }
	}
   }
    
}

int DoWGET(wwwstr,argm,retstr)
char *wwwstr;
char *argm;
char *retstr;
{
   char cmdfil[500];
   char cmdtmp[500];
   char fn1[] = "/tmp/fileXXXXXX";
   char fn2[] = "/tmp/fileXXXXXX";
   char *wget = "wget";
   char errstr[500] = "";
   int i,istat,igoogle,istat1,pid;
   char *p;
   FILE *out;

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   istat = 1;
   igoogle = 1;

#ifdef __CYGWIN__
   getusr(retstr);
   sprintf(cmdtmp,"%s%s.exe",exepath[0],wget);
   spaesc(cmdtmp);
#else
#ifdef DARWIN
   sprintf(cmdtmp,"%s%s",exepath[0],wget);
   if (!(access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp))) {
      strcpy(cmdtmp,wget);
   }
#else
   strcpy(cmdtmp,wget);
#endif
   strcpy(retstr,mktemp(fn1));
   strcpy(errstr,mktemp(fn2));
#endif


#ifdef __CYGWIN__

   if ((access(cmdtmp,F_OK) == 0 && !isdir(cmdtmp))) {

	if (p = strstr(cmdtmp,".exe")) p[0] = '\0';

	 strcpy(cmdfil,wwwstr);
	 strcat(cmdfil,argm);

	 pid = vfork();
	 switch(pid) {
	 case -1:
          fprintf(stderr,"Couldnt Fork\n");
          break;
	 case 0:       /*child */
	  execlp(cmdtmp,"wget",cmdfil,"-O",retstr,NULL);
	  _exit(0);
          break;
	 default:      /*parent*/
	  wait(&pid);
          break;
	}
	istat = 0;
   } else {
	fprintf(stderr,"%s not found\n",cmdtmp);
   }
#else
   strcat(cmdtmp," \"");
   strcat(cmdtmp,wwwstr);
   if (strstr(cmdtmp,"google") == NULL) igoogle = 0;
   if (argm != NULL) {
	strcat(cmdtmp,argm);
   }
   if (strstr(wwwstr,"cml")) {
	strcat(cmdtmp,".cml");
   } else if (strstr(wwwstr,"coordinates")) {
	strcat(cmdtmp,".ccp4");
	igoogle = 1;
   } else {
	if (!igoogle) strcat(cmdtmp,".ent.gz");
   }
   strcat(cmdtmp,"\" -O ");
   strcat(cmdtmp,retstr);
   if (!igoogle) strcat(cmdtmp,".gz");
   strcat(cmdtmp," 2> ");
   strcat(cmdtmp,errstr);

   fprintf(stderr,"Dowget: %s\n",cmdtmp);

   istat = system(cmdtmp);

   istat = 1;
   out = fopen(errstr,"r");
   if (out != NULL) {
	while (fgets(cmdtmp,MAXCMD,out) != NULL) {
	   if (strstr(cmdtmp,"connected") != NULL) {
		istat = 0;
	   }
	   if (strstr(cmdtmp,"No such file") != NULL) {
		istat = 1;
	   }
	}
	fclose(out);
   }

   if (!igoogle && !istat) {
      strcpy(cmdtmp,"gunzip ");
      strcat(cmdtmp,retstr);
      strcat(cmdtmp,".gz");
      istat1 = system(cmdtmp);
   }

#endif

#if defined(VMS) || defined(UNDERSC)
   curs(&ZERO);
#else
#ifdef CRAY
   CURS(&ZERO);
#else
   curs_(&ZERO);
#endif
#endif
   return(istat);

}

int CheckWGET()
{
   char *wwwstr = "http://www.google.com/index.html";
   char retstr[500] = "";
   int status;

   if (!hasWGET) {
        status = DoWGET(wwwstr,"",retstr);
	if (!status) {
	    hasWGET = 1;
	} else {
	    fprintf(stderr,"\nWARNING:\nThe standard HETATM hydrogen adding routine,\ndepends on the program \"wget\".\nYou can download wget from : http://ftp.gnu.org/gnu/wget/\n");

	}
   } else {
	status = 0;
   }
   
   return(status);

}

void GetPDBWWW(het,retstr)
char *het;
char *retstr;
{
//   char *wwwstr = "http://www.rcsb.org/pdb/downloadFile.do?fileFormat=pdb&compression=NO&structureId=";
   char *wwwstr = "ftp://ftp.wwpdb.org/pub/pdb/data/structures/all/pdb/pdb";

   DoWGET(wwwstr,het,retstr);
}

int PDBquery(het)
char *het;
{
   char *strid, *tmpid;
   FILE *pout;
   char line[MAXCMD];
   int i,ret=0;

   char *wwwstr = "http://www.rcsb.org/pdb/search/navbarsearch.do?inputQuickSearch=";

   if (npdbres > 0) {
	for (i=0; i < npdbres; i++) 
		free(pdbres[i]);
   }

   DoWGET(wwwstr,het,resfil);

   npdbres = 0;
  
   pout = fopen(resfil,"r");
   if (pout != NULL) {
	while (fgets(line,MAXCMD,pout) != NULL) { 
	   strid = strstr(line,"downloadFile");
	   if (strid != NULL) {
		strid = strstr(line,"structureId=");
	   	if (strid != NULL) {
		   tmpid = (char *) malloc(sizeof(char)*(4+1));
		   strncpy(tmpid,strid+12,4);
		   tmpid[4] = '\0';
		   pdbres[npdbres] = tmpid;
		   if (npdbres < MAXRES) {
			npdbres++;
		   } else {
			break;
		   }
		}
	   }
	}
	fclose(pout);
	ret = 1;
   }

/*
   for (i=0; i < npdbres; i++) 
	fprintf(stderr,"PDBID: %s\n",pdbres[i]);
*/

   RedrawSRCH();
   return(ret);
}

int PDBentry(het)
char *het;
{
   char *strid, *tmpid;
   FILE *pout;
   char line[MAXCMD];
   int i,fnd=0,ret=0;

   strcpy(strname,"structureId=");
   strcat(strname,het);

   pout = fopen(resfil,"r");
   if (pout != NULL) {
	while (fgets(line,MAXCMD,pout) != NULL) { 
	   strid = strstr(line,"qrb_title");
	   if (strid != NULL) {
		strid = strstr(line,strname);
	   	if (strid != NULL) {
		   fgets(line,MAXCMD,pout);
		   fgets(line,MAXCMD,pout);
		   strid = strchr(line,'\n');
		   if (strid != NULL) strid[0] = '\0';
		   for (tmpid = line; *tmpid == '\t'; tmpid++);
		   strcpy(qrb_title,tmpid);
		   /*fprintf(stderr,"title: %s\n",qrb_title);*/
		   fnd = 1;
		}
	   }
	   if (fnd) {
	        strid = strstr(line," Organism: ");
	   	if (strid != NULL) {
		   fgets(line,MAXCMD,pout);
		   fgets(line,MAXCMD,pout);
		   fgets(line,MAXCMD,pout);
		   fgets(line,MAXCMD,pout);
		   fgets(line,MAXCMD,pout);
		   tmpid = strchr(line,'>'); 
		   if (tmpid != NULL) {
			tmpid++;
			strid = strchr(tmpid,'<'); 
			if (strid != NULL) {
			   i = (int) (strid - tmpid);
		   	   strncpy(organism,tmpid,i);
			   organism[i] = '\0';
			   /*fprintf(stderr,"org: %s\n",organism);*/
			   break;
			}
		   }
		}
	   }
	}
	fclose(pout);
	ret = 1;
   }
   RedrawSRCH();
   return(ret);
}

int GetOMAPWWW(het,retstr)
char *het;
char *retstr;
{
   struct stat filestat;
   char *wwwstr = "http://eds.bmc.uu.se/cgi-bin/eds/gen_zip.pl?pdbCode=";
   char wwwstr2[MAXSTRLEN];
   int pid,ist;

   unsetenv("TMP");
   unsetenv("TEMP");
   unsetenv("TMPDIR");

   sprintf(wwwstr2,"http://www.ebi.ac.uk/pdbe/coordinates/files/%s",het);

   DoWGET(wwwstr2,"",retstr);

#ifdef __CYGWIN__
	    sprintf(stemp,"%s/%s.omap",het,het);
	    pid = vfork();
	    switch(pid) {
	    case -1:
	 	fprintf(stderr,"Couldnt Fork\n");
		break;
	    case 0:	/*child */
		execlp("tar","tar","-zxvf",retstr,stemp,
			"--strip-components","1",NULL);
		_exit(0);
		break;
	    default:	/*parent*/
		wait(&pid);
		break;
	    }
#else
   stat(retstr,&filestat);

   if (filestat.st_size) {

#endif
	    sprintf(wwwstr2,"./%s.ccp4",het);
	    ist = OSCopyFile(retstr,wwwstr2);
	    *Sinct = 585; *Snstr = 11;
	    cpstr(wwwstr2,Sstr,strlen(wwwstr2));
	    return(1);

#ifndef __CYGWIN__
   } else {
	DoCan(event.xbutton.x_root, event.xbutton.y_root,
	"No CCP4 file available.\nCheck at http://www.ebi.ac.uk/pdbe/coordinates/files/",0);
   }
#else
   }
#endif
   return(0);
}

void LigandQ(ihet)
int ihet;
{
   FILE *out;
   char cmdtmp[500] = "";
   char cmdfil[500];
   char *spntr;
   char *het;
   int i,j,istat,aihet,ifnd;
   int fnd,iend,itch=-15;

   char *wwwtotq = "ftp://ftp.ebi.ac.uk/pub/databases/msd/pdbechem/files/cml/";

   aihet = abs(ihet);

   if (aihet >= MXHETA) {
	fprintf(stderr,"\nLigandQ: hetatm residue outside array bounds\n\n");
	return;
   }

   fnd = 0;
   iend = -1;

   for (j=0; j < *xyzp->iatoms; j++) {
	if (xyzp->iresid[j] == ihet) {
	   if (!fnd) {
	      fnd = 1;
	   }
	   iend = j;
	}
   }

   if (iend == -1 ) return;

   het = (char *) malloc(80);


   strcpy(het,hetptr.HetAtm[aihet]);

   het[3] = '\0';

   fprintf(stderr,"\nRetrieving Ligand Charge from PDBeChem\n\n");

   istat = DoWGET(wwwtotq,het,cmdtmp);

   ifnd = 0;

   out = fopen(cmdtmp,"r");

   if (out != NULL) {
	while (fgets(cmdfil,MAXCMD,out) != NULL) {
	   if (strstr(cmdfil,"formalCharge") != NULL) {
		spntr = strstr(cmdfil,"formalCharge=\"");
		if (spntr) {
		    spntr = spntr + 14;
		    sscanf(spntr,"%d",&itch);
		}
		ifnd = 1;
		break;
	   }
	}
	fclose(out);
	if (ifnd) {
	   fprintf(stderr,"formalCharge %d\n",itch);
	   clfstrptr->ihetq[aihet] = itch;
	   clfstrptr->ihqset[aihet] = 1;
	} else {
	   fprintf(stderr,"NO formalCharge found\n");
	}
   }
}
/* Ligand2Amino NOT used */

int Ligand2Amino(ihet)
int ihet;
{
   int i,j,k,nc,iac;

   iac = 0;
   for (j=0; j < *xyzp->iatoms; j++) {

	if (xyzp->iresid[j] == ihet) {

	  nc = xyzp->iconn[j*(MXCON+1)];

	  for (k=0; k < nc; k++) {
		i = xyzp->iconn[j*(MXCON+1)+k+1];

		if (i > 0) if (xyzp->iresid[i] != ihet) iac++;
	  }
	}
    }
    return(iac);
}

int CheckHydro(ihet)
int ihet;
{
   int i,j,inoth,ih,aihet;

   inoth = 0; ih = 0;

   for (j=0; j < *xyzp->iatoms; j++) {
	if (xyzp->iresid[j] == ihet) {
	    if (xyzp->ianz[j] == 1) ih++;
	    else inoth++;
	}
   }

   aihet = abs(ihet);
   if (((float) ih/(float) inoth) > 0.2) clfstrptr->ihhadd[aihet] = 1;

   return(ih);
}

/*
- HEM:
  CAC 1*H (HAC) is added
  CAB 1*H (HAB) is added
  O2A 1*H (H2A) we choose NOT to add it
  O2B 1*H (H2B) we choose NOT to add it

  Discription HEM should include 2H's for CAB,CAC. It does not, This means
  the connections with amino acids are taken into account.

  discription HEM includes Fe (probably Fe2+, offsets 2*COO- charges:
  total Neutral, which is the initial formal charge given. But
  actually it should be 2+, because the description uses 2*COOH).

  Message 1: do NOT subtract because of connections with amino acids.
  Message 2: exclude FE from partial charge calculation, and set q(FE)=+2
*/

int isPO4(iat)
int iat;
{
    int xc,io,icns,k,l,la;

    if (xyzp->ianz[iat] != 15) return 0;
    xc = xyzp->iconn[iat*(MXCON+1)];

    io = 0;
    icns = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8) io++;
	   if (xyzp->ianz[la-1] == 6 || xyzp->ianz[la-1] == 7 || xyzp->ianz[la-1] >= 16) icns++;
	}
    }

    if (io == 4 || (io+icns == 4 && io >= 2) ) return 1;
    return 0;
}

int isCOO(iat)
int iat;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (xyzp->ianz[iat] != 6) return 0;

    io = 0;
    ic = 0;
    ih = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8) io++;
	   if (xyzp->ianz[la-1] == 6) ic++;
	   if (xyzp->ianz[la-1] == 1) ih++;
	}
    }

    if (io == 2 && ic == 1 && ih == 0) return 1;
    return 0;
}

int isBH4(iat)
int iat;
{
    int xc,io,ic,is,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (xyzp->ianz[iat] != 5) return 0;

    io = 0;
    ic = 0;
    is = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8) io++;
	   if (xyzp->ianz[la-1] == 6) ic++;
	   if (xyzp->ianz[la-1] == 16) is++;
	}
    }

    if (io + ic + is == 4) return 1;
    return 0;
}

int TertN(iat,con)
int iat;
int *con;
{
    int xc,i,io,ic,ich,ir,k,l,la,iout,iat1;

    ic = 0; ich = 0;
    xc = xyzp->iconn[iat*(MXCON+1)];
    ir = xyzp->iresid[iat];
    iat1 = iat + 1;
    iout = 0;
    
#if defined(VMS) || defined(UNDERSC)
    getrng(&iat1,&iout,xyzp->ianz,xyzp->iconn);
#else
#ifdef CRAY
    GETRNG(&iat1,&iout,xyzp->ianz,xyzp->iconn);
#else
    getrng_(&iat1,&iout,xyzp->ianz,xyzp->iconn);
#endif
#endif

    if (iout) return 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 6) {
		if (ic < 3) con[ic] = la;
		ic++;
	   }
	   if (xyzp->ianz[la-1] == 1) ich++;
	}
    }
    if (ic == 3 && ! (ich == 1)) return 1;
    return 0;
}

int isit_metal(ian)
int ian;
{
  int k;

  for (k=0; k < MEXCL; k++) {
	if (ian == mets->ianexc[k]) return 1;
  }

  return 0;
}
 
void LigandHydroPBE(ihet)
int ihet;
{
   FILE *out;
   char cmdtmp[500];
   char cmdfil[500];
   char chemid[10];
   char chemidOld[10] = "-1";
   char *spntr;
   char *het;
   char *htmp;
   double angles3[3] = {180.0,60.0,-60.0};
   double angles3a[2] = {120.0,-120.0};
   double angles2[3] = {0.0,180.0};
   double v[3];
   int ic[MXCON];
   int ice[MXCON];
   int mce[MXCON];
   int con[3];
   int i,j,k,l,l0,j1,k0,la,lanz,n,np,is,xc,ix,iy,idum,size,npdbe,hasH,aihet;
   int *sp, *nh, *ian, *ifl, *noth;
   int imode,log,nc,nce,nmce,fnd,iend,natoms,istat,itch=0,iac,notu,nht,ir,lr;
   float aret;
   int asel[6],anum;
   char **hetz;
   char *strp;
   char *wwwstr = "ftp://ftp.ebi.ac.uk/pub/databases/msd/pdbechem/files/cml/";
   aihet = abs(ihet);

   if (aihet >= MXHETA) {
	fprintf(stderr,"\nLigandHydroPBE: hetatm residue outside array bounds\n\n");
	return;
   }

   fnd = 0;
   iend = -1;
   imode = 1;

   for (j=0; j < *xyzp->iatoms; j++) {
	if (xyzp->iresid[j] == ihet) {
	   if (!fnd) {
	      fnd = 1;
	   }
	   iend = j;
	}
   }

   if (iend == -1 ) return;

   size = MXHETLAB;

   sp   = (int *) malloc((sizeof i)*size);
   nh   = (int *) malloc((sizeof i)*size);
   noth = (int *) malloc((sizeof i)*size);
   ifl  = (int *) malloc((sizeof i)*size);
   hetz = (char **) malloc((sizeof *hetz)*size);

   for (i=0; i < size; i++) {
	nh[i] = 0; noth[i] = -1; sp[i] = 0; ifl[i] = 0; hetz[i] = NULL;
   }

   het = (char *) malloc(80);
   strp = hetptr.HetAtm[aihet];
   if (strp[0] == ' ') strp++;
   strcpy(het,strp);
   het[3] = '\0';

   if (!HetTmp.init) iniHetTmp();
   ChkHetCoo(aihet);

   fprintf(stderr,"\nRetrieving Ligand information from PDBeChem\n\n");

   iac = Ligand2Amino(ihet);

   sprintf(cmdtmp,"%s/plush",exepath[0]);
   if (isdir(cmdtmp)) {
      sprintf(cmdtmp,"%s/plush/%s",exepath[0],het);
      imode = 0;
   } else {
      istat = DoWGET(wwwstr,het,cmdtmp);
      imode = 1;
   }

   out = fopen(cmdtmp,"r");

   npdbe = 0;
   if (out != NULL) {
	while (fgets(cmdfil,MAXCMD,out) != NULL) {
	   if (imode) {
		if (strstr(cmdfil,"formalCharge") != NULL) {
		   spntr = strstr(cmdfil,"formalCharge=\"");
		   if (spntr) {
		    spntr = spntr + 14;
		    sscanf(spntr,"%d",&itch);
		   }
		   break;
		}
	   } else {
		if (strstr(cmdfil,"Charge") != NULL) {
		   spntr = strstr(cmdfil,"Charge=\"");
		   if (spntr) {
		    spntr = spntr + 8;
		    sscanf(spntr,"%d",&itch);
		   }
		   break;
		}
	   }
	}
	fprintf(stderr,"formalCharge %d\n",itch);
	clfstrptr->ihetq[aihet] = itch;
	clfstrptr->ihqset[aihet] = 1;


   	if (imode) {
	   while (fgets(cmdfil,MAXCMD,out) != NULL) {
		if (strstr(cmdfil,"atomArray") != NULL) break;
	   } 
	}
	while (fgets(cmdfil,MAXCMD,out) != NULL) {

	    if (imode) {

		   if (strstr(cmdfil,"atom id=") != NULL) {
			spntr = strstr(cmdfil,"atom id=\"");
			if (spntr) {
			    /*spntr = spntr + 3;*/
			    spntr = spntr + 9;
		   	    sscanf(spntr,"%[^\"]",chemid);

			    if (strcmp(chemidOld,"-1") == 0) {

				strcpy(chemidOld,chemid);
				hetz[0] = (char *) malloc(strlen(chemid)+1);
				strcpy(hetz[0],chemid);

			    } else if (strcmp(chemid,chemidOld) != 0) {

				strcpy(chemidOld,chemid);
				npdbe++;
				hetz[npdbe] = 
					(char *) malloc(strlen(chemid)+1);
				strcpy(hetz[npdbe],chemid);

			    }

			    spntr = strstr(cmdfil,"hydrogenCount=\"");
			    if (spntr) {
				spntr = spntr + 15;
		   	        sscanf(spntr,"%d",&nh[npdbe]);
			    }

			}
		   }

	    } else {

		   if (strstr(cmdfil,"lab=") != NULL) {
			spntr = strstr(cmdfil,"lab=\"");
			if (spntr) {
			    spntr = spntr + 5;
		   	    sscanf(spntr,"%[^\"]",chemid);

			    if (strcmp(chemidOld,"-1") == 0) {

				strcpy(chemidOld,chemid);
				hetz[0] = (char *) malloc(strlen(chemid)+1);
				strcpy(hetz[0],chemid);

			    } else if (strcmp(chemid,chemidOld) != 0) {

				strcpy(chemidOld,chemid);
				npdbe++;
				hetz[npdbe] = 
					(char *) malloc(strlen(chemid)+1);
				strcpy(hetz[npdbe],chemid);

			    }

			    spntr = strstr(cmdfil,"NH=\"");
			    if (spntr) {
				spntr = spntr + 4;
		   	        sscanf(spntr,"%d",&nh[npdbe]);
			    }

			    spntr = strstr(cmdfil,"NOTH=\"");
			    if (spntr) {
				spntr = spntr + 6;
		   	        sscanf(spntr,"%d",&noth[npdbe]);
			    }

			}
		   }


	    } /* end imode */
	} /* end while */
	fclose(out);
   } /* end if out != NULL */
   npdbe++;

   nht = 0;

   if (npdbe == 1) goto nolab;

   clfstrptr->ihhadd[aihet] = 1;

   i = -1;

   natoms = iend + 1;

   for (j=0; j < natoms; j++) {

	if (xyzp->iresid[j] == ihet) {

	  i++;
	  j1 = j + 1;

	  l0 = -1;
	  for (l=0; l < hetlab.NHetLab; l++) 
		if (hetlab.iat[l] == j1) l0 = l;

	  if (l0 == -1) {
		fprintf(stderr,
		"LigandHydroPBE: atom %d : pdb label not found!\n",j1);
	  	return;
	  }


	  k0 = -1;

	  for (l=0; l < npdbe; l++) {
		htmp = hetlab.HetLab[l0];
		for (k=0; k < strlen(htmp); k++) {
		    if (htmp[0]!=' ') break;
		    htmp++;
		}
		n = 0;
		for (k=0; k < strlen(htmp); k++) {
		    if (htmp[k]==' ') break;
		    n++;
		}
		if (n == strlen(hetz[l])) {
		  if (strncmp(htmp,hetz[l],n) == 0) {
		    k0 = l;
		    break;
		  }
		}
	  }

	  hasH = 0;
	  nc = 0;
	  nce = 0;
	  nmce = 0;
	  xc = xyzp->iconn[j*(MXCON+1)];
	  ir = xyzp->iresid[j];

	  for (k=0; k < 3; k++) ic[k] = -1;

	  for (k=0; k < xc; k++) {
		l = xyzp->iconn[j*(MXCON+1)+k+1];
		la = abs(l);
		lanz = 0;
		lr = -1;
		if (la > 0) {
		   lanz = xyzp->ianz[la-1];
	  	   lr = xyzp->iresid[la-1];
		}

		if (ir == lr) {
		   if (l > 0 && lanz > 1) {
			ic[nc] = l;
			nc++;
		   } else if (lanz == 1) {
			hasH = 1;
		   }
		} else {
		   if (!isit_metal(lanz) && !isBH4(j)) {
			ice[nce] = l;
			nce++;
		   } else {
			mce[nmce] = l;
			nmce++;
		   }
		}
	  }

	  if (k0 != -1) {
	     if (strcmp(het,"HEM") == 0) {
		if (strcmp(hetz[k0],"O2A") == 0 || 
		    strcmp(hetz[k0],"O2D") == 0) {
			nht = nht + nh[k0];
			k0 = -1;
		}
	     }
	  }

	  if (k0 != -1 && hasH) ifl[k0] = 1;

	  if (k0 != -1 && !hasH) {

	   notu = nht;
	   nht = nht + nh[k0];

           ifl[k0] = 1;

	   if (nce != 0 || nmce != 0) {
		if (noth[k0] != -1) {

		   if (noth[k0] == nc + nce) {
	              for (k=0; k < nce; k++) {
			ic[nc] = ice[k];
			nc++;
		      }
		   } else {
	              for (k=0; k < nce; k++) {
			nh[k0]--;
			nht--;
			ic[nc] = ice[k];
			nc++;
		      }
		   }

		} else {
	           for (k=0; k < nce; k++) {
			nh[k0]--;
			nht--;
			ic[nc] = ice[k];
			nc++;
		   }
	           for (k=0; k < nmce; k++) {
			ic[nc] = mce[k];
			nc++;
		   }
		}
	   }
/*
fprintf(stderr,"Lab %s nc %d nh[k0] %d\n",hetlab.HetLab[l0],nc,nh[k0]);
*/
	   switch(nc) {
		case 1:
			ix = ic[0];
			xc = xyzp->iconn[(ix-1)*(MXCON+1)];

			if (xc > 0 && xc <= 4) {
			   l = 0;
			   for (k=0; k < xc; k++) {
				iy = xyzp->iconn[(ix-1)*(MXCON+1)+k+1];
				if (iy != j1) {
				    ic[l] = iy;
				    l++;
				}
			   }
			   switch(nh[k0]) {
				case 3:
/* 1 + 3 = 4 connections; atom is C sp3, N sp3 */
					for (k=0; k < 3; k++) {
					   AddAtom(ic[0],ix,j1,1.090,109.47,
						   angles3[k], xyzp->iresid[j]);
				           nht--;
					}
					break;
				case 2:
/* 1 + 2 = 3 connections; atom is C sp2 or N sp3,sp2 */
					for (k=0; k < 2; k++) {
					   AddAtom(ic[0],ix,j1,1.090,120.0,
						   angles2[k], xyzp->iresid[j]);
				           nht--;
					}
					break;
				case 1:
/* 1 + 1 = 2 connections; atom is C sp or N sp2 or O sp3 */
					switch(xyzp->ianz[j]) {
					   case 7:
					   	AddAtom(ic[0],ix,j1,
						1.090,120.0,180.0,
						xyzp->iresid[j]);
				        	nht--;
						break;
					   case 8:
						if (!isPO4(ix-1) && !isCOO(ix-1)) {
				   		   AddAtom(ic[0],ix,j1,
							   1.090,109.47,180.0,
							   xyzp->iresid[j]);
				        	   nht--;
						} else {
						}
						break;
					   case 16:
					   	AddAtom(ic[0],ix,j1,
						1.090,109.47,180.0,
						xyzp->iresid[j]);
				        	nht--;
						break;
					   case 6:
					   	AddAtom(ic[0],ix,j1,
						1.090,179.9,0.0,
						xyzp->iresid[j]);
				        	nht--;
						break;
					   default:
						break;
					}
					break;
				default:
					break;
			   }
			}

			break;
		case 2:
			switch(nh[k0]) {
/* 2 + 2 = 4 connections; atom is C sp3 */
			   case 2:
				   if (xyzp->ianz[j] == 8) break;
				   for (k=0; k < nh[k0]; k++) {
					AddAtom(ic[0],ic[1],j1,1.090,109.47,
					angles3a[k],xyzp->iresid[j]);
				        nht--;
				   }
				   break;
			   case 1:
/* 2 + 1 = 3 connections; atom is  C sp2  or N sp3,sp2 */
				   if (xyzp->ianz[j] == 8) break;
				   AddAtom(ic[0],ic[1],j1,1.090,120.0,
					180.0,xyzp->iresid[j]);
				   nht--;
				   break;
			   default:
				   break;
			}
			break;
		case 3:
			switch(nh[k0]) {
			   case 1:
/* 3 + 1 = 4 connections; atom is C sp3 */
				   asel[0] = ic[0];
				   asel[1] = j1;
				   asel[2] = ic[1];
				   asel[3] = ic[2];
				   anum = 4;

#if defined(VMS) || defined(UNDERSC)
				   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
	 			   TOMOLD(&aret,asel,&anum);
#else
				   tomold_(&aret,asel,&anum);
#endif
#endif

				   is = SIGN(aret);
				   AddAtom(ic[0],ic[1],j1,1.090,109.47,
					is*120.0,xyzp->iresid[j]);
				   nht--;
				   break;
			   default:
				   break;
			}
			break;
		default:
			break;
	   }
	  }
	}
     
   }

   *zmptrp->ihaszm = 0;
   ZMEAA = 0;
   fnd = 0;
   for (j=0; j < npdbe; j++) {
	if (nh[j] != 0 && ifl[j] == 0) {
	    fnd++;
	}
   }

   if (fnd) {

	fprintf(stderr,
	   "\nSome labels in PBE entry %s, not found in HETATM from pdb file\n\n",het);

	fprintf(stderr,"PBE labels:\n\n");
	for (j=0; j < npdbe; j++) 
	   fprintf(stderr,"%s nh %d used %d\n",hetz[j],nh[j],ifl[j]);

	fprintf(stderr,"\npdb file HETATM labels:\n\n");

	for (j=0; j < *xyzp->iatoms; j++) 
	   if (xyzp->iresid[j] == ihet) {
		j1 = j + 1;

		l0 = -1;
		for (l=0; l < hetlab.NHetLab; l++) 
		   if (hetlab.iat[l] == j1) l0 = l;

		if (l0 != -1)
	   	   fprintf(stderr,"atom %d %s\n",j1,hetlab.HetLab[l0]);
	   }
   }

nolab:

   if (nht) {

	   fprintf(stderr,"\nSome Hydrogens not used:\n");
	   fprintf(stderr,"\nDecreasing formal charge by %d units\n",nht);
/*
	if (iac) {
	   fprintf(stderr,"\n%s has connections with amino acids:\n",het);
	   fprintf(stderr,"\nIncreasing formal charge by %d units\n",iac);
	}

	clfstrptr->ihetq[aihet] = 
		clfstrptr->ihetq[aihet] - nht + iac;
*/
	clfstrptr->ihetq[aihet] = 
		clfstrptr->ihetq[aihet] - nht;

	fprintf(stderr,"New formalCharge %d\n",clfstrptr->ihetq[aihet]);
   }

   np = 0;
   for (j=0; j < natoms; j++) {
	if (xyzp->iresid[j] == ihet) {
	   if (xyzp->ianz[j] == 7) {
		if (TertN(j,con)) {
		   j1 = j + 1;
		   n = *xyzp->iatoms;
		   for (l=0; l<3; l++) {
		      v[l] = 0.0;
		      v[l] = v[l] + 
			(xyzp->coo[(con[0]-1)*3+l] - xyzp->coo[j*3+l]);
		      v[l] = v[l] + 
			(xyzp->coo[(con[1]-1)*3+l] - xyzp->coo[j*3+l]);
		      v[l] = v[l] + 
			(xyzp->coo[(con[2]-1)*3+l] - xyzp->coo[j*3+l]);
		      xyzp->coo[n*3+l] = xyzp->coo[j*3+l] - v[l];
		   }

		   asel[0] = j1;
		   asel[1] = con[0];
		   asel[2] = con[1];
		   asel[3] = con[2];
		   anum = 4;

#if defined(VMS) || defined(UNDERSC)
		   tomold(&aret,asel,&anum);
#else
#ifdef CRAY
		   TOMOLD(&aret,asel,&anum);
#else
		   tomold_(&aret,asel,&anum);
#endif
#endif
/*		   fprintf(stderr,"aret %f\n",aret);*/

		   if (ABS(aret) > 15.0) {
			asel[0] = n+1;
			asel[1] = j1;
			asel[2] = con[1];
			asel[3] = con[0];
			anum = 4;
			*xyzp->iatoms = *xyzp->iatoms + 1;

#if defined(VMS) || defined(UNDERSC)
			tomold(&aret,asel,&anum);
#else
#ifdef CRAY
			TOMOLD(&aret,asel,&anum);
#else
			tomold_(&aret,asel,&anum);
#endif
#endif
			*xyzp->iatoms = *xyzp->iatoms - 1;
			AddAtom(con[0],con[1],j1,1.090,109.47,aret,ihet);
			clfstrptr->ihetq[aihet] = clfstrptr->ihetq[aihet] + 1;
			np++;
		   }
		}
	   }
	}
   }

   if (np) {
	fprintf(stderr,"Protonated %d Tertiary Nitrogen(s) \nNew formalCharge %d\n",np,clfstrptr->ihetq[aihet]);
   }

   free(sp);
   free(nh);
   free(ifl);
   for (j=0; j < npdbe; j++) 
	if (hetz != NULL) free(hetz[j]);
   free(hetz);
   free(het);


}

/* 
  specify:

  DoHyd		Add Hydrogens
  DoChg		Calculate Charge, with ieemopt and CHGtot
  DoFF		Type by Ambfor Force Field 
*/

void LigandHydroQ(DoHyd,DoChg,DoFF,CHGtot)
int DoHyd;
int DoChg;
int DoFF;
int CHGtot;
{
      int i,imn,nhmol,TmpEemOpt,CHGstat,onemol;
      CHGstat = 0;

      TmpEemOpt = ieemopt + 1;

      if (*ipdbon) {

#if defined(VMS) || defined(UNDERSC)
	numhed(&nhmol,
#else
#ifdef CRAY
	NUMHED(&nhmol,
#else
	numhed_(&nhmol,
#endif
#endif
	xyzp->iresid);

	onemol = 0;
	if (nhmol == 4) onemol = 1;

	for (i=4; i<nhmol+1; i++) {

	    imn = -i;

	    if (i != calfptr->ishoh) {

		if (clfstrptr->ihashz) {
		    fprintf(stderr,"\nHETATM residue %s\n\n",hetptr.HetAtm[i]);
		} else {
		    fprintf(stderr,"\nHETATM residue %d\n\n",(i-4));
		}

		if (DoHyd) CheckHydro(imn);

		if (DoHyd && !clfstrptr->ihhadd[i]) LigandHydroPBE(imn);

		if (DoFF) {

		    if (clfstrptr->ihqset[i]) {
			*itot = clfstrptr->ihetq[i];
		    } else {
			if (onemol) {
			   *itot = CHGtot;
			} else {
			   *itot = 0;
			}
		    }

		    *fftyp = 7; 
		    typit(7,1);
		}

		if (DoChg) {

		    if (clfstrptr->ihqset[i]) {
			*itot = clfstrptr->ihetq[i];
		    } else {
			if (onemol) {
			   *itot = CHGtot;
			} else {
			   *itot = 0;
			}
		    }

		    if (ieemopt == 4) {

#if defined(VMS) || defined(UNDERSC)
			calgas(&imn,&ZERO,&CHGstat);
#else
#ifdef CRAY
			CALGAS(&imn,&ZERO,&CHGstat);
#else
			calgas_(&imn,&ZERO,&CHGstat);
#endif
#endif
		    } else {

#if defined(VMS) || defined(UNDERSC)
			eem(&TmpEemOpt,&imn,&CHGstat);
#else
#ifdef CRAY
			EEM(&TmpEemOpt,&imn,&CHGstat);
#else
			eem_(&TmpEemOpt,&imn,&CHGstat);
#endif
#endif
		    }

		    if (CHGstat)  
			fprintf(stderr,
			"WARNING: element missing charge scheme parameters!\n");
		}
	    }
	}


      } else {

	*itot = CHGtot;

	if (ieemopt == 4) {

#if defined(VMS) || defined(UNDERSC)
	    calgas(&ONE,&ZERO,&CHGstat);
#else
#ifdef CRAY
	    CALGAS(&ONE,&ZERO,&CHGstat);
#else
	    calgas_(&ONE,&ZERO,&CHGstat);
#endif
#endif

	} else {

#if defined(VMS) || defined(UNDERSC)
	    eem(&TmpEemOpt,&ONE,&CHGstat);
#else
#ifdef CRAY
	    EEM(&TmpEemOpt,&ONE,&CHGstat);
#else
	    eem_(&TmpEemOpt,&ONE,&CHGstat);
#endif
#endif
	}
	if (CHGstat) 
	    fprintf(stderr,
		"WARNING: element missing charge scheme parameters!\n");
      }


}

void LigandStruct(het)
int het;
{

  int i,j,k,l,n,nc,ir,istr;
  int nat,fnd,istart,iend,itot,ahet;
  COOSTRU *xyzpo;

    ahet = ABS(het);

    if (ahet >= MXHETA) {
	fprintf(stderr,"\nLigandStruct: hetatm residue outside array bounds\n\n");
	return;
    }

    istr = istruct;

    if (istruct == 0 && (&(COO[istruct]->coo) == NULL)) {
	    SaveFirstStruct();
	    nstruct++;
    }

    xyzpo   = &COO[istruct]->coo;

    fnd = 0;
    istart = 0;
    iend = -1;

    if (xyzpo->iatoms != NULL) {
    for (j=0; j < *xyzpo->iatoms; j++) {
	if (xyzpo->iresid[j] == het) {
	   if (!fnd) {
	      istart = j; 
	      fnd = 1;
	   }
	   iend = j;
	}
    }
    }

    if (iend == -1 ) return;

    nat = iend - istart + 1;

    AllocateStructure(&COO[nstruct]);
    if (nstruct != 0) SaveActiveStruct();

    if (ahet < MXHETA) {
	if (hetptr.Allocated[4]) free(hetptr.HetAtm[4]);
	if (COO[istr]->hetatm.Allocated[ahet]) {
		n = strlen(COO[istr]->hetatm.HetAtm[ahet]);
		hetptr.HetAtm[4] = (char *) malloc(n+1);
		strncpy(hetptr.HetAtm[4],COO[istr]->hetatm.HetAtm[ahet],n);
		hetptr.HetAtm[4][n] = '\0';
		hetptr.Allocated[4] = 1;
	}
    }

    AllocateSubStructures(COO[istr]->hetatm.HetAtm[ahet],0);

    if (nat > *xyzp->mxnat) {
	itot = nat + 500;
#if defined(VMS) || defined(UNDERSC)
	allcoo(&itot,&ZERO);
#else
#ifdef CRAY
	ALLCOO(&itot,&ZERO);
#else
	allcoo_(&itot,&ZERO);
#endif
#endif
    }

    for (j=0; j < nat; j++) {
	xyzp->iresid[j] = -4;
	xyzp->iatclr[j] = xyzpo->iatclr[j+istart];
	xyzp->iaton[j]  = xyzpo->iaton[j+istart];
	xyzp->ianz[j]   = xyzpo->ianz[j+istart];
	xyzp->ipdbt[j]  = xyzpo->ipdbt[j+istart];
	xyzp->ityp[j]   = xyzpo->ityp[j+istart];
	xyzp->qat[j]    = xyzpo->qat[j+istart];
	xyzp->isurf[j]  = xyzpo->isurf[j+istart];

	for (k=0; k < 3; k++) 
	   xyzp->coo[j*3+k] = xyzpo->coo[(j+istart)*3+k];

	nc = 0;
	for (k=0; k < xyzpo->iconn[(j+istart)*(MXCON+1)]; k++) {
	   i = xyzpo->iconn[(j+istart)*(MXCON+1)+k+1];
	   ir = xyzpo->iresid[i-1];
	   if (ir == het) {
		if (i >= 0) {
		   xyzp->iconn[j*(MXCON+1)+nc+1] = 
			xyzpo->iconn[(j+istart)*(MXCON+1)+k+1] - istart;
		} else {
		   xyzp->iconn[j*(MXCON+1)+nc+1] = 
			xyzpo->iconn[(j+istart)*(MXCON+1)+k+1] + istart;
		}
		nc++;
	   }
	}
	xyzp->iconn[j*(MXCON+1)] = nc;
    }
    *natorg = nat;
    *xyzp->iatoms = nat;
    clfstrptr->ihashz = 0;
    *ipdbon = 0;
    *backb = 0;

#if defined(VMS) || defined(UNDERSC)
    docent();doscal();
#else
#ifdef CRAY
    DOCENT();DOSCAL();
#else
    docent_();doscal_();
#endif
#endif
    posptr->zv = 2.0*scalptr->scali;
    posptr->xv = 0.0;
    posptr->yv = 0.0;
#ifdef DOGL
    posz = scalptr->scali;
    updfog(0);
#endif

    update_model = 1;
    update_struct();
    RedrawSTR();

    ZMEswitch[0].toggle = 1; ZMEAA = 0; EXPbox[0].fake = 1; 
    LastAmino = -1;
    CurAmino = -1;

    for (j=0; j < *xyzp->iatoms; j++) {
	if (xyzp->ianz[j] < 100) {
	   xyzp->iaton[j] = 2;
	} else {
	   xyzp->iaton[j] = 1;
	}
    }

#if defined(VMS) || defined(UNDERSC)
    intzmt(&ZERO);
#else
#ifdef CRAY
    INTZMT(&ZERO);
#else
    intzmt_(&ZERO);
#endif
#endif

    for (j=0; j < *xyzp->iatoms; j++) xyzp->iaton[j] = 1;

    pdb = 0;
    calfptr->ncalf = 0;
    hetptr.NHetAtm = 5;
   
}

#ifdef DOGL

#if defined(VMS) || defined(UNDERSC)
void oglin()
#else
#ifdef CRAY
void OGLIN()
#else
void oglin_()
#endif
#endif
{

      theLines[istruct] = glGenLists(1);

      glNewList(theLines[istruct], GL_COMPILE);

      glDisable(GL_LIGHTING);
      glEnable(GL_COLOR_MATERIAL);
      glBegin(GL_LINES);
}

void ogrdmol(char *top, double *r, double *adjus, int *natoms, int *nat, 
	int *iatclr, double *coo, int *iopt, int *conn, int *iconn)
{
      int i,j,atcol;

      *adjus = 0.529177;
      if (strstr(top,"AU")) *adjus = 1.0;
      *conn = 0;
      if (strstr(top,"CONN")) *conn = 1;
      *iopt = 0;
      if (strstr(top,"UNSCALED")) *iopt = 1;
      atcol = 1;
      if (strstr(top,"GRPCOL")) atcol = 0;
      
      if (*iopt) {
        r[0] = 1.0;
      } else {
	fgets(top,100,out);
	sscanf(top,"%lf %lf %lf",&r[0],&r[1],&r[2]);
      }
      fgets(top,100,out);
      sscanf(top,"%d",natoms);

      for (i=0; i<*natoms; i++) {
	  fgets(top,132,out);
	  if (atcol) {
	    sscanf(top,"%d %lf %lf %lf %d %d %d %d %d %d %d %d %d %d %d %d %d",
		&nat[i],&coo[i*3],&coo[i*3+1],&coo[i*3+2],
		&iconn[i*(MXCON+1)],
		&iconn[i*(MXCON+1)+1],&iconn[i*(MXCON+1)+2],
		&iconn[i*(MXCON+1)+3],&iconn[i*(MXCON+1)+4],
		&iconn[i*(MXCON+1)+5],&iconn[i*(MXCON+1)+6],
		&iconn[i*(MXCON+1)+7],&iconn[i*(MXCON+1)+8],
		&iconn[i*(MXCON+1)+9],&iconn[i*(MXCON+1)+10],
		&iconn[i*(MXCON+1)+11],&iconn[i*(MXCON+1)+12]);
	  } else {
	    sscanf(top,"%d %d %lf %lf %lf %d %d %d %d %d %d %d %d %d %d %d %d %d",
		&nat[i],&iatclr[i],&coo[i*3],&coo[i*3+1],&coo[i*3+2],
		&iconn[i*(MXCON+1)],
		&iconn[i*(MXCON+1)+1],&iconn[i*(MXCON+1)+2],
		&iconn[i*(MXCON+1)+3],&iconn[i*(MXCON+1)+4],
		&iconn[i*(MXCON+1)+5],&iconn[i*(MXCON+1)+6],
		&iconn[i*(MXCON+1)+7],&iconn[i*(MXCON+1)+8],
		&iconn[i*(MXCON+1)+9],&iconn[i*(MXCON+1)+10],
		&iconn[i*(MXCON+1)+11],&iconn[i*(MXCON+1)+12]);
	  }
	  xyzp->iaton[i] = 1;
	  for (j=0; j<3; j++) 
		coo[i*3+j] = coo[i*3+j]/(*adjus);
      }
}

void ogsize(int *natoms, double *coo, double *r)
{
   int i;
   double dijsq;

   for (i=0; i<*natoms; i++) {
	dijsq = coo[i*3]*coo[i*3] + 
		coo[i*3+1]*coo[i*3+1] + 
		coo[i*3+2]*coo[i*3+2];
	dijsq = dijsq / (r[0]*r[0]);
	if (dijsq > 0.0) dijsq = sqrt(dijsq);
	if (dijsq > posz) posz = dijsq;

   }
}

void dist(double *coo, double *dsq)
{
  double d;

  d = coo[0]*coo[0] + coo[1]*coo[1] + coo[2]*coo[2]; 
  if (d > 0.0) d = sqrt(d);
  if (d > *dsq) *dsq = d;
}

void dentr()
{
   int i;
   double t;

   for (i=0; i<*xyzp->iatoms; i++) {
	t = xyzp->coo[i*3];
	xyzp->coo[i*3] = -1.0*xyzp->coo[i*3+1];
	xyzp->coo[i*3+1] = -1.0*t;
	xyzp->coo[i*3+2] = -1.0*xyzp->coo[i*3+2];
   }
}

void ogxyz(out)
FILE *out;
{
    double tmp[3], dsq, dmaxsq, adj;
    int i,j,l,ia,ja,nc,icnn[MXCON];

    adj = *adjuss;

    fprintf(out,"[MOLECULE] UNSCALED CONN\n");
    fprintf(out,"%d\n",NAT->natoms);

    for (i=0; i< NAT->natoms; i++) {

           ia = NAT->nat[i];
	   nc = 0;

           for (j=0; j< NAT->natoms; j++) {

            ja = NAT->nat[j];

	    dsq = 0;
            for (l=0; l<3; l++) {
                tmp[l] = (XYZ->xyz[j][l] - XYZ->xyz[i][l]);
		dsq = dsq + tmp[l]*tmp[l];
	    }
            dmaxsq = (elmptr->vdwr[ia-1] + elmptr->vdwr[ja-1])/adj;
            dmaxsq = dmaxsq * dmaxsq;

	    if (i != j && dsq < dmaxsq && nc < MXCON) {
		icnn[nc] = j+1;
		nc++;
	    }

	   }

	   for (j=0; j<3; j++) 
		tmp[j] = (XYZ->xyz[i][j]-rotptr->t[j]) * adj;

	   fprintf(out,"%3d %12.6f %12.6f %12.6f %2d",
		NAT->nat[i],tmp[0],tmp[1],tmp[2],nc);
	   for (j=0; j<nc; j++) 
		fprintf(out," %5d ",icnn[j]);
	   fprintf(out,"\n");

    } 

}

void woglmol(out)
FILE *out;
{
   int i,j,k, nc, doit, natoms, icnn[MXCON];
   double tmp[3],t[3];

   fprintf(out,"[MOLECULE] UNSCALED GRPCOL CONN\n");

   for (i=0; i<*xyzp->iatoms; i++) xyzp->lring[i] = 0;

   natoms = 0;

   for (i=0; i<*xyzp->iatoms; i++) {
	doit = 0;
	if (*ipdbon) {
	   if (xyzp->iresid[i] > 0) {
		if (calfptr->reson[xyzp->iresid[i]-1] == 1) doit = 1;
	   } else if (xyzp->iresid[i] < -3) {
		doit = 1;
	   }
	} else {
	   doit = 1;
	}
	if (xyzp->ianz[i] < 100 && xyzp->ianz[i] > 0 &&
	    xyzp->iaton[i] > 0 && doit) {
	    natoms++;
	    xyzp->lring[i] = natoms;
	}
   }

   fprintf(out,"%d\n",natoms);

   for (i=0; i<*xyzp->iatoms; i++) {

	nc = 0;
	for (k=0; k < xyzp->iconn[i*(MXCON+1)]; k++) {
	   j = xyzp->iconn[i*(MXCON+1)+k+1];
	   if (j >= 0) {
		if (xyzp->lring[j-1] > 0) {
		   icnn[nc] = xyzp->lring[j-1];
		   nc++;
		}
	   }
	}

	doit = 0;
	if (*ipdbon) {
	   if (xyzp->iresid[i] > 0) {
		if (calfptr->reson[xyzp->iresid[i]-1] == 1) doit = 1;
	   } else if (xyzp->iresid[i] < -3) {
		doit = 1;
	   }
	} else {
	   doit = 1;
	}

	if (xyzp->iaton[i] > 0 && doit) {
	   for (j=0; j<3; j++) 
		tmp[j] = (xyzp->coo[i*3+j]-rotptr->t[j]) * (double)toangs;
	   fprintf(out,"%3d %2d %12.6f %12.6f %12.6f %2d",
		xyzp->ianz[i],xyzp->iatclr[i],tmp[0],tmp[1],tmp[2],nc);
	   for (j=0; j<nc; j++) 
		fprintf(out," %5d ",icnn[j]);
	   fprintf(out,"\n");
	   
	}
   }
}

void wrtall()
{
   int i,j,k,snd;
   char colstr[18];
   FILE *out;
   double tmp[3],adj;


   out = fopen("molden.ogl","w");
   if (out == NULL) {
      fprintf(stderr,"Couldnt open file molden.ogl\n");
      return;
   }

   fprintf(out,"[MOLDENOGL]\n");

   if (denmode) {
	adj = *adjuss;
	ogxyz(out);
   } else {
	adj = toangs;
	woglmol(out);
   }

   if (!dovrt) fprintf(stderr,"Due to failed memory allocation, written surfaces may be incomplete\n");

   for (i=0; i < NSurf[istruct]; i++) {

	if (nvert[istruct][i] > 4 && srfvert[istruct][i] != NULL) {

	   sprintf(colstr,"COLOR %3.1f %3.1f %3.1f",
		diffuseColor[istruct][i][0],
		diffuseColor[istruct][i][1],
		diffuseColor[istruct][i][2]);

	   switch(SStyp[istruct][i]) {
	   case 0:
		fprintf(out,"[SURFACE] %s \"%s\"\n",
			colstr,sndstr[istruct][i]);
		break;
	   case 1:
		fprintf(out,"[SURFACE] MAPPED %s \"%s\"\n",
			colstr,sndstr[istruct][i]);
		break;
	   case 2:
		snd = 0;
		for (j=0; j < 4; j++) {
		   if (i >= RIBindex[istruct].start[j] 
		    && i <= RIBindex[istruct].end[j]) {
	   		fprintf(out,"[RIBBON] %s %s \"%s\"\n",
				strsnd[j],colstr,sndstr[istruct][i]);
			snd = 1;
		   }
		}
		if (!snd) fprintf(out,"[ELEVATIONGRID] %s \"%s\"\n",
		   colstr,sndstr[istruct][i]);
		break;
	   }

	   for (j=0; j < nvert[istruct][i]; j++) {
		k = srfvert[istruct][i][j].type;
		if (k == 2) {
		   fprintf(out,"[HELIXIN]\n");
		} else if (k == 1) {
		   for (k=0; k < 3; k++) 
		    tmp[k] = 
			(srfvert[istruct][i][j].vert[k] - rotptr->t[k])*adj;
		   fprintf(out,"%f %f %f\n",tmp[0],tmp[1],tmp[2]);
		} else {
		   for (k=0; k < 3; k++) 
		    tmp[k] = srfvert[istruct][i][j].vert[k];
		   fprintf(out,"%f %f %f\n",tmp[0],tmp[1],tmp[2]);
		}
	   }
	}
   }

   fclose(out);
}

void srfcen()
{
   int i,j,k,n;
   float cen[3],dt,dist;

   n = 0;
   for (i=0; i < 3; i++) cen[i] = 0.0;

   for (i=0; i < NSurf[istruct]; i++) {
	for (j=0; j < nvert[istruct][i]; j++) {
		k = srfvert[istruct][i][j].type;
		if (k == 1) {
		   for (k=0; k < 3; k++) 
			cen[k] = cen[k] + srfvert[istruct][i][j].vert[k];
		   n++;
		}
	}
   }

   for (i=0; i < 3; i++) rotptr->t[i] = cen[i]/(double) n;
   
   scalptr->scali = 0.0;
   for (i=0; i < NSurf[istruct]; i++) {
	for (j=0; j < nvert[istruct][i]; j++) {
		k = srfvert[istruct][i][j].type;
		if (k == 1) {
		   dist = 0.0;
		   for (k=0; k < 3; k++) {
			dt = (srfvert[istruct][i][j].vert[k] - rotptr->t[k]);
			dist = dist + dt*dt;
		   }
		   if (dist > scalptr->scali) scalptr->scali = dist;
		}
	}
   }
   scalptr->scali = sqrt(scalptr->scali);
   scalptr->scal = scalptr->scali*2.4*scalptr->smag;
   posptr->zv = scalptr->scali;
   posptr->xv = 0.0;
   posptr->yv = 0.0;
   posptr->pincr = 0.02*scalptr->scali;
   posz = scalptr->scali;
   updfog(0);

}

int rdoglfile(infile)
char *infile;
{
   double adjus, r[3];
   int conn, mopt, mapped, iorb, isurf, ityp, icolset;
   int iopt,fend,i,j,ic,ichain,elev,ribb,surf,loop,iribc,iscnd;
   char rdstr[132];
   char *colstr;
   char *namestr;
   double v[3],vt[3],vc[3],dis,cntval;
   float coltmp[3];

   if (has_opengl) {
      *ifogl = 1;
      *fancy = 1;
   } else {
      return(1);
   }

   dis = 0.0;
   posz = 0.0;
   *ipdbon = 0;
   NSurf[istruct] = 0;
   iorb = -1;
   cntval = 0.0;
   ichain = -1;

   RIBindex[istruct].nhelx = 0;
   RIBindex[istruct].nbeta = 0;
   RIBindex[istruct].nrna = 0;
   RIBindex[istruct].ncoil = 0;

   for (i=0; i<4; i++) {
	RIBindex[istruct].start[i] = -1; 
	RIBindex[istruct].end[i] = -1; 
   }

   out = fopen(infile,"r");
   if (out == NULL) {
      fprintf(stderr,"Couldnt open file %s\n",infile);
      return(1);
   }

   fgets(rdstr,100,out);
   if (strncmp(rdstr,"[MOLDENOGL]",11) != 0) {
      fprintf(stderr,"This is not an [MOLDENOGL] file !\n");
      return(1);
   }

   iopt = 0;

   while(!(fend = feof(out))) {
      fgets(rdstr,100,out);
      if (strstr(rdstr,"[MOLECULE]") == NULL) goto Surf;
      ogrdmol(rdstr,r,&adjus,xyzp->iatoms,xyzp->ianz,xyzp->iatclr,
	xyzp->coo,&mopt,&conn,xyzp->iconn);
      if (!mopt) dentr();
      ogsize(xyzp->iatoms,xyzp->coo,r);
      ogmoll(0);
#if defined(VMS) || defined(UNDERSC)
      docent();doscal();setxyv();
#else
#ifdef CRAY
      DOCENT();DOSCAL();SETXYV();
#else
      docent_();doscal_();setxyv_();
#endif
#endif
   }


Surf:

   loop = 0;

   elev = 0;
   ribb = 0;
   lines = 0;
   surf = 0;
   isurf = 1;
   ityp = 0;
   mapped = 0;

   while(!(fend = feof(out))) {

      if (loop) fgets(rdstr,100,out);
      loop = 1;
      
      if (strncmp(rdstr,"[LINES",6) == 0) {
#if defined(VMS) || defined(UNDERSC)
	if (surf) ogend();
	oglin();
#else
#ifdef CRAY
	if (surf) OGEND();
	OGLIN();
#else
	if (surf) ogend_();
	oglin_();
#endif
#endif
	surf++;
	lines = 1;
	continue;
      }

      iribc = -1;
      if (strstr(rdstr,"[COL STRANDTOP]") != NULL) iribc = 0;
      if (strstr(rdstr,"[COL STRANDBOTTOM]") != NULL) iribc = 1;
      if (strstr(rdstr,"[COL HELIXOUT]") != NULL) iribc = 2;
      if (strstr(rdstr,"[COL HELIXIN]") != NULL) iribc = 3;
      if (strstr(rdstr,"[COL RNA]") != NULL) iribc = 4;
      if (strstr(rdstr,"[COL COIL]") != NULL) iribc = 5;
      if (iribc != -1) {
	colstr = strstr(rdstr,"]");
	if (colstr != NULL) {
	   colstr = colstr + 1;
	   sscanf(colstr,"%f %f %f",&ribcol[iribc][0],
		&ribcol[iribc][1],&ribcol[iribc][2]);
	}
	continue;
      }

      if (strncmp(rdstr,"[SURFACE",8) == 0 || 
	  strncmp(rdstr,"[ELEVATION",10) == 0 || 
	  strncmp(rdstr,"[RIBBON",7) == 0) {
	lines = 0;
#if defined(VMS) || defined(UNDERSC)
	if (surf) ogendd(&ichain);
#else
#ifdef CRAY
	if (surf) OGENDD(&ichain);
#else
	if (surf) ogendd_(&ichain);
#endif
#endif
	icolset = 0;
	colstr = strstr(rdstr,"COLOR");
	if (colstr != NULL) {
	   icolset = 1;
	   colstr = colstr + 5;
	   sscanf(colstr,"%f %f %f",&coltmp[0],&coltmp[1],&coltmp[2]);
	   for (i=0; i<3; i++) {
		diffuseColor[istruct][surf][i] = coltmp[i];
		cursrfcol[isurf-1][i] = coltmp[i];
	   }
	}

	namestr = strstr(rdstr,"\"");
	if (namestr != NULL) {
	   namestr++;
	} else {
	   namestr = unknown;
	}

	if (strncmp(rdstr,"[RIBBON",7) == 0) {
           iribc = -1;
	   if (strstr(rdstr,"STRANDTOP") != NULL) iribc = 0;
	   if (strstr(rdstr,"STRANDBOTTOM") != NULL) iribc = 1;
	   if (strstr(rdstr,"HELIXOUT") != NULL) iribc = 2;
	   if (strstr(rdstr,"HELIXIN") != NULL) iribc = 3;
	   if (strstr(rdstr,"RNA") != NULL) iribc = 4;
	   if (strstr(rdstr,"COIL") != NULL) iribc = 5;

	}


	if (strstr(rdstr,"MAPPED") != NULL) {
		mapped = 1;
	} else {
		mapped = 0;
	}

	iopt = 1;
	colstr = strstr(rdstr,"TRANS");
	if (colstr != NULL) {
	   colstr = colstr + 5;
	   iopt = -iopt;
	   if (sscanf(colstr,"%lf",&tr_val) <= 0) {
		tr_val = TRDEF;
	   }
	}

	if (strncmp(rdstr,"[ELEVATION",10) == 0 ||
	    strncmp(rdstr,"[RIBBON",7) == 0) {
	   if (strncmp(rdstr,"[ELEVATION",10) == 0) {
		elev = 1;
		ogelev(namestr);
	   } else {
		ribb = 1;
		switch (iribc) {
		case 0:
		case 1:
			iscnd = 1;
			break;
		case 2:
		case 3:
			iscnd = 0;
			break;
		case 4:
			iscnd = 2;
			break;
		case 5:
			iscnd = 3;
			break;
		}
#if defined(VMS) || defined(UNDERSC)
		ogribb(&iscnd);
#else
#ifdef CRAY
		OGRIBB(&iscnd);
#else
		ogribb_(&iscnd);
#endif
#endif
		if (iribc != -1)

		   if (RIBindex[istruct].start[iscnd] == -1) 
			RIBindex[istruct].start[iscnd] = NSurf[istruct]-1; 
		   RIBindex[istruct].end[iscnd] = NSurf[istruct]-1; 

		   if (icolset) {
			for (i=0; i<3; i++) 
			   diffuseColor[istruct][NSurf[istruct]-1][i] = 
				coltmp[i];
		   } else {
			for (i=0; i<3; i++) 
			   diffuseColor[istruct][NSurf[istruct]-1][i] = 
				ribcol[iribc][i];
		   }
		}

	} else {
	   elev = 0; ribb = 0;
#if defined(VMS) || defined(UNDERSC)
	   ogbegg(&isurf,&ZERO,&ityp,&iorb,&cntval,&mapped,namestr);
#else
#ifdef CRAY
	   OGBEGG(&isurf,&ZERO,&ityp,&iorb,&cntval,&mapped,namestr);
#else
	   ogbegg_(&isurf,&ZERO,&ityp,&iorb,&cntval,&mapped,namestr);
#endif
#endif
	   isurf++;
	   if (isurf > 2) isurf = 1;
	}
	surf++;
	fgets(rdstr,100,out);
      }

      if (lines) {

/*
Yes you are right the x and y coordinates are swapped in molden
Have to fix it sometime
*/
	sscanf(rdstr,"%d %lf %lf %lf %lf %lf %lf",
		&ic,&v[1],&v[0],&v[2],&vt[1],&vt[0],&vt[2]);
	for (j=0; j<3; j++) {
	   v[j] = r[0]*v[j] / adjus;
	   vt[j] = r[0]*vt[j] / adjus;
	}

	vc[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ;
	vc[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ;
	vc[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ;

#if defined(VMS) || defined(UNDERSC)
	ogcoll(&vc[0],&vc[1],&vc[2]);
	ogvrt(&v[0],&v[1],&v[2]);
	ogvrt(&vt[0],&vt[1],&vt[2]);
#else
#ifdef CRAY
	OGCOLL(&vc[0],&vc[1],&vc[2]);
	OGVRT(&v[0],&v[1],&v[2]);
	OGVRT(&vt[0],&vt[1],&vt[2]);
#else
	ogcoll_(&vc[0],&vc[1],&vc[2]);
	ogvrt_(&v[0],&v[1],&v[2]);
	ogvrt_(&vt[0],&vt[1],&vt[2]);
#endif
#endif
	continue;

      }

      if (mapped) {
	sscanf(rdstr,"%lf %lf %lf",&v[0],&v[1],&v[2]);
	v[0] = fabs(v[0]);
#if defined(VMS) || defined(UNDERSC)
	ogcoll(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
	OGCOLL(&v[0],&v[1],&v[2]);
#else
	ogcoll_(&v[0],&v[1],&v[2]);
#endif
#endif
        fgets(rdstr,100,out);
      }

      if (strncmp(rdstr,"[HELIXIN",8) == 0) {
#if defined(VMS) || defined(UNDERSC)
	sribcol(&THREE);
	setcll();
	if (icolset) {
	   for (i=0; i<3; i++) 
		diffuseColor[istruct][NSurf[istruct]-1][i] = coltmp[i];
	} else {
	   sribcol(&TWO);
	}
#else
#ifdef CRAY
	SRIBCOL(&THREE);
	SETCLL();
	if (icolset) {
	   for (i=0; i<3; i++) 
		diffuseColor[istruct][NSurf[istruct]-1][i] = coltmp[i];
	} else {
	   SRIBCOL(&TWO);
	}
#else
	sribcol_(&THREE);
	setcll_();
	if (icolset) {
	   for (i=0; i<3; i++) 
		diffuseColor[istruct][NSurf[istruct]-1][i] = coltmp[i];
	} else {
	   sribcol_(&TWO);
	}
#endif
#endif
        fgets(rdstr,100,out);
      }

      sscanf(rdstr,"%lf %lf %lf",&v[0],&v[1],&v[2]);
/*      for (j=0; j<3; j++) v[j] = 1.0*v[j];*/
#if defined(VMS) || defined(UNDERSC)
      ognrm(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
      OGNRM(&v[0],&v[1],&v[2]);
#else
      ognrm_(&v[0],&v[1],&v[2]);
#endif
#endif

      fgets(rdstr,100,out);
      sscanf(rdstr,"%lf %lf %lf",&v[0],&v[1],&v[2]);
      for (j=0; j<3; j++) v[j] = r[0]*v[j] / adjus;

#if defined(VMS) || defined(UNDERSC)
      ogvrt(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
      OGVRT(&v[0],&v[1],&v[2]);
#else
      ogvrt_(&v[0],&v[1],&v[2]);
#endif
#endif
      dist(v,&dis);

      if (elev || ribb) {

       for (i=0; i<3; i++) {

         fgets(rdstr,100,out);
         sscanf(rdstr,"%lf %lf %lf",&v[0],&v[1],&v[2]);
/*         for (j=0; j<3; j++) v[j] = 1.0*v[j];*/

#if defined(VMS) || defined(UNDERSC)
         ognrm(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
         OGNRM(&v[0],&v[1],&v[2]);
#else
         ognrm_(&v[0],&v[1],&v[2]);
#endif
#endif
         fgets(rdstr,100,out);
         sscanf(rdstr,"%lf %lf %lf",&v[0],&v[1],&v[2]);
	 for (j=0; j<3; j++) v[j] = r[0]*v[j] / adjus;

#if defined(VMS) || defined(UNDERSC)
         ogvrt(&v[0],&v[1],&v[2]);
#else
#ifdef CRAY
         OGVRT(&v[0],&v[1],&v[2]);
#else
         ogvrt_(&v[0],&v[1],&v[2]);
#endif
#endif
         dist(v,&dis);
        }

      }
   }

   if (dis > posz) posz = dis;
   scalptr->scali = posz;
   posptr->zv = posz;

#if defined(VMS) || defined(UNDERSC)
   ogendd(&ichain);
#else
#ifdef CRAY
   OGENDD(&ichain);
#else
   ogendd_(&ichain);
#endif
#endif

   for (i=0; i<NSurf[istruct]; i++) {
	SSon[istruct][i] = 1;
	clp[istruct][i] = 0;
	trns[istruct][i] = 0;
   }


   fclose(out);

   if (*xyzp->iatoms == 0) srfcen();

   plcnrm();

   dispsf();

   if (surf > 1) inistrc();

   UpdateSTRC();
   RedrawSTRC();

   return(0);

}
#else
int rdoglfile(infile)
char *infile;
{
   lViewer(infile);
   return(1);
}
#endif

#define TOANG 0.52917706

double calsrf(v1,v2,v3) 
double *v1;
double *v2;
double *v3;
{
   double a,b,c,s,opp, t1[3],t2[3],t3[3];
   int i;

   for (i = 0; i < 3; i++) {
	t1[i] = v1[i] - v2[i];
	t2[i] = v2[i] - v3[i];
	t3[i] = v1[i] - v3[i];
   }

   a = vln(t1);
   b = vln(t2);
   c = vln(t3);
   s = (a + b + c) / 2.0;
   opp = sqrt(s*(s-a)*(s-b)*(s-c))*TOANG*TOANG;

   return(opp);

}

double clsrf(v1,v2,v3) 
double *v1;
double *v2;
double *v3;
{
   double a,b,c,s,opp, t1[3],t2[3],t3[3];
   int i;

   for (i = 0; i < 3; i++) {
	t1[i] = v1[i] - v2[i];
	t2[i] = v2[i] - v3[i];
	t3[i] = v1[i] - v3[i];
   }

   a = vln(t1);
   b = vln(t2);
   c = vln(t3);
   s = (a + b + c) / 2.0;
   opp = sqrt(s*(s-a)*(s-b)*(s-c));

   return(opp);

}

void subdivide(v1,v2,v3,c1,c2,c3,pol,pol2,psa,tsa,exs,depth)
double *v1;
double *v2;
double *v3;
double c1;
double c2;
double c3;
double pol;
double pol2;
double *psa;
double *tsa;
double *exs;
int depth;
{

   double v12[3], v23[3], v31[3], val[3], c12,c23,c31, ctot, fr, s;
   int i, ires;

   ires = 0;
   ctot = 0.0;

   if (c1 > pol)  {ires++;ctot=ctot+(c1-pol);}
   if (c2 > pol)  {ires++;ctot=ctot+(c2-pol);}
   if (c3 > pol)  {ires++;ctot=ctot+(c3-pol);}
   if (ires) ctot = ctot / (double) ires;

   if (!ires) {
	ctot = 0.0;
	if (c1 < pol2)  {ires++;ctot=ctot+(c1-pol2);}
	if (c2 < pol2)  {ires++;ctot=ctot+(c2-pol2);}
	if (c3 < pol2)  {ires++;ctot=ctot+(c3-pol2);}
	if (ires) ctot = ctot / (double) ires;
   }

/*
   if (c1 < pol)  ires++;
   if (c2 < pol)  ires++;
   if (c3 < pol)  ires++;
*/

   fr = (double) ires / 3.0;

   if (ires == 3 || !depth) {
        s = calsrf(v1,v2,v3);
	*psa = *psa + fr*s;
	*tsa = *tsa + s;
	*exs = *exs + fabs(fr*s*ctot);
	return;

   } else {

	for (i = 0; i < 3; i++) {

	   v12[i] = (v1[i] + v2[i]) / 2.0;
	   v23[i] = (v2[i] + v3[i]) / 2.0;
	   v31[i] = (v3[i] + v1[i]) / 2.0;
	}

	c12 = (c1 + c2) / 2.0;
	c23 = (c2 + c3) / 2.0;
	c31 = (c3 + c1) / 2.0;

	subdivide(v1, v12, v31, c1, c12, c31, pol, pol2, psa, tsa, exs, depth-1);
	subdivide(v2, v23, v12, c2, c23, c12, pol, pol2, psa, tsa, exs, depth-1);
	subdivide(v3, v31, v23, c3, c31, c23, pol, pol2, psa, tsa, exs, depth-1);
	subdivide(v12, v23, v31, c12, c23, c31, pol, pol2, psa, tsa, exs, depth-1);

   }

}

#if defined(VMS) || defined(UNDERSC)
void calpsa(v,cval,pol,pol2,psa,tsa,exs,depth)
#else
#ifdef CRAY
void CALPSA(v,cval,pol,pol2,psa,tsa,exs,depth)
#else
void calpsa_(v,cval,pol,pol2,psa,tsa,exs,depth)
#endif
#endif
double v[3][3];
double *cval;
double *pol;
double *pol2;
double *psa;
double *tsa;
double *exs;
int *depth;
{
   double v1[3], v2[3], v3[3];
   int i;
  
   for (i = 0; i < 3; i++) {
	v1[i] = v[0][i];
	v2[i] = v[1][i];
	v3[i] = v[2][i];
   }
   subdivide(v1,v2,v3,cval[0],cval[1],cval[2],*pol,*pol2,psa,tsa,exs,*depth);

}

#if defined(VMS) || defined(UNDERSC)
void tstpsa(cval,pol,pol2,ires)
#else
#ifdef CRAY
void TSTPSA(cval,pol,pol2,ires)
#else
void tstpsa_(cval,pol,pol2,ires)
#endif
#endif
double *cval;
double *pol;
double *pol2;
int *ires;
{
   *ires = 0;

   if (cval[0] > *pol)  (*ires)++;
   if (cval[1] > *pol)  (*ires)++;
   if (cval[2] > *pol)  (*ires)++;

   if (! *ires) {
	if (cval[0] < *pol2)  (*ires)++;
	if (cval[1] < *pol2)  (*ires)++;
	if (cval[2] < *pol2)  (*ires)++;
   }

/*
   if (fabs(cval[0]) > *pol)  (*ires)++;
   if (fabs(cval[1]) > *pol)  (*ires)++;
   if (fabs(cval[2]) > *pol)  (*ires)++;
*/

}

#define X .525731112119133606 
#define Z .850650808352039932
#define SCV 2.0

 

static double icosa[12][3] = {    

   {-X, 0.0, Z}, {X, 0.0, Z}, {-X, 0.0, -Z}, {X, 0.0, -Z},    

   {0.0, Z, X}, {0.0, Z, -X}, {0.0, -Z, X}, {0.0, -Z, -X},    

   {Z, X, 0.0}, {-Z, X, 0.0}, {Z, -X, 0.0}, {-Z, -X, 0.0} 

};

static int tricnt = 0;
static int curat = 0;
static int *idoa = NULL;
static int *ipola = NULL;
static int *nats;
static int *nata;
static double *vpcm;
static double icofi[1280][3][3];

static int icoind[20][3] = { 

   {0,4,1}, {0,9,4}, {9,5,4}, {4,5,8}, {4,8,1},    

   {8,10,1}, {8,3,10}, {5,3,8}, {5,2,3}, {2,7,3},    

   {7,10,3}, {7,6,10}, {7,11,6}, {11,0,6}, {0,1,6}, 

   {6,1,10}, {9,0,11}, {9,11,2}, {9,2,5}, {7,2,11} };

void normalize(v)     
double *v;
{
   double d;

   d = sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); 

   if (d != 0.0) {

	v[0] /= d; v[1] /= d; v[2] /= d; 

   }


}

void subd(v1,v2,v3,depth)
double *v1;
double *v2;
double *v3;
int depth;
{

   double v12[3], v23[3], v31[3];
   int i;

   if (!depth) {
	for (i = 0; i < 3; i++) {
           icofi[tricnt][0][i] = v1[i];
           icofi[tricnt][1][i] = v2[i];
           icofi[tricnt][2][i] = v3[i];
	}
	tricnt++;
	if (tricnt > 1280) 
	   fprintf(stderr,"more triangles than storage allocated\n");

	return;

   } else {

	for (i = 0; i < 3; i++) {

	   v12[i] = (v1[i] + v2[i]) / 2.0;
	   v23[i] = (v2[i] + v3[i]) / 2.0;
	   v31[i] = (v3[i] + v1[i]) / 2.0;
	}

	normalize(v12);
	normalize(v23);
	normalize(v31);

	subd(v1, v12, v31, depth-1);
	subd(v2, v23, v12, depth-1);
	subd(v3, v31, v23, depth-1);
	subd(v12, v23, v31, depth-1);

   }

}

int isfree(v1,v2,vr)
double *v1;
double *v2;
double vr;
{
  double dx,d2;
  int i;
 
  d2 = 0.0;

  for (i = 0; i < 3; i++) {
	dx = v1[i] - v2[i];
	d2 = d2 + dx*dx;
  }

  if (d2 < vr*vr) return(0);
  return(1);
  
}

int verfree(v1,v2,v3)
double *v1;
double *v2;
double *v3;
{
   int i,j, icnt, icnt1,icnt2,icnt3;
   double vr;

   icnt1 = 1;
   icnt2 = 1;
   icnt3 = 1;

   for (i=0; i < *nats; i++ ) {
	if (i != curat && idoa[i]) {
	    vr = vpcm[nata[i]-1];
	    if (nata[i] == 1 && ipola[i] == 2) vr = 1.125 / (double) toangs;
	    if (nata[i] == 1 && ipola[i] == 3) vr = 1.1 / (double) toangs;
	    if (denmode) {
		if (!isfree(v1,&XYZ->xyz[i][0],vr)) icnt1 = 0; 
		if (!isfree(v2,&XYZ->xyz[i][0],vr)) icnt2 = 0; 
		if (!isfree(v3,&XYZ->xyz[i][0],vr)) icnt3 = 0; 
	    } else {
		if (!isfree(v1,&xyzp->coo[i*3],vr)) icnt1 = 0; 
		if (!isfree(v2,&xyzp->coo[i*3],vr)) icnt2 = 0; 
		if (!isfree(v3,&xyzp->coo[i*3],vr)) icnt3 = 0; 
	    }
	}
   }

   icnt = icnt1 + icnt2 + icnt3;
   return(icnt);
}

void subd2(v1,v2,v3,psa,depth)
double *v1;
double *v2;
double *v3;
double *psa;
int depth;
{

   double v12[3], v23[3], v31[3], fr, s;
   double colr[3] = {1.0,0.0,0.0};
   double colg[3] = {0.0,1.0,0.0};
   double colb[3] = {0.0,0.0,1.0};
   double *col;
   int i,j, ires;

   ires = verfree(v1,v2,v3);

   fr = (double) ires / 3.0;

   if (ires == 0 && !depth) return;

   if (ires == 3 || !depth) {
        s = calsrf(v1,v2,v3);
	*psa = *psa + fr*s;

	if (ipola[curat] >= 2) {
	    col = colb;
	} else if (ipola[curat] == 1) {
	    col = colr;
	} else {
	    col = colg;
	}
	for (j = 0; j < 3; j++) {
	   if (denmode) {
		v12[j] = XYZ->xyz[curat][j] - v1[j];
	   } else {
		v12[j] = xyzp->coo[curat*3+j] - v1[j];
	   }
	}
	normalize(v12);
#if defined(VMS) || defined(UNDERSC)
	ogcoll(&col[0],&col[1],&col[2]);
	ognrm(&v12[0],&v12[1],&v12[2]);
	ogvrt(&v1[0],&v1[1],&v1[2]);
#else
#ifdef CRAY
	OGCOLL(&col[0],&col[1],&col[2]);
	OGNRM(&v12[0],&v12[1],&v12[2]);
	OGVRT(&v1[0],&v1[1],&v1[2]);
#else
	ogcoll_(&col[0],&col[1],&col[2]);
	ognrm_(&v12[0],&v12[1],&v12[2]);
	ogvrt_(&v1[0],&v1[1],&v1[2]);
#endif
#endif

	for (j = 0; j < 3; j++) {
	   if (denmode) {
		v12[j] = XYZ->xyz[curat][j] - v2[j];
	   } else {
		v12[j] = xyzp->coo[curat*3+j] - v2[j];
	   }
	}
	normalize(v12);
#if defined(VMS) || defined(UNDERSC)
	ogcoll(&col[0],&col[1],&col[2]);
	ognrm(&v12[0],&v12[1],&v12[2]);
	ogvrt(&v2[0],&v2[1],&v2[2]);
#else
#ifdef CRAY
	OGCOLL(&col[0],&col[1],&col[2]);
	OGNRM(&v12[0],&v12[1],&v12[2]);
	OGVRT(&v2[0],&v2[1],&v2[2]);
#else
	ogcoll_(&col[0],&col[1],&col[2]);
	ognrm_(&v12[0],&v12[1],&v12[2]);
	ogvrt_(&v2[0],&v2[1],&v2[2]);
#endif
#endif

	for (j = 0; j < 3; j++) {
	   if (denmode) {
		v12[j] = XYZ->xyz[curat][j] - v3[j];
	   } else {
		v12[j] = xyzp->coo[curat*3+j] - v3[j];
	   }
	}
	normalize(v12);
#if defined(VMS) || defined(UNDERSC)
	ogcoll(&col[0],&col[1],&col[2]);
	ognrm(&v12[0],&v12[1],&v12[2]);
	ogvrt(&v3[0],&v3[1],&v3[2]);
#else
#ifdef CRAY
	OGCOLL(&col[0],&col[1],&col[2]);
	OGNRM(&v12[0],&v12[1],&v12[2]);
	OGVRT(&v3[0],&v3[1],&v3[2]);
#else
	ogcoll_(&col[0],&col[1],&col[2]);
	ognrm_(&v12[0],&v12[1],&v12[2]);
	ogvrt_(&v3[0],&v3[1],&v3[2]);
#endif
#endif

	return;

   } else {

	for (i = 0; i < 3; i++) {

	   v12[i] = (v1[i] + v2[i]) / 2.0;
	   v23[i] = (v2[i] + v3[i]) / 2.0;
	   v31[i] = (v3[i] + v1[i]) / 2.0;
	}

	subd2(v1, v12, v31, psa, depth-1);
	subd2(v2, v23, v12, psa, depth-1);
	subd2(v3, v31, v23, psa, depth-1);
	subd2(v12, v23, v31, psa, depth-1);

   }

}


double icosah(coo,scl)
double *coo;
double scl;
{
   int i,j;
   double v1[3], v2[3], v3[3], psa, d2, dx, vr, vr2;

   psa = 0.0;

   vr = scl;

   for (i=0; i < *nats; i++ ) {
	d2 = 0.0;
	for (j = 0; j < 3; j++) {
	   if (denmode) {
	      dx = coo[j] - XYZ->xyz[i][j];
	   } else {
	      dx = coo[j] - xyzp->coo[i*3+j];
	   }
	   d2 = d2 + dx*dx;
	}
	vr2 = vpcm[nata[i]-1];
	if (nata[i] == 1 && ipola[i] == 2) vr2 = 1.125 / (double) toangs;
	if (nata[i] == 1 && ipola[i] == 3) vr2 = 1.1 / (double) toangs;
	vr2 = vr2 + vr;
	idoa[i] = 0;
	if (d2 < vr2*vr2) idoa[i] = 1;
   }

   for (i = 0; i < 1280; i++) {    
	for (j = 0; j < 3; j++) {    
	   v1[j] = coo[j] + scl*icofi[i][0][j];
	   v2[j] = coo[j] + scl*icofi[i][1][j];
	   v3[j] = coo[j] + scl*icofi[i][2][j];
	}
	subd2(v1, v2, v3, &psa, 3);
   }
   fprintf(stderr,"psa atom %4d: %8.3f\n",curat+1,psa);
   return(psa);
}

#if defined(VMS) || defined(UNDERSC)
void tpsa()
#else
#ifdef CRAY
void TPSA()
#else
void tpsa_()
#endif
#endif
{
   int i,j,k, ichain, mapped, oglon;
   double psa,tsa,vr, vr2, v1[3],v2[3],v3[3],dx,d2,s;
   char *namestr = "Topol. Pol. surface";
  
   if (denmode) {
	nats = &NAT->natoms;
	nata = NAT->nat;
   } else {
	nats = xyzp->iatoms;
	nata = xyzp->ianz;
   }

   ichain = -1;
   mapped = 1;
   tsa = 0.0;
   psa = 0.0;

   tricnt = 0;

   for (i = 0; i < 20; i++) {    

	for (j = 0; j < 3; j++) {    
	   v1[j] = icosa[icoind[i][0]][j];
	   v2[j] = icosa[icoind[i][1]][j];
	   v3[j] = icosa[icoind[i][2]][j];
	}
	subd(v1, v2, v3, 3);

   }

   if ((idoa = (int *) malloc((sizeof i)*(*nats))) == NULL) {
	fprintf(stderr,"failed to allocate memory\n");
	return;
   }

   if ((ipola = (int *) malloc((sizeof i)*(*nats))) == NULL) {
	fprintf(stderr,"failed to allocate memory\n");
	return;
   }

   if ((vpcm = (double *) malloc((sizeof vr)*MXEL)) == NULL) {
	fprintf(stderr,"failed to allocate memory\n");
	return;
   }

   for (i=0; i < MXEL; i++ ) {
	vpcm[i] = SCV*elmptr->vdwr[i]/(double) toangs;
   }

   vpcm[0] = 1.5 / (double) toangs;
   vpcm[5] = 1.92 / (double) toangs;
   vpcm[6] = 1.82 / (double) toangs;
   vpcm[7] = 1.74 / (double) toangs;

   for (i=0; i < *nats; i++ ) {
	ipola[i] = 0;
	if (nata[i] == 8 || nata[i] == 7) ipola[i] = 1;
	if (nata[i] == 1) {
	   vr = elmptr->vdwr[nata[i]-1]/(double) toangs;
	   for (j=0; j < *nats; j++ ) {
		d2 = 0.0;
		for (k = 0; k < 3; k++) {
		   if (denmode) {
			dx = XYZ->xyz[j][k] - XYZ->xyz[i][k];
		   } else {
			dx = xyzp->coo[j*3+k] - xyzp->coo[i*3+k];
		   }
		   d2 = d2 + dx*dx;
		}
		vr2 = elmptr->vdwr[nata[j]-1]/(double) toangs;
		vr2 = vr2 + vr;
		if (d2 < vr2*vr2 && nata[j] == 7) ipola[i] = 2;
		if (d2 < vr2*vr2 && nata[j] == 8) ipola[i] = 3;
	   }
	}
   }


/*
  SCV scale vdw radii to be compatible with publication by Palm
  they took their radii from PCmodel
*/

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
   ogbegg(&ichain,&ZERO,&THREE,&i,&tsa,&mapped,namestr);
#else
#ifdef CRAY
   CURS(&ONE);
   OGBEGG(&ichain,&ZERO,&THREE,&i,&tsa,&mapped,namestr);
#else
   curs_(&ONE);
   ogbegg_(&ichain,&ZERO,&THREE,&i,&tsa,&mapped,namestr);
#endif
#endif

   for (i=0; i < *nats; i++ ) {
	curat = i;
	vr = vpcm[nata[i]-1];
	if (nata[i] == 1 && ipola[i] == 2) vr = 1.125 / (double) toangs;
	if (nata[i] == 1 && ipola[i] == 3) vr = 1.1 / (double) toangs;
	if (denmode) {
	   s = icosah(&XYZ->xyz[i][0],vr);
	} else {
	   s = icosah(&xyzp->coo[i*3],vr);
	}
	tsa = tsa + s;
	if (ipola[i]) psa = psa + s;
   }

#if defined(VMS) || defined(UNDERSC)
   ogendd(&ichain);
   curs(&ZERO);
#else
#ifdef CRAY
   OGENDD(&ichain);
   CURS(&ZERO);
#else
   ogendd_(&ichain);
   curs_(&ZERO);
#endif
#endif
   fprintf(stderr,"\nTotal Topological Polar Surface Area: %8.3f\n",psa);
   fprintf(stderr,"Total surface: %8.3f\n",tsa);

   free(ipola);
   free(idoa);
   free(vpcm);
   ipola = NULL;
   idoa = NULL;
   vpcm = NULL;

#ifdef DOGL
   oglon = (*fancy || *fullgl);
   if (denmode) oglon = *ifdogl;
   if (oglon && has_opengl) dispsf();
#endif
}

/*
mxpeak 2^^mxcpl
*/


void fndhnmr(iat,jcut,hcont,ncont)
int iat;
float jcut;
int *hcont;
int *ncont;
{
    int i,j,k,l,jat;
    float jc,nuc1;

    *ncont = 0;
    nuc1 = (float) nmrptr->nucshld[iat];

    jat = -1;
    for (i=0; i < xyzp->iconn[iat*(MXCON+1)]; i++) {
	jat = xyzp->iconn[iat*(MXCON+1)+i+1] - 1;
	if (jat >= 0) break;
    }
    if (jat < 0) return;

    for (i=0; i < xyzp->iconn[jat*(MXCON+1)]; i++) {
	j = xyzp->iconn[jat*(MXCON+1)+i+1];
	if (j >= 0) {
	    if (xyzp->ianz[j-1] == 1) {
		if (j-1 > iat) {
		   jc = (float) jcoupl[(j-1)*NAT->natoms + iat];
		} else {
		   jc = (float) jcoupl[iat*NAT->natoms + j-1];
		}
		if (ABS(jc) > jcut && nuc1 != (float) nmrptr->nucshld[j-1]) {
		   hcont[*ncont] = j - 1;
		   (*ncont)++;
		}
	    } else {
		for (k=0; k < xyzp->iconn[(j-1)*(MXCON+1)]; k++) {
		   l = xyzp->iconn[(j-1)*(MXCON+1)+k+1];
		   if (l >= 0 && l != jat) {
			if (xyzp->ianz[l-1] == 1) {
			    if (l-1 > iat) {
				jc = (float) jcoupl[(l-1)*NAT->natoms + iat];
			    } else {
				jc = (float) jcoupl[iat*NAT->natoms + l-1];
			    }
			    if (ABS(jc) > jcut && nuc1 != (float) nmrptr->nucshld[l-1]) {
				hcont[*ncont] = l - 1;
				(*ncont)++;
			    }
			}
		   }
		}
	    }
	}
    }
}

void javch3(ih)
int *ih;
{
    int i,j,jj;
    double jav;

    for (i=0; i < NAT->natoms; i++) {
	jav = 0.0;
	for (j=0; j < 3; j++) {
		if (ih[j] > i) {
		   jav = jav + jcoupl[ih[j]*NAT->natoms + i];
		} else {
		   jav = jav + jcoupl[i    *NAT->natoms + ih[j]];
		}
	}
	jav = jav / 3.0;
	for (j=0; j < 3; j++) {
		if (ih[j] > i) {
		   jcoupl[ih[j]*NAT->natoms + i]     = jav;
		} else {
		   jcoupl[i    *NAT->natoms + ih[j]] = jav;
		}
	}
    }
}

void avch3()
{
    int i,j,jj,nh,ih[3];
    double nucav;

    for (i=0; i < NAT->natoms; i++) {

	if (xyzp->ianz[i] == 6) {

	    nh = 0;
	    nucav = 0.0;

	    for (j=0; j < xyzp->iconn[i*(MXCON+1)]; j++) {

		jj = xyzp->iconn[i*(MXCON+1)+j+1]-1;
		if (jj >= 0) {
		   if (xyzp->ianz[jj] == 1) {
			ih[nh] = jj;
			nh++;
			nucav = nucav + nmrptr->nucshld[jj];
		   }
		}
	    }
	    if (nh == 3) {
		nucav = nucav / 3.0;
	        for (j=0; j < nh; j++) nmrptr->nucshld[ih[j]] = nucav;
		javch3(ih);
	    }
	}
    }
}

void nmrsplit(tpeaks,tinten,npeaks,splt)
float *tpeaks;
double *tinten;
int *npeaks;
float splt;
{
  int i,j,ntp; 
  float tp;
  double ti;

  ntp = *npeaks;

  for (i=0; i < *npeaks; i++) {
	tp = tpeaks[i];
	ti = tinten[i]/2.0;
	tpeaks[i] = tp + splt;
	tinten[i] = ti;
	tpeaks[ntp] = tp - splt;
	tinten[ntp] = ti;
	ntp++;
  }
  *npeaks = ntp;
}

void prep_nmr() {

  int i, j, ncl_peaks,npeaks,cl_peaks[mxcpl];
  float f, splt;
  float tpeaks[mxpeak];
  double d,tinten[mxpeak];

  NMRup = 1;

  if (peaks == NULL) {
     if ((peaks = (float *) malloc((sizeof f)*NAT->natoms*mxpeak)) == NULL) {
	fprintf(stderr, "Memory allocation error for nmr spectrum\n");
	return;
     }

     if ((inten = (double *) malloc((sizeof d)*NAT->natoms*mxpeak)) == NULL) {
	fprintf(stderr, "Memory allocation error for nmr spectrum\n");
	return;
     }
  }

  npks = 0;

  for (i=0; i < NAT->natoms; i++) {

    if (xyzp->ianz[i] == NMRnuc) {

	tpeaks[0] = *nmrref - (float) nmrptr->nucshld[i];
	tinten[0] = 1.0;
	npeaks = 1;

	if (NMRnuc == 1 && nmrptr->ihsnmr == 2) {
	    fndhnmr(i,jcut,cl_peaks,&ncl_peaks);
	    for (j=0; j < ncl_peaks; j++) {

		if (cl_peaks[j] > i) {
		    splt = (float) jcoupl[cl_peaks[j]*NAT->natoms + i]/NMRbas;
		} else {
		    splt = (float) jcoupl[i*NAT->natoms + cl_peaks[j]]/NMRbas;
		}

		nmrsplit(tpeaks,tinten,&npeaks,splt);
	    }
	}

	for (j=0; j < npeaks; j++) {
	   peaks[npks] = tpeaks[j];
	   inten[npks] = tinten[j];
           npks++;
	}
    }
  }

}

void click_nmr_spec(indx) 
int indx;
{
    int i,iat;
    float frq,dfrq,dfrqmn;

    if (indx < 0 || indx >= NAT->natoms*mxpeak) return;

    frq = spfrq[indx];
    dfrqmn = 10000.0;
    iat = -1;
   
    for (i=0; i < NAT->natoms; i++) {
	if (xyzp->ianz[i] == NMRnuc) {
	    dfrq = ABS(frq - (*nmrref - (float) nmrptr->nucshld[i]));
	    if (dfrq < dfrqmn) {
		dfrqmn = dfrq;
		iat = i;
	    }
	}
    }

    if (iat != -1) {
	for (i=0; i < NAT->natoms; i++) xyzp->iaton[i] = 1;

	for (i=0; i < NAT->natoms; i++) {
	    if (xyzp->ianz[i] == NMRnuc) {
		dfrq = ABS(frq - (*nmrref - (float) nmrptr->nucshld[i]));
		if (dfrq == dfrqmn) {
		    xyzp->iaton[i] = 3;
		}
	    }
	}

	update_sel = 1;
	update_model = 0;
	update_struct();
    }

}

void FRQextr()
{
    int i;

    min_freq = 100000;
    max_freq = -100000;
    for (i=0; i < npks; i++) {
	   if (spfrq[i] < min_freq) min_freq = (int) spfrq[i];
	   if (spfrq[i] > max_freq) max_freq = (int) spfrq[i];
    }
    if (min_freq > 0) min_freq = 0;

    if (spmode) {
	if (max_freq < 220) max_freq = 220;
    } else {
	if (max_freq < 10) max_freq = 10;
    }
}

void getrad(t,coo,iatoms,dret)
double *t;
double* coo;
int *iatoms;
double *dret;
{
   double d2,dx,dmx;
   int j,k;

   dmx = 0.0;

   for (j=0; j < *iatoms; j++ ) {
	d2 = 0.0;
	for (k = 0; k < 3; k++) {
	    dx = t[k] - coo[j*3+k];
	    d2 = d2 + dx*dx;
	}
	if (d2 > dmx) dmx = d2;
   }
   dmx = sqrt(dmx);
   *dret = dmx;
}

/*
prtcad_()
{
   prtcal_(calfptr->icalf,&calfptr->ncalf,calfptr->ianf,calfptr->islu,
	&calfptr->nchain,calfptr->iamino,calfptr->isal);
}
*/

void setiat(int iatoms)
{
#if defined(VMS) || defined(UNDERSC)
   setatms(&iatoms);
#else
#ifdef CRAY
   SETATMS(&iatoms);
#else
   setatms_(&iatoms);
#endif
#endif
}

void prt_(iop,iatoms)
int *iop;
int *iatoms;
{
   int i,it,j,k;

   fprintf(stderr,"%d iatoms %d \n",*iop,*iatoms);
/*
   it = calfptr->icalf[12][0]-1;
   fprintf(stderr,"%d icalf(1,13) %d coo %f  %f %f\n",*iop,it+1,
			xyzp->coo[it*3],xyzp->coo[it*3+1],
			xyzp->coo[it*3+2]);
   fprintf(stderr,"%d ATMsel %d coo %f  %f %f\n",*iop,ATMsel+1,
			xyzp->coo[ATMsel*3],xyzp->coo[ATMsel*3+1],
			xyzp->coo[ATMsel*3+2]);
*/
   
}

#ifdef DOGL

void DrCircle(int cx,int cy,float r,int nseg) 
{ 
	float c,s,t,x,y,angle;
	int i;
    
	angle = 2*3.1415926 / (float) nseg; 
	c = cosf(angle);
	s = sinf(angle);

	if (*persp) {
	   x = 0.5*height*r/(float) posptr->zv;
	} else {
	   x = 0.5*height*r/(float) scalptr->scal;
	}

        y = 0;

	glMatrixMode (GL_MODELVIEW);
	glLoadIdentity();
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, width, 0.0, height);
	glDisable(GL_LIGHTING);           
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_COLOR_MATERIAL);
	glLineStipple(4,0xAAAA);
	glEnable(GL_LINE_STIPPLE);

        glColor3f(1.0, 1.0, 1.0);
	glBegin(GL_LINE_LOOP); 

	for(i = 0; i < nseg; i++) { 
	   glVertex2f(x + (float) cx,height - (y + (float) cy));
        
	   t = x;
	   x = c * x - s * y;
	   y = s * t + c * y;
	} 

	glEnd(); 
	glDisable(GL_LINE_STIPPLE);
}

void rubber(iopt)
int iopt;
{
   GLfloat x1,y1,x2,y2;
   int v2dx,v2dy;

   glDisable(GL_LIGHTING);           
   glDisable(GL_DEPTH_TEST);         
   glDepthMask(GL_FALSE);            

   glLineWidth(1.0);

   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();

   gluOrtho2D(-1.0, 1.0, -1.0, 1.0);
   glRasterPos2f(-1.0,-1.0);

   if (iopt) {
	v2dx = width;
	v2dy = height;
   } else {
	v2dx = width;
	v2dy = width;
	if (v2dx > height) {
	   v2dx = height;
	   v2dy = height;
	}
   }

   glReadBuffer(GL_BACK);
   glDrawBuffer(GL_FRONT);
   glCopyPixels(0,0,v2dx,v2dy,GL_COLOR);
   glFlush();

   x1 = 2.0*((float) ZoomX1/(float) v2dx) - 1.0;
   y1 = 2.0*((float) (v2dy - ZoomY1 )/(float) v2dy) - 1.0;
   x2 = 2.0*( ((float) ZoomX1 + (float) ZoomW)/(float) v2dx) - 1.0;
   y2 = 2.0*( ((float) v2dy - (float) ZoomY1 - (float) ZoomH) /(float) v2dy) - 1.0;
   glDisable(GL_COLOR_MATERIAL);

   if (StarNet) {
	   theDens = glGenLists(1);
	   glNewList(theDens, GL_COMPILE_AND_EXECUTE);
   }

   glBegin(GL_LINE_LOOP);
   glColor3f(1.0f, 1.0f, 1.0f);
   glVertex2f(x1,y1);
   glVertex2f(x2,y1);
   glVertex2f(x2,y2);
   glVertex2f(x1,y2);
   glVertex2f(x1,y1);
   glEnd();

   if (StarNet) {
	glEndList();
	glDeleteLists(theDens,1);
   }

   glFlush();
   glDrawBuffer(GL_BACK);

   glEnable(GL_DEPTH_TEST);           
   glDepthMask(GL_TRUE);              
   glEnable(GL_LIGHTING);             

   glMatrixMode (GL_PROJECTION);
   glPopMatrix();                     
   glMatrixMode(GL_MODELVIEW);
   glPopMatrix();                     

}

void plcnrm()
{
   int isrf,i,j;
   float n[3],v[3];
   isrf = NSurf[istruct]-1;

   theNorm = glGenLists(1);
   glNewList(theNorm, GL_COMPILE);
   glDisable(GL_LIGHTING);
   glLineWidth(1.0);
   glEnable(GL_LINE_SMOOTH);
   glBegin(GL_LINES);

   for (i = 0; i < nvert[istruct][isrf]; i++) {
	if (srfvert[istruct][isrf][i].type == 1) {
	   v[0] = srfvert[istruct][isrf][i].vert[0];
	   v[1] = srfvert[istruct][isrf][i].vert[1];
	   v[2] = srfvert[istruct][isrf][i].vert[2];
	   glVertex3d(v[0],v[1],v[2]);
	   for (j = 0; j < 3; j++) v[j] = v[j] + n[j];
	   glVertex3d(v[0],v[1],v[2]);
/*	   fprintf(stderr,"1 %f %f %f\n",v[0],v[1],v[2]);*/
	} else {
	   n[0] = srfvert[istruct][isrf][i].vert[0];
	   n[1] = srfvert[istruct][isrf][i].vert[1];
	   n[2] = srfvert[istruct][isrf][i].vert[2];
/*	   fprintf(stderr,"0 %f %f %f\n",n[0],n[1],n[2]);*/
	}
   }

   glEnd();
   glEnable(GL_LIGHTING);
   glEndList();
}



typedef struct {
	unsigned char idLength;
	unsigned char colorMapType;
	unsigned char imageTypeCode;
	unsigned char colorMapSpec[5];
	unsigned short xOrigin;
	unsigned short yOrigin; 
	unsigned short width;
	unsigned short height;
	unsigned char bpp;
	unsigned char imageDesc;
} tga_header;

tga_header tgaheader;
static FILE *TGAFile;
unsigned char *imageData;

void Load_TGA(filename)
    char *filename;
{
    int i;
    unsigned int color_mode=GL_RGB;

    TGAFile = fopen(filename,"r");

    if (!TGAFile) {
	fprintf(stderr,"Output Error: Unable to read TGA file %s\n",filename);
	return;
    }

    if (fread((char *) &tgaheader, 18, 1, TGAFile) != 1)
       fprintf(stderr,"error reading header\n");

    int imageSize = tgaheader.width * tgaheader.height * (tgaheader.bpp/8);
    imageData = (unsigned char *) malloc(imageSize);
 
    fprintf(stderr,"tga: width %d height %d bpp %d\n",tgaheader.width,tgaheader.height,tgaheader.bpp);

    if (fread((char *) imageData, sizeof(char)*imageSize, 1, TGAFile) != 1) 
	fprintf(stderr,"error reading tga data\n");

    if (tgaheader.bpp == 24) {
	for (i = 0; i < imageSize; i+=3) {       
	   char c = imageData[i];
	   imageData[i] = imageData[i+2];
	   imageData[i+2] = c;
	}
    } else {
	if (tgaheader.bpp == 32) {
	   for (i = 0; i < imageSize; i+=4) {       
		char c = imageData[i];
		imageData[i] = imageData[i+2];
		imageData[i+2] = c;
	   }
	   color_mode = GL_RGBA;
	}
    }
 
    fclose(TGAFile);

    glGenTextures(1,(GLuint *) &rndid);
    glBindTexture(GL_TEXTURE_2D,rndid);

    glTexImage2D(GL_TEXTURE_2D,0,color_mode,tgaheader.width,tgaheader.height,
	0,color_mode,GL_UNSIGNED_BYTE,imageData);

}

#else
void plcnrm()
{
}
#endif


static float B1[3],B2[3],B3[3],ORI[3];
static float Bt1[3],Bt2[3],Bt3[3],ORI2[3];

typedef struct {
		int type;
		int n;
		float v1[3];
		float v2[3];
		float polar1;
		float polar2;
		float azimuth1;
		float azimuth2;
		float polarb1;
		float polarb2;
		float azimuthb1;
		float azimuthb2;
		float radius;
		float rp;
		float maxarc[2];
		float ene;
		float chgsc[2];
		float dissc[2];
		float angsc[3];
		float center[3];
		} AREASTRU;

#define EHBOND  -2.35
#define EVDW    -0.35
#define RHBOND1  1.9
#define RHBOND2  1.8
#define RVDW1    4.0
#define RVDW2    4.5
#define RVDW3    4.8
#define DELHBOND 1.2
#define DELVDW   1.6


static AREASTRU COOmin = {1,3,
			{-1.0,0.0,0.0},{0.0,1.0,0.0},
			-50.0,50.0,40.0,80.0,130.0,230.0,40.0,80.0,
			RHBOND2,RHBOND2,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{20.0,60.0,1.0},{0.0,0.0,0.0}};

static AREASTRU CO = {2,2,
			{-1.0,0.0,0.0},{0.0,0.0,0.0},
			0.0,70.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{5.0,70.0,1.0},{0.0,0.0,0.0}};

static AREASTRU ONH = {2,2,
			{-1.0,0.0,0.0},{0.0,0.0,0.0},
			0.0,70.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{0.0,50.0,0.6},{0.0,0.0,0.0}};

static AREASTRU NHP = {2,2,
			{-1.0,0.0,0.0},{0.0,0.0,0.0},
			0.0,40.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RHBOND2,RHBOND2,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{0.0,50.0,0.6},{0.0,0.0,0.0}};

static AREASTRU NARYL = {5,3,
			{-1.0,-1.0,0.0},{0.0,0.0,0.0},
			0.0,40.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{20.0,60.0,1.0},{0.0,0.0,0.0}};

static AREASTRU AMID1 = {5,3,
			{0.0,0.0,1.0},{0.0,0.0,0.0},
			0.0,35.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW1,RVDW1,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{0.6,1.0},
			{0.0,55.0,1.0},{0.5,0.0,0.0}};

static AREASTRU AMID2 = {5,3,
			{0.0,0.0,-1.0},{0.0,0.0,0.0},
			0.0,35.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW1,RVDW1,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{0.6,1.0},
			{0.0,55.0,1.0},{0.5,0.0,0.0}};

static AREASTRU NAMINO = {6,4,
			{-1.0,-1.0,-1.0},{0.0,0.0,0.0},
			0.0,40.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.0,0.0},{0.3,0.7},
			{20.0,60.0,1.0},{0.0,0.0,0.0}};

static AREASTRU SPH1 = {3,1,
			{0.0,0.0,0.0},{0.0,0.0,0.0},
			0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW1,RVDW1,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{-1.0,-1.0},
			{0.0,360.0,0.0},{0.0,0.0,0.0}};
static AREASTRU SPH2 = {3,1,
			{0.0,0.0,0.0},{0.0,0.0,0.0},
			0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW3,RVDW3,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{-1.0,-1.0},
			{0.0,360.0,0.0},{0.0,0.0,0.0}};
static AREASTRU CH3_PHE = {3,1,
			{0.0,0.0,0.0},{0.0,0.0,0.0},
			0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW2,RVDW1,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{0.6,1.0},
			{0.0,360.0,0.0},{0.0,0.0,0.0}};
static AREASTRU PHC1 = {4,3,
			{0.0,0.0,1.0},{0.0,0.0,0.0},
			0.0,70.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW2,RVDW2,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{0.6,1.0},
			{0.0,20.0,1.0},{0.5,0.0,0.0}};
static AREASTRU PHC2 = {4,3,
			{0.0,0.0,-1.0},{0.0,0.0,0.0},
			0.0,70.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW2,RVDW2,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{0.6,1.0},
			{0.0,20.0,1.0},{0.5,0.0,0.0}};
static AREASTRU PHR = {4,3,
			{-1.0,-1.0,0.0},{0.0,0.0,0.0},
			0.0,60.0,0.0,0.0,0.0,0.0,0.0,0.0,
			RVDW2,RVDW2,{DELVDW,DELVDW},EVDW,
			{1.0,0.0},{0.6,1.0},
			{0.0,30.0,1.0},{0.0,0.0,0.0}};
static AREASTRU OSP3 = {1,3,
			{1.0,0.0,0.0},{0.0,1.0,0.0},
			-80.0,80.0,80.0,150.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{0.0,40.0,0.6},{0.0,0.0,0.0}};
static AREASTRU OSP2 = {1,3,
			{1.0,0.0,0.0},{0.0,1.0,0.0},
			-60.0,60.0,90.0,160.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{0.0,40.0,0.6},{0.0,0.0,0.0}};
static AREASTRU COC = {7,3,
			{1.0,-1.0,0.0},{1.0,1.0,0.0},
			-80.0,80.0,55.0,125.0,0.0,0.0,0.0,0.0,
			RHBOND1,RHBOND1,{DELHBOND,DELHBOND},EHBOND,
			{1.766,-0.15},{0.3,0.7},
			{75.0,140.0,0.0},{0.0,0.0,0.0}};

#define H_ACC   0
#define H_DON   1
#define CH      2
#define CH2     3
#define CH3     4
#define PHE_CH3 5
#define ARO     6
#define AMIDE   7
#define SULFUR  8
#define PHENYL_CENTER  9
#define PHENYL_RING   10
#define METAL  11
#define METAL_ACC     12

// INCRSTRUC explanation:
//
// type: above are the possible values of the 'type' element defined
//
// area: area is the interaction geometry for the interaction
//
// npts: npts is the number of points in the interaction surface array
// points: pointer to the interaction surface array
//
// n = the number of atoms defining this interaction point
// atom[0-3] is the atoms index in the cooordinate array
// c[0-3][3] are the atoms coordinates
//
// for a ligand interaction point these are all defined by a call
// to AllInt()
// for a protein interaction point only the atom coordinates c[0-3][3] are set
// since the rest can be derived through the type element
//
// nfrag: the member 'n' determines the number of atoms thats is used to
//        define the interaction geometry. From this FrgInt() determines
//        the number of different fragments these atoms belong to (nfrag)
//
// frag[0-3]: the fragment index for the max 4 number of fragments


typedef struct {
		int type;
		AREASTRU area;
		int ohlig;
		int ohsame;
		double ORI[3];
		double c[4][3];
		double q0;
		double q1;
		double q2;
		double q3;
		int frag[4];
		int nfrag;
		int atom[4];
		int n;
		int npts;
		int link;
		int conf;
		int nconf;
		int ConfArr[200];
		int res;
		double *points;
		} INCRSTRU;

static INCRSTRU *inttyp[20000];
#define MAXLIGSTRU 10000
static INCRSTRU *ligtyp[MAXLIGSTRU];
static int nintp = 0;
static int lintp = 0;
static int lintconf = 0;
void cal_area(INCRSTRU *i);

typedef struct {
		float d;
		uint16_t grp1;
		uint16_t ind1;
		uint16_t pnt1;
		uint16_t grp2;
		uint16_t ind2;
		uint16_t pnt2;
		} CROSSSTRU;

typedef struct {
		int ind;
		int n;
		} HASHSTRU;

typedef struct {
		CROSSSTRU *XDist;
		int l;
		HASHSTRU *XHash;
		int n;
		} GRPSTRU;

#define MAXTRI 300000
#define MAXSTRI 50000
#define CLOSEC 1.0
#define CLUSRMS  0.1
#define VDWSCAL  0.01
#define MAXSOL  25

static float vdwscal = 1.0;

typedef struct {
		float d12;
		float d13;
		float d23;
		float p1[3];
		float p2[3];
		float p3[3];
		int lig[3];
		int ohlig[3];
		int grp[3];
		int atindx[3];
		int frag;
		int frags[3];
		int conf;
		int nconf;
		int ConfArr[200];
		int active;
		} TRISSTRU;

static TRISSTRU TriS[MAXSTRI];

static int ntriS = -1;

// p1c,p2c,p3c contains translated and rotated ligand interaction point 
// coordinates

// P1,P2,P3 contains original untranslated and unrotated ligand interaction 
// point coordinates

typedef struct {
		float d12;
		float d13;
		float d23;
		float p1[3];
		float p2[3];
		float p3[3];
		int lig[3];
		int ohlig[3];
		int prot[3];
		float p1c[3];
		float p2c[3];
		float p3c[3];
		float P1[3];
		float P2[3];
		float P3[3];
		float Cen[3];
		float Out[3];
		float CenO[3];
		float OutO[3];
		float OutOrg[3];
		float e12;
		float eint;
		float etot;
		int frag;
		int frags[3];
		int grp[3];
		int idx[3];
		int triS;
		int conf;
		int nconf;
		double *coo;
		double *oh[3];
		double t[3];
		double R1[4][4];
		double R2[4][4];
		} TRISTRU;

typedef struct {
		double *coo;
		} CARSTRU;

static TRISTRU Tri1;
static TRISTRU Tri2;
static TRISTRU *TriArr[MAXTRI];
static TRISTRU *TriFin[MAXSTRI];
static TRISTRU *TriArrCopy[MAXTRI];
static CARSTRU *TriC[MAXTRI];
static int ntris = -1;
static int ntrif = -1;

//  N = number of single bonds to rotate over
//  sng[1..N][0-1] two atoms of each single bond. Set in ProcLig
//  ityp gaff atom type of ligands atoms
//  NFRAG = number of fragments
//  ifrg[1..ndocka] = fragment number for each atom
//  SngFrg[1..N][0-1] the two atoms of each single bond, 
//                    the fragment number of each side [0] and [1]
//  FrgSngN[1..NFRAG] = number of rotatable bonds fragment is connected to
//  FrgSng[1..NFRAG][9] = for each fragment, the MAX 9 single bonds pointers
//                        the fragment is connected to
//  irsd[1..ndocka] = sp hybridisation number per atom, f.e. sp3 => 4
//                    SEE IHBT array
//  irng[1..ndocka] = is atom part of a ring =1

#define MXLIGA 1000
static int mxliga = MXLIGA;

typedef struct {
		int N;
		int NFRAG;
		int irsd[MXLIGA];
		int irng[MXLIGA];
		int jrng[MXLIGA];
		int ifrg[MXLIGA];
		int sng[MXLIGA][2];
		int dupsng[MXLIGA];
		int sngrot[MXLIGA];
		int SngFrg[MXLIGA][2];
		int FrgSng[MXLIGA][9];
		int FrgSngN[MXLIGA];
		int sngdone[MXLIGA];
		short int ityp[MXLIGA];
		} SNGSTRU;

static SNGSTRU singleb;

typedef struct {
		int i;
		int j;
		double dd;
		int stat;
		int *Arr;
		int N;
		} LDAT;

typedef struct {
		int Num;
		int *Arr;
		int N;
		int CC;
		} NNODE;

typedef struct node
{
    struct node *prev_node;
    LDAT info;
    struct node *next_node;
} node;
 
node *begin=NULL;

void ogAxs();
void ogAxs2();
void xyzROT4(double R[4][4],float *vt);
void RemCC_One(int L);
void RemCloseC_One(int L,int all);
void Frst_Rot(float *cc,float *uu,double sina,double cosa,double R[4][4]);
void Trans_Tri(TRISTRU *Tri1,TRISTRU *Tri2);
void PrtTrip(int indx,int ligind1,int ligind2);
float CalInt(int ind1,int ind2,double *points,double t[3],double R1[4][4],double R2[4][4],float *OutO, float *OutOrg, int deb);
void dsply_List(node *begin);
void set_List(node *begin,node **barr,int *N,int MXARR);
void replc_List(node *begin,int val,int nval);
void upd_List(node **barr,int *N,node *delnode);
struct node *addtoemptylist(node *begin,LDAT data_element);
struct node *addatendlist(node *begin,LDAT data_element);
struct node *insertdd(node *begin,node **barr,int *N,LDAT data_element);
struct node *deletenode(node *begin,node *delnode,LDAT *data_element,node **barr,int *N);
struct node *dlnode(node *begin,LDAT *data_element);

/* group R and RH */
static int GrpR[6] = {6,8,7,16,15,9};
static int GrpRH[] = {6,8,7,16,15,9,1};

static short int Cany[] = {7,6,5,8};
static short int C2ar[] = {8,6};
static short int Nany[] = {12,11,10,13,14,15,16};
static short int N2ar[] = {11,13};
static short int Nplan[] = {14,15};
static short int Oany[] = {18,17,19};
static short int Odbl[] = {18,19};
static short int Sany[] = {23,22,24,25};
static short int Aany[] = {11,13,15,6,8,23};
static short int DONG[] = {18,17,12,11,10,13,14,15,16};

static int MTXCOO1 = -1;
static int MTXCOO2 = -1;
static int MTXCO1 = -1;
static int MTXCO2 = -1;
static int MTXCO3 = -1;


static int isq[6][3] = { 0,1,3, 0,3,1, 1,0,3, 3,0,1, 1,3,0, 3,1,0};

static float gfvdw[MXGFF][2] = {
     {   0.0000, 0.0000},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.1094},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.9080, 0.0860},
     {   1.3870, 0.0157},
     {   1.2870, 0.0157},
     {   1.1870, 0.0157},
     {   1.4090, 0.0150},
     {   1.3590, 0.0150},
     {   1.4590, 0.0150},
     {   1.4870, 0.0157},
     {   0.6000, 0.0157},
     {   0.0000, 0.0000},
     {   0.6000, 0.0157},
     {   0.6000, 0.0157},
     {   0.0000, 0.0000},
     {   1.1000, 0.0157},
     {   1.75  , 0.061 },
     {   1.948 , 0.265 },
     {   2.22  , 0.320 },
     {   2.35  , 0.40  },
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.8240, 0.1700},
     {   1.6612, 0.2100},
     {   1.7210, 0.2104},
     {   1.6837, 0.1700},
     {   1.7683, 0.1520},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.1000, 0.2000},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   2.0000, 0.2500},
     {   1.9080, 0.0860} 
};

#define MXGTOR 638
#define MXTORS 4*NUMATM 

static int gftcon[MXGTOR][4] = {
     { 1, 2, 2, 1},
     { 1, 2, 3, 1},
     { 1, 2,13, 1},
     { 1, 2,14, 1},
     { 1, 2, 4, 1},
     { 1, 2,17, 1},
     { 1, 2,18, 1},
     { 1, 2,11, 1},
     { 1, 2,12, 1},
     { 1, 2, 5, 1},
     { 1, 2,15, 1},
     { 1, 2,16, 1},
     { 1, 2, 6, 1},
     { 1, 2, 9, 1},
     { 1, 2,10, 1},
     { 1, 2,36, 1},
     { 1, 2,38, 1},
     { 1, 2,43, 1},
     { 1, 2,44, 1},
     { 1, 2,45, 1},
     { 1, 2,46, 1},
     { 1, 2,41, 1},
     { 1, 2,48, 1},
     { 1, 2,50, 1},
     { 1, 2,51, 1},
     { 1, 2,58, 1},
     { 1, 2,53, 1},
     { 1, 2,58, 1},
     { 1, 2,59, 1},
     { 1, 2,60, 1},
     { 1, 2,61, 1},
     { 1, 2,54, 1},
     { 1, 2,55, 1},
     { 1, 2,62, 1},
     { 1, 2,56, 1},
     { 1, 2,63, 1},
     { 1, 2,68, 1},
     { 1, 2,69, 1},
     { 1, 2,66, 1},
     { 1, 2,70, 1},
     { 1, 2,67, 1},
     { 1, 2,71, 1},
     { 1, 3, 3, 1},
     { 1, 3,13, 1},
     { 1, 3,14, 1},
     { 1,13,13, 1},
     { 1,14,14, 1},
     { 1,13,14, 1},
     { 1, 3, 4, 1},
     { 1, 3, 5, 1},
     { 1, 3, 6, 1},
     { 1, 3, 9, 1},
     { 1, 3,10, 1},
     { 1, 3,11, 1},
     { 1, 3,12, 1},
     { 1, 3,17, 1},
     { 1, 3,18, 1},
     { 1, 3,15, 1},
     { 1, 3,16, 1},
     { 1, 3,36, 1},
     { 1, 3,38, 1},
     { 1, 3,39, 1},
     { 1, 3,40, 1},
     { 1, 3,41, 1},
     { 1, 3,42, 1},
     { 1, 3,43, 1},
     { 1, 3,44, 1},
     { 1, 3,45, 1},
     { 1, 3,46, 1},
     { 1, 3,47, 1},
     { 1, 3,48, 1},
     { 1, 3,50, 1},
     { 1, 3,51, 1},
     { 1, 3,53, 1},
     { 1, 3,57, 1},
     { 1, 3,58, 1},
     { 1, 3,59, 1},
     { 1, 3,60, 1},
     { 1, 3,61, 1},
     { 1, 3,54, 1},
     { 1, 3,55, 1},
     { 1, 3,62, 1},
     { 1, 3,56, 1},
     { 1, 3,63, 1},
     { 1, 3,65, 1},
     { 1, 3,68, 1},
     { 1, 3,69, 1},
     { 1, 3,66, 1},
     { 1, 3,70, 1},
     { 1, 3,67, 1},
     { 1, 3,71, 1},
     { 1, 4, 4, 1},
     { 1, 4,11, 1},
     { 1, 4,12, 1},
     { 1,11,12, 1},
     { 1,11,11, 1},
     { 1,12,12, 1},
     { 1, 9,10, 1},
     { 1, 9, 9, 1},
     { 1,10,10, 1},
     { 1, 4, 5, 1},
     { 1, 4, 6, 1},
     { 1, 4,36, 1},
     { 1, 4,38, 1},
     { 1, 4,45, 1},
     { 1, 4,46, 1},
     { 1,11,45, 1},
     { 1,12,46, 1},
     { 1, 4,43, 1},
     { 1, 4,44, 1},
     { 1, 9,44, 1},
     { 1,10,43, 1},
     { 1, 9,43, 1},
     { 1,10,44, 1},
     { 1, 4,39, 1},
     { 1, 4,40, 1},
     { 1, 4,41, 1},
     { 1, 9,41, 1},
     { 1,10,41, 1},
     { 1, 4,47, 1},
     { 1, 4,48, 1},
     { 1, 4,50, 1},
     { 1, 4,51, 1},
     { 1, 4,53, 1},
     { 1, 4,60, 1},
     { 1, 4,61, 1},
     { 1,11,61, 1},
     { 1,11,60, 1},
     { 1,12,61, 1},
     { 1, 4,58, 1},
     { 1, 4,59, 1},
     { 1, 9,58, 1},
     { 1, 9,59, 1},
     { 1,10,58, 1},
     { 1,10,59, 1},
     { 1, 4,54, 1},
     { 1, 4,55, 1},
     { 1,11,55, 1},
     { 1,12,55, 1},
     { 1, 4,62, 1},
     { 1,11,62, 1},
     { 1,12,62, 1},
     { 1, 4,56, 1},
     { 1,11,56, 1},
     { 1,12,56, 1},
     { 1, 4,63, 1},
     { 1,11,63, 1},
     { 1,12,63, 1},
     { 1, 4,68, 1},
     { 1, 4,69, 1},
     { 1, 4,66, 1},
     { 1,11,66, 1},
     { 1,12,66, 1},
     { 1, 4,70, 1},
     { 1,11,70, 1},
     { 1,12,70, 1},
     { 1, 4,67, 1},
     { 1,11,67, 1},
     { 1,12,67, 1},
     { 1, 4,71, 1},
     { 1,11,71, 1},
     { 1,12,71, 1},
     { 1, 5, 5, 1},
     { 1,15,15, 1},
     { 1,16,16, 1},
     { 1, 5, 6, 1},
     { 1, 5,36, 1},
     { 1,15,36, 1},
     { 1,16,36, 1},
     { 1, 5,38, 1},
     { 1, 5,45, 1},
     { 1, 5,46, 1},
     { 1, 5,39, 1},
     { 1, 5,40, 1},
     { 1, 5,41, 1},
     { 1, 5,47, 1},
     { 1, 5,48, 1},
     { 1, 5,50, 1},
     { 1, 5,51, 1},
     { 1, 5,53, 1},
     { 1, 5,60, 1},
     { 1, 5,61, 1},
     { 1, 5,54, 1},
     { 1, 5,55, 1},
     { 1, 5,62, 1},
     { 1, 5,56, 1},
     { 1, 5,63, 1},
     { 1, 5,68, 1},
     { 1, 5,69, 1},
     { 1, 5,66, 1},
     { 1, 5,70, 1},
     { 1, 5,67, 1},
     { 1, 5,71, 1},
     { 1, 5, 9, 1},
     { 1, 5,10, 1},
     { 1, 6, 6, 1},
     { 1, 6, 7, 1},
     { 1, 6, 8, 1},
     { 1, 7, 7, 1},
     { 1, 8, 8, 1},
     { 1, 6,36, 1},
     { 1, 6,38, 1},
     { 1, 6,45, 1},
     { 1, 6,46, 1},
     { 1, 6,40, 1},
     { 1, 6,41, 1},
     { 1, 6,42, 1},
     { 1, 6,43, 1},
     { 1, 6,44, 1},
     { 1, 6,47, 1},
     { 1, 9,47, 1},
     { 1,10,47, 1},
     { 1, 6,48, 1},
     { 1, 6,50, 1},
     { 1, 6,51, 1},
     { 1, 6,53, 1},
     { 1, 6,60, 1},
     { 1, 6,61, 1},
     { 1, 6,58, 1},
     { 1, 6,59, 1},
     { 1, 6,54, 1},
     { 1, 6,55, 1},
     { 1, 6,62, 1},
     { 1, 6,56, 1},
     { 1, 6,63, 1},
     { 1, 6,68, 1},
     { 1, 6,69, 1},
     { 1, 6,66, 1},
     { 1, 6,70, 1},
     { 1, 6,67, 1},
     { 1, 6,71, 1},
     { 1,36, 9, 1},
     { 1,36,10, 1},
     { 1,36,36, 1},
     { 1,36,38, 1},
     { 1,36,45, 1},
     { 1,36,46, 1},
     { 1,36,39, 1},
     { 1,36,40, 1},
     { 1,36,41, 1},
     { 1,36,43, 1},
     { 1,36,44, 1},
     { 1,36,47, 1},
     { 1,36,48, 1},
     { 1,36,50, 1},
     { 1,36,51, 1},
     { 1,36,53, 1},
     { 1,36,60, 1},
     { 1,36,61, 1},
     { 1,36,58, 1},
     { 1,36,59, 1},
     { 1,36,54, 1},
     { 1,36,55, 1},
     { 1,36,62, 1},
     { 1,36,56, 1},
     { 1,36,63, 1},
     { 1,36,68, 1},
     { 1,36,69, 1},
     { 1,36,66, 1},
     { 1,36,70, 1},
     { 1,36,67, 1},
     { 1,36,71, 1},
     { 1,37, 4, 1},
     { 1,37, 5, 1},
     { 1,37, 6, 1},
     { 1,37, 9, 1},
     { 1,37,10, 1},
     { 1,37,11, 1},
     { 1,37,12, 1},
     { 1,37,17, 1},
     { 1,37,18, 1},
     { 1,37,15, 1},
     { 1,37,16, 1},
     { 1,37,36, 1},
     { 1,37,37, 1},
     { 1,37,38, 1},
     { 1,37,39, 1},
     { 1,37,40, 1},
     { 1,37,41, 1},
     { 1,37,42, 1},
     { 1,37,43, 1},
     { 1,37,44, 1},
     { 1,37,45, 1},
     { 1,37,46, 1},
     { 1,37,47, 1},
     { 1,37,48, 1},
     { 1,37,50, 1},
     { 1,37,51, 1},
     { 1,37,53, 1},
     { 1,37,57, 1},
     { 1,37,58, 1},
     { 1,37,59, 1},
     { 1,37,60, 1},
     { 1,37,61, 1},
     { 1,37,54, 1},
     { 1,37,55, 1},
     { 1,37,62, 1},
     { 1,37,56, 1},
     { 1,37,63, 1},
     { 1,37,65, 1},
     { 1,37,68, 1},
     { 1,37,69, 1},
     { 1,37,66, 1},
     { 1,37,70, 1},
     { 1,37,67, 1},
     { 1,37,71, 1},
     { 1,38,38, 1},
     { 1,38,45, 1},
     { 1,38,46, 1},
     { 1,45,46, 1},
     { 1,45,45, 1},
     { 1,46,46, 1},
     { 1,43,43, 1},
     { 1,44,44, 1},
     { 1,43,44, 1},
     { 1,38,43, 1},
     { 1,38,44, 1},
     { 1,38,39, 1},
     { 1,45,39, 1},
     { 1,46,39, 1},
     { 1,38,40, 1},
     { 1,45,40, 1},
     { 1,46,40, 1},
     { 1,38,41, 1},
     { 1,45,41, 1},
     { 1,46,41, 1},
     { 1,41,43, 1},
     { 1,41,44, 1},
     { 1,38,47, 1},
     { 1,45,47, 1},
     { 1,46,47, 1},
     { 1,38,48, 1},
     { 1,45,48, 1},
     { 1,46,48, 1},
     { 1,38,50, 1},
     { 1,45,50, 1},
     { 1,46,50, 1},
     { 1,38,51, 1},
     { 1,45,51, 1},
     { 1,46,51, 1},
     { 1,43,51, 1},
     { 1,43,69, 1},
     { 1,38,53, 1},
     { 1,38,60, 1},
     { 1,38,61, 1},
     { 1,45,61, 1},
     { 1,38,58, 1},
     { 1,38,59, 1},
     { 1,43,53, 1},
     { 1,44,53, 1},
     { 1,43,58, 1},
     { 1,44,59, 1},
     { 1,44,58, 1},
     { 1,43,59, 1},
     { 1,45,60, 1},
     { 1,46,61, 1},
     { 1,38,54, 1},
     { 1,38,55, 1},
     { 1,45,55, 1},
     { 1,46,55, 1},
     { 1,38,56, 1},
     { 1,45,56, 1},
     { 1,46,56, 1},
     { 1,45,62, 1},
     { 1,46,62, 1},
     { 1,38,68, 1},
     { 1,45,68, 1},
     { 1,46,68, 1},
     { 1,38,69, 1},
     { 1,45,69, 1},
     { 1,46,69, 1},
     { 1,38,66, 1},
     { 1,45,70, 1},
     { 1,46,70, 1},
     { 1,38,67, 1},
     { 1,45,71, 1},
     { 1,46,71, 1},
     { 1,39,39, 1},
     { 1,39,40, 1},
     { 1,39,41, 1},
     { 1,39,47, 1},
     { 1,39,48, 1},
     { 1,39,50, 1},
     { 1,39,51, 1},
     { 1,39,53, 1},
     { 1,39,60, 1},
     { 1,39,61, 1},
     { 1,39,54, 1},
     { 1,39,55, 1},
     { 1,39,62, 1},
     { 1,39,56, 1},
     { 1,39,63, 1},
     { 1,39,68, 1},
     { 1,39,69, 1},
     { 1,39,66, 1},
     { 1,39,70, 1},
     { 1,39,67, 1},
     { 1,39,71, 1},
     { 1,40,40, 1},
     { 1,40,41, 1},
     { 1,40,47, 1},
     { 1,40,48, 1},
     { 1,40,50, 1},
     { 1,40,51, 1},
     { 1,40,53, 1},
     { 1,40,60, 1},
     { 1,40,61, 1},
     { 1,40,54, 1},
     { 1,40,55, 1},
     { 1,40,62, 1},
     { 1,40,56, 1},
     { 1,40,63, 1},
     { 1,40,68, 1},
     { 1,40,69, 1},
     { 1,40,66, 1},
     { 1,40,70, 1},
     { 1,40,67, 1},
     { 1,40,71, 1},
     { 1,41,41, 1},
     { 1,41,47, 1},
     { 1,41,48, 1},
     { 1,41,50, 1},
     { 1,41,51, 1},
     { 1,41,53, 1},
     { 1,41,60, 1},
     { 1,41,61, 1},
     { 1,41,54, 1},
     { 1,41,55, 1},
     { 1,41,62, 1},
     { 1,41,56, 1},
     { 1,41,63, 1},
     { 1,41,68, 1},
     { 1,41,69, 1},
     { 1,41,66, 1},
     { 1,41,70, 1},
     { 1,41,67, 1},
     { 1,41,71, 1},
     { 1,47,47, 1},
     { 1,47,48, 1},
     { 1,47,50, 1},
     { 1,47,51, 1},
     { 1,47,53, 1},
     { 1,47,60, 1},
     { 1,47,61, 1},
     { 1,47,54, 1},
     { 1,47,55, 1},
     { 1,47,62, 1},
     { 1,47,56, 1},
     { 1,47,63, 1},
     { 1,47,68, 1},
     { 1,47,69, 1},
     { 1,47,66, 1},
     { 1,47,70, 1},
     { 1,47,67, 1},
     { 1,47,71, 1},
     { 1,48,48, 1},
     { 1,48,50, 1},
     { 1,48,51, 1},
     { 1,48,53, 1},
     { 1,48,60, 1},
     { 1,48,61, 1},
     { 1,48,54, 1},
     { 1,48,55, 1},
     { 1,48,62, 1},
     { 1,48,56, 1},
     { 1,48,63, 1},
     { 1,48,68, 1},
     { 1,48,69, 1},
     { 1,48,66, 1},
     { 1,48,70, 1},
     { 1,48,67, 1},
     { 1,48,71, 1},
     { 1,50,50, 1},
     { 1,50,51, 1},
     { 1,50,53, 1},
     { 1,50,60, 1},
     { 1,50,61, 1},
     { 1,50,54, 1},
     { 1,50,55, 1},
     { 1,50,62, 1},
     { 1,50,56, 1},
     { 1,50,63, 1},
     { 1,50,68, 1},
     { 1,50,69, 1},
     { 1,50,66, 1},
     { 1,50,70, 1},
     { 1,50,67, 1},
     { 1,50,71, 1},
     { 1,51,51, 1},
     { 1,51,69, 1},
     { 1,51,68, 1},
     { 1,51,66, 1},
     { 1,51,70, 1},
     { 1,51,67, 1},
     { 1,51,71, 1},
     { 1,51,53, 1},
     { 1,51,60, 1},
     { 1,51,61, 1},
     { 1,51,54, 1},
     { 1,51,55, 1},
     { 1,51,62, 1},
     { 1,51,56, 1},
     { 1,51,63, 1},
     { 1,53,53, 1},
     { 1,53,60, 1},
     { 1,53,61, 1},
     { 1,53,58, 1},
     { 1,53,59, 1},
     { 1,60,60, 1},
     { 1,61,61, 1},
     { 1,58,58, 1},
     { 1,59,59, 1},
     { 1,58,59, 1},
     { 1,53,54, 1},
     { 1,60,54, 1},
     { 1,61,54, 1},
     { 1,53,55, 1},
     { 1,60,62, 1},
     { 1,61,62, 1},
     { 1,53,56, 1},
     { 1,60,63, 1},
     { 1,61,63, 1},
     { 1,53,68, 1},
     { 1,60,68, 1},
     { 1,61,68, 1},
     { 1,53,69, 1},
     { 1,60,69, 1},
     { 1,61,69, 1},
     { 1,53,66, 1},
     { 1,60,70, 1},
     { 1,61,70, 1},
     { 1,53,67, 1},
     { 1,60,71, 1},
     { 1,61,71, 1},
     { 1,54,54, 1},
     { 1,54,55, 1},
     { 1,54,62, 1},
     { 1,54,56, 1},
     { 1,54,63, 1},
     { 1,54,68, 1},
     { 1,54,69, 1},
     { 1,54,66, 1},
     { 1,54,70, 1},
     { 1,54,67, 1},
     { 1,54,71, 1},
     { 1,55,55, 1},
     { 1,62,62, 1},
     { 1,55,56, 1},
     { 1,62,63, 1},
     { 1,55,66, 1},
     { 1,62,70, 1},
     { 1,55,67, 1},
     { 1,62,71, 1},
     { 1,55,68, 1},
     { 1,62,68, 1},
     { 1,55,69, 1},
     { 1,62,69, 1},
     { 1,56,56, 1},
     { 1,63,63, 1},
     { 1,56,68, 1},
     { 1,63,68, 1},
     { 1,56,69, 1},
     { 1,63,69, 1},
     { 1,56,66, 1},
     { 1,63,70, 1},
     { 1,56,67, 1},
     { 1,63,71, 1},
     { 1,68,68, 1},
     { 1,68,69, 1},
     { 1,68,66, 1},
     { 1,68,70, 1},
     { 1,68,67, 1},
     { 1,68,71, 1},
     { 1,69,69, 1},
     { 1,69,66, 1},
     { 1,69,70, 1},
     { 1,69,67, 1},
     { 1,69,71, 1},
     { 1,66,66, 1},
     { 1,70,70, 1},
     { 1,66,67, 1},
     { 1,70,71, 1},
     { 1,67,67, 1},
     { 1,71,71, 1},
     { 5, 2,68,29},
     { 4, 4,69, 5},
     { 4, 4,36, 2},
     { 2,36,53, 4},
     {36, 5, 2,36},
     { 2,36, 5, 2},
     { 5, 5,36, 2},
     { 5, 5, 2,36},
     { 4,45,56,49},
     { 4,46,56,49},
     {11,45,56,49},
     {11,46,56,49},
     {12,45,56,49},
     {12,46,56,49},
     {26,36, 2,49},
     { 5,69,69, 5},
     { 5,39,47, 6},
     { 5,39,56,49},
     { 6,47,50,27},
     {50,56,51, 5},
     {51,56,51, 5},
     {19, 5, 2,49},
     {25, 5, 2,49},
     {25, 5, 5,25},
     {25, 5, 5, 5},
     {25, 5, 4, 4},
     {27,50, 5, 5},
     {27,50, 2,49},
     { 4, 4, 2,49},
     { 5, 4, 4, 5},
     { 5, 5, 5, 5},
     { 5, 5,39, 5},
     { 5, 5,51, 5},
     { 5, 5,51, 2},
     { 5,51, 5,51},
     { 5,51, 5,41},
     {49, 2,51, 5},
     {51, 5,41, 4},
     {51, 5, 5,51},
     {51, 5, 5,50},
     {50, 5, 5,50},
     {32, 5, 5,32},
     {33, 5, 5,33},
     {34, 5, 5,34},
     {19, 5, 5,51},
     {19, 5, 5,50},
     {19, 5, 5,32},
     {19, 5, 5,33},
     {19, 5, 5,34},
     {25, 5, 5,51},
     {25, 5, 5,50},
     {25, 5, 5,32},
     {25, 5, 5,33},
     {25, 5, 5,34}
};

static float gftor1[MXGTOR][2] = {
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {2.80,  0.0},
     {2.80,  0.0},
     {2.80,  0.0},
     {2.80,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {2.80,  0.0},
     {2.80,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.60,  0.0},
     {0.60,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.30,180.0},
     {1.30,180.0},
     {1.30,180.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {6.80,180.0},
     {6.80,180.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.50,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.70,  0.0},
     {0.70,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {5.00,  0.0},
     {5.00,  0.0},
     {9.50,180.0},
     {9.50,180.0},
     {1.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {2.00,180.0},
     {2.00,180.0},
     {2.00,180.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.20,  0.0},
     {1.20,  0.0},
     {1.20,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.90,  0.0},
     {1.90,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.90,  0.0},
     {0.90,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.85,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.25,180.0},
     {0.25,180.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.30,180.0},
     {0.00,  0.0},
     {1.20,180.0},
     {1.90,180.0},
     {1.70,180.0},
     {0.80,  0.0},
     {0.53,  0.0},
     {0.00,  0.0},
     {2.30,  0.0},
     {2.30,  0.0},
     {2.30,  0.0},
     {2.30,  0.0},
     {2.30,  0.0},
     {2.30,  0.0},
     {2.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.20,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.80,  0.0},
     {0.80,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.15,  0.0},
     {0.25,  0.0},
     {1.90,  0.0},
     {0.00,  0.0},
     {1.90,180.0},
     {0.20,180.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.80,180.0},
     {1.35,180.0},
     {0.00,  0.0},
     {1.40,180.0},
     {2.50,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {0.00,  0.0},
     {1.20,180.0},
     {0.45,180.0},
     {0.00,180.0},
     {0.25,  0.0},
     {0.25,  0.0},
     {0.19,  0.0},
     {0.25,  0.0},
     {0.55,  0.0},
     {0.25,  0.0},
     {0.25,  0.0},
     {0.19,  0.0},
     {0.25,  0.0},
     {0.55,  0.0}
};

static float gftor2[MXGTOR][2] = {
     {0.300, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {2.175, 180.000},
     {2.175, 180.000},
     {2.175, 180.000},
     {2.175, 180.000},
     {2.175, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {3.625, 180.000},
     {2.875, 180.000},
     {2.875, 180.000},
     {2.500, 180.000},
     {4.150, 180.000},
     {4.000, 180.000},
     {4.000, 180.000},
     {0.200, 180.000},
     {0.200, 180.000},
     {1.450, 180.000},
     {0.450, 180.000},
     {2.300, 180.000},
     {2.700, 180.000},
     {2.000, 180.000},
     {6.650, 180.000},
     {2.000, 180.000},
     {2.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {1.550, 180.000},
     {1.350, 180.000},
     {1.350, 180.000},
     {1.000,   0.000},
     {1.000,   0.000},
     {2.250, 180.000},
     {3.100, 180.000},
     {0.200, 180.000},
     {0.200, 180.000},
     {0.500,   0.000},
     {0.500,   0.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {1.000, 180.000},
     {1.000, 180.000},
     {4.000, 180.000},
     {4.000, 180.000},
     {4.000, 180.000},
     {0.000,   0.000},
     {2.550, 180.000},
     {0.650, 180.000},
     {4.150, 180.000},
     {4.150, 180.000},
     {4.150, 180.000},
     {0.800, 180.000},
     {0.800, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {0.300, 180.000},
     {0.000,   0.000},
     {0.625, 180.000},
     {1.700, 180.000},
     {1.700, 180.000},
     {0.675, 180.000},
     {0.750, 180.000},
     {1.050, 180.000},
     {1.050, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {0.950, 180.000},
     {0.950, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {4.750, 180.000},
     {0.450, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {0.325,   0.000},
     {0.325,   0.000},
     {0.325,   0.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {1.4333, 180.000},
     {1.4333, 180.000},
     {1.4333, 180.000},
     {0.500, 180.000},
     {1.100, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {0.600,   0.000},
     {0.600,   0.000},
     {0.600,   0.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {1.2667, 180.000},
     {1.2667, 180.000},
     {1.2667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.2667, 180.000},
     {0.2667, 180.000},
     {0.2667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {3.625, 180.000},
     {3.625, 180.000},
     {3.625, 180.000},
     {1.000, 180.000},
     {1.000, 180.000},
     {0.450, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {1.750,   0.000},
     {0.300, 180.000},
     {4.800, 180.0},
     {4.800, 180.0},
     {4.800, 180.0},
     {1.050, 180.000},
     {1.050, 180.000},
     {1.050, 180.000},
     {0.600, 180.000},
     {0.900, 180.000},
     {0.900, 180.000},
     {0.600, 180.000},
     {0.600, 180.000},
     {0.600, 180.000},
     {4.800, 180.000},
     {4.800, 180.000},
     {0.000, 180.000},
     {0.525, 180.000},
     {0.525, 180.000},
     {1.4667, 180.000},
     {1.4667, 180.000},
     {0.000, 180.000},
     {0.400, 180.000},
     {0.300,   0.000},
     {0.300,   0.000},
     {1.300, 180.000},
     {1.300, 180.000},
     {1.650, 180.000},
     {1.650, 180.000},
     {1.150,   0.000},
     {0.400,   0.000},
     {0.400,   0.000},
     {0.400,   0.000},
     {1.075,   0.000},
     {0.950,   0.000},
     {0.700,   0.000},
     {4.800, 180.000},
     {4.800, 180.000},
     {1.100,   0.000},
     {1.375, 180.000},
     {1.500,   0.000},
     {1.100,   0.000},
     {1.000, 180.000},
     {1.000, 180.000},
     {4.800, 180.000},
     {4.800, 180.000},
     {1.000, 180.000},
     {2.250,   0.000},
     {0.325,   0.000},
     {0.325,   0.000},
     {2.200, 180.000},
     {2.200, 180.000},
     {1.100,   0.000},
     {1.500,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {1.100, 180.000},
     {1.100, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {0.000, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {1.200, 180.000},
     {1.200, 180.000},
     {4.000, 180.000},
     {4.000, 180.000},
     {4.000, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {6.100, 180.000},
     {6.100, 180.000},
     {6.100, 180.000},
     {8.000, 180.000},
     {8.000, 180.000},
     {8.000, 180.000},
     {1.700, 180.000},
     {1.700, 180.000},
     {1.700, 180.000},
     {4.800, 180.000},
     {4.800, 180.000},
     {2.800, 180.000},
     {2.800, 180.000},
     {2.800, 180.000},
     {0.750, 180.000},
     {0.750, 180.000},
     {0.750, 180.000},
     {3.200, 180.000},
     {3.200, 180.000},
     {3.200, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {4.800, 180.000},
     {4.800, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {5.400, 180.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.100, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.650, 180.000},
     {6.6667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.100, 180.000},
     {2.100, 180.000},
     {2.100, 180.000},
     {2.800, 180.000},
     {2.800, 180.000},
     {2.800, 180.000},
     {6.650, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {6.6667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.250,   0.000},
     {0.000,   0.000},
     {1.600,   0.000},
     {1.900,   0.000},
     {4.000, 180.000},
     {2.200,   0.000},
     {1.800,   0.000},
     {3.200, 180.000},
     {3.200, 180.000},
     {3.200, 180.000},
     {2.350,   0.000},
     {2.100, 180.000},
     {2.100, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {3.100,   0.000},
     {2.600,   0.000},
     {3.750,   0.000},
     {3.750,   0.000},
     {3.1333,   0.000},
     {3.1333,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.900,   0.000},
     {1.200,   0.000},
     {6.000, 180.000},
     {1.000,   0.000},
     {0.650,   0.000},
     {1.000, 180.000},
     {1.000, 180.000},
     {1.000, 180.000},
     {1.450,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.8333, 180.000},
     {0.8333, 180.000},
     {1.800,   0.000},
     {7.800,   0.000},
     {1.050,   0.000},
     {1.050,   0.000},
     {3.6667, 180.000},
     {3.6667, 180.000},
     {0.000,   0.000},
     {2.550, 180.000},
     {1.500,   0.000},
     {0.000,   0.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {2.350,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.800,   0.000},
     {0.800,   0.000},
     {1.600,   0.000},
     {2.100,   0.000},
     {0.750,   0.000},
     {0.750,   0.000},
     {0.100, 180.000},
     {0.100, 180.000},
     {1.800, 180.000},
     {3.900, 180.000},
     {3.000, 180.000},
     {0.300, 180.000},
     {0.300, 180.000},
     {0.300, 180.000},
     {1.900, 180.000},
     {0.575, 180.000},
     {0.575, 180.000},
     {2.400,   0.000},
     {2.400,   0.000},
     {2.300, 180.000},
     {2.700, 180.000},
     {2.600, 180.000},
     {2.600, 180.000},
     {0.3333,   0.000},
     {0.3333,   0.000},
     {1.600,   0.000},
     {1.600,   0.000},
     {1.500, 180.000},
     {1.500, 180.000},
     {1.500, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.400,   0.000},
     {2.400,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.200,   0.000},
     {1.800,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {1.200, 180.000},
     {1.200, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {3.000, 180.000},
     {2.200,   0.000},
     {1.050, 180.000},
     {1.050, 180.000},
     {0.800,   0.000},
     {0.800,   0.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {6.600, 180.000},
     {1.200, 180.000},
     {1.200, 180.000},
     {7.200, 180.000},
     {7.200, 180.000},
     {7.200, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {6.650, 180.000},
     {2.450,   0.000},
     {2.450,   0.000},
     {6.6667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {1.400, 180.000},
     {6.650, 180.000},
     {1.500,   0.000},
     {1.500,   0.000},
     {6.6667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {1.8333, 180.000},
     {1.8333, 180.000},
     {4.600,   0.000},
     {0.000,   0.000},
     {3.850,   0.000},
     {3.850,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {6.650, 180.000},
     {1.450, 180.000},
     {6.650, 180.000},
     {0.3167, 180.000},
     {6.650, 180.000},
     {0.000,   0.000},
     {6.650, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.600, 180.000},
     {0.600, 180.000},
     {6.6667, 180.000},
     {0.600,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {3.800, 180.000},
     {3.800, 180.000},
     {6.6667, 180.000},
     {0.000,   0.000},
     {6.6667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {4.6667, 180.000},
     {4.6667, 180.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {3.0667, 180.000},
     {3.0667, 180.000},
     {6.650, 180.000},
     {0.000,   0.000},
     {6.6667, 180.000},
     {4.3333, 180.000},
     {6.6667, 180.000},
     {0.1556, 180.000},
     {2.250, 180.000},
     {1.100, 180.000},
     {0.650, 180.000},
     {1.000, 180.000},
     {2.000, 180.000},
     {0.850, 180.000},
     {0.000,   0.000},
     {0.070,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.500, 180.0},
     {3.500,   0.000},
     {1.900,   0.000},
     {3.000, 180.0},
     {1.500,   0.000},
     {1.200,   0.000},
     {1.200,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {2.300, 180.000},
     {2.175, 180.000},
     {6.650, 180.000},
     {0.250, 180.000},
     {0.480, 180.000},
     {0.100, 180.000},
     {0.000,   0.000},
     {0.850, 180.000},
     {0.650,   0.000},
     {2.700, 180.000},
     {0.000,   0.000},
     {1.175,   0.000},
     {1.175,   0.000},
     {1.175,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000},
     {0.000,   0.000}
};

static float gftor3[MXGTOR][2] = {
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.156,   0.000},
     {  0.156,   0.000},
     {  0.156,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.300,   0.000},
     {  0.156,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.167,   0.000},
     {  0.383,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.133,   0.000},
     {  0.133,   0.000},
     {  0.133,   0.000},
     {  0.022,   0.000},
     {  0.022,   0.000},
     {  0.250,   0.000},
     {  0.333,   0.000},
     {  0.200,   0.000},
     {  0.200,   0.000},
     { 0.1444,   0.000},
     { 0.1444,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000, 180.000},
     {  0.000, 180.000},
     {  0.000,  80.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.500,   0.000},
     {  1.500,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.000, 180.000},
     {  1.000, 180.000},
     {  1.000, 180.000},
     {  1.000, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.500, 180.000},
     {  1.500, 180.000},
     {  0.000,   0.000},
     {  0.500, 180.000},
     {  0.500, 180.000},
     {  0.000,   0.000},
     {  0.250,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     { 0.1888,   0.000},
     { 0.2333,   0.000},
     { 0.1833,   0.000},
     { 0.0833, 180.000},
     { 0.3333,   0.000},
     { 0.5666,   0.000},
     { 1.6666, 180.000},
     { 1.6666, 180.000},
     { 1.6666, 180.000},
     {  0.150,   0.000},
     {  0.050,   0.000},
     {  0.050,   0.000},
     { 0.0888,   0.000},
     { 0.0888,   0.000},
     { 0.6666,   0.000},
     { 0.3333,   0.000},
     { 0.2833,   0.000},
     { 0.2833,   0.000},
     { 0.1333,   0.000},
     { 0.1333,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.100,   0.000},
     {  1.100,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.800, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.175,   0.000},
     {  1.175,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.100, 180.000},
     {  0.100, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.400,   0.000},
     {  0.400,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.400, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     { 0.5333,   0.000},
     { 0.5333,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.650,   0.000},
     {  1.650,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.400, 180.000},
     {  0.400, 180.000},
     {  0.500,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  1.150,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     { 0.2666,   0.000},
     { 0.2666,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     { 0.1166,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.300,   0.000},
     {  0.300,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     { 0.2666,   0.000},
     {  0.000,   0.000},
     { 0.2777,   0.000},
     {  5.600,   0.000},
     {  5.300,   0.000},
     {  0.700,   0.000},
     {  0.700,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.300,   0.000},
     {  0.300,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.625,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.700, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.150, 180.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.600,   0.000},
     {  1.900,   0.000},
     {  2.300,   0.000},
     {  0.000,   0.000},
     {  0.250,   0.000},
     {  0.250,   0.000},
     {  0.080, 180.000},
     {  0.080, 180.000},
     {  0.150,   0.000},
     {  0.160,   0.000},
     {  0.380, 180.000},
     {  0.160,   0.000},
     {  0.000,   0.000},
     {  0.300,   0.000},
     {  0.000,   0.000},
     {  0.180,   0.000},
     {  0.300,   0.000},
     {  0.383,   0.000},
     {  0.383,   0.000},
     {  0.100,   0.000},
     {  0.383,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.144,   0.000},
     {  0.144,   0.000},
     {  0.144,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000},
     {  0.000,   0.000}
};

static float gftor4[MXGTOR][2] = {
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     { 0.35, 180.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.4, 180.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.5, 180.0},
     {  0.1,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0},
     {  0.0,   0.0}
};

void alldck(xyzc,ZSizep)
COOSTRU *xyzc;
int *ZSizep;
{
   int memstat;
   double d;
   int i;
   short int j;
   int ZSize;

   memstat = 1;
   ZSize = *ZSizep;

   if ((xyzc->coo = (double *) malloc((sizeof d)*ZSize*3)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->qat = (double *) malloc((sizeof d)*ZSize)) == NULL) {
	memstat = 0;
   }


   if ((xyzc->ianz = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->iaton = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->iconn = (int *) malloc((sizeof i)*ZSize*(MXCON+1))) == NULL) {
	memstat = 0;
   }

   if ((xyzc->iatclr = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->iresid = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->isurf = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->lwrit = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->lring = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->icont = (int *) malloc((sizeof i)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->ityp = (short int *) malloc((sizeof j)*ZSize)) == NULL) {
	memstat = 0;
   }

   if ((xyzc->ipdbt = (short int *) malloc((sizeof j)*ZSize)) == NULL) {
	memstat = 0;
   }

   xyzc->rzp   = NULL;
   xyzc->ixp    = NULL;
   xyzc->iyp    = NULL;
   xyzc->inat   = NULL;

   if (!memstat) {
	fprintf(stderr,"Out of memory alldck\n");
   } else {
	xyzc->iatoms = 0;
	for (i=0; i < ZSize; i++) {
		xyzc->qat[i] = 0.0;
		xyzc->ianz[i] = 0;
		xyzc->ityp[i] = 0;
		xyzc->lring[i] = 0;
		xyzc->lwrit[i] = 0;
		xyzc->iaton[i] = 2;
		xyzc->iatclr[i] = 1;
	}
	xyzc->mxnat = &mxliga;
	xyzc->mxorg = 1;
   }
}

int ChkLig(int ATMselp)
{
  if (ATMselp < lintp && DCKLIGPROC) return 1;
  return 0;
}

int ChkProt(int ATMselp)
{
  if (ATMselp < nintp && DCKPROTPROC) return 1;
  return 0;
}

void NoCH_Prot(int *iclos)
{
   int k,l,la;

   for (k=0; k<*xyzp->iatoms; k++) {
	if (iclos[k]) {
	   if (xyzp->ianz[k] == 1) {
		l = xyzp->iconn[k*(MXCON+1)+1];
		la = abs(l);
		if (la > 0) if (xyzp->ianz[la-1] == 6) iclos[k] = 0; 
	   }
	}
   }
}

void NoCH_Lig(int *frg)
{
   int k,l,la;

   for (k=0; k < ndocka; k++) {
	if (frg[k]) {
	   if (DCKxyz.ianz[k] == 1) {
		l = DCKxyz.iconn[k*(MXCON+1)+1];
		la = abs(l);
		if (la > 0) if (DCKxyz.ianz[la-1] == 6) frg[k] = 0; 
	   }
	}
   }
}

void FillOpt(int *iclos,int i)
{
   int j,k,kmin1,kmin2;
   float dd,tt,dmin1,dmin2;

// Fill iclos array with protein atoms closer than OPTradius to ligand pose //

   dmin1 = 10000.0;
   dmin2 = 10000.0;
   kmin1 = -1;
   kmin2 = -1;

   for (k=0; k<*xyzp->iatoms; k++) {

	dd = 0.0;
	iclos[k] = 0;

//	if (xyzp->iresid[k] > 0 && xyzp->ianz[k] != 1) {
	if (xyzp->iresid[k] > 0) {
	    for (j=0; j<3; j++) {
		tt = ((float) xyzp->coo[k*3+j] - TriArr[i]->Cen[j]);
		dd = dd + tt*tt;
	    }
	    dd = sqrt(dd)*toangs;
	    if (dd < OPTRadius) {
		iclos[k] = 1;
		if (dd < dmin1) {
		   dmin1 = dd;
		   kmin1 = k;
		} else {
		   if (dd < dmin2) {
			dmin2 = dd;
			kmin2 = k;
		   }
		}
	    }
	}
   }

   if (kmin1 != -1) iclos[kmin1] = 2;
   if (kmin2 != -1) iclos[kmin2] = 2;
}

void FillCOpt(int *iclos,int i)
{
   int j,k,l,ia;
   float dd,tt,dmin;

// This different from FillOpt in that FillOpt only looks
// for protein atoms close to TriArr[i]->Cen
// FillCOpt looks at atoms close to singleb.sng[l][0]

   dmin = 10000.0;

   for (k=0; k<*xyzp->iatoms; k++) {

	dd = 0.0;
	iclos[k] = 0;

	if (xyzp->iresid[k] > 0) {
	  for (l=0; l < singleb.N; l++) {
	    ia = singleb.sng[l][0];
	    for (j=0; j<3; j++) {
		tt = ((float) xyzp->coo[k*3+j] - TriArr[i]->coo[ia*3+j]);
		dd = dd + tt*tt;
	    }
	    dd = sqrt(dd)*toangs;
	    if (dd < OPTRadius) {
		iclos[k] = 1;
		if (dd < dmin) {
		   dmin = dd;
		}
	    }
	  }
	}
   }

}

void FillFull(int *iclos,int i)
{
   int j,k,l,ia;
   float dd,tt,dmin;

// This different from FillOpt in that FillOpt only looks
// for protein atoms close to TriArr[i]->Cen
// FillCOpt looks at atoms close to singleb.sng[l][0]

   dmin = 10000.0;

   for (k=0; k<*xyzp->iatoms; k++) {

	dd = 0.0;
	iclos[k] = 0;

	if (xyzp->iresid[k] > 0) {
	  for (l=0; l < ndocka; l++) {
	    for (j=0; j<3; j++) {
		tt = ((float) xyzp->coo[k*3+j] - TriArr[i]->coo[l*3+j]);
		dd = dd + tt*tt;
	    }
	    dd = sqrt(dd)*toangs;
	    if (dd < OPTRadius) {
		iclos[k] = 1;
		if (dd < dmin) {
		   dmin = dd;
		}
	    }
	  }
	}
   }

}

void FillClos(int *iclos,int itri)
{
   int j,k,l,ia;
   float dd,tt,dmin;

// This different from FillOpt in that FillOpt only looks
// for protein atoms close to TriArr[i]->Cen
// FillClos looks at atoms close to all atoms of the ligand pose

   for (k=0; k<*xyzp->iatoms; k++) {

	dd = 0.0;
	iclos[k] = 0;

	if (xyzp->iresid[k] > 0) {
	  for (l=0; l < ndocka; l++) {
	    for (j=0; j<3; j++) {
		tt = ((float) xyzp->coo[k*3+j] - TriArr[itri]->coo[l*3+j]);
		dd = dd + tt*tt;
	    }
	    dd = sqrt(dd)*toangs;
	    if (dd < OPTRadius) iclos[k] = 1;
	  }
	}
   }

}

void ChkBump(int *iclos,int i)
{
   int j,k,l,kmin,jmin,il,it;
   float dd,dl,tt,dmin,vdwr1,vdwr2,dir[3],ddif,xx;

   dmin = 10000.0;
   kmin = -1;
   jmin = -1;

   for (j=0; j<*xyzp->iatoms; j++) {
	if (iclos[j] == 2) {
	   kmin = j;
	   it = (int) xyzp->ityp[j];
	   il = chgvdwptr->ambvdt[it-1]-1;
	   vdwr1 = (float) chgvdwptr->ambvw1[il];
	   iclos[j] = 1;
	   break;
	}
   }


   for (j=0; j < ndocka; j++) {
	
     if (DCKxyz.ianz[j] != 1) {
	dd = 0.0;
	for (k=0; k<3; k++) {
	   tt = (float) (TriArr[i]->coo[j*3+k] - xyzp->coo[kmin*3+k]);
	   tt = tt*toangs;
	   dd = dd + tt*tt;
	}
	dd = sqrt(dd);

	if (dd < dmin) {
	   dmin = dd;
	   jmin = j;
	}
     }
   }


   if (jmin != -1) {
	
	it = (int) singleb.ityp[jmin];
	if (it < 0) {
	   il = ABS(it) - 1;
	   vdwr2 = (float) chgvdwptr->gfvdw[il][0];
	}

	dd = 0.0;
	for (k=0; k<3; k++) {
	   dir[k] = (float) (TriArr[i]->coo[jmin*3+k] - xyzp->coo[kmin*3+k]);
	   dir[k] = dir[k]*toangs;
	   dd = dd + dir[k]*dir[k];
	}
	dd = sqrt(dd);

	if (dd < vdwr1+vdwr2) {

//fprintf(stderr,"bumping up Tri %d dd %f vdwr1+vdwr2 %f jmin %d kmin %d\n",i,dd,vdwr1+vdwr2,jmin,kmin);

	   dl = veclen(dir);
	   for (k=0; k<3; k++) dir[k] = dir[k]/dl;
	   
	   ddif = vdwr1 + vdwr2 - dd + 0.1;

	   for (k=0; k<3; k++) dir[k] = dir[k]*ddif/toangs;

	   for (j=0; j < ndocka; j++) {
		for (k=0; k<3; k++) {
		   TriArr[i]->coo[j*3+k] = TriArr[i]->coo[j*3+k] 
			+ (double) dir[k];
		}
	   }

	   for (k=0; k<3; k++) {
		TriArr[i]->Cen[k]  = TriArr[i]->Cen[k] + dir[k];
	   }

	} else {
//fprintf(stderr,"NOT bumping up Tri %d dd %f vdwr1+vdwr2 %f\n",i,dd,vdwr1+vdwr2);
	}
   }

   dmin = 10000.0;
   kmin = -1;
   jmin = -1;

   for (j=0; j<*xyzp->iatoms; j++) {
	if (iclos[j] == 2) {
	   kmin = j;
	   it = (int) xyzp->ityp[j];
	   il = chgvdwptr->ambvdt[it-1]-1;
	   vdwr1 = (float) chgvdwptr->ambvw1[il];
	   iclos[j] = 1;
	   break;
	}
   }


   for (j=0; j < ndocka; j++) {
	
     if (DCKxyz.ianz[j] != 1) {
	dd = 0.0;
	for (k=0; k<3; k++) {
	   tt = (float) (TriArr[i]->coo[j*3+k] - xyzp->coo[kmin*3+k]);
	   tt = tt*toangs;
	   dd = dd + tt*tt;
	}
	dd = sqrt(dd);

	if (dd < dmin) {
	   dmin = dd;
	   jmin = j;
	}
     }
   }


   if (jmin != -1) {
	
	it = (int) singleb.ityp[jmin];
	if (it < 0) {
	   il = ABS(it) - 1;
	   vdwr2 = (float) chgvdwptr->gfvdw[il][0];
	}

	dd = 0.0;
	for (k=0; k<3; k++) {
	   dir[k] = (float) (TriArr[i]->coo[jmin*3+k] - xyzp->coo[kmin*3+k]);
	   dir[k] = dir[k]*toangs;
	   dd = dd + dir[k]*dir[k];
	}
	dd = sqrt(dd);

	if (dd < vdwr1+vdwr2) {

//fprintf(stderr,"bumping up Tri %d dd %f vdwr1+vdwr2 %f jmin %d kmin %d\n",i,dd,vdwr1+vdwr2,jmin,kmin);

	   dl = veclen(dir);
	   for (k=0; k<3; k++) dir[k] = dir[k]/dl;
	   
	   ddif = vdwr1 + vdwr2 - dd;

	   for (k=0; k<3; k++) dir[k] = dir[k]*ddif/toangs;

	   for (j=0; j < ndocka; j++) {
		for (k=0; k<3; k++) {
		   TriArr[i]->coo[j*3+k] = TriArr[i]->coo[j*3+k] 
			+ (double) dir[k];
		}
	   }

	   for (k=0; k<3; k++) {
		TriArr[i]->Cen[k]  = TriArr[i]->Cen[k] + dir[k];
	   }

	} else {
//fprintf(stderr,"NOT bumping up Tri %d dd %f vdwr1+vdwr2 %f\n",i,dd,vdwr1+vdwr2);
	}
   }
}

void AssChg(float *q)
{
   int i,it;

   typit(7,1);

   for (i=0; i < *xyzp->iatoms; i++) {
	it = (int) xyzp->ityp[i];
	if (! (it < 0)) {
	   q[i] = (float) chgvdwptr->ambchg[it-1];
	} else {
	   q[i] = 0.0;
	}
   }
}

void AssVDW(float *vdwr, float *vdwe)
{
   int i,it,il;

   for (i=0; i < *xyzp->iatoms; i++) {
	it = (int) xyzp->ityp[i];
	if (! (it <= 0)) {
	   il = chgvdwptr->ambvdt[it-1]-1;
	   vdwr[i] = (float) chgvdwptr->ambvw1[il];
	   vdwe[i] = (float) chgvdwptr->ambvw2[il];
	} else {
	   vdwr[i] = 0.0;
	   vdwe[i] = 0.0;
	}
   }
}

void AssVDWL(float *vdwr, float *vdwe,float *q)
{
   int i,it,il;

   for (i=0; i < ndocka; i++) {
	it = (int) singleb.ityp[i];
	if (it < 0) {
	   il = ABS(it) - 1;
	   vdwr[i] = (float) chgvdwptr->gfvdw[il][0];
	   vdwe[i] = (float) chgvdwptr->gfvdw[il][1];
	   q[i] = (float) DCKxyz.qat[i];

	} else {
	   vdwr[i] = 0.0;
	   vdwe[i] = 0.0;
	   q[i] = 0.0;
	}
   }
}

#define MXDIH 4

static int jact[MXDIH][MXLIGA];
static int jopt[MXDIH][MXLIGA];

//#define DCKSCLASH 3.0
#define DCKSCLASH 7.0
#define BIGD 10000.0

float CalClash(iclos,itri,vdwr,vdwrl,coo,idih)
int *iclos;
int itri;
float *vdwr;
float *vdwrl;
double *coo;
int idih;
{
   int i,j,k;
   float tt,dd,dmin,vdwr1,vdwr2,vsum;

   for (i=0; i<*xyzp->iatoms; i++) {

	vdwr1 = vdwr[i];

	if (iclos[i]) {
	   for (j=0; j < ndocka; j++) {

	     if (jopt[idih][j] == 1) {
		vdwr2 = vdwrl[j];
		if (DCKxyz.ianz[j] == 1) vdwr2 = 0.0;
		vsum = vdwr1 + vdwr2;
		vsum = vsum*vsum;
		dd = 0.0;

		for (k=0; k<3; k++) {
		   tt = (float) (coo[j*3+k] - xyzp->coo[i*3+k]);
		   tt = tt*toangs;
		   dd = dd + tt*tt;
		}

		if (dd+DCKSCLASH < vsum) return(BIGD);
	     }
	   }
	}
   }

   return(0.0);
}

float CalTorQ(float *rwxyz,int ndocka,float *F)
{
   int k,l;
   float Tres[3],R[3],Tl,Tmin;
/*   float tx,ty,tz,vec[3],TminA,TminB,TminC,TotResX,TotResY,TotResZ;*/
/*   float Res[3],F[3][ndocka];*/
   float Res[3];

/*
   TotResX = 0.0; TotResY = 0.0; TotResZ = 0.0;
*/
   Tres[0] = 0.0; Tres[1] = 0.0; Tres[2] = 0.0;
   Tmin = 10000.0;

   for (k=0; k < ndocka; k++) {

/*
		tx = TriArr[i]->coo[k*3+0] - TriArr[i]->Cen[0];
		ty = TriArr[i]->coo[k*3+1] - TriArr[i]->Cen[1];
		tz = TriArr[i]->coo[k*3+2] - TriArr[i]->Cen[2];

		vec[0] = tx; vec[1] = 0.0; vec[2] = 0.0;
		cross(vec,&F[0][i],Res);
		TotResX = TotResX + Res[0];

		vec[0] = 0.0; vec[1] = ty; vec[2] = 0.0;
		cross(vec,&F[0][i],Res);
		TotResY = TotResY + Res[1];

		vec[0] = 0.0; vec[1] = 0.0; vec[2] = tz;
		cross(vec,&F[0][i],Res);
		TotResZ = TotResZ + Res[2];
*/

	for (l=0; l < 3; l++) {
	   R[l] = rwxyz[k*3+l];
	}

	cross(R,&F[k],Res);

	for (l=0; l < 3; l++) {
	   Tres[l] = Tres[l] + Res[l];
	}
   }

   Tl = sqrt(Tres[0]*Tres[0] + Tres[1]*Tres[1] + Tres[2]*Tres[2]);
   return(Tl);
}

int AllArr(float **q, float **vdwr, float **vdwe, int **iclos, float **F)
{
   int i;
   float f;

   if ((*q = (float *) malloc((sizeof f)*(*xyzp->iatoms))) == NULL) {
	return(0);
   }

   if ((*vdwr = (float *) malloc((sizeof f)*(*xyzp->iatoms))) == NULL) {
	return(0);
   }

   if ((*vdwe = (float *) malloc((sizeof f)*(*xyzp->iatoms))) == NULL) {
	return(0);
   }

   if ((*iclos = (int *) malloc((sizeof i)*(*xyzp->iatoms))) == NULL) {
	return(0);
   }

   if ((*F = (float *) malloc(3*(sizeof f)*(*xyzp->iatoms))) == NULL) {
	return(0);
   }

   return(1);
}

int AllVDWArr(float **q, float **vdwr, float **vdwe, int size)
{
   int i;
   float f;

   if ((*q = (float *) malloc((sizeof f)*(size))) == NULL) {
	return(0);
   }

   if ((*vdwr = (float *) malloc((sizeof f)*(size))) == NULL) {
	return(0);
   }

   if ((*vdwe = (float *) malloc((sizeof f)*(size))) == NULL) {
	return(0);
   }

   return(1);
}

void Newxyz(float a, float *dir, float *cwxyz)
{
   float z[3],E;
   int l,j;

   for (l=0; l < 3; l++) {
	z[l] = a*dir[l];
   }

   for (j=0; j < ndocka; j++) {
	for (l=0; l < 3; l++) cwxyz[3*j+l] = cwxyz[3*j+l] + z[l];
   }

// return a not correct, it needs to return E as function of cwxyz
// as calculated by CalcFE

   return;
}

float CalcE(float *cxyz,int ohind, int *iclos,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel)
{
   int i,j,k,l;
   float vr[3],rv,rv2,rs2,rs3,rsum,rinv,epsm,p6,p12;
   float e,ev,eq,econv;

   ev = 0.0; eq = 0.0;
   econv = 332.05382;

   for (i=0; i < *xyzp->iatoms; i++) {
     if (iclos[i]) {
	   for (l=0; l < 3; l++) {
		vr[l] = (cxyz[l] - (float) xyzp->coo[i*3+l]);
		vr[l] =  vr[l]*toangs;
	   }
	   rv2 = vr[0]*vr[0] + vr[1]*vr[1] + vr[2]*vr[2];
	   rv = sqrt(rv2);
	   rinv = 1.0/rv;
	   rsum = vdwr[i] + vdwrl[ohind];
	   epsm = sqrt(vdwe[i]*vdwel[ohind]);
	   rs2 = rsum*rsum;
	   rs3 = rs2*rsum;
	   p6   = (rs3*rs3) / (rv2*rv2*rv2);
	   p12  = p6 * p6;

	   e    = epsm * (p12 - 2.0*p6);

	   ev   = ev + e;
   
	   e = q[i]*ql[ohind]*econv*rinv;

	   eq = eq + e;	
     }
   }

   return(eq + ev);

}

void CalcFE(float *cool,double *coo,int *iclos,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel,
		float *F,float *E,float *dir,int *frg)
{
   int i,j,k,l;
   float vr[3],rv,rv2,rs2,rs3,rsum,rinv,epsm,p6,p12;
   float de,e,ev,eq,econv,Fj[3];

   ev = 0.0; eq = 0.0;
   econv = 332.05382;

   for (j=0; j < ndocka; j++) {
     for (l=0; l < 3; l++) {
	F[j*3+l] = 0.0;
     }
   }


   for (i=0; i < *xyzp->iatoms; i++) {
     if (iclos[i]) {
	for (j=0; j < ndocka; j++) {
	 if (frg[j]) {
	   for (l=0; l < 3; l++) {
		vr[l] = (cool[j*3+l] - (float) coo[i*3+l]);
		vr[l] =  vr[l]*toangs;
	   }
	   rv2 = vr[0]*vr[0] + vr[1]*vr[1] + vr[2]*vr[2];
	   rv = sqrt(rv2);
	   rinv = 1.0/rv;
	   rsum = vdwr[i] + vdwrl[j];
	   epsm = sqrt(vdwe[i]*vdwel[j]);
	   rs2 = rsum*rsum;
	   rs3 = rs2*rsum;
	   p6   = (rs3*rs3) / (rv2*rv2*rv2);
	   p12  = p6 * p6;

	   e    = epsm * (p12 - 2.0*p6);
	   de   = epsm * (p12 - p6) * (-12.0/rv);
	   de   = de / rv;

	   for (l=0; l < 3; l++) {
		Fj[l] = de * vr[l];
	   }

	   ev   = ev + VDWSCAL*e;
   
	   for (l=0; l < 3; l++) {
		F[j*3+l] = F[j*3+l] + Fj[l];
	   }

	   e = q[i]*ql[j]*econv*rinv;

	   de = -e*rinv*rinv;

	   for (l=0; l < 3; l++) {
		F[j*3+l] = F[j*3+l] + + de * vr[l];
	   }

	   eq = eq + e;	
	 }
	}
     }
   }

   *E = eq + ev;

   for (l=0; l < 3; l++) dir[l] = 0.0;

   for (j=0; j < ndocka; j++) {
	for (l=0; l < 3; l++) dir[l] = dir[l] + F[j*3+l];
   }

}

void CaljFE(float *cool,double *coo,int *iclos,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel,
		float *F,float *E,float *dir,int *frg)
{
   int i,j,k,l;
   float vr[3],rv,rv2,rs2,rs3,rsum,rinv,epsm,p6,p12;
   float de,e,ev,eq,econv,Fj[3];

   ev = 0.0; eq = 0.0;
   econv = 332.05382;

   for (j=0; j < ndocka; j++) {
     for (l=0; l < 3; l++) {
	F[j*3+l] = 0.0;
     }
   }

   for (i=0; i < *xyzp->iatoms; i++) {
     if (iclos[i]) {
	for (j=0; j < ndocka; j++) {
	   for (l=0; l < 3; l++) {
		vr[l] = (cool[j*3+l] - (float) coo[i*3+l]);
		vr[l] =  vr[l]*toangs;
	   }
	   rv2 = vr[0]*vr[0] + vr[1]*vr[1] + vr[2]*vr[2];
	   rv = sqrt(rv2);
	   rinv = 1.0/rv;
	   rsum = vdwr[i] + vdwrl[j];
	   epsm = sqrt(vdwe[i]*vdwel[j]);
	   rs2 = rsum*rsum;
	   rs3 = rs2*rsum;
	   p6   = (rs3*rs3) / (rv2*rv2*rv2);
	   p12  = p6 * p6;

	   e    = epsm * (p12 - 2.0*p6);
	   de   = epsm * (p12 - p6) * (-12.0/rv);

	   de   = de / rv;

	   for (l=0; l < 3; l++) {
		Fj[l] = de * vr[l];
	   }

	   ev   = ev + e;
   
	   for (l=0; l < 3; l++) {
		F[j*3+l] = F[j*3+l] + Fj[l];
	   }

	   e = q[i]*ql[j]*econv*rinv;

	   de = -e*rinv*rinv;

	   for (l=0; l < 3; l++) {
		F[j*3+l] = F[j*3+l] + + de * vr[l];
	   }

	   eq = eq + e;	
	}
     }
   }

   *E = eq + ev;

   for (l=0; l < 3; l++) dir[l] = 0.0;

   for (j=0; j < ndocka; j++) {
	for (l=0; l < 3; l++) dir[l] = dir[l] + F[j*3+l];
   }
}

float golden(float *cool,double *coo,int *iclos,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel,
		float *F,float a,float b,
		float *dir,int *frg)
{
   float c,d,gr,tol,Ec,Ed,dum[3];
   float wxyz[3*MXLIGA];
   int i,j;

   gr = (sqrt(5.0) - 1.0) / 2.0;
   tol = 1.0e-5;

   c = a + (b - a)*(1.0-gr);
   d = a + (b - a)*gr;

   while (ABS(c-d) > tol) {

	for (i=0; i < ndocka; i++) {
	   for (j=0; j < 3; j++) {
		wxyz[3*i+j] = cool[3*i+j];
	   }
	}

	Newxyz(c,dir,wxyz);
	CalcFE(wxyz,coo,iclos,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,&Ec,dum,frg);

	for (i=0; i < ndocka; i++) {
	   for (j=0; j < 3; j++) {
		wxyz[3*i+j] = cool[3*i+j];
	   }
	}

	Newxyz(d,dir,wxyz);
	CalcFE(wxyz,coo,iclos,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,&Ed,dum,frg);
	if (Ec < Ed) {
	   b = d;
	   d = c;
	   c = a + (1.0-gr)*(b-a);
	} else {
	   a = c;
	   c = d;
	   d = a + gr*(b-a);
	}
   }

   for (i=0; i < ndocka; i++) {
	for (j=0; j < 3; j++) {
	    cool[3*i+j] = wxyz[3*i+j] ;
	}
   }

   return((b+a)/2.0);
}

void Rxyz(float xin, float yin, float zin, 
	  int a, int b, int c,
	  float *xout, float *yout, float *zout)
{
  float csa,sna,csb,snb,csc,snc;

  Get_FTsin(a,&sna,&csa);
  Get_FTsin(b,&snb,&csb);
  Get_FTsin(c,&snc,&csc);


  *xout = xin*csa*csb + yin*(csa*snb*snc - sna*csc) +
		        zin*(csa*snb*csc + sna*snc);
  *yout = xin*sna*csb + yin*(sna*snb*snc + csa*csc) +
		        zin*(sna*snb*csc - csa*snc);
  *zout = -xin*snb + yin*csb*snc + zin*csb*csc;
}

void Trans2Cen(float *coot, int itri, int ndocka)
{
   int i,j;

   for (i=0; i < ndocka; i++) {
	for (j=0; j < 3; j++) {
	   coot[3*i+j] = ((float) TriArr[itri]->coo[3*i+j] - 
				TriArr[itri]->Cen[j]);
	}
   }
}

void Cen2Trans(float *coot, int itri, int ndocka)
{
   int i,j;

   for (i=0; i < ndocka; i++) {
	for (j=0; j < 3; j++) {
	   coot[3*i+j] = (coot[3*i+j] + (float) TriArr[itri]->Cen[j]);
	}
   }
}

void PickFrags(int *indx, int itri, int ndocka)
{
   int i,j;

   for (i=0; i < ndocka; i++) {
	indx[i] = 0;
	if (singleb.ifrg[i] == TriArr[itri]->frags[0] ||
	    singleb.ifrg[i] == TriArr[itri]->frags[1] ||
	    singleb.ifrg[i] == TriArr[itri]->frags[2]) indx[i] = 1;
   }
}

void PickFrag(int *indx, int itri, int ndocka)
{
   int i,j;

   for (i=0; i < ndocka; i++) {
	indx[i] = 0;
	if (singleb.ifrg[i] == TriArr[itri]->frag) indx[i] = 1;
   }
}

void PickFull(int *indx, int itri, int ndocka)
{
   int i;

   for (i=0; i < ndocka; i++) indx[i] = 1;
}

int ChkFrag(int *indx,int ndocka)
{
   int i,j;

   for (i=0; i < ndocka; i++) {
	if (indx[i] == 1) return(1);
   }
   return(0);
}

int Write_Results(File_Name,Tri,ntri,xyz,Eopt,maxi)
char *File_Name;
TRISTRU *Tri[MAXTRI];
int ntri;
COOSTRU *xyz;
int Eopt;
int maxi;
{
   int ierr,i,n,iattmp,ipdbtmp,maxsol,itel;
   int *ianztmp;
   short int *ityptmp;

   cpstr(File_Name,tmpfil,SUBLEN1);
   ierr = 0;

#if defined(VMS) || defined(UNDERSC)
   filop(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
#ifdef CRAY
   FILOP(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
   filop_(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#endif
#endif

   if (ierr) {
	if (DoCan(event.xbutton.x_root,event.xbutton.y_root,
	 "WARNING: was not able to write docking output",0)) {
		i = 0;
	}
	return(0);
   }

if (debugdck) fprintf(stderr,"\nWrite_Results: %s\n\n",File_Name);

   ianztmp = xyzp->ianz;
   ityptmp = xyzp->ityp;
   xyzp->ianz = xyz->ianz;
   xyzp->ityp = xyz->ityp;

   iattmp = *xyzp->iatoms;
   *xyzp->iatoms = ndocka;
   ipdbtmp = *ipdbon;
   *ipdbon = 0;

   eneptr->iener = 1;

   if (maxi) {
	maxsol = dcksol;
	n = MINI(ntri,maxsol);
   } else {
	n = ntri;
   }

if (debugdck) fprintf(stderr,"Write_Results: n %d\n",n);

   itel = 0;
   for (i = 0; i < n; i++ ) {
      if (Tri[i] != NULL && Tri[i]->coo != NULL) {
	if (Eopt) {
	   eneptr->energy = Tri[i]->eint;

	   if (!debugdck) {
		fprintf(stderr,"#%d E=%.3f\n",i,Tri[i]->eint);
	   } else {
		fprintf(stderr,"#%d E=%.3f lig %d %d %d prot %d %d %d\n",i,Tri[i]->eint,Tri[i]->lig[0],Tri[i]->lig[1],Tri[i]->lig[2],Tri[i]->prot[0],Tri[i]->prot[1],Tri[i]->prot[2]);
	   }
	} else {
	   eneptr->energy = Tri[i]->etot;

	   if (!debugdck) {
		fprintf(stderr,"#%d E=%.3f\n",i,Tri[i]->etot);
	   } else {
		fprintf(stderr,"#%d E=%.3f lig %d %d %d prot %d %d %d\n",i,Tri[i]->etot,Tri[i]->lig[0],Tri[i]->lig[1],Tri[i]->lig[2],Tri[i]->prot[0],Tri[i]->prot[1],Tri[i]->prot[2]);
	   }
	}
//	Prt_Coo(Tri[i]->P1,100);
//	Prt_Coo(Tri[i]->P2,100);
//	Prt_Coo(Tri[i]->P3,100);

#if defined(VMS) || defined(UNDERSC)
	wrmod(&SEVENTYSEVEN,
#else
#ifdef CRAY
	WRMOD(&SEVENTYSEVEN,
#else
	wrmod_(&SEVENTYSEVEN,
#endif
#endif
	Tri[i]->coo,xyz->qat,xyz->ianz,xyz->iaton,xyz->iatclr,xyz->iconn,
	xyz->iresid,xyz->lring,xyz->inat,xyz->ityp,xyz->ipdbt,
	calfptr->icalf,&calfptr->ncalf,calfptr->iamino,&calfptr->ishoh,
	&cell->natc,&cell->nspg,&cell->ichx,
	&cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	&cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);
	   itel++;
      }
   }

   eneptr->iener = 0;
   *xyzp->iatoms = iattmp;
   *ipdbon = ipdbtmp;
   xyzp->ianz = ianztmp;
   xyzp->ityp = ityptmp;

   fprintf(stderr,"\n");

#if defined(VMS) || defined(UNDERSC)
   filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
   FILCLO(&SEVENTYSEVEN);
#else
   filclo_(&SEVENTYSEVEN);
#endif
#endif

}

int Write_Mol(File_Name,nats,dckxyz,mode)
char *File_Name;
int nats;
COOSTRU dckxyz;
int mode;
{
   int ierr,i,n,iattmp,ipdbtmp,maxsol,itel;
   int *ianztmp, mxnatd, ihaszmd;
   short int *ityptmp;
   COOSTRU *pp;
   int idum;
   double rdum;

   pp = xyzp;

   cpstr(File_Name,tmpfil,SUBLEN1);
   ierr = 0;

#if defined(VMS) || defined(UNDERSC)
   filop(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
#ifdef CRAY
   FILOP(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
   filop_(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#endif
#endif

   if (ierr) {
      fprintf(stderr,"WARNING: was not able to write mol from ligand");
   }


   iattmp = *xyzp->iatoms;
   ipdbtmp = *ipdbon;
   mxnatd = *(xyzp->mxnat);
   ihaszmd = *(zmptrp->ihaszm);

//   *xyzp->iatoms = ndocka;
   *xyzp->iatoms = nats;
   *ipdbon = 0;

   if (mode == 0) {
#if defined(VMS) || defined(UNDERSC)
	outmod(&SEVENTYSEVEN,
#else
#ifdef CRAY
	OUTMOD(&SEVENTYSEVEN,
#else
	outmod_(&SEVENTYSEVEN,
#endif
#endif
	dckxyz.coo,dckxyz.ianz,dckxyz.iconn);
   } else {
#if defined(VMS) || defined(UNDERSC)
	wrmod(&SEVENTYSEVEN,
#else
#ifdef CRAY
	WRMOD(&SEVENTYSEVEN,
#else
	wrmod_(&SEVENTYSEVEN,
#endif
#endif
	dckxyz.coo,dckxyz.qat,dckxyz.ianz,dckxyz.iaton,dckxyz.iatclr,
	dckxyz.iconn,
	dckxyz.iresid,dckxyz.lring,dckxyz.inat,dckxyz.ityp,dckxyz.ipdbt,
	&idum,&ZERO,&idum,&idum,
	&idum,&idum,&idum, &rdum,&rdum,&rdum, &rdum,&rdum,&rdum);
   }

   *xyzp->iatoms = iattmp;
   *ipdbon = ipdbtmp;
   *(xyzp->mxnat)  = mxnatd;
   *(zmptrp->ihaszm) = ihaszmd;

#if defined(VMS) || defined(UNDERSC)
   filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
   FILCLO(&SEVENTYSEVEN);
#else
   filclo_(&SEVENTYSEVEN);
#endif
#endif

}

void RotTri(int itri, int lowa, int higha, int angstp, 
		float *wxyz, float *rwxyz, float *cwxyz, 
		float *q, float *vdwr, float *vdwe,
		float *ql, float *vdwrl, float *vdwel, float *F,
		float *dir, int *frg, int *iclos)
{
// lowa -4 hiang  5 angstp 1.0 BmpCheck 1 ECheck 1
// lowa -9 hiang 10 angstp 5.0 BmpCheck 0 ECheck 0

   int k,l,j;
   float Emin,E,vl,tdir[3],c;
   int angx,angy,angz,angxm,angym,angzm;
   int anglex,angley,anglez;

   Emin = 10000.0;
   angxm = 10000; angym = 10000; angzm = 10000;

// translate origin to center of triangle


   Trans2Cen(wxyz,itri,ndocka);

///* loop over a,b,c angles to calculate Energy as function of angles */

   for (angx=lowa; angx < higha; angx++) {
	anglex = angx*angstp;

	for (angy=lowa; angy < higha; angy++) {
	    angley = angy*angstp;

	    for (angz=lowa; angz < higha; angz++) {
		anglez = angz*angstp;

// do rotation around x,y,x axes (Rx,Ry,Rz) and copy to rwxyz

		for (k=0; k < ndocka; k++) {
		    Rxyz(wxyz[k*3], wxyz[k*3+1], wxyz[k*3+2], 
			anglex,angley,anglez,
			&rwxyz[k*3], &rwxyz[k*3+1], &rwxyz[k*3+2]);
		}

		Cen2Trans(rwxyz,itri,ndocka);

// calculate forces and energy on rotated ligand coordinates

if (Match_tri(TriArr[itri],11,1,13,69,70,12)) {
fprintf(stderr,"RotTri: angx %d angy %d angz %d\n\n",angx,angy,angz);
}
		CalcFE(rwxyz,xyzp->coo,iclos,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,&E,dir,frg);

if (Match_tri(TriArr[itri],11,1,13,69,70,12)) {
fprintf(stderr,"RotTri: E %.3f Emin %.3f\n\n",E,Emin);
}
		if (E < Emin)  {
		    Emin = E;
		    for (k=0; k < ndocka; k++) {
			for (l=0; l < 3; l++)  {
			   cwxyz[k*3+l] = rwxyz[k*3+l];
			}
		    }
		    angxm = angx;
		    angym = angy;
		    angzm = angz;
		}

	    } // end for anglez
	} // end for angley
   } // end for anglex

if (debugdck) fprintf(stderr,"RotTri Emin %.3f\n",Emin);

   if (Emin < 50.0) {
//   if (Emin < BIGD) {

	TriArr[itri]->eint = Emin;

	for (k=0; k < ndocka; k++) {
		   for (l=0; l < 3; l++) {
			TriArr[itri]->coo[k*3+l] = (double) cwxyz[k*3+l];
		   }
	}

	CalcFE(cwxyz,xyzp->coo,iclos,q,vdwr,vdwe,
		ql,vdwrl,vdwel,F,&E,dir,frg);

	vl = veclen(dir); if (vl == 0.0) return;

	for (l=0; l < 3; l++) dir[l] = -dir[l] / vl;

	c = golden(cwxyz,xyzp->coo,iclos,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,0.0,1.0,dir,frg);

	CalcFE(cwxyz,xyzp->coo,iclos,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,&E,dir,frg);

if (debugdck) fprintf(stderr,"RotTri E %.3f\n",E);

	if (E < 0.0) {
//	if (E < 100.0) {

	   TriArr[itri]->eint = E;

	   for (k=0; k < ndocka; k++) {
		for (l=0; l < 3; l++) {
		   TriArr[itri]->coo[k*3+l] = (double) cwxyz[k*3+l];
		}
	   }

		   
	   for (l=0; l < 3; l++) {
		tdir[l] = (cwxyz[l] - rwxyz[l]);
		TriArr[itri]->Cen[l] = TriArr[itri]->Cen[l] + (double) tdir[l];
	   }

	} else {
	   TriArr[itri]->eint = 0.0;
	}
   }


}

int struct_cmp(const AREASTRU * lhs, const AREASTRU * rhs)
{
    return memcmp(lhs, rhs, sizeof(AREASTRU));
}

void OHFnd(TRISTRU *Tri,double *cooProt,int it)
{
   int i,j,iopt,indx,il;
   double dd,tt,ddmin;

   ddmin = BIGD;
   iopt = -1;

   for (i=0; i<36; i++) {
	dd = 0.0;
	for (j=0; j<3; j++) {
	   tt = cooProt[j] + Tri->oh[it][i*3+j];
	   tt =  tt * tt;
	   dd = dd + tt;
	   if (dd < ddmin) {
		ddmin = dd;
		iopt = i;
	   }
	}
   }

   if (iopt != -1) {

	indx = Tri->lig[it];
	il = ligtyp[indx]->atom[0];

	for (j=0; j<3; j++) {
	   Tri->coo[il*3+j] = Tri->oh[it][iopt*3+j];
	}
	
   }
}

void OHAllInt(C,indx,at1,at2,at3,coo,ohcoo,iconf,link,ohsame,jj)
COOSTRU *C;
int *indx;
int at1;
int at2;
int at3;
double *coo;
double *ohcoo;
int iconf;
int link;
int ohsame;
int jj;
{
   int j;
   INCRSTRU tmptyp;

   ligtyp[*indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

   for (j=0; j<3; j++) {
//	ligtyp[*indx]->c[0][j] = ohcoo[jj*6+j];
	ligtyp[*indx]->c[0][j] = ohcoo[jj*3+j];
	ligtyp[*indx]->c[1][j] = coo[(at2)*3+j];
	ligtyp[*indx]->c[2][j] = coo[(at3)*3+j];
	ligtyp[*indx]->atom[0] = at1;
	ligtyp[*indx]->atom[1] = at2;
	ligtyp[*indx]->atom[2] = at3;
	ligtyp[*indx]->n = 2;
   }

   ligtyp[*indx]->type = H_DON;
   ligtyp[*indx]->area = ONH;
   ligtyp[*indx]->conf = iconf;
   ligtyp[*indx]->link = link;
   ligtyp[*indx]->ohlig = 1;
   ligtyp[*indx]->ohsame = ohsame;

   cal_area(ligtyp[*indx]);
   (*indx)++;
}

void OHGenRot(double *coo, double **GenOH, int i1, int i2, int i3,
		int n, int iang)
{

// i1 is C, i2 is O is Origin (O), i3 is H

   int i,j;
   float v1[3],v2[3],v3[3],O[3],XX,YY,arad;
   float v12[3],v32[3],cosa,sina,csa,sna,vl,todeg;
   double *OHPTR;

   todeg = 45.0e0/atan(1.0e0);

   if (!allConf(GenOH,n)) exit(-1);
   
   OHPTR = *GenOH;

   for (j=0; j<3; j++) {
	O[j]   = (float) (coo[i2*3+j]);
	v12[j] = (float) (coo[i1*3+j] - coo[i2*3+j]);
	v32[j] = (float) (coo[i3*3+j] - coo[i2*3+j]);
	v1[j]  = v12[j];
   }
   
   vecnrm(v1);
   cross(v1,v32,v3);
   vecnrm(v3);
   cross(v1,v3,v2);
   IMPRD(v32,v2,&cosa,1);
   IMPRD(v32,v1,&sina,1);
   vl = veclen(v32);

   XX = vl*cosa;
   YY = vl*sina;

   for (i=0; i<n; i++) {
	arad = (float) (i*iang);
	csa = cos(arad/todeg);
	sna = sin(arad/todeg);
	
	for (j=0; j<3; j++) {
	   OHPTR[i*3+j] = (float) (O[j] + XX*(csa*v2[j] + sna*v3[j]) + YY*v1[j]);
	}

   }

}

void OHRot(TRISTRU *Tri, int i1, int i2, int i3, int it)
{

// i1 is C, i2 is O is Origin (O), i3 is H

   int i,j;
   float v1[3],v2[3],v3[3],O[3],XX,YY,arad;
   float v12[3],v32[3],cosa,sina,csa,sna,vl,todeg;

   todeg = 45.0e0/atan(1.0e0);

   if (!allConf(&Tri->oh[it],36)) exit(-1);

   for (j=0; j<3; j++) {
	O[j]   = (float) (Tri->coo[i2*3+j]);
	v12[j] = (float) (Tri->coo[i1*3+j] - Tri->coo[i2*3+j]);
	v32[j] = (float) (Tri->coo[i3*3+j] - Tri->coo[i2*3+j]);
	v1[j]  = v12[j];
   }
   
   vecnrm(v1);
   cross(v1,v32,v3);
   vecnrm(v3);
   cross(v1,v3,v2);
   IMPRD(v32,v2,&cosa,1);
   IMPRD(v32,v1,&sina,1);
   vl = veclen(v32);

   XX = vl*cosa;
   YY = vl*sina;

   for (i=0; i<36; i++) {
	arad = (float) (i*10);
	csa = cos(arad/todeg);
	sna = sin(arad/todeg);
	
	for (j=0; j<3; j++) {
	   Tri->oh[it][i*3+j] = O[j] + XX*(csa*v2[j] + sna*v3[j]) + YY*v1[j];
	}

   }

}

void RotOH(int indx, int i1, int i2, int i3, int *iclos,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel)
{
   int i,j;
   float v1[3],v2[3],v3[3],cxyz[3],O[3],XX,YY,E,Emin,cminxyz[3],arad;
   float v12[3],v32[3],cosa,sina,csa,sna,vl,x,y,todeg;

   todeg = 45.0e0/atan(1.0e0);
   Emin = 10000.0;

fprintf(stderr,"RotOH: %d %d %d\n",i1,i2,i3);
   for (j=0; j<3; j++) {
	O[j]   = TriArr[indx]->coo[i2*3+j];
	v12[j] = TriArr[indx]->coo[i1*3+j] - TriArr[indx]->coo[i2*3+j];
	v32[j] = TriArr[indx]->coo[i3*3+j] - TriArr[indx]->coo[i2*3+j];
	v1[j]  = v12[j];
   }
   
   vecnrm(v1);
   cross(v1,v32,v3);
   vecnrm(v3);
   cross(v1,v3,v2);
   IMPRD(v32,v2,&cosa,1);
   IMPRD(v32,v1,&sina,1);
   vl = veclen(v32);

   XX = vl*cosa;
   YY = vl*sina;

   for (i=0; i<72; i++) {
	arad = (float) (i*5);
	csa = cos(arad/todeg);
	sna = sin(arad/todeg);
// rotation is about v1 and thus in the plane spanned by v2 and v3

	
// cxyz contains the rotated H coordinates

	for (j=0; j<3; j++) {
	   cxyz[j] = O[j] + XX*(csa*v2[j] + sna*v3[j]) + YY*v1[j];
	}

	E = CalcE(cxyz,i3,iclos,q,vdwr,vdwe,ql,vdwrl,vdwel);
	if (E < Emin) {
	   E = Emin;
	   for (j=0; j<3; j++) {
		cminxyz[j] = cxyz[j];
	   }
	}
   }

   for (j=0; j<3; j++) {
	TriArr[indx]->coo[i3*3+j] = cminxyz[j];
   }

// the optimised H position also has an effect on the interaction points
// But since this is in principle ligand pose dependent, we CAN NOT
// store this in the ligtyp array. We have to create a specific
// memory location for this and flag this in the ligtyp array

}

static int cmpeint(const void * a,const void * b)
{
    TRISTRU **Tria = (TRISTRU **) a;
    TRISTRU **Trib = (TRISTRU **) b;
    if ((*Tria) == NULL || (*Trib) == NULL) return -1;
    if ((*Tria)->eint > (*Trib)->eint) return 1;
    else
       if ((*Tria)->eint == (*Trib)->eint) return  0;
       else          return -1;
}

static int cmptriF(const void * a,const void * b)
{
    TRISTRU **Tria = (TRISTRU **) a;
    TRISTRU **Trib = (TRISTRU **) b;
    if ((*Tria)->etot > (*Trib)->etot) return 1;
    else
       if ((*Tria)->etot == (*Trib)->etot) return  0;
       else          return -1;
}

int Match_Tri(TRISSTRU Tri,int l1,int l2,int l3)
{

    if (Tri.lig[0] == l1 &&
	Tri.lig[1] == l2 &&
	Tri.lig[2] == l3 ) {
	return(1);
   }

return(0);

}

int Match_tri(TRISTRU * Tri,int l1,int l2,int l3,int p1,int p2,int p3)
{

if (Tri->lig[0] == l1 &&
    Tri->lig[1] == l2 &&
    Tri->lig[2] == l3 ) {
    if (Tri->prot[0] == p1 &&
	Tri->prot[1] == p2 &&
	Tri->prot[2] == p3 ) {
	return(1);
   }
}

return(0);

}

static int ADPAIR1[MAXLIGSTRU] = {MAXLIGSTRU*(-1)};
static int ADPAIR2[MAXLIGSTRU] = {MAXLIGSTRU*(-1)};
static int PAIRT[MAXLIGSTRU] = {MAXLIGSTRU*(0)};

void Get_Att_Frag(int ifrag,int *FrgArr,int *FrgN)
{
   int i;

   for (i=0; i < singleb.N; i++) {
	if (singleb.SngFrg[i][0] == ifrag || singleb.SngFrg[i][1] == ifrag) {
	   if (singleb.SngFrg[i][0] == ifrag) {
		FrgArr[*FrgN] = singleb.SngFrg[i][1];
	   }
	   if (singleb.SngFrg[i][1] == ifrag) {
		FrgArr[*FrgN] = singleb.SngFrg[i][0];
	   }
	   (*FrgN)++;
	}
   }
}

void R2Tri(float *v1, float *cen, float *wxyz, int dg, int itri)
{
   int i,j,deg;
   float pt[3],CEN[3];
   double R1[4][4],sina,cosa;

   Get_Tsin(dg,&sina,&cosa);

   CEN[0] = 0.0; CEN[1] = 0.0; CEN[2] = 0.0;

   vecnrm(v1);

   Frst_Rot(CEN,v1,sina,cosa,R1);

   for (i=0; i<ndocka; i++) {


     for (j=0; j < 3; j++) {
	wxyz[3*i+j] = ((float) TriArr[itri]->coo[3*i+j] - cen[j]);
     }


     for (j=0; j<3; j++) {
	pt[j] = wxyz[i*3+j];
     }

     xyzROT4(R1,pt);

     for (j=0; j<3; j++) {
	wxyz[i*3+j] = pt[j] + cen[j];
     }

   }

}


void TriRot(int itri, float *wxyz, float *cwxyz, float *cen, float *v1,
		float *q, float *vdwr, float *vdwe,
		float *ql, float *vdwrl, float *vdwel, float *F,
		float *dir, int *frg, int *iclos)
{

   int k,l;
   float Emin,E,tdir[3];
   int ang;
   float angle;

   Emin = BIGD;

// translate origin to center of triangle

   for (ang=-60; ang < 61; ang++) {

	R2Tri(v1,cen,wxyz,ang,itri);

// calculate forces and energy on rotated ligand coordinates

	CalcFE(wxyz,xyzp->coo,iclos,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,&E,dir,frg);

	if (E < Emin)  {
	    Emin = E;
	    for (k=0; k < ndocka; k++) {
		for (l=0; l < 3; l++)  {
		   cwxyz[k*3+l] = wxyz[k*3+l];
		}
	    }
	}

   } 

   if (Emin < BIGD) {

	TriArr[itri]->eint = Emin;

	for (k=0; k < ndocka; k++) {
	    for (l=0; l < 3; l++) {
		TriArr[itri]->coo[k*3+l] = (double) cwxyz[k*3+l];
	    }
	}
		   
   } else {
	TriArr[itri]->eint = 0.0;
   }


}

int GenCen(int itri,float *v,float *cen)
{
   int i,j,ind1,ind2,lig[3],itel;
   double co[3][3];

   itel = 0;

   for (i=0; i < 3; i++) {
	lig[i] = TriArr[itri]->lig[i];

	if (ligtyp[lig[i]]->type == H_ACC) {

	   for (j=0; j < 3; j++) {
		co[itel][j] = TriArr[itri]->coo[3*ligtyp[lig[i]]->atom[0]+j];
	   }
	   itel++;

	} else if (ligtyp[lig[i]]->type == H_DON) {

	   for (j=0; j < 3; j++) {
		co[itel][j] = TriArr[itri]->coo[3*ligtyp[lig[i]]->atom[1]+j];
	   }
	   itel++;
	}
   }
   
   if (itel == 2) {
      for (j=0; j < 3; j++) {
	v[j] = co[1][j] - co[0][j];
	cen[j] = (co[1][j] + co[0][j])/2.0;
      }
      return(1);
   } else {
      return(0);
   }
}

int IsAccDon(int itri)
{
   int i,lig[3],typ[3],ida[3];

   if (itri < 0) return(0);

   for (i=0; i < 3; i++) {
	ida[i] = 0;
	lig[i] = TriArr[itri]->lig[i];
	typ[i] = ligtyp[lig[i]]->type;
	if (typ[i] == H_ACC || typ[i] == H_DON) ida[i] = 1;
   }

   if (ida[0] && ida[1] && ida[2]) return(1);

   return(0);
}

int OptTris()
{
   int i,j,k,l,n,it,*iclos;
   float *F,E,a,b,c,vl;
   float *q,*vdwr,*vdwe,dir[3],tdir[3];
   float ql[MXLIGA],vdwrl[MXLIGA],vdwel[MXLIGA];
   int frg[MXLIGA],FrgArr[9],FrgN;
   float *wxyz,*rwxyz,*cwxyz,*tmpxyz,cen[3],vrot[3],Ebck;

   if (!AllArr(&q,&vdwr,&vdwe,&iclos,&F)) return(0);

   allFConf(&wxyz,ndocka);
   allFConf(&rwxyz,ndocka);
   allFConf(&cwxyz,ndocka);
   allFConf(&tmpxyz,ndocka);

   AssChg(q);
   AssVDW(vdwr,vdwe);
   AssVDWL(vdwrl,vdwel,ql);

   FrgN = 0;
   Get_Att_Frag(ADPAIR1[0],FrgArr,&FrgN);
   Get_Att_Frag(ADPAIR2[0],FrgArr,&FrgN);

   if (IsAccDon(0)) {
      vdwscal = VDWSCAL;
   }

if (debugdck) fprintf(stderr,"OptTris: ntris %d\n\n",ntris);

   for (i=0; i < ntris; i++) {
	if (TriArr[i] != NULL) {

	    FillOpt(iclos,i);

	    ChkBump(iclos,i);


// translate origin to center of triangle

	    Trans2Cen(wxyz,i,ndocka);

	    if (MapConformers) {
		PickFrag(frg,i,ndocka);
	    } else {
		PickFrags(frg,i,ndocka);
	    }


if (Match_tri(TriArr[i],11,1,13,69,70,12)) {
fprintf(stderr,"OptTris: frg\n\n");
for (j=0; j < ndocka; j++) {
fprintf(stderr,"frg[%d] %d\n",j,frg[j]);
}
fprintf(stderr,"OptTris: iclos\n\n");
for (j=0; j < *xyzp->iatoms; j++) {
if (iclos[j]) {
fprintf(stderr,"iclos[%d] %d\n",j,iclos[j]);
}
}
}
	    RotTri(i,-9,10,5,
		wxyz,rwxyz,cwxyz,q,vdwr,vdwe,
		ql,vdwrl,vdwel,F,dir,frg,iclos);

	    if (TriArr[i]->eint < 0.0) {

		RotTri(i,-4,5,1,
		wxyz,rwxyz,cwxyz,q,vdwr,vdwe,
		ql,vdwrl,vdwel,F,dir,frg,iclos);

		RotTri(i,-4,5,1,
		wxyz,rwxyz,cwxyz,q,vdwr,vdwe,
		ql,vdwrl,vdwel,F,dir,frg,iclos);

		if (GenCen(i,vrot,cen)) {

		   Ebck = TriArr[i]->eint;

		   FillFull(iclos,i);

		   PickFull(frg,i,ndocka);

		   TriRot(i,wxyz,cwxyz,cen,vrot,q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,dir,frg,iclos);

		   TriArr[i]->eint = Ebck;
		}

	    } else {
		if (TriArr[i]->coo != NULL) free(TriArr[i]->coo);
		free(TriArr[i]);
		TriArr[i] = NULL;
	    }

	}
   }

   Compress_Tri_L();

if (debugdck) {
   for (i=0; i < ntris; i++) {
	if (TriArr[i] != NULL) {
	   PrtTrip(i,9,25);
	}
   }
}

   if (ntris > 0) {
	if (MapConformers) {
	   qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmptriF);
	} else {
	   qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmpeint);
	}
   }

   vdwscal = 1.0;

if (debugdck) Write_Results("optdock.mol2",TriArr,ntris,&DCKxyz,1,1);

}

int gttpar(iat,it,trs1,trs2,trs3,trs4,ityp)
int iat[4];
int it[4];
float trs1[4];
float trs2[4];
float trs3[4];
float trs4[4];
short int *ityp;
{
      float todeg,angl;
      int first = 1,i1,i2,i3,i4,ita,itb,itc,itd;
      int l,istat,it1,it2,it3,it4;

      todeg = 45.0e0 / atan(1.0e0);
      istat = 0;

      i1 = (int) ityp[iat[0]];
      i2 = (int) ityp[iat[1]];
      i3 = (int) ityp[iat[2]];
      i4 = (int) ityp[iat[3]];

      it[0] = iat[0];
      it[1] = iat[1];
      it[2] = iat[2];
      it[3] = iat[3];

      ita = ABS(i1);
      if (ita == 72) ita = 6;

      itb = ABS(i2);
      if (itb == 72) itb = 6;

      itc = ABS(i3);
      if (itc == 72) itc = 6;

      itd = ABS(i4);
      if (itd == 72) itd = 6;

      it1 = ita;
      it2 = itb;
      it3 = itc;
      it4 = itd;

      if (itb < itc) {
         it1 = ita;
         it2 = itb;
         it3 = itc;
         it4 = itd;
      } else if (itc < itb) {
         it1 = itd;
         it2 = itc;
         it3 = itb;
         it4 = ita;
      } else if (ita < itd) {
         it1 = ita;
         it2 = itb;
         it3 = itc;
         it4 = itd;
      } else if (itd < ita) {
         it1 = itd;
         it2 = itc;
         it3 = itb;
         it4 = ita;
      }

next:

      istat = 0;
      for (l=0;l<MXGTOR;l++) {
          if ((gftcon[l][0] == it1) &&
	      (gftcon[l][1] == it2) &&
	      (gftcon[l][2] == it3) &&
	      (gftcon[l][3] == it4) ) {

                 istat = 1;

                 trs1[0] = gftor1[l][0];
                 trs1[1] = gftor1[l][1];
                 angl = gftor1[l][1] / todeg;
                 trs1[2] = cos(angl);
                 trs1[3] = sin(angl);

                 trs2[0] = gftor2[l][0];
                 trs2[1] = gftor2[l][1];
                 angl = gftor2[l][1] / todeg;
                 trs2[2] = cos(angl);
                 trs2[3] = sin(angl);

                 trs3[0] = gftor3[l][0];
                 trs3[1] = gftor3[l][1];
                 angl = gftor3[l][1] / todeg;
                 trs3[2] = cos(angl);
                 trs3[3] = sin(angl);

                 trs4[0] = gftor4[l][0];
                 trs4[1] = gftor4[l][1];
                 angl = gftor4[l][1] / todeg;
                 trs4[2] = cos(angl);
                 trs4[3] = sin(angl);

	  }
      }

      if (istat == 0 && first) {
	it1 = 1;
	it4 = 1;
	first = 0;
	goto next;
      }

      if (istat == 0) 
            fprintf(stderr,"No torsion parameter: %3d %3d %3d %3d\n",\
		it[0],it[1],it[2],it[3]);

      return(istat);
}

// torset initialises torsion parameters, based on two atoms
// calls gttpar: gets parameters from gftor1,2,3,4 arrays
// based on connectivity of atom types (gftcon array)
// sets it[4] array
//
// first call torset then tors for calc etors (with it[4] as input)
// based on value of torsion angle, calculated from coordinates
//
// tors calculates Etors or Eimp_tors, depending on value idoimp

int torset(ia1,ia2,nt,it,trs1,trs2,trs3,trs4,iconn,ityp)
int ia1;
int ia2;
int *nt;
int it[MXTORS][4];
float trs1[MXTORS][4];
float trs2[MXTORS][4];
float trs3[MXTORS][4];
float trs4[MXTORS][4];
int *iconn;
short int *ityp;
{
      int iat[4],j,k,l,itt[4];
      float trs1t[4],trs2t[4],trs3t[4],trs4t[4];

      iat[1] = ia1;
      iat[2] = ia2;
      *nt = 0;

      for (j=0; j < iconn[iat[1]*(MXCON+1)]; j++) {

	iat[0] = iconn[iat[1]*(MXCON+1)+1+j] - 1;

	if (iat[0] >= 0 && iat[0] != iat[2]) {

	   for (k=0; k < iconn[iat[2]*(MXCON+1)]; k++) {
		iat[3] = iconn[iat[2]*(MXCON+1)+1+k] - 1;

		if (iat[3] >= 0 && (iat[3] != iat[1] && iat[3] != iat[0]) ) {

		   if (gttpar(iat,itt,trs1t,trs2t,trs3t,trs4t,ityp)) {
			if (*nt < MXTORS) {
			   for (l=0; l < 4; l++) {
				it  [*nt][l] = itt[l];
				trs1[*nt][l] = trs1t[l];
				trs2[*nt][l] = trs2t[l];
				trs3[*nt][l] = trs3t[l];
				trs4[*nt][l] = trs4t[l];
			   }
			   (*nt)++;
			}
		   } else {
		      fprintf(stderr,"torsion parameter not found\n");
		      return(0);
		   }

		}

	   }

	}

      }

      return(1);
}

void tors(et,nt,it,trs1,trs2,trs3,trs4,coo)
float *et;
int nt;
int it[MXTORS][4];
float trs1[MXTORS][4];
float trs2[MXTORS][4];
float trs3[MXTORS][4];
float trs4[MXTORS][4];
double *coo;
// double coo or float coo ? check with dckxyz
// improd outputs a double *, here used as float *; need conversion !!!
{

   int i,j,ia,ib,ic,id,nterms;
   float cosna[4],sinna[4],v[4],sa[4],ca[4],phi[4];
   float va[3],vb[3],vc[3],vd[3],vba[3],vcb[3],vdc[3],vca[3],vdb[3];
   float vt[3],vu[3],vtu[3];
   float rt2,ru2,rtru,rcb,e;

   *et = 0.0;

// ia,ib,ic,id should run from 0-n, and therfor so should iti[] and it[]

   nterms = 4;

   for (i=0; i < nt; i++) {

      ia = it[i][0];
      ib = it[i][1];
      ic = it[i][2];
      id = it[i][3];

// coordinates of atoms a,b,c,d

      for (j=0; j <3; j++) {
	va[j] = ((float) coo[ia*3+j])*toangs;
	vb[j] = ((float) coo[ib*3+j])*toangs;
	vc[j] = ((float) coo[ic*3+j])*toangs;
	vd[j] = ((float) coo[id*3+j])*toangs;
      }

// vectors ba, cb, dc, ca, db

      vsubt(vb,va,vba);
      vsubt(vc,vb,vcb);
      vsubt(vd,vc,vdc);
      vsubt(vc,va,vca);
      vsubt(vd,vb,vdb);

// t outvector ba x cb, u outvector cb x dc

      cross(vba,vcb,vt);
      cross(vcb,vdc,vu);

// tu outvector t x u

      cross(vt,vu,vtu);

      rt2 = vt[0]*vt[0] + vt[1]*vt[1] + vt[2]*vt[2];
      ru2 = vu[0]*vu[0] + vu[1]*vu[1] + vu[2]*vu[2];

      rtru = veclen(vu)*veclen(vt);

      if (rtru > 0.0) {

	rcb = veclen(vcb);

	IMPRD(vt,vu,&cosna[0],1);
	IMPRD(vcb,vtu,&sinna[0],0);

	sinna[0] = sinna[0] / (rcb*rtru);

// torsional parameters 

	v [0] = trs1[i][0];
	ca[0] = trs1[i][2];
	sa[0] = trs1[i][3];

	v [1] = trs2[i][0];
	ca[1] = trs2[i][2];
	sa[1] = trs2[i][3];

	v [2] = trs3[i][0];
	ca[2] = trs3[i][2];
	sa[2] = trs3[i][3];

	v [3] = trs4[i][0];
	ca[3] = trs4[i][2];
	sa[3] = trs4[i][3];


	for (j=0; j < nterms-1; j++) {
	   cosna[j+1] = cosna[0]*cosna[j] - sinna[0]*sinna[j];
	   sinna[j+1] = cosna[0]*sinna[j] + sinna[0]*cosna[j];
	}

	e = 0.0;

	for (j=0; j < nterms; j++) {
	   phi[j]  = 1.0 + (cosna[j]*ca[j] + sinna[j]*sa[j]);
	   e = e + v[j]*phi[j];
	}

	*et = *et + e;

      }
   }

}

float CalTorS(isng,xyz,coo,nt,it,trs1,trs2,trs3,trs4)
int isng;
COOSTRU *xyz;
double *coo;
int *nt;
int it[MXTORS][4];
float trs1[MXTORS][4];
float trs2[MXTORS][4];
float trs3[MXTORS][4];
float trs4[MXTORS][4];
{
   int i,ia1,ia2,err;
   float et;

   ia1 = singleb.sng[isng][0];
   ia2 = singleb.sng[isng][1];
   et = 0.0;err = 1;

   if (!singleb.sngdone[isng]) {
	*nt = 0;
	err = torset(ia1,ia2,nt,it,trs1,trs2,trs3,trs4,
		xyz->iconn,singleb.ityp);
	singleb.sngdone[isng] = 1;
   }

   if (err) tors(&et,*nt,it,trs1,trs2,trs3,trs4,coo);

   return et;
}

void CalTorE(xyz)
COOSTRU *xyz;
{
   int i,nt,it[MXTORS][4],ia1,ia2;
   float trs1[MXTORS][4];
   float trs2[MXTORS][4];
   float trs3[MXTORS][4];
   float trs4[MXTORS][4];
   float et;

   for (i=0; i < singleb.N; i++) {
	ia1 = singleb.sng[i][0];
	ia2 = singleb.sng[i][1];
	nt = 0; et = 0.0;
	if (torset(ia1,ia2,&nt,it,trs1,trs2,trs3,trs4,
		xyz->iconn,singleb.ityp)) {
	   tors(&et,nt,it,trs1,trs2,trs3,trs4,xyz->coo);
	}
   }
}

void vdwlj(ev,xyz)
float *ev;
COOSTRU *xyz;
{
      int i,j,k,i1,i2;
      float vr[3],v14sc,vdwr1,vdwr2,vdwe1,vdwe2,rv2,rsum,epsm,rv,
		rs2,rs3,p6,p12,e;

      *ev = 0.0;
      v14sc = 0.5;

// we only do this for 1..4 interactions

      for (i=0; i<ndocka; i++) {

	i1 = (int) xyz->ityp[i];
	i1 = ABS(i1)-1;
	vdwr1 = gfvdw[i1][0];
        vdwe1 = gfvdw[i1][1];

	if (vdwe1 != 0.0) {

	   for (k=i+1; k<ndocka; k++) {

		i2 = (int) xyz->ityp[k];
		i2 = ABS(i2)-1;
		vdwr2 = gfvdw[i2][0];
        	vdwe2 = gfvdw[i2][1];

		if (vdwe2 != 0.0) {

		  for (j=0; j<3; j++) {
			vr[j] = (xyz->coo[i*3+j] - xyz->coo[k*3+j])*toangs;
		  }
 
		  rv2 = vr[0]*vr[0] + vr[1]*vr[1] + vr[2]*vr[2];


//          [ (Rmin)**12       (Rmin)**6 ]
// e = eps  [ (----)     - 2.0 (----)    ]
//          [ ( r  )           ( r  )    ]


		  rsum = vdwr1 + vdwr2;
		  epsm = sqrt(vdwe1 * vdwe2);
		  epsm = epsm * v14sc;
		  rv   = sqrt(rv2);
		  rs2  = rsum*rsum;
		  rs3  = rs2*rsum;
		  p6   = (rs3*rs3) / (rv2*rv2*rv2);
		  p12  = p6 * p6;

		  e    = epsm * (p12 - 2.0*p6);

		  *ev   = *ev + e;
   
		}

	   }
	}
      }

}

float vdwS(isng,xyz,coo)
int isng;
COOSTRU *xyz;
double *coo;
{
      int i,j,k,i1,i2,ia1,ia2,ia3,ia4;
      float vr[3],v14sc,vdwr1,vdwr2,vdwe1,vdwe2,rv2,rsum,epsm,rv,
		rs2,rs3,p6,p12,e,ev;

      ev = 0.0;
      v14sc = 0.5;

      ia1 = singleb.sng[isng][0];
      ia2 = singleb.sng[isng][1];

// we only do this for 1..4 interactions

      for (i=0; i < xyz->iconn[ia1*(MXCON+1)]; i++) {

	ia3 = xyz->iconn[ia1*(MXCON+1)+1+i] - 1;

	if (ia3 != ia2) {

	   i1 = (int) xyz->ityp[ia3];
	   i1 = ABS(i1)-1;
	   vdwr1 = gfvdw[i1][0];
           vdwe1 = gfvdw[i1][1];

	   if (vdwe1 != 0.0) {

	     for (k=0; k < xyz->iconn[ia2*(MXCON+1)]; k++) {

		ia4 = xyz->iconn[ia2*(MXCON+1)+1+k] - 1;

		if (ia4 != ia1) {

		   i2 = (int) xyz->ityp[ia4];
		   i2 = ABS(i2)-1;
		   vdwr2 = gfvdw[i2][0];
        	   vdwe2 = gfvdw[i2][1];

		   if (vdwe2 != 0.0) {

			for (j=0; j<3; j++) {
			   vr[j] = (coo[ia3*3+j] - coo[ia4*3+j])*toangs;
			}
 
			rv2 = vr[0]*vr[0] + vr[1]*vr[1] + vr[2]*vr[2];


//          [ (Rmin)**12       (Rmin)**6 ]
// e = eps  [ (----)     - 2.0 (----)    ]
//          [ ( r  )           ( r  )    ]


			rsum = vdwr1 + vdwr2;
			epsm = sqrt(vdwe1 * vdwe2);
			epsm = epsm * v14sc;
			rv   = sqrt(rv2);
			rs2  = rsum*rsum;
			rs3  = rs2*rsum;
			p6   = (rs3*rs3) / (rv2*rv2*rv2);
			p12  = p6 * p6;

			e    = epsm * (p12 - 2.0*p6);

			ev   = ev + e;
   
		   }
		}

	     } // for k
	   } // ifend vdwe1 != 0
	} // ifend ia3 != ia2
      }

      return(ev);
}

void Create_Vecs(ia1,ia2,v1,v2,v3,k,xyz)
int ia1;
int ia2;
float *v1;
float *v2;
float *v3;
int k;
COOSTRU *xyz;
{
    int i,j,ia3;
    float vl,v23[3];

    for (j=0; j < 3; j++) {
	v1[j] = ((float) (TriArr[k]->coo[ia1*3+j] - 
			TriArr[k]->coo[ia2*3+j]));
    }

    vl = veclen(v1);

    for (j=0; j < 3; j++) {
	v1[j] = v1[j] / vl;
    }

    for (i=0; i < xyz->iconn[ia2*(MXCON+1)]; i++) {

	   ia3 = xyz->iconn[ia2*(MXCON+1)+1+i] - 1;

	   if (ia3 != ia1) {

		for (j=0; j < 3; j++) {
		   v23[j] = ((float) (TriArr[k]->coo[ia3*3+j] - 
		   		   TriArr[k]->coo[ia2*3+j]));
		}
		break;
	   }

    }

    cross(v1,v23,v2);

    vl = veclen(v2);

    for (j=0; j < 3; j++) {
	v2[j] = v2[j] / vl;
    }

    cross(v1,v2,v3);

}


void RotDih(ia1,ia2,euc,coo,feuc,angle,v1,v2,v3,idx)
int ia1;
int ia2;
double *euc;
double *coo;
float *feuc;
float angle;
float *v1;
float *v2;
float *v3;
int idx;
{
     int i,j,k;
     float v23[3],x,y,z,x2,y2,cosa,sina;
     double cc;

     cosa = cos(angle);
     sina = sin(angle);

     for (k=0; k < ndocka; k++) {

	 if (jact[idx][k] == 1 && k != ia1 && k != ia2) {

	   for (j=0; j < 3; j++) {
		v23[j] = (float) (coo[k*3+j] - coo[ia2*3+j]);
	   }

	   IMPRD(v1,v23,&z,0);
	   IMPRD(v2,v23,&y,0);
	   IMPRD(v3,v23,&x,0);

	   x2 = (cosa*x - sina*y);
	   y2 = (sina*x + cosa*y);

// new coordinates

	   for (j=0; j < 3; j++) {
		cc = (double) (v1[j]*z + v2[j]*y2 + v3[j]*x2);
		euc[k*3+j] = coo[ia2*3+j] + cc;
		feuc[k*3+j] = (float) euc[k*3+j];
	   }

	 } else {
	   for (j=0; j < 3; j++) {
		euc[k*3+j] = coo[k*3+j];
		feuc[k*3+j] = (float) euc[k*3+j];
	   }
	 }
     } // end for k

}

void cplig(euc,coo)
double *euc;
double *coo;
{
     int i,j;

     for (i=0; i < ndocka; i++) {
	for (j=0; j < 3; j++) {
	    euc[i*3+j] = coo[i*3+j];
	}
     }

}


float FindCooAngles(int ias[2][MXDIH], int sngs[MXDIH], 
			int ndih, int itri, int *iclos,int *frg,
			float *q,float *vdwr,float *vdwe,
			float *ql,float *vdwrl,float *vdwel,float *F,
			double *euc,double *coo,COOSTRU *xyz,
			int *nt,int it[MXTORS][4],
			float trs1[MXTORS][4],
			float trs2[MXTORS][4],
			float trs3[MXTORS][4],
			float trs4[MXTORS][4])
{
     int ang1,ang2,ang3,ang4,k;
     float angle1,angle2,angle3,angle4,todeg;
     float p1,p2,pf,dir[3],emin,tmin;
     float v1[3],v2[3],v3[3];
     float *feuc,*feuc1,*feuc2,*feuc3;
     double *euc1,*euc2,*euc3,*finc;

     allFConf(&feuc,ndocka);
     allFConf(&feuc1,ndocka);
     allFConf(&feuc2,ndocka);
     allFConf(&feuc3,ndocka);
     allConf(&euc1,ndocka);
     allConf(&euc2,ndocka);
     allConf(&euc3,ndocka);
     allConf(&finc,ndocka);

// need buffer to store orig coordinates !! Can be feuc ???
// coo has the ligand pose

     todeg = 45.0 / atan(1.0);

     emin = BIGD;
     tmin = BIGD;

     for (ang1=-2; ang1 < 3; ang1++) {

	angle1 = (((float) ang1)*30.0)/todeg;
	Create_Vecs(ias[0][0],ias[1][0],v1,v2,v3,itri,xyz);
	RotDih(ias[0][0],ias[1][0],euc,coo,feuc,angle1,v1,v2,v3,0);

	if (CalClash(iclos,itri,vdwr,vdwrl,euc,0) == BIGD) {

	   continue;

	} else {

	   p1 = CalTorS(sngs[0],xyz,euc,nt,it,trs1,trs2,trs3,trs4);

	   CaljFE(feuc,xyzp->coo,iclos,
		q,vdwr,vdwe,ql,vdwrl,vdwel,F,&p2,dir,frg);

	   if (p2 < emin) {
		emin = p2;
		tmin = p1;
		cplig(finc,euc);
	   }
	}

	if (ndih > 1) {

	 for (ang2=-2; ang2 < 3; ang2++) {

	   angle2 = (((float) ang2)*30.0)/todeg;
	   Create_Vecs(ias[0][1],ias[1][1],v1,v2,v3,itri,xyz);
	   RotDih(ias[0][1],ias[1][1],euc1,euc,feuc1,angle2,v1,v2,v3,1);

	   if (CalClash(iclos,itri,vdwr,vdwrl,euc1,1) == BIGD) {
		continue;
	   } else {

		p1 = CalTorS(sngs[1],xyz,euc1,nt,it,trs1,trs2,trs3,trs4);

		CaljFE(feuc1,xyzp->coo,iclos,
			q,vdwr,vdwe,ql,vdwrl,vdwel,F,&p2,dir,frg);

		if (p2 < emin) {
		   emin = p2;
		   tmin = p1;
		   cplig(finc,euc1);
		}

	   }

	   if (ndih > 2) {

	      for (ang3=-2; ang3 < 3; ang3++) {

		angle3 = (((float) ang3)*30.0)/todeg;
		Create_Vecs(ias[0][2],ias[1][2],v1,v2,v3,itri,xyz);
	   	RotDih(ias[0][2],ias[1][2],euc2,euc1,feuc2,angle3,
			v1,v2,v3,2);
		if (CalClash(iclos,itri,vdwr,vdwrl,euc2,2) == BIGD) {
		   continue;
		} else {


		   p1 = CalTorS(sngs[2],xyz,euc2,nt,it,trs1,trs2,trs3,trs4);

		   CaljFE(feuc2,xyzp->coo,iclos,
			q,vdwr,vdwe,ql,vdwrl,vdwel,F,&p2,dir,frg);

		   if (p2 < emin) {
			emin = p2;
			tmin = p1;
			cplig(finc,euc2);
		   }

		}

		if (ndih > 3) {

		  for (ang4=-2; ang4 < 3; ang4++) {

		   angle4 = (((float) ang4)*30.0)/todeg;
		   Create_Vecs(ias[0][3],ias[1][3],v1,v2,v3,itri,xyz);
	   	   RotDih(ias[0][3],ias[1][3],euc3,euc2,feuc3,angle4,
				v1,v2,v3,3);
		   if (CalClash(iclos,itri,vdwr,vdwrl,euc3,3) == BIGD) {
			continue;
		   } else {
			p1 = CalTorS(sngs[3],xyz,euc3,
				nt,it,trs1,trs2,trs3,trs4);

			CaljFE(feuc3,xyzp->coo,iclos,
				q,vdwr,vdwe,ql,vdwrl,vdwel,F,&p2,dir,frg);

			if (p2 < emin) {
			   emin = p2;
			   tmin = p1;
			   cplig(finc,euc3);
			}
		   }
		  }
		}

	      }
	   }

	 }
	}
     }

/* this part is for when MXDIH is raised to six !!!
     if (ndih > 4) {

      for (ang1=-2; ang1 < 3; ang1++) {

	angle1 = (((float) ang1)*30.0)/todeg;
	Create_Vecs(ias[0][4],ias[1][4],v1,v2,v3,itri,xyz);
	RotDih(ias[0][4],ias[1][4],euc,coo,feuc,angle1,v1,v2,v3,4);

	if (CalClash(iclos,itri,vdwr,vdwrl,euc,4) == BIGD) {

	   continue;

	} else {

	   p1 = CalTorS(sngs[4],xyz,euc,nt,it,trs1,trs2,trs3,trs4);

	   CaljFE(feuc,xyzp->coo,iclos,
		q,vdwr,vdwe,ql,vdwrl,vdwel,F,&p2,dir,frg);

	   if (p2 < emin) {
		emin = p2;
		tmin = p1;
		cplig(finc,euc);
	   }
	}

	if (ndih > 5) {

	 for (ang2=-2; ang2 < 3; ang2++) {

	   angle2 = (((float) ang2)*30.0)/todeg;
	   Create_Vecs(ias[0][5],ias[1][5],v1,v2,v3,itri,xyz);
	   RotDih(ias[0][5],ias[1][5],euc1,euc,feuc1,angle2,v1,v2,v3,5);

	   if (CalClash(iclos,itri,vdwr,vdwrl,euc1,5) == BIGD) {
		continue;
	   } else {

		p1 = CalTorS(sngs[5],xyz,euc1,nt,it,trs1,trs2,trs3,trs4);

		CaljFE(feuc1,xyzp->coo,iclos,
			q,vdwr,vdwe,ql,vdwrl,vdwel,F,&p2,dir,frg);

		if (p2 < emin) {
		   emin = p2;
		   tmin = p1;
		   cplig(finc,euc1);
		}

	   }

	 }
	}
      }
     }
*/

     if (emin == BIGD) {
//	RemCC_One(itri);
     } else {
	cplig(euc,finc);
     }

     free(finc);
     free(euc1);
     free(euc2);
     free(euc3);
     free(feuc);
     free(feuc1);
     free(feuc2);
     free(feuc3);

if (debugdck) fprintf(stderr,"\nFindCooAngles: tmin %.3f Emin %.3f\n\n",tmin,emin);

     if (tmin == BIGD) tmin = 0.0;
     if (emin == BIGD) emin = 0.0;

     return(tmin+emin);
}


float FindOAngles(int ias[2][MXDIH], int sngs[MXDIH], 
		int ndih, int itri, int *iclos, int *frg,
		double *euc, COOSTRU *xyz, double *coo,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel, float *F)
{
   int nt,k;
   int     it[MXTORS][4];
   float trs1[MXTORS][4];
   float trs2[MXTORS][4];
   float trs3[MXTORS][4];
   float trs4[MXTORS][4];
   float Emin;

   nt = 0;

// coo ligand pose in -> euc is adjusted optimised pose

   Emin = FindCooAngles(ias,sngs,ndih,itri,iclos,frg,
			q,vdwr,vdwe,
			ql,vdwrl,vdwel,F,
			euc,coo,xyz,&nt,it,trs1,trs2,trs3,trs4);

   return(Emin);

// keep lowest prof ?? and the associated euc ??
}

float FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,co,coo,xyz,
			nt,it,trs1,trs2,trs3,trs4)
int isng;
int ic[3];
int ia2;
int itel;
float v1[3];
float v2[3];
float v3[3];
float angle;
double co[3][3];
double *coo;
COOSTRU *xyz;
int *nt;
int it[MXTORS][4];
float trs1[MXTORS][4];
float trs2[MXTORS][4];
float trs3[MXTORS][4];
float trs4[MXTORS][4];
{
     int i,j,in;
     float cosa,sina,v23[3],x,y,z,x2,y2,p1,p2;

       cosa = cos(angle);
       sina = sin(angle);

// restore original coordinates 

       for (i=0; i < itel; i++) {
	 if (ic[i] >= 0) {
	   for (j=0; j < 3; j++) {
		coo[ic[i]*3+j] = co[i][j];
	   }
	 }
       }

       for (i=0; i < itel; i++) {

	   in = ic[i];

	   for (j=0; j < 3; j++) {
		v23[j] = (float) (coo[in*3+j] - coo[ia2*3+j]);
	   }

	   IMPRD(v1,v23,&z,0);
	   IMPRD(v2,v23,&y,0);
	   IMPRD(v3,v23,&x,0);

	   x2 = (cosa*x - sina*y);
	   y2 = (sina*x + cosa*y);

// new coordinates

	   for (j=0; j < 3; j++) {
		coo[in*3+j] = coo[ia2*3+j] +
				(v1[j]*z + v2[j]*y2 + v3[j]*x2);
	   }
        }
	p1 = CalTorS(isng,xyz,coo,nt,it,trs1,trs2,trs3,trs4);
        p2 = vdwS(isng,xyz,coo);
	return(p1+p2);

}


void FindAngles(int first, int ia2, int isng, int itel, int *ic,
		COOSTRU *xyz, double co[3][3], double *coo,
		float *v1, float *v2, float *v3,
		float *angopt, float *toropt)
{
   int i,j,ang,angp1,angm1,ango[3],nt,nprof;
   float cosa,sina,angle,todeg,oute,prof[36];
   float anglep5,anglem5,outep5,outem5;
   int it[MXTORS][4];
   float trs1[MXTORS][4];
   float trs2[MXTORS][4];
   float trs3[MXTORS][4];
   float trs4[MXTORS][4];

   todeg = 45.0 / atan(1.0);

   nprof = 0;
   nt = 0;

   for (ang=0; ang < 36; ang++) {
	angle = (((float) ang)*10.0)/todeg;
	if (first) {
	  prof[ang] = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,
			co,xyz->coo,xyz,&nt,it,trs1,trs2,trs3,trs4);
	} else {
	  prof[ang] = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,
			co,coo,xyz,&nt,it,trs1,trs2,trs3,trs4);
	}
	if (prof[ang] == 0.0) nprof++;

   }

   if (nprof == 36 && singleb.dupsng[isng] == 1) {
	toropt[0] = 0.0;
	angopt[0] = 0.0;
	return;
   }

   angopt[0] = -BIGD;
   angopt[1] = -BIGD;
   angopt[2] = -BIGD;

   toropt[0] =  BIGD;
   toropt[1] =  BIGD;
   toropt[2] =  BIGD;

   itel = -1;

   for (ang=0; ang < 36; ang++) {

	if (ang == 0) {
	   angm1 = 35;
	   angp1 = ang + 1;

	} else if (ang == 35) {
	   angm1 = ang - 1;
	   angp1 = 0;
	} else {
	   angm1 = ang - 1;
	   angp1 = ang + 1;
	}

	if (prof[ang] < prof[angm1] && prof[ang] < prof[angp1]) {
	   itel++;
	   toropt[itel] = prof[ang];
	   angopt[itel] = ((float) ang)*10.0;
	   ango[itel]   = ang;
	}
   }

   itel++;

   if (itel == 2) toropt[2] = 0.0;

   for (i=0; i < itel; i++) {

	angle   = ango[i]*10 + 5 ;
	anglep5 = ((int) angle) / todeg;

	if (first) {
	  outep5 = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,anglep5,
			co,xyz->coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	} else {
	  outep5 = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,anglep5,
			co,coo,xyz,&nt,it,trs1,trs2,trs3,trs4);
	}

	angle   = ango[i]*10 - 5 ;
	anglem5 = ((int) angle) / todeg;

	if (first) {
	  outem5 = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,anglem5,
			co,xyz->coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	} else {
	  outem5 = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,anglem5,
			co,coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	}

	if (outep5 < toropt[i]) {

	  toropt[i] = outep5;
	  angopt[i] = anglep5;

	  for (j=0; j < 5; j++) {

	    angle = ango[i]*10 + j + 1;
	    angle = ((int) angle) / todeg;

	    if (first) {
		oute = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,
			co,xyz->coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	    } else {
		oute = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,
			co,coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	    }

	    if (oute < toropt[i]) {
		toropt[i] = oute;
	  	angopt[i] = angle;
	    }
		
	  }
	}

	if (outem5 < toropt[i]) {

	  toropt[i] = outem5;
	  angopt[i] = anglem5;

	  for (j=0; j < 5; j++) {

	    angle = ango[i]*10 - 5 + j;
	    angle = ((int) angle) / todeg;

	    if (first) {
		oute = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,
			co,xyz->coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	    } else {
		oute = FindOptAngles(isng,ic,ia2,itel,v1,v2,v3,angle,
			co,coo,xyz,
			&nt,it,trs1,trs2,trs3,trs4);
	    }

	    if (oute < toropt[i]) {
		toropt[i] = oute;
	  	angopt[i] = angle;
	    }
		
	  }
	}
   }

   if (itel == 0) {

	angopt[0] = 0.0;
	angopt[1] = 120.0;
	angopt[2] = 240.0;
	itel = 3;

   } else {
   }

   for (i=0; i < itel; i++) {
	for (j=0; j < 3; j++) {
	   if (first) {
		xyz->coo[ic[i]*3+j] = co[i][j];
	   } else {
		coo[ic[i]*3+j] = co[i][j];
	   }
	}
   }

}

float CalcInter(double *cool,double *coo,int *iclos,
		float *q,float *vdwr,float *vdwe,
		float *ql,float *vdwrl,float *vdwel)
{
   int i,j,l;
   float vr[3],rv,rv2,rs2,rs3,rsum,rinv,epsm,p6,p12;
   float e,ev,eq,econv;
   float evmax;
   int ivmax,jvmax;

   ev = 0.0; eq = 0.0;
   econv = 332.05382;
   evmax = 0.0;

   for (i=0; i < *xyzp->iatoms; i++) {
     if (iclos[i]) {
	for (j=0; j < ndocka; j++) {

	   for (l=0; l < 3; l++) {
		vr[l] =  (float) (cool[j*3+l] - coo[i*3+l]);
		vr[l] =  vr[l]*toangs;
	   }

	   rv2 = vr[0]*vr[0] + vr[1]*vr[1] + vr[2]*vr[2];
	   rv = sqrt(rv2);
	   rinv = 1.0/rv;
	   rsum = vdwr[i] + vdwrl[j];
	   epsm = sqrt(vdwe[i]*vdwel[j]);
	   rs2 = rsum*rsum;
	   rs3 = rs2*rsum;
	   p6   = (rs3*rs3) / (rv2*rv2*rv2);
	   p12  = p6 * p6;

	   e    = epsm * (p12 - 2.0*p6);

if (e > evmax) {
	evmax = e;
	ivmax = i;
	jvmax = j;
}
	   ev   = ev + VDWSCAL*e;
   
	   e = q[i]*ql[j]*econv*rinv;

	   eq = eq + e;	
	}
     }
   }

//fprintf(stderr,"CalcInter: evmax %.3f prot %d lig %d\n\n",evmax,ivmax,jvmax);
   return(eq+ev);

}

void Conformers_Energies(xyz)
COOSTRU *xyz;
{
   int k,l,*iclos;
   float *q,*vdwr,*vdwe,*F;
   float Eintra,Einter;
   float ql[MXLIGA],vdwrl[MXLIGA],vdwel[MXLIGA];
   int nt;
   int     it[MXTORS][4];
   float trs1[MXTORS][4];
   float trs2[MXTORS][4];
   float trs3[MXTORS][4];
   float trs4[MXTORS][4];

   if (!AllArr(&q,&vdwr,&vdwe,&iclos,&F)) return;

   AssChg(q);
   AssVDW(vdwr,vdwe);
   AssVDWL(vdwrl,vdwel,ql);

   nt = 0;

   for (k=0; k < ntris; k++) {

      if (TriArr[k]->coo != NULL) {

	FillClos(iclos,k); 

	Eintra = 0.0;

	for (l=0; l < singleb.N; l++) {
	   singleb.sngdone[l] = 0;
	   Eintra = Eintra +
		CalTorS(l,xyz,TriArr[k]->coo,&nt,it,trs1,trs2,trs3,trs4);
	}

	TriArr[k]->e12 = Eintra;

	Einter = CalcInter(TriArr[k]->coo,xyzp->coo,iclos,
		q,vdwr,vdwe,ql,vdwrl,vdwel);

	TriArr[k]->eint = Einter;
	TriArr[k]->etot = Einter + Eintra;

	if (TriArr[k]->etot > 0.0 && MapConformers) {
	    if (TriArr[k]->coo != NULL) free(TriArr[k]->coo);
	    free(TriArr[k]);
	    TriArr[k] = NULL;
	}
     }
   }

   Compress_Tri_L();

   free(q);
   free(vdwr);
   free(vdwe);
   free(F);
}

void Optimise_Conformers(ias,sngs,ndih,xyz)
int ias[2][MXDIH];
int sngs[MXDIH];
int ndih;
COOSTRU *xyz;
{
   int i,j,k,*iclos;
   int ia1,ia2,ia3,ic[3],itel,isng;
   double *euc;
   float *q,*vdwr,*vdwe,*F,Etor;
   float ql[MXLIGA],vdwrl[MXLIGA],vdwel[MXLIGA];
   int frg[MXLIGA];

   if (ndih == 0) return;

   if (!AllArr(&q,&vdwr,&vdwe,&iclos,&F)) return;
   allConf(&euc,ndocka);

   AssChg(q);
   AssVDW(vdwr,vdwe);
   AssVDWL(vdwrl,vdwel,ql);

   for (k=0; k < MXLIGA; k++) frg[k] = 1;

   for (k=0; k < singleb.N; k++) singleb.sngdone[k] = 0;

// create orthogonal set of axes, v1,v2,v3: v1 is the rotation axis (z)

   for (k=0; k < ntris; k++) {

if (debugdck) fprintf(stderr,"Optimise_Conformers: TriArr[%d]->eint %.3f\n",k,TriArr[k]->eint);
      if ((TriArr[k]->eint < 0.0 || !MapConformers) 
		&& TriArr[k]->coo != NULL) {

	FillCOpt(iclos,k); 

	Etor = FindOAngles(ias,sngs,ndih,k,iclos,frg,
		euc,xyz,TriArr[k]->coo,
		q,vdwr,vdwe,
		ql,vdwrl,vdwe,F);

// toropt is not declared. But it also not correct the prof
// answer consists of two components: the torsion part is
// the real eint(ernal) part. The second has to do with
// ligand - protein ineractions


	if (TriArr[k] != NULL && TriArr[k]->coo != NULL) {

	   if (Etor < 0.0 ) {
if (debugdck) fprintf(stderr,"Optimise_Conformers: Etor %.3f\n",Etor);
		TriArr[k]->eint = Etor;

		for (i=0; i < ndocka; i++) {
		   for (j=0; j < 3; j++) {
			TriArr[k]->coo[i*3+j] = euc[i*3+j];
		   }
		}
	   }
	}

     }
   }

}

void Loop_Opt_Dih(Ifrag,xyz,ivis)
int Ifrag;
COOSTRU *xyz;
int ivis;
{
  int i,j,k,l,m,ia1,ia2,iact[MXLIGA],ifrag,jfrag,IFRG[9],NFRG,frg;
  int jfrg[9],nfrag,DFRG[MXLIGA];
  int ias[2][MXDIH],sngs[MXDIH],ndih;

  ndih = 0;
  IFRG[0] = Ifrag;
  NFRG = 1;
//fprintf(stderr,"Loop_Opt_Dih: Ifrag %d\n",Ifrag);

  for (i=0; i < MXDIH; i++) {
     for (k=0; k < MXLIGA; k++) {
	jact[i][k] = 0;
	jopt[i][k] = 0;
     }
  }

  for (k=0; k < singleb.NFRAG; k++) DFRG[k] = 0;

  while (1) {

   for (k=0; k < NFRG; k++) {

      ifrag = IFRG[k];
      DFRG[ifrag] = 1;
      nfrag = 0;

      for (j=0; j < singleb.FrgSngN[ifrag]; j++) {
	frg = 0;
	l = singleb.FrgSng[ifrag][j];

	if (!DFRG[singleb.SngFrg[l][0]] && DFRG[singleb.SngFrg[l][1]]) frg = 1;
	if (DFRG[singleb.SngFrg[l][0]] && !DFRG[singleb.SngFrg[l][1]]) frg = 1;

	if (frg) {
           for (i=0; i < ndocka; i++) iact[i] = 0;

	   jfrag = singleb.SngFrg[l][0];
	   if (!DFRG[jfrag]) jfrg[nfrag] = jfrag;

	   jfrag = singleb.SngFrg[l][1];
	   if (!DFRG[jfrag]) jfrg[nfrag] = jfrag;

	   if (singleb.ifrg[singleb.sng[l][0]] == ifrag) {
		ia1 = singleb.sng[l][0];
		ia2 = singleb.sng[l][1];
	   } else {
		ia2 = singleb.sng[l][0];
		ia1 = singleb.sng[l][1];
	   }

	   DFRG[jfrg[nfrag]] = 1;

	   if (singleb.dupsng[l] == 2) {
	      if (ndih < MXDIH) {
		ias[0][ndih] = ia1;
		ias[1][ndih] = ia2;
		xyz->iatclr[ia1] = 15;
		xyz->iatclr[ia2] = 15;
		sngs[ndih] = l;
	   	if (Create_Act(ia1,ia2,iact,xyz)) {
		   for (m=0; m < ndocka; m++) {
			jact[ndih][m] = iact[m];
		   }
		   
	   	}
		ndih++;
	      }
	   }
	   nfrag++;
	}
      }
   }

//fprintf(stderr,"Loop_Opt_Dih: nfrag %d\n",nfrag);
   if (nfrag == 0) goto OPT;

   NFRG = nfrag;
   for (k=0; k < NFRG; k++) IFRG[k] = jfrg[k];
  }

OPT:

  if (debugdck) fprintf(stderr,"Loop_Opt_Dih: ndih %d\n",ndih);

  for (k=0; k < ndih; k++) {
//     fprintf(stderr,"idih %d\n",k);
     for (i=0; i < ndocka; i++) {
	if (k == ndih-1) {
	   jopt[k][i] = jact[k][i];
	} else {
	   if (jact[k][i] == 1 && jact[k+1][i] == 0) {
		jopt[k][i] = 1;
	   } else {
		jopt[k][i] = 0;
	   }
	}
     }
  }

  if (!ivis) Optimise_Conformers(ias,sngs,ndih,xyz);

  return;

}

void Create_Conformers_Single(ia1,ia2,isng,iact,xyz)
int ia1;
int ia2;
int isng;
int *iact;
COOSTRU *xyz;
{
   int i,j,k,l;
   int ia3,ic[3],itel,ntrift,first;
   float v1[3],v2[3],v3[3],v23[3],vl,x,y,z,x2,y2;
   float cosa,sina,angle,todeg,angopt[3],toropt[3];
   double co[3][3];
   static TRISTRU *FinTmp[MAXSTRI];

   todeg = 45.0 / atan(1.0);

   singleb.dupsng[isng] = IsSymFrg(isng,xyz);

// create orthogonal set of axes, v1,v2,v3: v1 is the rotation axis (z)

   if (ntrif == -1) {
	ntrift = 1;
	first = 1;
   } else {
	ntrift = ntrif;
	for (k=0; k < ntrift; k++) {
	   FinTmp[k] = TriFin[k];
	   TriFin[k] = NULL;
	}
	ntrif = -1;
	first = 0;
   }

   for (k=0; k < ntrift; k++) {

     for (j=0; j < 3; j++) {
	if (first) {
	   v1[j] = ((float) (xyz->coo[ia1*3+j] - xyz->coo[ia2*3+j]));
	} else {
	   v1[j] = ((float) (FinTmp[k]->coo[ia1*3+j] - FinTmp[k]->coo[ia2*3+j]));
	}
     }

     vl = veclen(v1);

     for (j=0; j < 3; j++) {
	v1[j] = v1[j] / vl;
     }

     for (i=0; i < xyz->iconn[ia2*(MXCON+1)]; i++) {

	ia3 = xyz->iconn[ia2*(MXCON+1)+1+i] - 1;

	if (ia3 != ia1) {
	   for (j=0; j < 3; j++) {
		if (first) {
		   v23[j] = ((float) (xyz->coo[ia3*3+j] - 
				xyz->coo[ia2*3+j]));
		} else {
		   v23[j] = ((float) (FinTmp[k]->coo[ia3*3+j] - 
				FinTmp[k]->coo[ia2*3+j]));
		}
	   }
	   break;
	}

     }

     cross(v1,v23,v2);

     vl = veclen(v2);

     for (j=0; j < 3; j++) {
	v2[j] = v2[j] / vl;
     }

     cross(v1,v2,v3);
 
// retrieve the three atoms connected to ia2, that need to be rotated

     itel = -1;

     ic[0] = -1; ic[1] = -1; ic[2] = -1;

     for (i=0; i < xyz->iconn[ia2*(MXCON+1)]; i++) {

       ia3 = xyz->iconn[ia2*(MXCON+1)+1+i] - 1;

       if (ia3 != ia1) {
	  itel++;
	  ic[itel] = ia3;

	  for (j=0; j < 3; j++) {
	     if (first) {
		co[itel][j] = xyz->coo[ic[itel]*3+j];
	     } else {
		co[itel][j] = FinTmp[k]->coo[ic[itel]*3+j];
	     }
	  }
       }
     }

     itel++;

// find three optimal angles for rotation
// allocate play temporary structure,such that etors can be calculated

     if (first) {
	FindAngles(first,ia2,isng,itel,ic,
		xyz,co,NULL,
		v1,v2,v3,angopt,toropt);
     } else {
	FindAngles(first,ia2,isng,itel,ic,
		xyz,co,FinTmp[k]->coo,
		v1,v2,v3,angopt,toropt);
     }


// now create max three new conformations
   
     for (l=0; l < singleb.dupsng[isng]; l++) {

	angle = angopt[l]/todeg;
	cosa  = cos(angle);
	sina  = sin(angle);

	if (ntrif >= MAXSTRI-1) return;

	ntrif++;
	if (TriFin[ntrif] == NULL) 
	   TriFin[ntrif] = (TRISTRU *) malloc(sizeof(TRISTRU));

	allConf(&TriFin[ntrif]->coo,ndocka);

// allocated space for new conformer,but what to copy into it ?
// docked base fragment ?? Or loop over placements of base fragments ??

	if (first) {
	   TriFin[ntrif]->eint = 0.0;
	} else {
	   TriFin[ntrif]->eint = FinTmp[k]->eint + toropt[l];
	}

	for (i=0; i < ndocka; i++) {
         for (j=0; j<3; j++) {
	   if (first) {
		TriFin[ntrif]->coo[i*3+j] = xyz->coo[i*3+j];
	   } else {
		TriFin[ntrif]->coo[i*3+j] = FinTmp[k]->coo[i*3+j];
	   }
         }
	}

	for (i=0; i < ndocka; i++) {

	   if (iact[i] == 1 && i != ia1 && i != ia2) {
	      for (j=0; j < 3; j++) {
		v23[j] = ((float) (TriFin[ntrif]->coo[i*3+j] - 
				TriFin[ntrif]->coo[ia2*3+j]));
	      }
	      IMPRD(v1,v23,&z,0);
	      IMPRD(v2,v23,&y,0);
	      IMPRD(v3,v23,&x,0);

// x2 and y2 could be reversed

	      x2 = (cosa*x - sina*y);
	      y2 = (sina*x + cosa*y);

	      for (j=0; j < 3; j++) {
		TriFin[ntrif]->coo[i*3+j] =  TriFin[ntrif]->coo[ia2*3+j] +
				v1[j]*z + v2[j]*y2 + v3[j]*x2;
	      }
	   }
	}
     }

     if (ntrift != 1 && first) {
	if (FinTmp[k]->coo != NULL) free(FinTmp[k]->coo);
	free(FinTmp[k]);
     }
   }

   ntrif++;

   
}

int Create_Act(IA1,IA2,iact,xyz)
int IA1;
int IA2;
int iact[MXLIGA];
COOSTRU *xyz;
{
   int i,j,k,ia1,ia2,ia3,iflg;
   int icn[MXLIGA],icno[MXLIGA],ICN[MXLIGA],ICNO[MXLIGA],ncn,NCN,ndck;


   for (j=0; j < MXLIGA; j++) {
	icn[j] = 0;
	icno[j] = 0;
	ICN[j] = -1;
	ICNO[j] = -1;
   }

   ICN[0]  = IA2;
   ICNO[0] = IA1;
   NCN = 1;

NEXTR:
   ncn = -1;

   for (j=0; j < NCN; j++) {
      ia2 = ICN[j];
      ia1 = ICNO[j];
      for (i=0; i < xyz->iconn[ia2*(MXCON+1)]; i++) {
	ia3 = xyz->iconn[ia2*(MXCON+1)+1+i] - 1;
	if (ia3 != ia1 && iact[ia3] == 0) {
	   iflg = 0;
	   for (k=0; k < ncn; k++) {
		if (icn[k] == ia3) iflg = 1;
	   }
	   if (!iflg) {
		iact[ia3] = 1;
		if (ncn < MXLIGA-1) {
		   ncn++;
		   icn[ncn]  = ia3;
		   icno[ncn] = ia2;
		} else {
		   ncn = -1;
		}
	   }
	}
      }
   }
   ncn++;

   ndck = 0;
   for (j=0; j < ndocka; j++) {
	if (iact[j] == 1) ndck++;
   }

   if (ncn == 0) {
	if (ndck == ndocka) return(0);
	return(1);
   }

   NCN = ncn;
   for (i=0; i < NCN; i++) {
	ICN[i]  = icn[i];
	ICNO[i] = icno[i];
   }
   goto NEXTR;
   return(0);
}

// what about xyz, have to pass on to Create_Conformers_Single ?

void CopyLig(xyz)
COOSTRU *xyz;
{
   int i,j;

   if (TriFin[0] == NULL) 
	   TriFin[0] = (TRISTRU *) malloc(sizeof(TRISTRU));
   allConf(&TriFin[0]->coo,ndocka);

   for (i=0; i < ndocka; i++) {
      for (j = 0; j < 3; j++ ) {
	TriFin[0]->coo[i*3+j] = xyz->coo[i*3+j];
      }
   }

   ntrif = 1;
}

void Create_Conformers(Ifrag,xyz)
int Ifrag;
COOSTRU *xyz;
{
   int i,j,k,l,ia1,ia2,iact[MXLIGA],ifrag,jfrag,IFRG[9],NFRG,frg;
   int jfrg[9],nfrag,DFRG[MXLIGA];

   IFRG[0] = Ifrag;
   NFRG = 1;

   for (k=0; k < singleb.NFRAG; k++) DFRG[k] = 0;

while (1) {

   nfrag = 0;
   for (k=0; k < NFRG; k++) {

      ifrag = IFRG[k];
      DFRG[ifrag] = 1;

      for (j=0; j < singleb.FrgSngN[ifrag]; j++) {
	frg = 0;
	l = singleb.FrgSng[ifrag][j];

	if (!DFRG[singleb.SngFrg[l][0]] && DFRG[singleb.SngFrg[l][1]]) frg = 1;
	if (DFRG[singleb.SngFrg[l][0]] && !DFRG[singleb.SngFrg[l][1]]) frg = 1;

	if (frg) {
           for (i=0; i < ndocka; i++) iact[i] = 0;

	   jfrag = singleb.SngFrg[l][0];
	   if (!DFRG[jfrag]) jfrg[nfrag] = jfrag;

	   jfrag = singleb.SngFrg[l][1];
	   if (!DFRG[jfrag]) jfrg[nfrag] = jfrag;

	   if (singleb.ifrg[singleb.sng[l][0]] == ifrag) {
		ia1 = singleb.sng[l][0];
		ia2 = singleb.sng[l][1];
	   } else {
		ia2 = singleb.sng[l][0];
		ia1 = singleb.sng[l][1];
	   }

	   DFRG[jfrg[nfrag]] = 1;

	   if (Create_Act(ia1,ia2,iact,xyz)) {
	   }
	   Create_Conformers_Single(ia1,ia2,l,iact,xyz);
	   if (singleb.FrgSngN[ifrag] >= 1) nfrag++;
	}
      }
   }

if (nfrag == 0) fprintf(stderr,"Create_Conformers: nfrag == 0\n");
   if (nfrag == 0) return;

   NFRG = nfrag;
   for (k=0; k < NFRG; k++) IFRG[k] = jfrg[k];
}

// This only takes care of the first series of connected. NOT
// the ones connected to those !!
}

 
double dst(Tri1,Tri2)
TRISTRU *Tri1;
TRISTRU *Tri2;
{
   int i,j;
   double dd,tt;

   dd = 0.0;

   for (i = 0; i < ndocka; i++ ) {
      for (j = 0; j < 3; j++ ) {
	tt = (Tri1->coo[i*3+j] - Tri2->coo[i*3+j]);
	dd = dd + tt*tt;
      }
   }
   dd = dd / ndocka;
   dd = sqrt(dd);
   return(dd);
}

double dst_coo(xyzp1,xyzp2,nato1,nato2)
COOSTRU *xyzp1;
COOSTRU *xyzp2;
int nato1;
int nato2;
{
   int i,j;
   double dd,tt;

   dd = 0.0;

   if (nato2 < nato1) return(-1.0);

   for (i = 0; i < nato1; i++ ) {
      for (j = 0; j < 3; j++ ) {
	tt = (xyzp1->coo[i*3+j] - xyzp2->coo[i*3+j])*toangs;
	dd = dd + tt*tt;
      }
   }
   dd = dd / (nato1);
   dd = sqrt(dd);
   return(dd);
}

static int cmpldat(a,b)
LDAT *a, *b;
{
    if (a->dd > b->dd) return 1;
    else
       if (a->dd == b->dd) return  0;
       else          return -1;
}

static int cmptri(const void * a,const void * b)
{
    TRISTRU **Tria = (TRISTRU **) a;
    TRISTRU **Trib = (TRISTRU **) b;
    if ((*Tria) == NULL || (*Trib) == NULL) return 0;
    if ((*Tria)->e12 > (*Trib)->e12) return  1;
    if ((*Tria)->e12 < (*Trib)->e12) return -1;
    return 0;
    
}

static int ldateq(a,b)
LDAT *a, *b;
{
    if (a->dd == b->dd && a->i == b->i && a->j == b->j) return 1;
    return 0;
}

void dsply_List(node *begin)
{
    int n,i;
    node *p;
    
    n = 0;
    if (begin == NULL) {
        fprintf(stderr,"List is empty\n");
        return;
    }

    p = begin;

    fprintf(stderr,"List is :\n");

    while (p != NULL) {
        fprintf(stderr,"(i=%d,j=%d,dd=%f,stat=%d)",
		p->info.i,p->info.j,p->info.dd,p->info.stat);

	if (p->info.N > 0) {
           fprintf(stderr,"(Arr=");
	   for (i=0; i<p->info.N; i++) {
		fprintf(stderr,"%3d,",p->info.Arr[i]);
	   }
	}
        fprintf(stderr,")\n");


        p = p->next_node;
	n++;
    }

    fprintf(stderr,"\n");
    fprintf(stderr,"# %d Elemnts\n",n);
}
 
void set_List(node *begin,node **barr,int *N,int MXARR)
{
    node *p;
    
    *N = 0;
    if (begin == NULL) return;

    p = begin;

    while(p != NULL) {
	barr[*N] = p;
        p = p->next_node;
	(*N)++;
	if (*N == MXARR) return;
    }
}

int max_List(node *begin)
{
    node *p;
    LDAT info;
    int mx;
    
    mx = 0;
    if (begin == NULL) return(mx);

    p = begin;
    info = p->info;
    mx = info.i;
    if (info.j > mx) mx = info.j;

    while(p != NULL) {
	info = p->info;
	if (info.i > mx) mx = info.i;
	if (info.j > mx) mx = info.j;
        p = p->next_node;
    }

    return(mx);
}

void upd_List(node **barr,int *N,node *delnode)
{
    int i,j;

    for (i=0; i < *N; i++) {
	if (barr[i] == delnode) {
	   (*N)--;
	   for (j=i; j < *N; j++) {
		barr[j] = barr[j+1];
	   }
	}
    }
}

void replc_List(node *begin,int val,int nval)
{
    int n,i,j;
    node *p;
    
    n = 0;

    if (begin==NULL) {
        return;
    }

    p = begin;
    while (p != NULL) {
	i = p->info.i; j = p->info.j;
	if (i == val || j == val) {
	   if (i == val) i = nval;
	   if (j == val) j = nval;
	   if (i < j) {
		   p->info.i = i;
		   p->info.j = j;
	   } else {
		   p->info.i = j;
		   p->info.j = i;
	   }
	}
        p=p->next_node;
	n++;
    }
}
 
node *addtoemptylist(node *begin,LDAT data_element)
{
    node *temp;
    temp=(node *)malloc(sizeof(node));
    temp->info=data_element;
    temp->prev_node=NULL;
    temp->next_node=NULL;
    begin=temp;
    return begin;
}
 
node *addatendlist(node *begin,LDAT data_element)
{
    node *temp,*p;

    if (begin == NULL) {
        printf("List is empty\n");
        return NULL;
    }
 
    temp = (node *) malloc(sizeof(node));
    temp->info = data_element;

    p=begin;
    while (p->next_node != NULL)
        p=p->next_node;

    p->next_node=temp;
    temp->next_node=NULL;
    temp->prev_node=p;
    return begin;
}
 
node *insertdd(node *begin,node **barr,int *N,LDAT data_element)
{
    node *temp,*p,*tp,*tn;
    int n;

    temp = (node *) malloc(sizeof(node));
    temp->info = data_element;
    temp->next_node = NULL;
    temp->prev_node = NULL;

    p = begin;
    tp = NULL;

    n = 0;
    while (p != NULL) {
        if (p->next_node == NULL)  {

            temp->prev_node=p;
            temp->next_node=p->next_node;
            p->next_node = temp;
	    goto NEXT;

	} else if (p->prev_node == NULL) {
	   if (p->info.dd < data_element.dd) {
              temp->prev_node = NULL;
              temp->next_node= p;
              p->prev_node = temp;
	      begin = temp;
	      goto NEXT;
	   }

	} else {

	   if (p->info.dd < data_element.dd && 
	    p->next_node->info.dd >= data_element.dd) {

            temp->prev_node=p;
            temp->next_node=p->next_node;

            p->next_node->prev_node = temp;

            p->next_node = temp;
	    goto NEXT;
           }

        }
	tp = p;
        p = p->next_node;
	n++;
    }
NEXT:
    return begin;
}
 
node *deletenode(node *begin,node *delnode,LDAT *data_element,node **barr,int *N)
{
    node *temp,*tp,*tn;

    if (begin == NULL) {
	goto NEXT;
    }

    if (begin->next_node == NULL) {  
        if (begin->info.i == data_element->i && 
		begin->info.j == data_element->j) {
            temp  = begin;
            begin = NULL;
	    data_element->dd = temp->info.dd;
	    delnode = begin;

        } else {
	    delnode = NULL;

        }
	goto NEXT;
    }
    

    if (begin->info.i == data_element->i && 
	begin->info.j == data_element->j) {

        temp=begin;
	data_element->dd = temp->info.dd;
        begin=begin->next_node;  
        begin->prev_node=NULL;
	delnode = begin;
	goto NEXT;
    }
 
    temp=begin->next_node;
    tp = begin;
    tn = temp->next_node;

    while (temp->next_node != NULL) {

        if (temp->info.i == data_element->i && 
		temp->info.j == data_element->j) {

            if (tp != NULL) {
		if (tp->next_node != NULL) {
		   tp->next_node = temp->next_node;
		}
	    }
            if (tn != NULL) {
		tn->prev_node = temp->prev_node;
	    }
	    delnode = temp;
	    goto NEXT;
        }
	tp = temp;
        temp=temp->next_node;
	tn = temp->next_node;
    }
 
    if (temp->info.i == data_element->i && 
	temp->info.j == data_element->j) {
	data_element->dd = temp->info.dd;

        temp->prev_node->next_node=NULL;
	delnode = temp;
	goto NEXT;
    }

    delnode = NULL;
NEXT:
    upd_List(barr,N,delnode);
    return begin;
}
 
node *dlnode(node *p,LDAT *data_element)
{
    node *temp,*tp,*tn,*ipp;
    int ip = 0;

    if (p == NULL) {
	goto NEXT;
    }

    if (p->next_node == NULL) {  
        if (p->info.i == data_element->i && 
		p->info.j == data_element->j) {
            temp  = p;
            p = NULL;
	    data_element->dd = temp->info.dd;
        }
	goto NEXT;
    }
    

    if (p->info.i == data_element->i && 
	p->info.j == data_element->j) {

        temp=p;
	data_element->dd = temp->info.dd;
	ipp = p->prev_node;
        p=p->next_node;  
	p->prev_node=ipp;
	goto NEXT;
    }
 
    temp=p->next_node;
    tp = p;
    tn = temp->next_node;

    while (temp->next_node != NULL) {

        if (temp->info.i == data_element->i && 
		temp->info.j == data_element->j) {

            if (tp != NULL) {
		if (tp->next_node != NULL) {
		   tp->next_node = temp->next_node;
		}
	    }
            if (tn != NULL) {
		tn->prev_node = temp->prev_node;
	    }
	    goto NEXT;
        }
	tp = temp;
        temp=temp->next_node;
	tn = temp->next_node;
    }
 
    if (temp->info.i == data_element->i && 
	temp->info.j == data_element->j) {
	data_element->dd = temp->info.dd;

        temp->prev_node->next_node=NULL;
	goto NEXT;
    }

NEXT:
    return p;
}
 
void Add2Delarr(node *delnode,node **delarr,int *N,int MXARR)
{
    if (delnode == NULL) return;

    if (*N < MXARR) {
	delarr[(*N)] =  delnode;
	(*N)++;
    }
}

void FreeDelarr(node **delarr,int *N)
{
    int i;

    for (i=0; i < *N; i++) {
	if (delarr[i] != NULL) free(delarr[i]);
    }
}

LDAT get_info(node *begin,LDAT data_element)
{
    node *temp;
    LDAT nulinfo;

    nulinfo.i = -1; nulinfo.j = -1;
    if (begin == NULL) {
        return nulinfo;
    }

    if (begin->next_node == NULL) {  

        if (begin->info.i == data_element.i && 
		begin->info.j == data_element.j) {
            return begin->info;
        } else {
            return nulinfo;
        }
    }
    

    if (begin->info.i == data_element.i && 
		begin->info.j == data_element.j) {
        return begin->info;
    }
 
    temp = begin->next_node;

    while (temp->next_node != NULL) {

        if (temp->info.i == data_element.i && 
		temp->info.j == data_element.j) {
            return temp->info;
        }
        temp=temp->next_node;
    }
 
    if (temp->info.i == data_element.i && 
		temp->info.j == data_element.j) {

        return temp->info;
    }

    return nulinfo;
}
 
void delC(arr,n,value)
int *arr;
int *n;
int value;
{
    int i,j,k;

    k = -1;

    for (i=0; i < *n; i++) {
	if (arr[i] == value) {
	   k = i;
	}
    }

    if (k == -1) return;

    (*n)--;
    for (i=k; i < *n; i++) {
	arr[i] = arr[i+1];
    }
}

void repC(arr,n,value,nval)
int *arr;
int *n;
int value;
int nval;
{
    int i;

    for (i=0; i < *n; i++) {
	if (arr[i] == value) {
	   arr[i] = nval;
	}
    }

}

void redC(arr,n,nval)
int *arr;
int *n;
int nval;
{
    int i,j,frst,nn;


    frst = -1;
    i = 0;

    while (i < *n) {
	if (arr[i] == nval) {
	   if (frst != -1) {
		nn = (*n) - 1;
		for (j=i; j < nn; j++) {
		   arr[j] = arr[j+1];
		}
		(*n)--;
	   } else {
		frst = 0;
	   }
	}
	i++;
    }

}

void delArr(arr,n,value)
LDAT *arr;
int *n;
int value;
{
    int i;

    (*n)--;
    for (i=value; i < *n; i++) {
	arr[i] = arr[i+1];
    }
}

void prL(int *L,int N,int C1)
{
   int kk;
   for (kk=0; kk < N; kk++) {
      fprintf(stderr,"L[%d] %d\n",C1,L[kk]);
   }
}

int rd_tmpArr(tmpArr,K,L,N)
LDAT **tmpArr;
int *K;
int *L[MAXTRI];
int N[MAXTRI];
{
    int i,j;
    FILE *of;
    LDAT *tArr;
    int NN;
    int LL[1000];
    

    of = fopen("tmparr","r");

    if (of == NULL) {
	fprintf(stderr,"Error opening file tmparr\n");
 	return(-1);
    }

    *K = 0;

    fread(K, (size_t) sizeof(int), (size_t) 1, of);
    
    tArr = (LDAT *) malloc((*K)*sizeof(LDAT));

    for (i=0; i < *K; i++) {
	fread(&tArr[i], (size_t) sizeof(LDAT), (size_t) 1, of);
    }

    *tmpArr = tArr;

    for (i=0; i < *K; i++) {
	fread(&N[i], (size_t) sizeof(int), 1, of);
	L[i] = (int *) malloc(N[i]*sizeof(int));
    }


    for (i=0; i < *K; i++) {
	fread(&LL, (size_t) sizeof(int), (size_t) N[i], of);
	for (j=0; j < N[i]; j++) {
	   L[i][j] = LL[j];
	}
    }

    fclose(of);

    return(0);
}

int Chk_NNode(int *Arr,int N,int val)
{
	int i;
	
	for (i=0; i < N; i++) 
	   if (Arr[i] == val) return(1);
	return(0);
}

void Cr_NNode(NNODE **NewNodes,int *NNewNodes,int Cnew,int C1,int C2,int mx)
{
	int i,j;

/*
fprintf(stderr,"in Cr_NNode: NNewNodes %3d Cnew %3d C1 %3d C2 %3d mx %3d\n",*NNewNodes,Cnew,C1,C2,mx);
*/
	NewNodes[*NNewNodes] = (NNODE *) malloc(sizeof(NNODE));
	NewNodes[*NNewNodes]->Num = Cnew;
	NewNodes[*NNewNodes]->Arr = (int *) malloc(sizeof(int)*1000);
	NewNodes[*NNewNodes]->CC = 0;

	if (C1 <= mx && C2 <= mx) {

	   NewNodes[*NNewNodes]->Arr[0] = C1;
	   NewNodes[*NNewNodes]->Arr[1] = C2;
	   NewNodes[*NNewNodes]->N = 2;

	} else if (C1 > mx && C2 > mx) {

	   NewNodes[*NNewNodes]->N = 0;
	   for (i=0; i < *NNewNodes; i++) {
		if (NewNodes[i] != NULL) {
		   if (NewNodes[i]->Num == C1 || NewNodes[i]->Num == C2) {
			for (j=0; j < NewNodes[i]->N ; j++) {
			   if (!Chk_NNode(NewNodes[*NNewNodes]->Arr,
				NewNodes[*NNewNodes]->N, NewNodes[i]->Arr[j])) {
			   NewNodes[*NNewNodes]->Arr[NewNodes[*NNewNodes]->N] = 
						NewNodes[i]->Arr[j];
			   NewNodes[*NNewNodes]->N++;
			   }
			}
		   }
		}
	   }

	} else if (C1 > mx && C2 <= mx) {

	   NewNodes[*NNewNodes]->Arr[0] = C2;
	   NewNodes[*NNewNodes]->N = 1;

	   for (i=0; i < *NNewNodes; i++) {
		if (NewNodes[i] != NULL) {
		   if (NewNodes[i]->Num == C1) {
			for (j=0; j < NewNodes[i]->N ; j++) {
			   NewNodes[*NNewNodes]->Arr[NewNodes[*NNewNodes]->N] = 
						NewNodes[i]->Arr[j];
			   NewNodes[*NNewNodes]->N++;
			}
		   }
		}
	   }

	} else if (C2 > mx && C1 <= mx) {

	   NewNodes[*NNewNodes]->Arr[0] = C1;
	   NewNodes[*NNewNodes]->N = 1;

	   for (i=0; i < *NNewNodes; i++) {
		if (NewNodes[i] != NULL) {
		   if (NewNodes[i]->Num == C2) {
			for (j=0; j < NewNodes[i]->N ; j++) {
			   NewNodes[*NNewNodes]->Arr[NewNodes[*NNewNodes]->N] = 
						NewNodes[i]->Arr[j];
			   NewNodes[*NNewNodes]->N++;
			}
		   }
		}
	   }

	}
	(*NNewNodes)++;
}

int Get_NNode(NNODE **NewNodes,int *NNewNodes,int Ctar,int mx)
{
	int i,j;

	for (i=0; i < *NNewNodes; i++) {
	   if (NewNodes[i] != NULL) {
		if (NewNodes[i]->Num == Ctar) return(i);
	   }
	}

	return(-1);
}

void Prt_NNode(NNODE **NewNodes,int *NNewNodes)
{
	int i,j;

	for (i=0; i < *NNewNodes; i++) {
	   if (NewNodes[i] != NULL) {
		fprintf(stderr,"New Node %3d: CC %d {\n",NewNodes[i]->Num,NewNodes[i]->CC);
		for (j=0; j < NewNodes[i]->N ; j++) 
			fprintf(stderr,"%3d",NewNodes[i]->Arr[j]);
		fprintf(stderr,"\n}\n");
	   }
	}

}

void Clus_Min_NNode(NNODE **NewNodes,int *NNewNodes)
{
	int i,j,imn;
	float emin;

	emin = 10000.0;
	imn = -1;

	for (i=0; i < *NNewNodes; i++) {
	   if (NewNodes[i] != NULL) {
	      if (NewNodes[i]->CC) {
		for (j=0; j < NewNodes[i]->N ; j++) {
		   if (TriArr[NewNodes[i]->Arr[j]] != NULL) {
		      if (TriArr[NewNodes[i]->Arr[j]]->e12 < emin) {
			emin = TriArr[NewNodes[i]->Arr[j]]->e12;
			imn  = NewNodes[i]->Arr[j];
		      }
		   }
		}
		if (imn != -1) {
		   for (j=0; j < NewNodes[i]->N ; j++) {
			if (NewNodes[i]->Arr[j] != imn) {
			   free(TriArr[NewNodes[i]->Arr[j]]);
			   TriArr[NewNodes[i]->Arr[j]] = NULL;
			}
		   }
		   
		}
	      }
	   }
	}

}

void Test_Linkage(N,L,K,tmpArr)
int N[MAXTRI];
int *L[MAXTRI];
int *K;
LDAT *tmpArr;
{
    if (N[0] == 0) L[0] = (int *) malloc(2*sizeof(int));
    if (N[1] == 0) L[1] = (int *) malloc(2*sizeof(int));
    if (N[2] == 0) L[2] = (int *) malloc(2*sizeof(int));

    *K = 3;
    L[0][0] = 1; L[0][1] = 2; N[0] = 2; tmpArr[0].dd = 3.0; tmpArr[0].i = 0; tmpArr[0].j = 1;
    L[1][0] = 0; L[1][1] = 2; N[1] = 2; tmpArr[1].dd = 4.0; tmpArr[1].i = 1; tmpArr[1].j = 2;
    L[2][0] = 0; L[2][1] = 1; N[2] = 2; tmpArr[2].dd = 5.0; tmpArr[2].i = 0; tmpArr[2].j = 2;

}

void TmpLig(INCRSTRU *ligtmp,int indx,int ind)
{
   int j;

   ligtmp =  (INCRSTRU *) malloc(sizeof(INCRSTRU));

   memcpy(ligtmp, ligtyp[ind], sizeof(INCRSTRU));

   for (j=0; j<3; j++) {
	ligtmp->c[0][j] = TriArr[indx]->coo[ligtmp->atom[0]*3+j];
   }

   cal_area(ligtmp);
}

void CalcAllInt(int deb,int all)
{
    int i,j,k,ido,grpj,grpk;
    float etot;
    INCRSTRU *ligtmp;

// all = 1: calculate interaction of matching ligand points with protein
//          interaction points
//
// all = 0: calculate interaction of matching ligand points with protein
//          interaction points, but only those belonging to the fragment
//          of the triangle in TriArr
//
// The latter is a score by fragment

    for (i=0; i < ntris; i++) {
	if (TriArr[i] != NULL) {
	   
	   if (deb) fprintf(stderr,"TriArr[%3d]:\n\n",i);

	   etot = 0.0;

	   for (j=0; j < lintp; j++) {

	      grpj = Find_Group(ligtyp[j]->type);
	      grpj = Find_Matching_Group(grpj);

	      ido = 0;

	      if (!all) {
		if (ligtyp[j]->conf != -1)  {

		   if (TriArr[i]->frags[0] == ligtyp[j]->frag[0] ||
		       TriArr[i]->frags[1] == ligtyp[j]->frag[0] ||
		       TriArr[i]->frags[2] == ligtyp[j]->frag[0]) ido = 1;
		} else {
		   if (ligtyp[j]->nfrag == 1) 
			if (TriArr[i]->frag == ligtyp[j]->frag[0]) ido = 1;
		}
	      } else {
		ido = 1;
	      }

	      if (ido) {
		for (k=0; k < nintp; k++) {
	         grpk = Find_Group(inttyp[k]->type);
		 if (grpj == grpk) {
	
 			etot = etot + 
			CalInt(k,j,ligtyp[j]->points,TriArr[i]->t,
				TriArr[i]->R1,TriArr[i]->R2,
				TriArr[i]->OutO,TriArr[i]->OutOrg,deb);
		 }
		}
	      }
	   }
	   TriArr[i]->e12 = etot;
	   if (all) TriArr[i]->etot = TriArr[i]->e12 + TriArr[i]->eint;

	   if (deb) fprintf(stderr,"etot = %f\n\ne12 %.3f eint %.3f\n",
			etot,TriArr[i]->e12,TriArr[i]->eint);
	}
    }
}

/* wrt_TriArr and rd_TriArr have not been tested, 
   they probably need more work */

void wrt_TriArr()
{
    int i,j;
    FILE *of;

    of = fopen("TriArr","w");

    fwrite(&ntris, (size_t) sizeof(int), (size_t) 1, of);

    for (i=0; i < ntris; i++) {
	fwrite(TriArr[i], (size_t) sizeof(TRISTRU), (size_t) 1, of);
    }

    fwrite(&ndocka, (size_t) sizeof(int), (size_t) 1, of);

    for (i=0; i < ntris; i++) {
	fwrite(TriArr[i]->coo, (size_t) sizeof(double)*ndocka*3, (size_t) 1, of);
    }

    fclose(of);
}

void rd_TriArr()
{
    int i,j;
    FILE *of;

    of = fopen("TriArr","r");

    fread(&ntris, (size_t) sizeof(int), (size_t) 1, of);

    for (i=0; i < ntris; i++) {
	TriArr[i] = (TRISTRU *) malloc(sizeof(TRISTRU));
	fread(TriArr[i], (size_t) sizeof(TRISTRU), (size_t) 1, of);
    }

    fread(&ndocka, (size_t) sizeof(int), (size_t) 1, of);

    for (i=0; i < ntris; i++) {
	TriArr[i]->coo = (double *) malloc(sizeof(double)*ndocka*3);
	fread(TriArr[i]->coo, (size_t) sizeof(double)*ndocka*3, (size_t) 1, of);
    }

    fclose(of);
}

void wrt_tmpArr(tmpArr,K,L,N)
LDAT *tmpArr;
int K;
int *L[MAXTRI];
int N[MAXTRI];
{
    int i,j;
    FILE *of;
    int LL[1000];

    of = fopen("tmparr","w");

    
    fwrite(&K, (size_t) sizeof(int), (size_t) 1, of);

    for (i=0; i < K; i++) {
	fwrite(&tmpArr[i], (size_t) sizeof(LDAT), (size_t) 1, of);
    }

    for (i=0; i < K; i++) {
	fwrite(&N[i], (size_t) sizeof(int), 1, of);
    }

    for (i=0; i < K; i++) {
	for (j=0; j < N[i]; j++) {
	   LL[j] = L[i][j];
	}
	fwrite(&LL, (size_t) sizeof(int), (size_t) N[i], of);
    }

    fclose(of);
}

#define MAXNNODE 10000

void Linkage_List()
{
    int i,j,k,K,l,n,iN,nt,frst,inm;
    double dd,ddthresh,*DDc1,*DDc2;
    LDAT *tmpArr;
    LDAT info,info_tmp;
    NNODE *NewNodes[MAXNNODE];
    int tmpi[MAXTRI],N[MAXTRI],*L[MAXTRI];
    int NN1,NN2,NARR,BTEL,NDEL,MXARR;
    int *L1,*L2,NNewNodes;
    int C1,C2,Ci,Cj,Cnew,stat,istat,mx,inode,inode1,inode2,OldN;
    node *p,*delnode,**BARR,**DELARR;

    ddthresh = CLUSRMS/toangs;
    NNewNodes = 0;

    for (i=0; i < MAXNNODE; i++) {
	NewNodes[i] = NULL;
    }

    K = 0;
    NDEL = 0;

    n = ntris;

    if (n == 1) return;

    nt = (n*(n+1))/2;

    tmpArr = (LDAT *) malloc(nt*sizeof(LDAT));

    for (i=0; i < nt; i++) {
	tmpArr[i].stat = -1;
	tmpArr[i].Arr = NULL;
	tmpArr[i].N = 0;
    }

    k = -1;
    for (i=0; i < n; i++) {
	inm = 0;
	for (j=0; j < n; j++) {
	   if (TriArr[i] != NULL && TriArr[j] != NULL) {
	      dd = dst(TriArr[i],TriArr[j]);
	      if (j > i) {
		if (dd <= 0.000001) {
	    	   if (TriArr[j]->coo != NULL) free(TriArr[j]->coo);
	           free(TriArr[j]);
	           TriArr[j] = NULL;
		   for (l=0; l < j; l++) {
			if (N[l] > 0) {
			   delC(L[l],&N[l],j);
			   delC(tmpi,&inm,j);
			}
		   }
		   for (l=0; l < k+1; l++) 
			if (tmpArr[l].i == j || tmpArr[l].j == j) 
			   tmpArr[l].dd = -1.0; 
		} else if (dd < ddthresh) {
		   k++; 
		   if (nt > k) {
			tmpArr[k].dd = dd;
			tmpArr[k].i = i;
			tmpArr[k].j = j;
			tmpArr[k].stat = -1;
		   } else {
			fprintf(stderr,"k %d > nt %d\n",k,nt);
		   }
		   tmpi[inm] = j;
		   inm++;
		}
	      } else if (j == i) {
	      } else {
		if (dd >  0.000001 && dd < ddthresh) {
		   tmpi[inm] = j;
		   inm++;
		}
	      }
	   }
	}

	if (inm > 0) {
	   N[i] = inm;
	   qsort(tmpi, inm, sizeof(int), SI);
	   L[i] = (int *) malloc((k+1)*sizeof(int));
	   for (l=0; l < inm; l++)  L[i][l] = tmpi[l];
	} else {
	   N[i] = 0;
	   L[i] = NULL;
	}
    }

    K = k + 1;

if (debugdck) fprintf(stderr,"0 K %d\n",K);

    for (i=0; i < k+1; i++) 
	while (tmpArr[i].dd == -1.0 && K > 0) delArr(tmpArr,&K,i);

if (debugdck) fprintf(stderr,"aft delArr K %d\n",K);

    if (!K) return;

    if (0) wrt_tmpArr(tmpArr,K,L,N);

    if (0) Test_Linkage(N,L,&K,tmpArr);

    CalcAllInt(0,0);

    qsort((LDAT *) tmpArr, K, sizeof(LDAT), cmpldat);

if (debugdck) fprintf(stderr,"K %d\n",K);
    MXARR = K + 1000;

    BARR = (node **) malloc(MXARR*sizeof(node *));
    DELARR = (node **) malloc(MXARR*sizeof(node *));

    frst = -1;

    for (i=0; i < K; i++) {
	if ( frst == -1) {
	   begin = addtoemptylist(begin,tmpArr[i]);
	   frst = 0;
	} else {
	   begin = addatendlist(begin,tmpArr[i]);
	}
    }

    set_List(begin,BARR,&NARR,MXARR);
    mx = max_List(begin);

    p = BARR[0]; BTEL = 0;
    Cnew = mx + 1;

    delnode = NULL;

    while (p != NULL) {

	if (debugdck) dsply_List(begin);

	C1 = p->info.i;
	C2 = p->info.j;

	if (debugdck) {
fprintf(stderr,"Cluster candidate C1 %d C2 %d N[C1] %d N[C2] %d\n\n",C1,C2,N[C1],N[C2]);
prL(L[C1],N[C1],C1);
fprintf(stderr,"\n");
prL(L[C2],N[C2],C2);
fprintf(stderr,"\n");
	}

	delC(L[C1],&N[C1],C2);
	delC(L[C2],&N[C2],C1);

	stat = p->info.stat;
	iN = p->info.N;

	begin = deletenode(begin,delnode,&p->info,BARR,&NARR);
	p = dlnode(p,&p->info);
	Add2Delarr(delnode,DELARR,&NDEL,MXARR);

	N[Cnew] = N[C1] + N[C2];
	L[Cnew] = (int *) malloc(K*sizeof(int));
	N[Cnew] = 0;

	NN1 = N[C1];
	NN2 = N[C2];
	L1 = (int *) malloc(NN1*sizeof(int));
	L2 = (int *) malloc(NN2*sizeof(int));
	DDc1 = (double *) malloc(NN1*sizeof(double));
	DDc2 = (double *) malloc(NN2*sizeof(double));

	for (Ci=0; Ci < NN1; Ci++) L1[Ci] = L[C1][Ci];
	for (Cj=0; Cj < NN2; Cj++) L2[Cj] = L[C2][Cj];
	
	if (Get_NNode(NewNodes,&NNewNodes,Cnew,mx) == -1)
		Cr_NNode(NewNodes,&NNewNodes,Cnew,C1,C2,mx);

	if (stat == -1) {
	   info.stat = 1;
	   info.Arr = (int *) malloc(sizeof(int)*1000);
	   info.Arr[0] = C1;
	   info.Arr[1] = C2;
	   info.N = 2;
	} else {
	   info.stat = stat + 1;
	   info.N = 0;

	   if (C1 > mx) {
		inode1 = Get_NNode(NewNodes,&NNewNodes,C1,mx);
		if (inode1 != -1) {
	   	    for (i=0; i < NewNodes[inode1]->N; i++) {
			if (!Chk_NNode(info.Arr,info.N,
				NewNodes[inode1]->Arr[i])) {
			   info.Arr[info.N] = NewNodes[inode1]->Arr[i];
			   info.N++;
			}
		    }
		}
	   } else {
		info.Arr[info.N] = C1;
		info.N++;
	   }

  	   if (C2 > mx) {
		inode2 = Get_NNode(NewNodes,&NNewNodes,C2,mx);
		if (inode2 != -1) {
	   	   for (i=0; i < NewNodes[inode2]->N; i++) {
			if (!Chk_NNode(info.Arr,info.N,
				NewNodes[inode2]->Arr[i])) {
			   info.Arr[info.N] = NewNodes[inode2]->Arr[i];
			   info.N++;
			}
		   }
		}
	   } else {
		info.Arr[info.N] = C2;
		info.N++;
	   }
	}

	set_List(begin,BARR,&NARR,MXARR);
	if (N[C1] == 0 && N[C2] == 0) NewNodes[NNewNodes-1]->CC = 1;

	if (0) Prt_NNode(NewNodes,&NNewNodes);

	if (NARR == 0) goto NEXT;

	OldN = info.N;

	while (N[C1] != 0 || N[C2] != 0) {

	   for (Ci=0; Ci < NN1; Ci++) {

	      if (L1[Ci] < C1) {
		      info.i = L1[Ci]; info.j = C1;
	      } else {
		      info.i = C1; info.j = L1[Ci];
	      }
	      info_tmp = get_info(begin,info);
	      DDc1[Ci] = info_tmp.dd;


	      if (!Chk_NNode(L2,NN2,L1[Ci])) {

		   if (L1[Ci] < C1) {
		      info.i = L1[Ci]; info.j = C1; 
		   } else {
		      info.i = C1; info.j = L1[Ci];
		   }
		   info_tmp = get_info(begin,info);

		   if (! (info_tmp.i == -1 && info_tmp.j == -1) ) {

		      info.i = L1[Ci]; info.j = Cnew; 
		      info.dd = DDc1[Ci];
		      info.N = OldN;

		      if (info.i > mx) {
			inode = Get_NNode(NewNodes,&NNewNodes,info.i,mx);
			if (inode != -1) {
	   		   for (i=0; i < NewNodes[inode]->N; i++) {
				info.Arr[info.N] = NewNodes[inode]->Arr[i];
				info.N++;
			   }
			}
		      }

		      begin = insertdd(begin,BARR,&NARR,info);
		      set_List(begin,BARR,&NARR,MXARR);
		      info.N = OldN;

		      L[L1[Ci]][N[L1[Ci]]] = Cnew; 
		      N[L1[Ci]]++;

		      L[Cnew][N[Cnew]] = L1[Ci]; N[Cnew]++;

		      delC(L[C1],&N[C1],L1[Ci]);

		      delC(L[Ci],&N[Ci],C1);
		      delC(L[Ci],&N[Ci],C2);
		   }
	      }

	      if (L1[Ci] < C1) {
		      info.i = L1[Ci]; info.j = C1;
	      } else {
		      info.i = C1; info.j = L1[Ci];
	      }
	      begin = deletenode(begin,delnode,&info,BARR,&NARR);
	      Add2Delarr(delnode,DELARR,&NDEL,MXARR);

	   }

	   for (Cj=0; Cj < NN2; Cj++) {

		if (L2[Cj] < C2) {
		      info.i = L2[Cj]; info.j = C2;
		} else {
		      info.i = C2; info.j = L2[Cj];
		}
	        info_tmp = get_info(begin,info);
	        DDc2[Cj] = info_tmp.dd;

		if (!Chk_NNode(L1,NN1,L2[Cj])) {

		   if (L2[Cj] < C2) {
		      info.i = L2[Cj]; info.j = C2; 
		   } else {
		      info.i = C2;     info.j = L2[Cj];
		   }
		   info_tmp = get_info(begin,info);

		   if (! (info_tmp.i == -1 && info_tmp.j == -1)) { 

		      info.i = L2[Cj]; info.j = Cnew; 
		      info.dd = DDc2[Cj];
		      info.N = OldN;

		      if (info.i > mx) {
			inode = Get_NNode(NewNodes,&NNewNodes,info.i,mx);
			if (inode != -1) {
	   		   for (i=0; i < NewNodes[inode]->N; i++) {
				info.Arr[info.N] = NewNodes[inode]->Arr[i];
				info.N++;
			   }
			}
		      }

		      begin = insertdd(begin,BARR,&NARR,info);
		      set_List(begin,BARR,&NARR,MXARR);
		      info.N = OldN;

		      L[L2[Cj]][N[L2[Cj]]] = Cnew; 
		      N[L2[Cj]]++;

		      L[Cnew][N[Cnew]] = L2[Cj]; N[Cnew]++;

		      delC(L[C2],&N[C2],L2[Cj]);

		      delC(L[Cj],&N[Cj],C1);
		      delC(L[Cj],&N[Cj],C2);
		   }
		}

		if (L2[Cj] < C2) {
		      info.i = L2[Cj]; info.j = C2;
		} else {
		      info.i = C2; info.j = L2[Cj];
		}
		begin = deletenode(begin,delnode,&info,BARR,&NARR);
	        Add2Delarr(delnode,DELARR,&NDEL,MXARR);

	   }

	   for (Ci=0; Ci < NN1; Ci++) {
	      delC(L[Ci],&N[Ci],C1);
	      for (Cj=0; Cj < NN2; Cj++) {

		delC(L[Cj],&N[Cj],C2);

		if (L1[Ci] < L2[Cj]) {

		   delC(L[C1],&N[C1],L1[Ci]);

		} else if (L1[Ci] > L2[Cj]) {

		   delC(L[C2],&N[C2],L2[Cj]);

		} else if (L1[Ci] == L2[Cj]) {


		   if (L1[Ci] < C1) {
		      info.i = L1[Ci]; info.j = C1;
		   } else {
		      info.i = C1; info.j = L1[Ci];
		   }
		   begin = deletenode(begin,delnode,&info,BARR,&NARR);
	           Add2Delarr(delnode,DELARR,&NDEL,MXARR);

		   if (L1[Ci] < C2) {
		      info.i = L1[Ci]; info.j = C2;
		   } else {
		      info.i = C2; info.j = L1[Ci];
		   }
		   begin = deletenode(begin,delnode,&info,BARR,&NARR);
	           Add2Delarr(delnode,DELARR,&NDEL,MXARR);

		   info.i = L1[Ci]; info.j = Cnew; 
		   info.dd = MAXI(DDc1[Ci],DDc2[Cj]);

		   info.N = OldN;

		   if (info.i > mx) {
			inode = Get_NNode(NewNodes,&NNewNodes,info.i,mx);
			if (inode != -1) {
	   		   for (i=0; i < NewNodes[inode]->N; i++) {
				info.Arr[info.N] = NewNodes[inode]->Arr[i];
				info.N++;
			   }
			}
		   }


		   begin = insertdd(begin,BARR,&NARR,info);
		   info.N = OldN;
		   set_List(begin,BARR,&NARR,MXARR);

		   L[L1[Ci]][N[L1[Ci]]] = Cnew; 
		   N[L1[Ci]]++;

		   L[Cnew][N[Cnew]] = L1[Ci]; N[Cnew]++;

		   delC(L[C1],&N[C1],L1[Ci]);
		   delC(L[C2],&N[C2],L2[Cj]);

		   delC(L[Ci],&N[Ci],C1);
		   delC(L[Cj],&N[Cj],C2);

		}
	      }

	   }
	}

	for (i=0; i < Cnew; i++) {
	   repC(L[i],&N[i],C1,Cnew);
	   repC(L[i],&N[i],C2,Cnew);
	   redC(L[i],&N[i],Cnew);
	}

	for (j=0; j < Cnew+1; j++) {
	   for (i=0; i < Cnew; i++) {
		redC(L[i],&N[i],j);
	   }
	}

	replc_List(begin,C1,Cnew);
	replc_List(begin,C2,Cnew);
	replc_List(p,C1,Cnew);
	replc_List(p,C2,Cnew);

	Cnew++; BTEL++;
	if (BTEL >= NARR) {
	   if (NARR == 0) goto NEXT;
	   BTEL = 0;
	}
	p = BARR[BTEL];
	free(L1);
	free(L2);
	L1 = NULL;
	L2 = NULL;
    }

NEXT:
    Clus_Min_NNode(NewNodes,&NNewNodes);

    return;
	
}

static float rndf(float num)
{
    float integer = ceilf(num);
    if (num > 0)
        return integer - num > 0.5f ? integer - 1.0f : integer;
    return integer - num >= 0.5f ? integer - 1.0f : integer;
}

int issCOO(iat,io1,io2)
int iat;
int *io1;
int *io2;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (xyzp->ianz[iat] != 6) return 0;

    *io1 = -1;
    *io2 = -1;
    io = 0;
    ic = 0;
    ih = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8)  {
		io++;
		if (io == 1) *io1 = la-1;
		if (io == 2) *io2 = la-1;
	   }
	   if (xyzp->ianz[la-1] == 6) ic++;
	   if (xyzp->ianz[la-1] == 1) ih++;
	}
    }

    if (io == 2 && ic == 1 && ih == 0) return 1;
    return 0;
}

int isAZIDE(iat)
int iat;
{
    int xc,io,ic,ih,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 7 && isANY(xyzp->ityp[iat],N2ar,2))) return 0;
    
    n = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 7 && 
		isANY(xyzp->ityp[la-1],Nany,7)) {
		n++;
	   }
	}
    }
    if (n == 2) return 1;
    return 0;
}

int isNaryl(iat,io1,io2)
int iat;
int *io1;
int *io2;
{
    int xc,io,ic,ih,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 7 && isANY(xyzp->ityp[iat],N2ar,2) && xc == 2)) return 0;
    
    n = 0;
    *io1 = -1;
    *io2 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (isANY(xyzp->ianz[la-1],GrpR,6)) {
		n++;
		if (n == 1) *io1 = la - 1;
		if (n == 2) *io2 = la - 1;
	   }
	}
    }
    if (n == 2) return 1;
    return 0;
}

int isNamino(iat,io1,io2,io3)
int iat;
int *io1;
int *io2;
int *io3;
{
    int xc,io,ic,ih,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 7 && xyzp->ityp[iat] == 10 && xc == 3)) return 0;
    
    n = 0;
    *io1 = -1;
    *io2 = -1;
    *io3 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (isANY(xyzp->ianz[la-1],GrpRH,7)) {
		n++;
		if (n == 1) *io1 = la - 1;
		if (n == 2) *io2 = la - 1;
		if (n == 3) *io3 = la - 1;
	   }
	}
    }
    if (n == 3) return 1;
    return 0;
}

int isOH(iat,io1)
int iat;
int *io1;
{
    int xc,io,ic,ih,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 8 && isANY(xyzp->ityp[iat],Oany,3) && xc == 2)) 
		return 0;
    
    n = 0;
    *io1 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 1) {
		n++;
		*io1 = la - 1;
	   } else {
		if (isANY(xyzp->ianz[la-1],GrpRH,7)) n++;
	   }
	}
    }
    if (n == 2) return 1;
    return 0;
}

int isNT(iat,io1)
int iat;
int *io1;
{
    int xc,io,ic,ih,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 7 && isANY(xyzp->ityp[iat],Nany,7) && xc == 1)) return 0;
    
    n = 0;
    *io1 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (isANY(xyzp->ianz[la-1],GrpRH,7)) {
		n++;
		if (n == 1) *io1 = la - 1;
	   }
	}
    }
    if (n == 1) return 1;
    return 0;
}

int isSNH(iat,io1,io2)
int iat;
int *io1;
int *io2;
{
    int xc,io,ic,ih,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 7 && isANY(xyzp->ityp[iat],Nany,7) && xc == 2)) return 0;
    
    n = 0;
    ih = 0;
    *io1 = -1;
    *io2 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (isANY(xyzp->ityp[la-1],Sany,4)) {
		n++;
		if (n == 1) *io1 = la - 1;
	   }
	   if (xyzp->ianz[la-1] == 1) {
		ih++;
		if (ih == 1) *io2 = la - 1;
	   }
	}
    }
    if (n == 1 && ih == 1) return 1;
    return 0;
}

int isAMID(iat,np,io2)
int iat;
int *np;
int *io2;
{
    int xc,xn,i,k,l,la,ll,lla,no,nn,nh;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 6 && xyzp->ityp[iat] == 6 && xc == 3)) return 0;
    
    no = 0; nn = 0; nh = 0;
    *np = -1;
    *io2 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && xyzp->ityp[la-1] == 18) {
		no++;
		if (no == 1) *io2 = la - 1;
	   }
	   if (xyzp->ianz[la-1] == 7 && 
		(xyzp->ityp[la-1] == 14 || xyzp->ityp[la-1] == 15)) {
		nn++;
		if (nn == 1) *np = la - 1;
		xn = xyzp->iconn[(la-1)*(MXCON+1)];
		for (i=0; i < xn; i++) {
		   ll = xyzp->iconn[(la-1)*(MXCON+1)+i+1];
		   lla = abs(ll);
		   if (lla > 0) {
	   		if (xyzp->ianz[lla-1] == 1) nh++;
		   }
		}
	   }
	}
    }
    if (no == 1 && nn == 1 && nh >= 1) return 1;
    return 0;
}

int isRF(iat,io1)
int iat;
int *io1;
{
    int xc,k,l,la,n;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 9 && xc == 1)) return 0;
    
    n = 0;
    *io1 = -1;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (isANY(xyzp->ianz[la-1],GrpR,6)) {
		n++;
		if (n == 1) *io1 = la - 1;
	   }
	}
    }
    if (n == 1) return 1;
    return 0;
}

int isCO(iat,io1)
int iat;
int *io1;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 6 && isANY(xyzp->ityp[iat],C2ar,2))) return 0;

    *io1 = -1;
    io = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && 
		xyzp->iconn[(la-1)*(MXCON+1)] == 1) {
		if (xyzp->ityp[la-1] == 18)  {
		   io++;
		   if (io == 1) *io1 = la-1;
		}
	   }
	}
    }

    if (io == 1) return 1;
    return 0;
}

int isCOmin(iat,io1)
int iat;
int *io1;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    if (!(xyzp->ianz[iat] == 6 && isANY(xyzp->ityp[iat],Cany,4))) return 0;

    *io1 = -1;
    io = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && 
		xyzp->iconn[(la-1)*(MXCON+1)] == 1) {
		if (xyzp->ityp[la-1] == 17)  {
		   io++;
		   if (io == 1) *io1 = la-1;
		}
	   }
	}
    }

    if (io == 1) return 1;
    return 0;
}

int isSO(iat,io1,io2)
int iat;
int *io1;
int *io2;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 16 || isANY(xyzp->ityp[iat],Sany,4)) return 0;

    *io1 = -1;
    *io2 = -1;
    io = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && xyzp->iconn[(la-1)*(MXCON+1)] == 1)  {
		if (isANY(xyzp->ityp[la-1],Oany,3)) {
		io++;
		if (io == 1) *io1 = la-1;
		if (io == 2) *io2 = la-1;
		}
	   }
	}
    }

    if (io == 1 || io == 2) return 1;
    return 0;
}

int isCH3R(iat)
int iat;
{
    int xc,i,ir,ih,k,l,la;

    if (xyzp->ianz[iat] != 6 || xyzp->ityp[iat] != 5) return 0;

    xc = xyzp->iconn[iat*(MXCON+1)];

    ih = 0;
    ir = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 1) ih++;
	   if (isANY(xyzp->ianz[la-1],GrpR,6)) ir++;
	}
    }

    if (ih == 3 && ir == 1) return 1;
    if (ih == 2 && ir == 2) return 2;
    if (ih == 1 && ir == 3) return 3;
    return 0;
}

int isS3(iat)
int iat;
{

    if (xyzp->ianz[iat] == 16 && xyzp->ityp[iat] == 22) return 1;

    return 0;
}

int isCarR(iat)
int iat;
{
    int xc,i,ir,ih,k,l,la;

    if (xyzp->ianz[iat] != 6 || xyzp->ityp[iat] != 8) return 0;

    xc = xyzp->iconn[iat*(MXCON+1)];

    ih = 0;
    ir = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 1) ih++;
	   if (isANY(xyzp->ianz[la-1],GrpR,6)) ir++;
	}
    }

    if (ih == 0 && ir == 3) return 1;
    if (ih == 1 && ir == 2) return 2;
    return 0;
}

int isPO(iat,io1,io2,io3)
int iat;
int *io1;
int *io2;
int *io3;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 15 || xyzp->ityp[iat] != 26) return 0;

    *io1 = -1;
    *io2 = -1;
    *io3 = -1;
    io = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && xyzp->iconn[(la-1)*(MXCON+1)] == 1)  {
		if (isANY(xyzp->ityp[la-1],Oany,3)) {
		io++;
		if (io == 1) *io1 = la-1;
		if (io == 2) *io2 = la-1;
		if (io == 3) *io3 = la-1;
		}
	   }
	}
    }

    if (io >1 && io <= 3) return 1;
    return 0;
}

int isNO2(iat,io1,io2)
int iat;
int *io1;
int *io2;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 7 || !isANY(xyzp->ityp[iat],N2ar,2)) return 0;

    *io1 = -1;
    *io2 = -1;
    io = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && xyzp->iconn[(la-1)*(MXCON+1)] == 1)  {
		if (xyzp->ityp[la-1] == 18) {
		io++;
		if (io == 1) *io1 = la-1;
		if (io == 2) *io2 = la-1;
		}
	   }
	}
    }

    if (io == 2) return 1;
    return 0;
}

int isNO(iat,io1)
int iat;
int *io1;
{
    int xc,io,ic,ih,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 7 || !isANY(xyzp->ityp[iat],Nany,7)) return 0;

    *io1 = -1;
    io = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 8 && xyzp->iconn[(la-1)*(MXCON+1)] == 1)  {
		if (isANY(xyzp->ityp[la-1],Oany,3)) {
		io++;
		if (io == 1) *io1 = la-1;
		}
	   }
	}
    }

    if (io == 1) return 1;
    return 0;
}

int isCOH(iat,ic,ih,it)
int iat;
int *ic;
int *ih;
int *it;
{
    int xc,icc,ihh,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 8 || xyzp->ityp[iat] != 17) return 0;

    *ic = -1;
    *ih = -1;
    icc = 0;
    ihh = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (l > 0) {
	   *it = xyzp->ityp[la-1];
// 5 = C.3 6 = C.2 8 = C.ar
	   if (xyzp->ianz[la-1] == 6 && (*it == 5 || *it == 6 || *it == 8))  {
		icc++;
		if (icc == 1) *ic = la-1;
	   }
	   if (xyzp->ianz[la-1] == 1)  {
		ihh++;
		if (ihh == 1) *ih = la-1;
	   }
	}
    }

    if (icc == 1 && ihh == 1) return 1;
    return 0;
}

int isC3OH(iat,ic,ih)
int iat;
int *ic;
int *ih;
{
    int xc,icc,ihh,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 8 || xyzp->ityp[iat] != 17) return 0;

    *ic = -1;
    *ih = -1;
    icc = 0;
    ihh = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 6 && xyzp->ityp[la-1] == 5)  {
		icc++;
		if (icc == 1) *ic = la-1;
	   }
	   if (xyzp->ianz[la-1] == 1)  {
		ihh++;
		if (ihh == 1) *ih = la-1;
	   }
	}
    }

    if (icc == 1 && ihh == 1) return 1;
    return 0;
}

int isC2OH(iat,ic,ih)
int iat;
int *ic;
int *ih;
{
    int xc,icc,ihh,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 8 || xyzp->ityp[iat] != 17) return 0;

    *ic = -1;
    *ih = -1;
    icc = 0;
    ihh = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (xyzp->ianz[la-1] == 6 && 
		(xyzp->ityp[la-1] == 6 || xyzp->ityp[la-1] == 8))  {
		icc++;
		if (icc == 1) *ic = la-1;
	   }
	   if (xyzp->ianz[la-1] == 1)  {
		ihh++;
		if (ihh == 1) *ih = la-1;
	   }
	}
    }

    if (icc == 1 && ihh == 1) return 1;
    return 0;
}

int isCOC(iat,ic1,ic2)
int iat;
int *ic1;
int *ic2;
{
    int xc,icc,ihh,k,l,la;

    xc = xyzp->iconn[iat*(MXCON+1)];
    
    if (xyzp->ianz[iat] != 8 || xyzp->ityp[iat] != 17) return 0;

    *ic1 = -1;
    *ic2 = -1;
    icc = 0;

    for (k=0; k < xc; k++) {
	l = xyzp->iconn[iat*(MXCON+1)+k+1];
	la = abs(l);
	if (la > 0) {
	   if (isANY(xyzp->ianz[la-1],GrpR,6)) {
		icc++;
		if (icc == 1) *ic1 = la-1;
		if (icc == 2) *ic2 = la-1;
	   }
	}
    }

    if (icc == 2) return 1;
    return 0;
}

void isC3RNG(C,iring,oring,n)
COOSTRU *C;
int iring[6];
int oring[6];
int n;
{
   int i,j,k;

   for (i=0; i < n; i++) {
	oring[i] = 0;
	if (isANY(C->ityp[iring[i]],C2ar,2)) {
	   for (j=0; j < C->iconn[(iring[i])*(MXCON+1)]; j++) {
	      k = C->iconn[(iring[i])*(MXCON+1)+1+j]-1;
	      if (C->ianz[k] == 1) oring[i] = 1;
	   }
	}
   }
}

void ReORNG(C,iring,n)
COOSTRU *C;
int iring[6];
int n;
{
   int i,ii,j,k,jring[6];

   for (i=0; i < n; i++) {
	if (C->lwrit[iring[i]] == 0) {
	   k = i;
	   break;
	}
   }

   
   j = 0;
   for (i=k; i < k+n; i++) {
	ii = i;
	if (i > n-1) ii =  i - n;
	jring[j] = iring[ii];
	j++;
   }
   for (i=0; i < n; i++) iring[i] = jring[i];
}

int isDON(typ)
short int typ;
{
   int i,ret;

   ret = 0;

   for (i=0; i < 9; i++) if (typ == DONG[i]) ret = 1;
 
   return(ret);
}

int isANY(ele,arr,n)
short int ele;
short int *arr;
int n;

{
   int i,ret;

   ret = 0;

   for (i=0; i < n; i++) if (ele == arr[i]) ret = 1;
 
   return(ret);
}

void RNGmin1(iring,n)
int iring[6];
int n;
{
   int i;
  
   for (i=0; i < n; i++) {
	iring[i] = iring[i] - 1;
   }
}

void RNGput(iring,n,ival)
int iring[6];
int n;
int ival;
{
   int i;

   for (i=0; i < n; i++) {
	if (singleb.jrng[iring[i]] == 0) {
	   singleb.jrng[iring[i]] = ival;
	}
   }
}

int Has_Con(C,ele,ian,iele)
COOSTRU *C;
int ele;
int ian;
int iele[3];
{
   int i,j,k,ret;

   ret = 0;
   k = -1;
   for (i=0; i < 4; i++) iele[i] = -1;

   for (i=0; i < C->iconn[(ele)*(MXCON+1)]; i++) {
	j = C->iconn[(ele)*(MXCON+1)+1+i]-1;
	if (C->ianz[j] == ian) {
	   ret = 1;
	   k++;
	   iele[k] = j;
	}
   }
 
   return(ret);
}

void ReleaseLig()
{
   int i;

   for (i=0; i<lintp; i++) {
	free(ligtyp[i]);
   }
}

void AllInt(C,indx,at1,at2,at3,at4,n,grp1,grp2,coo,iconf,link)
COOSTRU *C;
int *indx;
int at1;
int at2;
int at3;
int at4;
int n;
int grp1;
AREASTRU grp2;
double *coo;
int iconf;
int link;
{
   int j;
   INCRSTRU tmptyp;

   ligtyp[*indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

   for (j=0; j<3; j++) {
	switch(n) {
	case 1:
		ligtyp[*indx]->c[0][j] = coo[(at1)*3+j];
		ligtyp[*indx]->atom[0] = at1;
		ligtyp[*indx]->n = 1;
		break;
	case 2:
		ligtyp[*indx]->c[0][j] = coo[(at1)*3+j];
		ligtyp[*indx]->c[1][j] = coo[(at2)*3+j];
		ligtyp[*indx]->atom[0] = at1;
		ligtyp[*indx]->atom[1] = at2;
		ligtyp[*indx]->n = 2;
		break;
	case 3:
		ligtyp[*indx]->c[0][j] = coo[(at1)*3+j];
		ligtyp[*indx]->c[1][j] = coo[(at2)*3+j];
		ligtyp[*indx]->c[2][j] = coo[(at3)*3+j];
		ligtyp[*indx]->atom[0] = at1;
		ligtyp[*indx]->atom[1] = at2;
		ligtyp[*indx]->atom[2] = at3;
		ligtyp[*indx]->n = 3;
		break;
	case 4:
		ligtyp[*indx]->c[0][j] = coo[(at1)*3+j];
		ligtyp[*indx]->c[1][j] = coo[(at2)*3+j];
		ligtyp[*indx]->c[2][j] = coo[(at3)*3+j];
		ligtyp[*indx]->c[3][j] = coo[(at4)*3+j];
		ligtyp[*indx]->atom[0] = at1;
		ligtyp[*indx]->atom[1] = at2;
		ligtyp[*indx]->atom[2] = at3;
		ligtyp[*indx]->atom[3] = at4;
		ligtyp[*indx]->n = 4;
		break;
	default:
		break;
	}
   }
   ligtyp[*indx]->type = grp1;
   ligtyp[*indx]->area = grp2;
   ligtyp[*indx]->conf = iconf;
   ligtyp[*indx]->link = link;
   ligtyp[*indx]->ohlig = 0;
   ligtyp[*indx]->ohsame = 0;

   cal_area(ligtyp[*indx]);
   (*indx)++;
}

void FrgInt(indx)
int indx;
{
// Set members frag and nfrag of structure ligtyp (INCRSTRU)

   int fragi[4],at1,at2,at3,at4,f0n1,f0n2,f0n3,f1n2,f1n3,f2n3;

   at1 = ligtyp[indx]->atom[0];
   at2 = ligtyp[indx]->atom[1];
   at3 = ligtyp[indx]->atom[2];
   at4 = ligtyp[indx]->atom[3];

   switch(ligtyp[indx]->n) {
	case 1:
		ligtyp[indx]->frag[0] = singleb.ifrg[at1];
		ligtyp[indx]->nfrag = 1;
		break;
	case 2:
		fragi[0] = singleb.ifrg[at1];
		fragi[1] = singleb.ifrg[at2];

		ligtyp[indx]->frag[0] = fragi[0];

		if (fragi[0] != fragi[1]) {
		   ligtyp[indx]->frag[1] = fragi[1];
		   ligtyp[indx]->nfrag = 2;
		} else {
		   ligtyp[indx]->nfrag = 1;
		}
		break;
	case 3:
		fragi[0] = singleb.ifrg[at1];
		fragi[1] = singleb.ifrg[at2];
		fragi[2] = singleb.ifrg[at3];

		ligtyp[indx]->frag[0] = fragi[0];

		if (fragi[0] != fragi[1]) {

		   ligtyp[indx]->frag[1] = fragi[1];

		   if (fragi[0] != fragi[2]) {
			if (fragi[1] != fragi[2]) {
			   ligtyp[indx]->frag[2] = fragi[2];
			   ligtyp[indx]->nfrag = 3;
			} else {
			   ligtyp[indx]->nfrag = 2;
			}
		   } else {
			ligtyp[indx]->nfrag = 2;
		   }

		} else {

		   if (fragi[0] != fragi[2]) {
			ligtyp[indx]->frag[1] = fragi[2];
			ligtyp[indx]->nfrag = 2;
		   } else {
			ligtyp[indx]->nfrag = 1;
		   }

		}
		break;
	case 4:

		fragi[0] = singleb.ifrg[at1];
		fragi[1] = singleb.ifrg[at2];
		fragi[2] = singleb.ifrg[at3];
		fragi[3] = singleb.ifrg[at4];

		f0n1 = 0; if (fragi[0] == fragi[1]) f0n1 = 1;
		f0n2 = 0; if (fragi[0] == fragi[2]) f0n2 = 1;
		f0n3 = 0; if (fragi[0] == fragi[3]) f0n3 = 1;
		f1n2 = 0; if (fragi[1] == fragi[2]) f1n2 = 1;
		f1n3 = 0; if (fragi[1] == fragi[3]) f1n3 = 1;
		f2n3 = 0; if (fragi[2] == fragi[3]) f2n3 = 1;

		if (f0n1 && f0n2 && f0n3) {
// all four atoms are from the same fragment

		   ligtyp[indx]->frag[0] = fragi[0];
		   ligtyp[indx]->nfrag = 1;

		} else if ((f0n1 && f1n2 && !f0n3) || 
		   ((f1n2 && f2n3 && !f0n1) || (f2n3 && f0n3 && !f1n2)) ||
			   (f0n1 && f1n3 && !f2n3)) {

// three atoms are from the same fragment, ONE is NOT: two fragments

		   if (f0n1 && f1n2 && !f0n3) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[3];
		   }

		   if ((f1n2 && f2n3 && !f0n1) ||
		       (f2n3 && f0n3 && !f1n2)) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[1];
		   }

		   if (f0n1 && f1n3 && !f2n3) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[2];
		   }

		   ligtyp[indx]->nfrag = 2;

		} else if ((f0n1 && f2n3 && !f1n2) || 
			   (f0n2 && f1n3 && !f0n1) || 
			   (f0n3 && f1n2 && !f0n1)) {
// two atoms are from one fragment, two others are from other frag:
// two fragments


		   if (f0n1 && f2n3 && !f1n2) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[2];
		   }
		   if (f0n2 && f1n3 && !f0n1) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[1];
		   }
		   if (f0n3 && f1n2 && !f0n1) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[1];
		   }

		   ligtyp[indx]->nfrag = 2;

		} else if ((f0n1 && !f0n2 && !f0n3) || 
			   (f0n2 && !f0n1 && !f0n3) || 
			   (f0n3 && !f0n1 && !f0n2) ||
			   (f1n2 && !f0n1 && !f1n3) ||
			   (f1n3 && !f0n1 && !f1n2) ||
			   (f2n3 && !f0n2 && !f1n2) ) {

// two atoms are from one fragment, two others are from different frags:
// three fragments
		   ligtyp[indx]->nfrag = 3;

		   if (f0n1 && !f0n2 && !f0n3) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[2];
			ligtyp[indx]->frag[2] = fragi[3];
		   }

		   if ((f0n2 && !f0n1 && !f0n3) ||
		       (f1n2 && !f0n1 && !f1n3)) {
			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[1];
			ligtyp[indx]->frag[2] = fragi[3];
		   }

		   if ((f0n3 && !f0n1 && !f0n2) ||
		       (f1n3 && !f0n1 && !f1n2) ||
		       (f2n3 && !f0n2 && !f1n2)) {

			ligtyp[indx]->frag[0] = fragi[0];
			ligtyp[indx]->frag[1] = fragi[1];
			ligtyp[indx]->frag[2] = fragi[2];
		   }

		} else {

// all four atoms are from different fragments

		   ligtyp[indx]->frag[0] = fragi[0];
		   ligtyp[indx]->frag[1] = fragi[1];
		   ligtyp[indx]->frag[2] = fragi[2];
		   ligtyp[indx]->frag[3] = fragi[3];
		   ligtyp[indx]->nfrag = 4;
		}
		break;
	default:
		break;
   }
}

int ceil_odd(arcl)
float arcl;
{
   int ires;

   ires = (int) ceil(arcl);
   if (ires % 2 != 1)  ires++;
   return ires;
 
}

 int equidist_npts(inttyp,b1,b2,b3,e1l)
 INCRSTRU *inttyp;
 double *b1;
 double *b2;
 double *b3;
 double e1l;
 {
   int ncirc[2],i,j,ntmp;
   float arcl[2], polrange,azirange;
   float a,D,D1,D2,theta,phi,thetad,phid,r,a1[2],a2[2],p1[2],p2[2],rq;
   int indx = 0, N,M1,M2,m,n;
   double x,y,z;

   if (inttyp->area.type == 3) {
	polrange = 180.0;
   } else {
	polrange = inttyp->area.polar2 - inttyp->area.polar1;
   }

   if (inttyp->area.type == 2 || inttyp->area.type == 3 || inttyp->area.type == 4) {
	azirange = 360.0;
   } else {
	azirange = inttyp->area.azimuth2 - inttyp->area.azimuth1;
   }

   arcl[0] = 1.0 + 2.0*PI*inttyp->area.rp * polrange / 
  	(360.0*inttyp->area.maxarc[0]);

   arcl[1] = 1.0 + 2.0*PI*inttyp->area.rp * azirange /
	(360.0*inttyp->area.maxarc[1]);

   ncirc[0] = ceil_odd(arcl[0]);
   ncirc[1] = ceil_odd(arcl[1]);

   polrange = polrange / (float) (ncirc[0] - 1);
   azirange = azirange / (float) (ncirc[1] - 1);

   a1[0] = inttyp->area.azimuth1;
   a1[1] = inttyp->area.azimuth2;

   if (inttyp->area.type == 1) {
	a2[0] = inttyp->area.azimuthb1;
	a2[1] = inttyp->area.azimuthb2;
   } else {
	a2[0] = 0.0;
	a2[1] = 180.0;
   }

   p1[0] = inttyp->area.polar1;
   p1[1] = inttyp->area.polar2;
   p2[0] = inttyp->area.polarb1;
   p2[1] = inttyp->area.polarb2;

   r = inttyp->area.rp;
   N = 4.0*PI*r*r/
	(inttyp->area.maxarc[0]*inttyp->area.maxarc[1]);
/*
   N = 4.0*PI*r*r/
	(inttyp->area.maxarc[0]*inttyp->area.maxarc[1]);
   N = 2000;
*/

   rq = r/inttyp->area.maxarc[0];
   N = 4.0*PI*rq*rq;
/*fprintf(stderr,"equi: N %d\n",N);*/
   N = 2000;
   r = r/toangs;
   a = 4.0*PI*r*r/N;
   D = sqrt(a);
   M1 = rndf(PI/D);
/*fprintf(stderr,"equi: D %f PI/D %f M1 %d\n",D,PI/D,M1);*/
   D1 = PI/ (float) M1;
   D2 = a / D1;
 
   indx = 0;

   if (inttyp->area.type == 2 || inttyp->area.type == 3 || 
		inttyp->area.type == 4) {

	if (inttyp->area.polar1 == 0.0) {
	   indx = 1;
	} else {
	   indx = 0;
	}

	ntmp = ncirc[0];
	if (inttyp->area.type == 3) ntmp = ncirc[0]-1;
	
	for (i = 1; i < ntmp; i++) {

	   theta = inttyp->area.polar1 + i*polrange;

 	   for (j = 0; j < ncirc[1]-1; j++) {
	      phi = inttyp->area.azimuth1 + j*azirange;

	      indx++; 
	   }
	}
	if (inttyp->area.type == 3) indx++;

   } else {

/*fprintf(stderr,"cal_area M1 %d \n",M1);*/
	for (m = 0; m < M1; m++) {

	   theta = PI * (((float) m) + 0.5) / ((float) M1);
	   thetad = theta*180.0/PI;
	   M2 = rndf(2.0*PI*sin(theta)/D2);

	   for (n = 0; n < M2; n++) {

		phi = 2.0*PI*((float) n) / ((float) M2);
		phid = phi*180.0/PI;
		if (phid > 270.0) phid = phid - 360.0;

		if ((phid >= p1[0] && phid <= p1[1]) ||
		    (phid >= p2[0] && phid <= p2[1]) ) {
		if ((thetad >= a1[0] && thetad <= a1[1])  || 
		    (thetad >= a2[0] && thetad <= a2[1]) ) {

	   	indx++;

		} /* if end */

		
	   } /* if end */
	} /* for n end */
     } /* for m end */
   }

   return indx;
 }

 void equidist_sphere(inttyp,b1,b2,b3,ori)
 INCRSTRU *inttyp;
 double *b1;
 double *b2;
 double *b3;
 double *ori;
 {
   int ncirc[2],i,j,ntmp;
   float arcl[2], polrange,azirange;
   float a,D,D1,D2,theta,phi,thetad,phid,r,a1[2],a2[2],p1[2],p2[2],rq;
   int indx = 0, N,M1,M2,m,n;
   double x,y,z;

   if (inttyp->area.type == 3) {
	polrange = 180.0;
   } else {
	polrange = inttyp->area.polar2 - inttyp->area.polar1;
   }

   if (inttyp->area.type == 2 || inttyp->area.type == 3 || 
	inttyp->area.type == 4) {
	azirange = 360.0;
   } else {
	azirange = inttyp->area.azimuth2 - inttyp->area.azimuth1;
   }

   arcl[0] = 1.0 + PI*inttyp->area.rp * polrange / 
  	(180.0*inttyp->area.maxarc[0]);

   arcl[1] = 1.0 + PI*inttyp->area.rp * azirange /
	(180.0*inttyp->area.maxarc[1]);

   ncirc[0] = ceil_odd(arcl[0]);
   ncirc[1] = ceil_odd(arcl[1]);

   polrange = polrange / (float) (ncirc[0] - 1);
   azirange = azirange / (float) (ncirc[1] - 1);


   r = inttyp->area.rp;
/*
   N = 4.0*PI*r*r/
	(inttyp->area.maxarc[0]*inttyp->area.maxarc[1]);
   N = 2000;
*/

   a1[0] = inttyp->area.azimuth1;
   a1[1] = inttyp->area.azimuth2;

   if (inttyp->area.type == 1) {
	a2[0] = inttyp->area.azimuthb1;
	a2[1] = inttyp->area.azimuthb2;
   } else {
	a2[0] = 0.0;
	a2[1] = 180.0;
   }

   p1[0] = inttyp->area.polar1;
   p1[1] = inttyp->area.polar2;
   p2[0] = inttyp->area.polarb1;
   p2[1] = inttyp->area.polarb2;


   rq = r/inttyp->area.maxarc[0];
   N = 4.0*PI*rq*rq;
   r = r/toangs;
   N = 2000;
   a = 4.0*PI*r*r/N;
   D = sqrt(a);
   M1 = rndf(PI/D);
   D1 = PI/ (float) M1;
   D2 = a / D1;
 
   indx = 0;

   if (inttyp->area.type == 2 || inttyp->area.type == 3 || inttyp->area.type == 4) {

	x = 0.0;
	y = 0.0;
	z = r;

	if (inttyp->area.polar1 == 0.0) {

	   inttyp->points[0] = ori[0] + x*b3[0] + y*b2[0] + z*b1[0];
	   inttyp->points[1] = ori[1] + x*b3[1] + y*b2[1] + z*b1[1];
	   inttyp->points[2] = ori[2] + x*b3[2] + y*b2[2] + z*b1[2];

	   indx = 1;
	} else {
	   indx = 0;
	}

	ntmp = ncirc[0];
	if (inttyp->area.type == 3) ntmp = ncirc[0]-1;
	
	for (i = 1; i < ntmp; i++) {

//	   theta = ((double) i)*polrange;
	   theta = (double) inttyp->area.polar1 + ((double) i)*polrange;
	   theta = PI*theta / 180.0;


 	   for (j = 0; j < ncirc[1]-1; j++) {

	      phi = ((double) j)*azirange;
	      phi = PI*phi / 180.0;

	      x = r*sin(theta)*cos(phi);
	      y = r*sin(theta)*sin(phi);
	      z = r*cos(theta);

	      inttyp->points[indx*3+0] = ori[0] + x*b3[0] + y*b2[0] + z*b1[0];
	      inttyp->points[indx*3+1] = ori[1] + x*b3[1] + y*b2[1] + z*b1[1];
	      inttyp->points[indx*3+2] = ori[2] + x*b3[2] + y*b2[2] + z*b1[2];
	      indx++; 
	   }
	}

	if (inttyp->area.type == 3) {

	   x = 0.0;
	   y = 0.0;
	   z = -r;

	   inttyp->points[indx*3+0] = ori[0] + x*b3[0] + y*b2[0] + z*b1[0];
	   inttyp->points[indx*3+1] = ori[1] + x*b3[1] + y*b2[1] + z*b1[1];
	   inttyp->points[indx*3+2] = ori[2] + x*b3[2] + y*b2[2] + z*b1[2];

	   indx++;
	}

   } else {

	for (m = 0; m < M1; m++) {
	   theta = PI * (((float) m) + 0.5) / ((float) M1);
	   thetad = theta*180.0/PI;
	   M2 = rndf(2.0*PI*sin(theta)/D2);
	   for (n = 0; n < M2; n++) {
		phi = 2.0*PI*((float) n) / ((float) M2);
		phid = phi*180.0/PI;
		if (phid > 270.0) phid = phid - 360.0;

		if ((phid >= p1[0] && phid <= p1[1]) ||
		    (phid >= p2[0] && phid <= p2[1]) ) {
		  if ((thetad >= a1[0] && thetad <= a1[1])  || 
		       (thetad >= a2[0] && thetad <= a2[1]) ) {

		   x = r*sin(theta)*cos(phi);
		   y = r*sin(theta)*sin(phi);
	 	   z = r*cos(theta);

		   inttyp->points[indx*3+0] = 
			inttyp->c[0][0] + x*b2[0] + y*b3[0] + z*b1[0];
	   	   inttyp->points[indx*3+1] = 
			inttyp->c[0][1] + x*b2[1] + y*b3[1] + z*b1[1];
	   	   inttyp->points[indx*3+2] = 
			inttyp->c[0][2] + x*b2[2] + y*b3[2] + z*b1[2];

	   	   indx++;

		  } /* if end */

		
	        } /* if end */
	   } /* for n end */
	} /* for m end */
   }

 }

 void cal_area(inttyp)
 INCRSTRU *inttyp;
 {
 int ncirc[2],i,j,indx,bole;
 float arcl[2], polrange,azirange,phi,theta;
 double e0[3],e1[3],e2[3],e3[3],ori[3];
 double b1[3],b2[3],b3[3];
 double x,y,z,e1l,e2l,e1lt,e2lt;

 e1[0] = 0.0; e1[1] = 0.0; e1[2] = 1.0;
 e2[0] = 1.0; e2[1] = 0.0; e2[2] = 0.0;
 e3[0] = 0.0; e3[1] = 1.0; e3[2] = 0.0;

 for (i = 0; i < 3; i++) {
    if (inttyp->area.type != 3) {
	e1[i] =  inttyp->c[1][i] - inttyp->c[0][i];
	if (inttyp->area.type != 2 && inttyp->area.type != 3) {
	   e2[i] =  inttyp->c[2][i] - inttyp->c[0][i];
	}
	if (inttyp->area.type == 6) {
	   e3[i] =  inttyp->c[3][i] - inttyp->c[0][i];
	}
    }
 }

 for (i = 0; i < 3; i++) {
	ori[i] = inttyp->c[0][i] + 
		inttyp->area.center[0]*e1[i] + 
		inttyp->area.center[1]*e2[i] +
		inttyp->area.center[2]*e3[i];
	ORI[i] = (float) ori[i];
	inttyp->ORI[i] = ori[i];
 }


/*
transform to orthogonal basis:
FIRST normalize e1,e2,e3
*/

 e1l = dveclen(e1);
 e2l = dveclen(e2);

 if (inttyp->area.type != 6) {
    for (i = 0; i < 3; i++) {
	e1[i] = e1[i] / e1l;
	e2[i] = e2[i] / e2l;
    }
    crossprd(e1,e2,e3);
 }

 for (i = 0; i < 3; i++) {
	b1[i] = e1[i];
	b2[i] = e2[i];
	b3[i] = e3[i];
 }

 for (i = 0; i < 3; i++) {
    if (inttyp->area.type != 3) {
	e1[i] = inttyp->area.v1[0]*b1[i] + inttyp->area.v1[1]*b2[i] +
		inttyp->area.v1[2]*b3[i];
	if (inttyp->area.type != 2 && inttyp->area.type != 3 && 
		inttyp->area.type != 4 && inttyp->area.type != 5 &&
		inttyp->area.type != 6) {
	   e2[i] = inttyp->area.v2[0]*b1[i] + inttyp->area.v2[1]*b2[i] +
		inttyp->area.v2[2]*b3[i];
	}
    }
 }

 e1lt = dveclen(e1);
 e2lt = dveclen(e2);

 for (i = 0; i < 3; i++) {
	e1[i] = e1[i] / e1lt;
	e2[i] = e2[i] / e2lt;
	b1[i] = e1[i];
 }

 crossprd(e1,e2,e3);

 if (inttyp->area.type == 5 || inttyp->area.type == 6) {
    crossprd(e1,e3,e2);
    for (i = 0; i < 3; i++) {
	b1[i] = e1[i];
	b2[i] = e2[i];
	b3[i] = e3[i];
    }
    inttyp->area.type = 2;

 } else {
    crossprd(e1,e3,b2);
    crossprd(b1,b2,b3);
 }

 for (i = 0; i < 3; i++) {
	B1[i] = (float) b1[i];
	B2[i] = (float) b2[i];
	B3[i] = (float) b3[i];
 }

 inttyp->npts = equidist_npts(inttyp,b1,b2,b3,e1l);

 if (inttyp->npts != 0) {

    inttyp->points =  (double *) malloc((sizeof x)*(inttyp->npts+1)*3);

    equidist_sphere(inttyp,b1,b2,b3,ori);
 }

}

#define DCKCOFF  10.0
#define DCKCMIN  1.5
#define DCKDEV   0.55
#define N_GROUPS      7

#define H_ACC_GROUP   0
#define H_DON_GROUP   1
#define PHC_GROUP     2
#define PHR_GROUP     3
#define ARO_GROUP     4
#define MET_GROUP     5
#define MACC_GROUP    6

static double dckcoff = DCKCOFF;
static int FiltAD =  0;
static int prE =  0;
static int hpr =  1;
static int DistI[N_GROUPS];
static int PDist[N_GROUPS];
static int NDist[N_GROUPS];
static int *IDist[N_GROUPS];
static GRPSTRU XGRP[N_GROUPS][N_GROUPS];

int cmpcrs(a,b)
CROSSSTRU *a, *b;
{
    if (a->d > b->d) return 1;
    else
       if (a->d == b->d) return  0;
       else          return -1;
}

int CmpORI(ORI1,ORI2)
double *ORI1;
double *ORI2;
{
    int i,j;

    for (i=0; i < 3; i++)  if (ORI1[i] != ORI2[i]) return 1;
   
    return 0;
}

int GetCrossGroup(grp1,grp2,fill)
int grp1;
int grp2;
int fill;
{
    int i,j,k,l,m,n,id1,id2;
    double dd,tt;
    
    n = 0;

    for (i=0; i < DistI[grp1]; i++) {
	id1 = IDist[grp1][i];
	for (k=0; k < inttyp[id1]->npts; k++) {
	   for (j=i+1; j < DistI[grp2]; j++) {
	     id2 = IDist[grp2][j];
	     if (CmpORI(inttyp[id1]->ORI, inttyp[id2]->ORI)) {
		for (l=0; l < inttyp[IDist[grp2][j]]->npts; l++) {
		   dd = 0.0;
		   for (m=0; m < 3; m++) {
		   	tt = inttyp[id1]->points[k*3+m] -
			     inttyp[id2]->points[l*3+m];
			dd = dd + tt*tt;

		   }
		   dd = sqrt(dd)*toangs;
		   if (dd < dckcoff && dd > DCKCMIN) {
			if (! ((id1 == id2) && (k == l))) {

			 if (fill) {
			   XGRP[grp1][grp2].XDist[n].d = (float) dd;
			   XGRP[grp1][grp2].XDist[n].grp1 = grp1;
			   XGRP[grp1][grp2].XDist[n].ind1 = IDist[grp1][i];
			   XGRP[grp1][grp2].XDist[n].pnt1 = k;
			   XGRP[grp1][grp2].XDist[n].grp2 = grp2;
			   XGRP[grp1][grp2].XDist[n].ind2 = IDist[grp2][j];
			   XGRP[grp1][grp2].XDist[n].pnt2 = l;
			 }
			 n++;
			}
		   }
		}
	      }
	   }
	}
    }

    return n;
}

void ScanCrossGroup(grp1,grp2,ind1,ind2)
int grp1;
int grp2;
int ind1;
int ind2;
{
    int i;
    
    fprintf(stderr,"ScanCrossGroup: [%d,%d] for distances between interactionpoints %d %d\n\n",grp1,grp2,ind1,ind2);
    for (i=0; i < XGRP[grp1][grp2].n; i++) {
	if (XGRP[grp1][grp2].XDist[i].ind1 == ind1 &&
	    XGRP[grp1][grp2].XDist[i].ind2 == ind2) {
fprintf(stderr,"d %.3f pnt1 %d pnt2 %d\n",XGRP[grp1][grp2].XDist[i].d,XGRP[grp1][grp2].XDist[i].pnt1,XGRP[grp1][grp2].XDist[i].pnt2);
	}

    }

}

void ScanCrossGroupDist(grp1,grp2,ind1,ind2,d)
int grp1;
int grp2;
int ind1;
int ind2;
float d;
{
   int i,ii,iii,j,idmin,idmax,d100,n;
   float dd,dmin,dmax;
   GRPSTRU *grp_p01;
   CROSSSTRU *xrsii;
    
   d100 = (int) dckcoff*dckcoff;

   dmin = ABS(d - DCKDEV); 
   if (dmin > (float) dckcoff) {
	idmin = d100;
   } else if (dmin < DCKCMIN) {
	idmin = 1;
   } else {
	idmin = (int) rndf(dmin*10.0);
	if (idmin > d100) return;
   }

   dmax = ABS(d + DCKDEV); 
   if (dmax > (float) dckcoff) {
	idmax = d100;
   } else if (dmax < DCKCMIN) {
	idmax = 1;
   } else {
	idmax = (int) rndf(dmax*10.0);
	if (idmax > d100) idmax = d100;
   }

   fprintf(stderr,"ScanCrossGroupD: [%d,%d] for distances %.3f between interactionpoints %d %d\n\n",grp1,grp2,d,ind1,ind2);
   for (i=0; i < XGRP[grp1][grp2].n; i++) {
	if (XGRP[grp1][grp2].XDist[i].ind1 == ind1 &&
	    XGRP[grp1][grp2].XDist[i].ind2 == ind2) {
	   if (ABS(XGRP[grp1][grp2].XDist[i].d-d) < DCKDEV) {
fprintf(stderr,"d %.3f pnt1 %d pnt2 %d\n",XGRP[grp1][grp2].XDist[i].d,XGRP[grp1][grp2].XDist[i].pnt1,XGRP[grp1][grp2].XDist[i].pnt2);
	   }
	}

   }

   fprintf(stderr,"ScanCrossGroupD: [%d,%d] for distances %.3f via XHash of interaction points %d %d\n\n",grp1,grp2,d,ind1,ind2);
   fprintf(stderr,"ScanCrossGroupD: [%d,%d] for distances %.3f via XHash idmin %d idmax %d\n\n",grp1,grp2,d,idmin,idmax);
   grp_p01 = &XGRP[grp1][grp2];

   for (i = idmin; i < idmax+1; i++ ) {
	n   = grp_p01->XHash[i].n;
	ii  = grp_p01->XHash[i].ind;

	if (ii+n >= grp_p01->n) break;

	for (j = 0; j < n; j++ ) {

	   iii = ii + j;
	   xrsii = &grp_p01->XDist[iii];

	   if (i == idmin && j == 0) fprintf(stderr,"dist[%d,%d] %.3f \n",iii,ii,xrsii->d);
	   if (ABS(xrsii->d-d) < DCKDEV && xrsii->ind1 == ind1 && xrsii->ind2 == ind2) {
		fprintf(stderr,"d %.3f pnt1 %d pnt2 %d iii %d\n",
			xrsii->d,xrsii->pnt1,xrsii->pnt2,iii);
	   }
	}
   }
}

void PrtInt(int i1,int i2,int i3,int j1,int j2,int j3)
{
    int i,j,k,m;
    double dd,tt;
    double d12,d13,d23;
    double d12min,d13min,d23min;
    double d12max,d13max,d23max;
    double D12,D13,D23;
    double v1[3],v2[3],v3[3];

// This function test for the existance of a triplet (i1,i2,i3)
// of protein interaction points, against a ligand triplet (j1,j2,j3)
// THIS IS ACCOMPLISHED without the setup_distances tables !!

// First create distances from ligand interaction points

    if (j1 >= lintp || j2 >= lintp || j3 >= lintp) return;

    for (i = 0; i<3; i++ ) {
      v1[i] = ligtyp[j1]->ORI[i] - ligtyp[j2]->ORI[i];
      v2[i] = ligtyp[j2]->ORI[i] - ligtyp[j3]->ORI[i];
      v3[i] = ligtyp[j1]->ORI[i] - ligtyp[j3]->ORI[i];
    }
    D12 = dveclen(v1)*toangs;
    D23 = dveclen(v2)*toangs;
    D13 = dveclen(v3)*toangs;

    d12min = BIGD; d13min = BIGD; d23min = BIGD;
    d12max = 0.0; d13max = 0.0; d23max = 0.0;
fprintf(stderr,"find protein interaction triples for interaction points %d,%d,%d \n",i1,i2,i3);
fprintf(stderr,"within distances from ligand interaction triple: %d,%d,%d\n",j1,j2,j3);
fprintf(stderr,"ligand distance: D12 %.3f D13 %.3f D23 %.3f\n",D12,D13,D23);
fprintf(stderr,"dckcoff: %.3f\n",dckcoff);

    if (i1 >= nintp || i2 >= nintp || i3 >= nintp) return;

    for (i=0; i<inttyp[i1]->npts; i++) {
       for (j=0; j<inttyp[i2]->npts; j++) {

	  d12 = 0.0;
	  for (m=0; m < 3; m++) {
	  	tt = inttyp[i1]->points[i*3+m] -
		     inttyp[i2]->points[j*3+m];
		d12 = d12 + tt*tt;
	  }
	  d12 = sqrt(d12)*toangs;
	  if (d12 < d12min) d12min = d12;
	  if (d12 > d12max) d12max = d12;

          for (k=0; k<inttyp[i3]->npts; k++) {
		d13 = 0.0;
		for (m=0; m < 3; m++) {
		   	tt = inttyp[i1]->points[i*3+m] -
			     inttyp[i3]->points[k*3+m];
			d13 = d13 + tt*tt;
		}
		d13 = sqrt(d13)*toangs;
		if (d13 < d13min) d13min = d13;
		if (d13 > d13max) d13max = d13;

		d23 = 0.0;
		for (m=0; m < 3; m++) {
		   	tt = inttyp[i2]->points[j*3+m] -
			     inttyp[i3]->points[k*3+m];
			d23 = d23 + tt*tt;

		}
		d23 = sqrt(d23)*toangs;
		if (d23 < d23min) d23min = d23;
		if (d23 > d23max) d23max = d23;

		if (d12 < dckcoff && d13 < dckcoff && d23 < dckcoff) {
	if (ABS(d12-D12) < DCKDEV && ABS(d13-D13) < DCKDEV && 
		ABS(d23-D23) < DCKDEV) {
		   fprintf(stderr,"i,j,k %d,%d,%d d12 %.3f d13 %.3f d23 %.3f\n",i,j,k,d12,d13,d23);
	}
	if (ABS(d12-D12) < 1.5*DCKDEV && ABS(d13-D13) < 1.5*DCKDEV && 
		ABS(d23-D23) < 1.5*DCKDEV) {
		   fprintf(stderr,"1.5: i,j,k %d,%d,%d d12 %.3f d13 %.3f d23 %.3f\n",i,j,k,d12,d13,d23);
	}
		}
	  }
       }
    }
    fprintf(stderr,"d12min %.3f d13min %.3f d23min %.3f\n",d12min,d13min,d23min);
    fprintf(stderr,"d12max %.3f d13max %.3f d23max %.3f\n",d12max,d13max,d23max);
}

void Setup_Distance_Tables()
{
    int i,j,k,l,m,n,jnew,ll,kk;
    double dd,tt;
    double d12,d13,d23;
    int done;


    for (i=0; i<N_GROUPS; i++) {
	PDist[i] = 0;
	NDist[i] = 0;
	DistI[i] = 0;
    }

    for (i=0; i<nintp; i++) {
	switch (inttyp[i]->type) {
	case H_ACC:
		PDist[H_ACC_GROUP] = PDist[H_ACC_GROUP] + inttyp[i]->npts;
		NDist[H_ACC_GROUP]++;
		break;

	case H_DON:
		PDist[H_DON_GROUP] = PDist[H_DON_GROUP] + inttyp[i]->npts;
		NDist[H_DON_GROUP]++;
		break;
		
	case PHENYL_CENTER:
		PDist[PHC_GROUP] = PDist[PHC_GROUP] + inttyp[i]->npts;
		NDist[PHC_GROUP]++;
		break;
		
	case AMIDE:
	case PHE_CH3:
	case PHENYL_RING:
		PDist[PHR_GROUP] = PDist[PHR_GROUP] + inttyp[i]->npts;
		NDist[PHR_GROUP]++;
		break;
		
	case CH:
	case CH2:
	case CH3:
	case SULFUR:
	case ARO:
		PDist[ARO_GROUP] = PDist[ARO_GROUP] + inttyp[i]->npts;
		NDist[ARO_GROUP]++;
		break;
		
	case METAL:
		PDist[MET_GROUP] = PDist[MET_GROUP] + inttyp[i]->npts;
		NDist[MET_GROUP]++;
		break;

	case METAL_ACC:
		PDist[MACC_GROUP] = PDist[MACC_GROUP] + inttyp[i]->npts;
		NDist[MACC_GROUP]++;
		break;
	}
    }

    for (i=0; i<N_GROUPS; i++) {
	IDist[i] = (int *) malloc(sizeof(int)*NDist[i]);
    }

    for (i=0; i<nintp; i++) {
	switch (inttyp[i]->type) {
	case H_ACC:
		IDist[H_ACC_GROUP][DistI[H_ACC_GROUP]] = i;
		DistI[H_ACC_GROUP]++;
		break;

	case H_DON:
		IDist[H_DON_GROUP][DistI[H_DON_GROUP]] = i;
		DistI[H_DON_GROUP]++;
		break;
		
	case PHENYL_CENTER:
		IDist[PHC_GROUP][DistI[PHC_GROUP]] = i;
		DistI[PHC_GROUP]++;
		break;
		
	case AMIDE:
	case PHE_CH3:
	case PHENYL_RING:
		IDist[PHR_GROUP][DistI[PHR_GROUP]] = i;
		DistI[PHR_GROUP]++;
		break;
		
	case CH:
	case CH2:
	case CH3:
	case SULFUR:
	case ARO:
		IDist[ARO_GROUP][DistI[ARO_GROUP]] = i;
		DistI[ARO_GROUP]++;
		break;
		
	case METAL:
		IDist[MET_GROUP][DistI[MET_GROUP]] = i;
		DistI[MET_GROUP]++;
		break;

	case METAL_ACC:
		IDist[MACC_GROUP][DistI[MACC_GROUP]] = i;
		DistI[MACC_GROUP]++;
		break;
	}
    }

    for (l=0; l < N_GROUPS; l++) {
	for (k=l; k < N_GROUPS; k++) {
	   if (l < 4 && k < 4) {
	      XGRP[l][k].n = GetCrossGroup(l,k,0);

	      XGRP[l][k].XDist = NULL;
	      XGRP[l][k].XHash = NULL;

	      if (XGRP[l][k].n != 0) {
		XGRP[l][k].XDist = 
			(CROSSSTRU *) malloc(sizeof(CROSSSTRU)*XGRP[l][k].n);

		if (XGRP[l][k].XDist == NULL) 
			fprintf(stderr,"Failed to allocate memory !\n");

		XGRP[l][k].n = GetCrossGroup(l,k,1);

		qsort((CROSSSTRU *) XGRP[l][k].XDist, 
		    XGRP[l][k].n, sizeof(CROSSSTRU), cmpcrs);

		XGRP[l][k].l = 
			(int) rndf(XGRP[l][k].XDist[XGRP[l][k].n-1].d*10.0);

		XGRP[l][k].XHash = 
			(HASHSTRU *) malloc(sizeof(HASHSTRU)*(XGRP[l][k].l+1));
    
		for (i=0; i<XGRP[l][k].l; i++) {
		    XGRP[l][k].XHash[i].n = 0;
		    XGRP[l][k].XHash[i].ind = 0;
		}

		jnew = -1;
		ll = 0;

		for (i=0; i<XGRP[l][k].n; i++) {
		   j = (int) rndf(XGRP[l][k].XDist[i].d*10.0);
		   if (j != jnew) {
			if (jnew != -1) XGRP[l][k].XHash[jnew].n = ll;
			XGRP[l][k].XHash[j].ind = i;
			ll = 0;
			jnew = j;
	   	   }
	   	   ll++;
		}

	      }
	   } else {
	      XGRP[l][k].n = 0;

	      XGRP[l][k].XDist = NULL;
	      XGRP[l][k].XHash = NULL;
	   }
	}
    }

//    ScanCrossGroup(0,0,61,227);
//    ScanCrossGroupDist(0,0,51,235,12.896);
//    PrtInt(51,235,144,38,54,42);
}

int Find_Group(grp)
int grp;
{
   switch (grp) {
   case H_ACC:
	return H_ACC_GROUP;
	break;

   case H_DON:
	return H_DON_GROUP;
	break;
		
   case PHENYL_CENTER:
	return PHC_GROUP;
	break;
		
   case AMIDE:
   case PHE_CH3:
   case PHENYL_RING:
	return PHR_GROUP;
	break;
		
   case CH:
   case CH2:
   case CH3:
   case SULFUR:
   case ARO:
	return ARO_GROUP;
	break;
		
   case METAL:
	return MET_GROUP;
	break;

   case METAL_ACC:
	return MACC_GROUP;
	break;
   }
}

int Find_Matching_Group(grp)
int grp;
{
   switch (grp) {
   case H_ACC_GROUP:
	return H_DON_GROUP;
	break;
   case H_DON_GROUP:
	return H_ACC_GROUP;
	break;
   case PHC_GROUP:
	return PHR_GROUP;
	break;
   case PHR_GROUP:
	return PHC_GROUP;
	break;
   case ARO_GROUP:
	return ARO_GROUP;
	break;
   case MET_GROUP:
	return MACC_GROUP;
	break;
   case MACC_GROUP:
	return MET_GROUP;
	break;
   }
}

void Calc_Centroid(Tri)
TRISTRU *Tri;
{

/* calculates centroid of a triangle */
/* should also fill in l,k,m */

   int i,j,k,l;
   float v1[3],v2[3],v3[3],dd;
   
   for (i = 0; i<3; i++ ) {
      Tri->Cen[i] = (Tri->p1[i] + Tri->p2[i] + Tri->p3[i]) / 3.0;
      v1[i] = Tri->p2[i] - Tri->p1[i];
      v2[i] = Tri->p3[i] - Tri->p1[i];
      v3[i] = Tri->p3[i] - Tri->p2[i];
   }
   Tri->d12 = veclen(v1)*toangs;
   Tri->d13 = veclen(v2)*toangs;
   Tri->d23 = veclen(v3)*toangs;

   cross(v1,v2,Tri->Out);
   dd = veclen(Tri->Out);
   if (dd > 0.0) {
      for (i = 0; i<3; i++ ) Tri->Out[i] = Tri->Out[i] / dd;
   }

/* to tranform one triangle onto another:
   1 Translate Tri1.Cen[] to Tri2.Cen[]
   2 Take the two outvectors Tri1.Out[] and Tri2.Out[],
     calculate out vector from these vecs. This will be the axis of
     rotation,
     Take outvector of Out(Rot) x Tri2.out = OutF
     Now Out(Rot),Tri2.out and OutF form the basis on which will be rotatied
         z       ,x            y
   3 Now rotate Tri1 around Tri2.out, such that Tri1.p1[] == Tri2.p1[]
*/
}

void alntw_(isel1,isel2,iscst,nscnd)
int *isel1;
int *isel2;
int *iscst;
int *nscnd;
{

/* fill Tri1 and Tri2 structures with coordinates of two sets of
   three coordinates of two separate structure and find the transformation
   that moves stuct1 onto struct2 (trans_tri)
*/

   int i,j;

   for (j=0; j<3; j++) {
	Tri1.p1[j] = (float) xyzp->coo[(isel1[0]-1)*3+j];
	Tri1.p2[j] = (float) xyzp->coo[(isel1[1]-1)*3+j];
	Tri1.p3[j] = (float) xyzp->coo[(isel1[2]-1)*3+j];

	Tri2.p1[j] = (float) xyzp->coo[(*iscst+isel2[0]-1)*3+j];
	Tri2.p2[j] = (float) xyzp->coo[(*iscst+isel2[1]-1)*3+j];
	Tri2.p3[j] = (float) xyzp->coo[(*iscst+isel2[2]-1)*3+j];
   }

   Calc_Centroid(&Tri1);
   Calc_Centroid(&Tri2);

   Trans_Tri(&Tri1,&Tri2);
}

void Frst_Rot(cc,uu,sina,cosa,R)
float *cc;
float *uu;
double sina;
double cosa;
double R[4][4];
{

    int i,j;
    double ca,sa,c[3],u[3];

    ca = cosa;
    sa = sina;

    for (i = 0; i<3; i++ ) {
	c[i] = (double) cc[i];
	u[i] = (double) uu[i];
    }

    R[0][0] = u[0]*u[0] + (u[1]*u[1] + u[2]*u[2])*ca;
    R[0][1] = u[0]*u[1]*(1.0 - ca) - u[2]*sa;
    R[0][2] = u[0]*u[2]*(1.0 - ca) + u[1]*sa;
    R[0][3] = (c[0]*(u[1]*u[1]+u[2]*u[2])-u[0]*(c[1]*u[1]+c[2]*u[2]))*(1.0 - ca) + (c[1]*u[2] - c[2]*u[1])*sa;

    R[1][0] = u[0]*u[1]*(1.0 - ca) + u[2]*sa;
    R[1][1] = u[1]*u[1] + (u[0]*u[0] + u[2]*u[2])*ca;
    R[1][2] = u[1]*u[2]*(1.0 - ca) - u[0]*sa;
    R[1][3] = (c[1]*(u[0]*u[0]+u[2]*u[2])-u[1]*(c[0]*u[0]+c[2]*u[2]))*(1.0 - ca) + (c[2]*u[0] - c[0]*u[2])*sa;

    R[2][0] = u[0]*u[2]*(1.0 - ca) - u[1]*sa;
    R[2][1] = u[1]*u[2]*(1.0 - ca) + u[0]*sa;
    R[2][2] = u[2]*u[2] + (u[0]*u[0] + u[1]*u[1])*ca;
    R[2][3] = (c[2]*(u[0]*u[0]+u[1]*u[1])-u[2]*(c[0]*u[0]+c[1]*u[1]))*(1.0 - ca) + (c[0]*u[1] - c[1]*u[0])*sa;

    R[3][0] = 0.0;
    R[3][1] = 0.0;
    R[3][2] = 0.0;
    R[3][3] = 1.0;
}

void vecnrm(float *v)
{
   float vl;
   int j;

   vl = veclen(v);
   for (j=0; j<3; j++) {
	v[j] = v[j] / vl;
   }
}
   
void xyzROT3(R,vt)
double R[4][4];
float *vt;
{
   int j,k;
   double p[3],pp[3];

   for (j=0; j<3; j++) {
	p[j] = vt[j];
	pp[j] = 0.0;
   }

   for (j=0; j<3; j++) {
	for (k=0; k<3; k++) {
	   pp[j] = pp[j] + R[j][k]*p[k];
	}
   }

   for (j=0; j<3; j++) {
	vt[j] = (float) pp[j];
   }
}

void xyzROT4(R,vt)
double R[4][4];
float *vt;
{
   int j,k;
   double p[4],pp[4];

   for (j=0; j<3; j++) {
	p[j] = vt[j];
	pp[j] = 0.0;
   }

   p[3] = 1.0;
   for (j=0; j<3; j++) {
	for (k=0; k<4; k++) {
	   pp[j] = pp[j] + R[j][k]*p[k];
	}
   }

   for (j=0; j<3; j++) {
	vt[j] = (float) pp[j];
   }
}

void Trans_Coo(Tri2,coo)
TRISTRU *Tri2;
double *coo;
{
   int i,j;
   float pt[3];
   double R1[4][4],R2[4][4],t[3];

   if (!allConf(&Tri2->coo,ndocka)) exit(-1);

   for (j = 0; j<3; j++ ) {
	t[j] = Tri2->t[j];
   }

   for (i=0; i<ndocka; i++) {
     for (j=0; j<3; j++) {
	Tri2->coo[i*3+j] = t[j] + coo[i*3+j];
     }
   }

   for (i=0; i<4; i++) 
     for (j=0; j<4; j++) R1[i][j] = Tri2->R1[i][j];

   for (i=0; i<ndocka; i++) {
     for (j=0; j<3; j++) {
	pt[j] = Tri2->coo[i*3+j];
     }

     xyzROT4(R1,pt);

     for (j=0; j<3; j++) {
	Tri2->coo[i*3+j] = pt[j];
     }
   }

   for (i=0; i<4; i++) 
     for (j=0; j<4; j++) R2[i][j] = Tri2->R2[i][j];


   for (i=0; i<ndocka; i++) {
     for (j=0; j<3; j++) {

	pt[j] = (float) Tri2->coo[i*3+j];
     }

     xyzROT4(R2,pt);

     for (j=0; j<3; j++) {
	Tri2->coo[i*3+j] = (double) pt[j];
     }
   }

   for (j=0; j<3; j++) {
     if (Tri2->ohlig[j] == 1) {
	i = Tri2->lig[j];
	OHRot(Tri2,ligtyp[i]->atom[1],ligtyp[i]->atom[0],ligtyp[i]->atom[2],j);
	OHFnd(Tri2,inttyp[Tri2->prot[j]]->ORI,j);
     }
   }

}

void PrtTrp(int indx)
{
fprintf(stderr,"Triplet %d lig %d %d %d prot %d %d %d\n",indx,
		TriArr[indx]->lig[0],TriArr[indx]->lig[1],TriArr[indx]->lig[2],
		TriArr[indx]->prot[0],TriArr[indx]->prot[1],TriArr[indx]->prot[2]);
fprintf(stderr,"prot dist d12 %f d13 %f d23 %f\n",
		TriArr[indx]->d12,TriArr[indx]->d13,TriArr[indx]->d23);

fprintf(stderr,"grp %d %d %d\n",
		TriArr[indx]->grp[0],TriArr[indx]->grp[1],TriArr[indx]->grp[2]);
}

void PrtTrip(int indx,int ligind1,int ligind2)
{
fprintf(stderr,"No match Triplet %d lig %d %d %d prot %d %d %d\n",indx,
		TriArr[indx]->lig[0],TriArr[indx]->lig[1],TriArr[indx]->lig[2],
		TriArr[indx]->prot[0],TriArr[indx]->prot[1],TriArr[indx]->prot[2]);
	if (TriArr[indx]->lig[0] == ligind1 || 
		TriArr[indx]->lig[1] == ligind1 || 
		TriArr[indx]->lig[2] == ligind1) {

		fprintf(stderr,"Triplet %d lig %d %d %d prot %d %d %d\n",indx,
		TriArr[indx]->lig[0],TriArr[indx]->lig[1],TriArr[indx]->lig[2],
		TriArr[indx]->prot[0],TriArr[indx]->prot[1],TriArr[indx]->prot[2]);

		fprintf(stderr,"prot dist d12 %f d13 %f d23 %f\n",
		TriArr[indx]->d12,TriArr[indx]->d13,TriArr[indx]->d23);

		fprintf(stderr,"grp %d %d %d\n",
		TriArr[indx]->grp[0],TriArr[indx]->grp[1],TriArr[indx]->grp[2]);

	}

	if (TriArr[indx]->lig[0] == ligind2 || 
		TriArr[indx]->lig[1] == ligind2 || 
		TriArr[indx]->lig[2] == ligind2) {

		fprintf(stderr,"Triplet %d lig %d %d %d prot %d %d %d\n",indx,
		TriArr[indx]->lig[0],TriArr[indx]->lig[1],TriArr[indx]->lig[2],
		TriArr[indx]->prot[0],TriArr[indx]->prot[1],TriArr[indx]->prot[2]);

		fprintf(stderr,"prot dist d12 %f d13 %f d23 %f\n",
		TriArr[indx]->d12,TriArr[indx]->d13,TriArr[indx]->d23);

		fprintf(stderr,"grp %d %d %d\n",
		TriArr[indx]->grp[0],TriArr[indx]->grp[1],TriArr[indx]->grp[2]);
	}
}

void Compress_Tri_L()
{
   int i,ntritmp,tut,n;
   double dd;

   ntritmp = -1;

   for (i = 0; i < ntris; i++) {
	if (TriArr[i] != NULL) {
	   ntritmp++;
	   TriArrCopy[ntritmp] = TriArr[i];
	}
   }

   ntritmp++;
   ntris = ntritmp;

   for (i = 0; i < ntris; i++) {
	TriArr[i] = TriArrCopy[i];
   }
}

void Compress_Tri_List()
{
   int i,ntritmp,tut,n;
   double dd;

   if (ntris < MAXSOL) return;

   ntritmp = -1;

   n = ntris+1;
   tut = (ntris+1) % 2;
   if (tut > 0) n--;

   for (i = 0; i < n; i = i + 2 ) {
	if (TriArr[i] == NULL && TriArr[i+1] != NULL) {
	   ntritmp++;
	   TriArrCopy[ntritmp] = TriArr[i+1];
	   continue;
	}
	if (TriArr[i] != NULL && TriArr[i+1] == NULL) {
	   ntritmp++;
	   TriArrCopy[ntritmp] = TriArr[i];
	   continue;
	}
	if (TriArr[i] == NULL && TriArr[i+1] == NULL) continue;
	if (TriArr[i]->coo == NULL || TriArr[i+1]->coo == NULL) continue;
	dd = dst(TriArr[i],TriArr[i+1]);
	if (dd <= 0.000001) {
	    if (TriArr[i+1]->coo != NULL) free(TriArr[i+1]->coo);
	    free(TriArr[i+1]);
	    TriArr[i+1] = NULL;
	    ntritmp++;
	    TriArrCopy[ntritmp] = TriArr[i];
	} else {
	    ntritmp++;
	    TriArrCopy[ntritmp] = TriArr[i];
	    ntritmp++;
	    TriArrCopy[ntritmp] = TriArr[i+1];
	}
   }

   ntris = ntritmp;

   for (i = 0; i < ntris+1; i++) {
	TriArr[i] = TriArrCopy[i];
   }
}

void Compress_Tri_List_e12_nocoo()
{
   int i,ntritmp,n;
   double dd;

   ntritmp = -1;

   n = ntris;
   for (i = 0; i < n; i++) {
	if (TriArr[i] != NULL) {
		if (TriArr[i]->e12 < 0.0) {
		   ntritmp++;
		   TriArrCopy[ntritmp] = TriArr[i];
		}
	}
   }

   ntritmp++;

   ntris = ntritmp;
   for (i = 0; i < ntris; i++) {
	TriArr[i] = TriArrCopy[i];
   }
}

void Compress_Tri_List_e12()
{
   int i,ntritmp,n;
   double dd;

   ntritmp = -1;

   n = ntris;
   for (i = 0; i < n; i++) {
	if (TriArr[i] != NULL) {
	   if (TriArr[i]->coo != NULL) {
		if (TriArr[i]->e12 < 0.0) {
		   ntritmp++;
		   TriArrCopy[ntritmp] = TriArr[i];
		}
	   }
	}
   }

   ntritmp++;

   ntris = ntritmp;
   for (i = 0; i < ntris; i++) {
	TriArr[i] = TriArrCopy[i];
   }
}

#define E12WIN 2.0

static float E12min = BIGD;

int CalcOne(int itri)
{
    int i,j,lj;
    float etot;

    if (TriArr[itri] != NULL) {
	   
	   etot = 0.0;

	   for (j=0; j < 3; j++) {
		lj = TriArr[itri]->lig[j];
 		etot = etot + 
			CalInt(TriArr[itri]->prot[j],lj,ligtyp[lj]->points,
				TriArr[itri]->t,
				TriArr[itri]->R1,TriArr[itri]->R2,
				TriArr[itri]->OutO,TriArr[itri]->OutOrg,0);
	   }

	   TriArr[itri]->e12 = etot;

	   if (etot < E12min) {
		E12min = etot;
//	        if (Match_tri(TriArr[itri],8,24,13,51,235,145)) return(0);
	   } else {
		if (etot > E12min + E12WIN) return(1);
	   }

    }

    return(0);
}

int CalcSchInt()
{
    int i,j,lj,lig[3],ido,idoc,frag,conf,ntriso,NtrisCut,ntrisc,first;
    float etot,emin;

    emin = 10000.0;
    frag = -1;

    for (i=0; i < ntris; i++) {
	if (TriArr[i] != NULL) {
	   
	   etot = 0.0;

	   for (j=0; j < 3; j++) {
		lj = TriArr[i]->lig[j];
 		etot = etot + 
			CalInt(TriArr[i]->prot[j],lj,ligtyp[lj]->points,
				TriArr[i]->t,
				TriArr[i]->R1,TriArr[i]->R2,
				TriArr[i]->OutO,TriArr[i]->OutOrg,0);
	   }


	   TriArr[i]->e12 = etot;

	   if (etot < emin) {
		emin = etot;
		frag = TriArr[i]->frag;
		lig[0] = TriArr[i]->lig[0];
		lig[1] = TriArr[i]->lig[1];
		lig[2] = TriArr[i]->lig[2];
	   }

	}
    }

    Compress_Tri_List_e12_nocoo();

    if (ntris > 0) {
	qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmptri);
    }

    NtrisCut = -1;
    ntrisc = ntris;

    for (i=0; i < ntris; i++) {
      if (TriArr[i] != NULL) {

	ido = 0; idoc = 0; conf = -1;
	if (TriArr[i]->conf != -1) idoc = 1;
	if (idoc) {
	   conf = TriArr[i]->conf;
	} else {
	   if (TriArr[i]->frag == frag) ido = 1;
	}

	if (TriArr[i]->e12 > TriArr[0]->e12 + E12WIN) {
	   if (NtrisCut == -1) NtrisCut = i;
	   ido = 0; idoc = 0;
	}

	if (ido) {
	    Trans_Coo(TriArr[i],DCKxyz.coo);
	} else if (idoc) {
	    if (TriArr[i]->nconf == 0) {
		Trans_Coo(TriArr[i],TriFin[conf]->coo);
		continue;
	    }

	    first = 1;
	    for (j=0; j < ligtyp[TriArr[i]->lig[0]]->nconf; j++) {
		conf = ligtyp[TriArr[i]->lig[0]]->ConfArr[j];

		if (Find_Lig_Conf(conf,i)) {
		   if (first) {
			Trans_Coo(TriArr[i],TriFin[conf]->coo);
			first = 0;
		   } else {
			TriArr[ntrisc] = (TRISTRU *) malloc(sizeof(TRISTRU));
			TriArr[ntrisc]->coo = 
			(double *) malloc(sizeof(double)*ndocka*3);
			memcpy(TriArr[ntrisc], TriArr[i], sizeof(TRISTRU));
			Trans_Coo(TriArr[ntrisc],TriFin[conf]->coo);
			ntrisc++;
		   }
		}
	    }

	} else {
	    if (TriArr[i]->coo != NULL) free(TriArr[i]->coo);
	    free(TriArr[i]);
	    TriArr[i] = NULL;
	}
      }
    }

    ntris = ntrisc;

    ntriso = -1;

    for (i=0; i < 10; i++) {
	Compress_Tri_List();
	if ( ntris == ntriso || ntris == 1) break;
	ntriso = ntris;
        fprintf(stderr,"compressed ntris %d\n",ntris);
    }

    return(frag);
}

void Trans_Tri(Tri1,Tri2)
TRISTRU *Tri1;
TRISTRU *Tri2;
{
   int i,j,k,l;
   float v1[3],v2[3],v3[3],V1[4],V2[3],V3[3];
   float x,y,z,pt[3],pl,COSA,SINA,cosa,sina;
   double R1[4][4],R2[4][4],t[3];

/* Tri1 is target, Tri2 to be transformed */

   for (j = 0; j<3; j++ ) {
	t[j] = (double) (Tri1->Cen[j] - Tri2->Cen[j]);
	v3[j] = Tri1->p1[j] - Tri1->Cen[j];
	V1[j] = Tri2->p1[j] - Tri2->Cen[j];
	V2[j] = Tri2->Out[j];
	ORI2[j] = Tri2->Cen[j] + (float) t[j];
	Tri2->Cen[j] = ORI2[j];
	Tri2->p1c[j] = Tri2->p1[j] + t[j];
	Tri2->p2c[j] = Tri2->p2[j] + t[j];
	Tri2->p3c[j] = Tri2->p3[j] + t[j];
	Tri2->P1[j] = Tri1->p1[j];
	Tri2->P2[j] = Tri1->p2[j];
	Tri2->P3[j] = Tri1->p3[j];
	Tri2->t[j] = t[j];
	Tri2->CenO[j] = Tri1->Cen[j];
	Tri2->OutOrg[j] = Tri1->Out[j];
	Tri2->prot[j] = Tri1->prot[j];
   }

   vecnrm(Tri2->Out);
   vecnrm(Tri1->Out);

   cross(Tri2->Out,Tri1->Out,v1);
   cross(Tri1->Out,Tri2->Out,v1);
   cross(Tri1->Out,v1,v2);
   
   vecnrm(v1);
   vecnrm(v2);
   
   IMPRD(Tri2->Out,Tri1->Out,&cosa,1);
   IMPRD(Tri2->Out,v2,&sina,1);

   Frst_Rot(Tri1->Cen,v1,sina,cosa,R1);

   vecnrm(V1);
   vecnrm(V2);
   
   xyzROT3(R1,V1);
   xyzROT3(R1,V2);
   xyzROT4(R1,ORI2);

   xyzROT4(R1,Tri2->p1c);
   xyzROT4(R1,Tri2->p2c);
   xyzROT4(R1,Tri2->p3c);

   for (j = 0; j<3; j++ ) {
	Tri2->OutO[j] = V2[j];
   }

   for (i=0; i<4; i++) 
     for (j=0; j<4; j++) Tri2->R1[i][j] = R1[i][j];

   cross(Tri1->Out,v3,v2);

/* orthonormal basis Tri2.out=z,v2=x,v3=y */

   vecnrm(v2);
   vecnrm(v3);
   vecnrm(Tri1->Out);
   vecnrm(V1);
   cross(V2,V1,V3);

   
   for (i=0; i<3; i++) {
	ORI[i] = Tri1->Cen[i];
	B1[i] = Tri1->Out[i];
	B2[i] = v2[i];
	B3[i] = v3[i];
   }
   
   for (i=0; i<3; i++) {
	Bt1[i] = V2[i];
	Bt2[i] = V1[i];
	Bt3[i] = V3[i];
   }
   
   IMPRD(v3,V1,&COSA,1);
   IMPRD(v3,V3,&SINA,1);

   Frst_Rot(ORI2,V2,SINA,COSA,R2);

   xyzROT4(R2,Tri2->p1c);
   xyzROT4(R2,Tri2->p2c);
   xyzROT4(R2,Tri2->p3c);

   for (i=0; i<4; i++) 
     for (j=0; j<4; j++) Tri2->R2[i][j] = R2[i][j];

}

void Store_Tri(Tri1,Tri2)
TRISTRU *Tri1;
TRISTRU *Tri2;
{
   int j;
   double t[3];

/* Tri1 is target, Tri2 to be transformed */

   for (j = 0; j<3; j++ ) {
	t[j] = (double) (Tri1->Cen[j] - Tri2->Cen[j]);
	Tri2->P1[j] = Tri1->p1[j];
	Tri2->P2[j] = Tri1->p2[j];
	Tri2->P3[j] = Tri1->p3[j];
	Tri2->t[j] = t[j];
	Tri2->CenO[j] = Tri1->Cen[j];
	Tri2->OutOrg[j] = Tri1->Out[j];
   }


}

int Triangle_Same_Previous(Tri1,Tri2)
TRISTRU *Tri1;
TRISTRU *Tri2;
{
   int i;


/* Tri->d12,d13,d23 angs
   Tri->p1,p2,p3 au */

   if (Tri1 == NULL || Tri2 == NULL) return 0;

   if (Tri1->prot[0] != Tri2->prot[0] || Tri1->prot[1] != Tri2->prot[1] || 
	Tri1->prot[2] != Tri2->prot[2]) return 0;

   if (ABS(Tri1->d12 - Tri2->d12) < 0.001 && ABS(Tri1->d13 - Tri2->d13) < 0.001 && ABS(Tri1->d23 - Tri2->d23) < 0.001) {

	for (i=0; i < 3; i++) {
	    if (ABS(Tri1->p1c[i] - Tri2->p1c[i]) > 0.001) return 0;
	    if (ABS(Tri1->p2c[i] - Tri2->p2c[i]) > 0.001) return 0;
	    if (ABS(Tri1->p3c[i] - Tri2->p3c[i]) > 0.001) return 0;
	}
	return 1;
   } else {
	return 0;
   }
}

void FreeTri(int j)
{
   if (TriArr[j]->coo != NULL) free(TriArr[j]->coo);
   free(TriArr[j]);
   TriArr[j] = NULL;
}

#define MAXSOLLIGTRI 20

void Find_Triangle_Match(Tri,idxs)
TRISTRU Tri;
int idxs;
{
   int grp[3],ogrp[3],i,j,k,l,ii,kk,idd,iee,n,m;
   int ind1,ind2,pnt1,pnt2,jind,jpnt,yesh;
   int AddTri,oo,idmin,idmax,iemin,iemax,iii,kkk,N,d100;
   float dd,ee,tt,ddd,ddt,eet,dckc;
   GRPSTRU *grp_p01, *grp_p12;
   CROSSSTRU *xrsii, *xrskk;
   TRISTRU TriA;

   d100 = (int) dckcoff*dckcoff;
   dckc = (float) dckcoff;

   if (Tri.d12 > dckc || Tri.d13 > dckc || Tri.d23 > dckc) return;

   TriA = Tri;

/* convert specific group to general groups: eg H_ACC to H_ACC_GROUP */

   ogrp[0] = Find_Group(Tri.grp[0]);
   ogrp[1] = Find_Group(Tri.grp[1]);
   ogrp[2] = Find_Group(Tri.grp[2]);

/* convert genreral groups to general matching groups */

   grp[0] = Find_Matching_Group(ogrp[0]);
   grp[1] = Find_Matching_Group(ogrp[1]);
   grp[2] = Find_Matching_Group(ogrp[2]);

   grp_p01 = &XGRP[grp[0]][grp[1]];
   grp_p12 = &XGRP[grp[1]][grp[2]];

   if (grp_p01->n == 0) return;
   if (grp_p12->n == 0) return;

   if (grp_p01->XDist == NULL)  return;
   if (grp_p01->XHash == NULL)  return;
   if (grp_p12->XDist == NULL)  return;
   if (grp_p12->XHash == NULL)  return;

   dd = ABS(Tri.d12 - DCKDEV); 
   if (dd > dckc) {
	idmin = d100;
   } else if (dd < DCKCMIN) {
	idmin = 1;
   } else {
	idmin = (int) rndf(dd*10.0);
	if (idmin > d100) return;
   }

   dd = ABS(Tri.d12 + DCKDEV); 
   if (dd > dckc) {
	idmax = d100;
   } else if (dd < DCKCMIN) {
	idmax = 1;
   } else {
	idmax = (int) rndf(dd*10.0);
	if (idmax > d100) idmax = d100;
   }

   ee = ABS(Tri.d23 - DCKDEV); 
   if (ee > dckc) {
	iemin = d100;
   } else if (ee < DCKCMIN) {
	iemin = 1;
   } else {
	iemin = (int) rndf(ee*10.0);
	if (iemin > d100) return;
   }

   ee = ABS(Tri.d23 + DCKDEV);
   if (ee > dckc) {
	iemax = d100;
   } else if (ee < DCKCMIN) {
	iemax = 1;
   } else {
	iemax = (int) rndf(ee*10.0);
	if (iemax > d100) iemax = d100;
   }

   for (idd = idmin; idd < idmax+1; idd++ ) {
     N = 0;
     for (iee = iemin; iee < iemax+1; iee++ ) {

       n   = grp_p01->XHash[idd].n;
       ii  = grp_p01->XHash[idd].ind;

       if (ii+n >= grp_p01->n) break;

       m   = grp_p12->XHash[iee].n;
       kk  = grp_p12->XHash[iee].ind;

       if (kk+m >= grp_p12->n) break;

       for (i = 0; i < n; i++ ) {

	iii = ii + i;
	xrsii = &grp_p01->XDist[iii];

	ddt  = xrsii->d;

	for (k = 0; k < m; k++ ) {
	   kkk = kk + k;
	   xrskk = &grp_p12->XDist[kkk];

	   eet  = xrskk->d;


	   yesh = -1;

	   if (xrsii->grp2 == grp[1]) {

		if (xrskk->grp2 == grp[1]) {
		   if (xrsii->ind2 == xrskk->ind2 && 
		       xrsii->pnt2 == xrskk->pnt2) yesh = 1;

		} else if (xrskk->grp1 == grp[1]) {
		   if (xrsii->ind2 == xrskk->ind1 && 
		       xrsii->pnt2 == xrskk->pnt1) yesh = 2;
		}

	   } else if (xrsii->grp1 == grp[1]) {

		if (xrskk->grp1 == grp[1]) {
		   if (xrsii->ind1 == xrskk->ind1 && 
		       xrsii->pnt1 == xrskk->pnt1) yesh = 3;
		} else if (xrskk->grp2 == grp[1]) {
		   if (xrsii->ind1 == xrskk->ind2 && 
		       xrsii->pnt1 == xrskk->pnt2) yesh = 4;
		}
	   }

	   if (yesh != -1) {


		switch (yesh) {
		case 1:

		   ind1 = xrsii->ind1;
		   ind2 = xrskk->ind1;
		   pnt1 = xrsii->pnt1;
		   pnt2 = xrskk->pnt1;
		   jind = xrsii->ind2;
		   jpnt = xrsii->pnt2;
		   break;

		case 2:

		   ind1 = xrsii->ind1;
		   ind2 = xrskk->ind2;
		   pnt1 = xrsii->pnt1;
		   pnt2 = xrskk->pnt2;
		   jind = xrsii->ind2;
		   jpnt = xrsii->pnt2;
		   break;

		case 3:

		   ind1 = xrsii->ind2;
		   ind2 = xrskk->ind2;
		   pnt1 = xrsii->pnt2;
		   pnt2 = xrskk->pnt2;
		   jind = xrsii->ind1;
		   jpnt = xrsii->pnt1;
		   break;

		case 4:

		   ind1 = xrsii->ind2;
		   ind2 = xrskk->ind1;
		   pnt1 = xrsii->pnt2;
		   pnt2 = xrskk->pnt1;
		   jind = xrsii->ind1;
		   jpnt = xrsii->pnt1;
		   break;

		default:
		   break;
		}


		ddd = 0.0;
		for (l=0; l < 3; l++) {
		   tt = inttyp[ind1]->points[pnt1*3+l] -
		        inttyp[ind2]->points[pnt2*3+l];
		   ddd = ddd + tt*tt;

		}
		ddd = sqrt(ddd)*TOANG;

		if ((ABS(Tri.d13 - ddd) < DCKDEV) &&
		    (ABS(Tri.d12 - ddt) < DCKDEV) &&
		    (ABS(Tri.d23 - eet) < DCKDEV)) {

			ntris++; N++;
			if (ntris >= MAXTRI) {
			   ntris = MAXTRI - 1;
			   return;
/*			fprintf(stderr,"ntris exceeded MAXTRI\n");*/
			} else {

			   if (N >= MAXSOLLIGTRI) goto IDD;

			   TriArr[ntris] = (TRISTRU *) malloc(sizeof Tri);
			   TriArr[ntris]->coo = NULL;

			   for (l=0; l < 3; l++) {
				TriArr[ntris]->p1[l] = Tri.p1[l];
				TriArr[ntris]->p2[l] = Tri.p2[l];
				TriArr[ntris]->p3[l] = Tri.p3[l];
				TriArr[ntris]->grp[l] = Tri.grp[l];
				TriArr[ntris]->lig[l] = Tri.lig[l];
			   }

			   Calc_Centroid(TriArr[ntris]);

			   for (l=0; l < 3; l++) {
				TriA.p1[l] = 
				   inttyp[ind1]->points[pnt1*3+l];
				TriA.p2[l] = 
				   inttyp[jind]->points[jpnt*3+l];
				TriA.p3[l] = 
				   inttyp[ind2]->points[pnt2*3+l];
				TriA.grp[l] = grp[l];
			   }

			   TriA.prot[0] = ind1;
			   TriA.prot[1] = jind;
			   TriA.prot[2] = ind2;

			   TriArr[ntris]->prot[0] = ind1;
			   TriArr[ntris]->prot[1] = jind;
			   TriArr[ntris]->prot[2] = ind2;

			   Calc_Centroid(&TriA);

			   AddTri = 1;
 			   if (ntris > 1) {
 			      if (Triangle_Same_Previous(
				    TriArr[ntris],TriArr[ntris-1])) AddTri = 0;
			   }

			   if (AddTri) {

// TriA contains protein triangle. TriArr[ntris] contains ligand triangle

				Trans_Tri(&TriA,TriArr[ntris]);
				TriArr[ntris]->conf = Tri.conf;
				TriArr[ntris]->nconf = Tri.nconf;
				if (TriArr[ntris]->conf == -1) {
				   TriArr[ntris]->frag = Tri.frag;
				} else {
				   TriArr[ntris]->frag = -1;
				   TriArr[ntris]->frags[0] = Tri.frags[0];
				   TriArr[ntris]->frags[1] = Tri.frags[1];
				   TriArr[ntris]->frags[2] = Tri.frags[2];
				}
				TriArr[ntris]->triS = idxs;
				if (CalcOne(ntris)) {
				   FreeTri(ntris);
				   ntris--;
				}
			   } else {
				FreeTri(ntris);
				ntris--;
			   }
			}

		}
	   }
	} /* end for (k = 0; k < m; k++ ) */
       } /* end for (i = 0; i < n; i++ ) */

     }
IDD:
     i = 0;
   }
}

float CalInt(ind1,ind2,lpoints,t,R1,R2,OutO,OutOrg,deb)
int ind1;
int ind2;
double *lpoints;
double t[3];
double R1[4][4];
double R2[4][4];
float OutO[3];
float OutOrg[3];
int deb;
{
    int i,j,l,ipr;
    float e12,ddev,adev1,adev2,dd,aqmin,aq,at,todeg;
    float fq1,fq2,fd1,fa1,fa2;
    float O[3],T[3];
    double ctmp[3],v1[3],v2[3],cosa;
   
    ipr = 0;

    for (l=0; l < 3; l++) O[l] = t[l] + ligtyp[ind2]->ORI[l];
    xyzROT4(R1,O);
    xyzROT4(R2,O);

    todeg = 45.0e0/atan(1.0e0);

    e12 = inttyp[ind1]->area.ene + ligtyp[ind2]->area.ene;

    fq1 = 1.0;

    if (inttyp[ind1]->q0*ligtyp[ind2]->q0 < inttyp[ind1]->area.chgsc[1])
	fq1 = inttyp[ind1]->area.chgsc[0];

    fq2 = 1.0;

    if (inttyp[ind1]->q0*ligtyp[ind2]->q0 < ligtyp[ind2]->area.chgsc[1])
	fq2 = ligtyp[ind2]->area.chgsc[0];

    fd1 = 1.0;

    ddev = 0.0;

    for (i = 0; i < 3; i++ ) {
	dd = (inttyp[ind1]->ORI[i] - O[i]);
	ddev +=  dd*dd;
    }

    ddev = sqrt(ddev);
    ddev = ddev*toangs;

    ddev = ddev - 0.5*(inttyp[ind1]->area.radius + ligtyp[ind2]->area.radius);
    ddev = ABS(ddev);

    if (ddev <= inttyp[ind1]->area.dissc[0]) {
	fd1 = 1.0;
    } else if (inttyp[ind1]->area.dissc[0] < ddev && 
	ddev < inttyp[ind1]->area.dissc[1]) {
	fd1 = 1.0 - (ddev - inttyp[ind1]->area.dissc[0])/
		    (inttyp[ind1]->area.dissc[1]-inttyp[ind1]->area.dissc[0]);
    } else {
	fd1 = 0.0;
	return 0.0;
    }

    if (inttyp[ind1]->area.angsc[0] == 0 && 
	inttyp[ind1]->area.angsc[1] == 360.0) {

	fa1 = 1.0;

    } else {

	
	adev1 = 0.0;
	aqmin = 10000.0;

	for (i = 0; i < inttyp[ind1]->npts; i++ ) {
	   aq = 0.0;
	   for (j = 0; j < 3; j++ ) {
		at = inttyp[ind1]->points[i*3+j] - O[j];
		aq = aq + at*at;
	   }
	   if (aq < aqmin) {
		aqmin = aq;
		for (j = 0; j < 3; j++ ) 
		   ctmp[j] = inttyp[ind1]->points[i*3+j];
	   }
	}

	for (j = 0; j < 3; j++ ) {
	   v1[j] = O[j] - inttyp[ind1]->ORI[j];
	   v2[j] = ctmp[j] - inttyp[ind1]->ORI[j];
	}
    
	dimprod(v1,v2,&cosa);

	if (fabs(cosa) == 1.0) {
           adev1 = 0.0;
	   if (cosa < 0) adev1 = 180.0;
	} else {
           adev1 = (float) acos(cosa)*todeg;
	}
    
	fa1 = 1.0;

	if (adev1 <= inttyp[ind1]->area.angsc[0]) {
	   fa1 = 1.0;
	} else if (inttyp[ind1]->area.angsc[0] < adev1 && 
		   adev1 < inttyp[ind1]->area.angsc[1]) {
	   fa1 = 1.0 - (adev1 - inttyp[ind1]->area.angsc[0])/
		    (inttyp[ind1]->area.angsc[1]-inttyp[ind1]->area.angsc[0]);
	} else {
	   fa1 = 0.0;
	   return 0.0;
	}
    }


    if (ligtyp[ind2]->area.angsc[0] == 0 && 
	ligtyp[ind2]->area.angsc[1] == 360.0) {

	fa2 = 1.0;

    } else {

	adev2 = 0.0;
	aqmin = 10000.0;

	for (i = 0; i < ligtyp[ind2]->npts; i++ ) {
	   aq = 0.0;
	   for (j = 0; j < 3; j++ ) T[j] = t[j] + lpoints[i*3+j];
	   xyzROT4(R1,T);
	   xyzROT4(R2,T);
	   for (j = 0; j < 3; j++ ) {
		at = T[j] - inttyp[ind1]->ORI[j];
		aq = aq + at*at;
	   }
	   if (aq < aqmin) {
		aqmin = aq;
		for (j = 0; j < 3; j++ ) ctmp[j] = T[j];
	   }
	}

	for (j = 0; j < 3; j++ ) {
	   v1[j] = inttyp[ind1]->ORI[j] - O[j];
	   v2[j] = ctmp[j] - O[j];
	}
    
	dimprod(v1,v2,&cosa);

	if (fabs(cosa) == 1.0) {
           adev2 = 0.0;
	   if (cosa < 0) adev2 = 180.0;
	} else {
           adev2 = (float) acos(cosa)*todeg;
	}
    
	fa2 = 1.0;

	if (adev2 <= ligtyp[ind2]->area.angsc[0]) {
	   fa2 = 1.0;
	} else if (ligtyp[ind2]->area.angsc[0] < adev2 && 
		   adev2 < ligtyp[ind2]->area.angsc[1]) {
	   fa2 = 1.0 - (adev2 - ligtyp[ind2]->area.angsc[0])/
		    (ligtyp[ind2]->area.angsc[1]-ligtyp[ind2]->area.angsc[0]);
	} else {
	   fa2 = 0.0;
	   return 0.0;
	}
    }

if (e12 > 0.0) fprintf(stderr,"CalInt: e12 %.3f\n",e12);
if (fq1 < 0.0 || fq2 < 0.0 || fd1 < 0.0 || fa1 < 0.0 || fa2 < 0.0) 
	fprintf(stderr,"CalInt: fq1 %.3f fq2 %.3f fd1 %.3f fa1 %.3f fa2 %.3f\n",fq1,fq2,fd1,fa1,fa2);
    e12 = e12*fq1*fq2*fd1*fa1*fa2;
    return e12;
}

void Tris_NoLink()
{
    int i,j,n,ihacc1,ihacc2,ihdon1,ihdon2;

    for (i=0; i < ntriS; i++) {
	if ((TriS[i].grp[0] == H_ACC || TriS[i].grp[1] == H_ACC || 
		TriS[i].grp[2] == H_ACC) ||
	    (TriS[i].grp[0] == H_DON || TriS[i].grp[1] == H_DON ||
		TriS[i].grp[2] == H_DON)) {

		   ihacc1 = -1; ihdon1 = -1;
		   ihacc2 = -1; ihdon2 = -1;
		   for (j=0; j < 3; j++) {
			if (TriS[i].grp[j] == H_ACC) {
			   if (ihacc1 == -1) {
				ihacc1 = j;
			   } else if (ihacc2 == -1) {
				ihacc2 = j;
			   }
			}
		   }
		   for (j=0; j < 3; j++) {
			if (TriS[i].grp[j] == H_DON) {
			   if (ihdon1 == -1) {
				ihdon1 = j;
			   } else if (ihdon2 == -1) {
				ihdon2 = j;
			   }
			}
		   }
		   if ((ihacc1 != -1 || ihacc2 != -1) && 
		       (ihdon1 != -1 || ihdon2 != -1)) {

		     if (ihdon1 != -1 && ihacc1 != -1) {
			if (ligtyp[TriS[i].lig[ihdon1]]->link == 
			    ligtyp[TriS[i].lig[ihacc1]]->link) {
			   TriS[i].active = 0;
			}
		     }
		     if (ihdon1 != -1 && ihacc2 != -1) {
			if (ligtyp[TriS[i].lig[ihdon1]]->link == 
			    ligtyp[TriS[i].lig[ihacc2]]->link) {
			   TriS[i].active = 0;
			}
		     }
		     if (ihdon2 != -1 && ihacc1 != -1) {
			if (ligtyp[TriS[i].lig[ihdon2]]->link == 
			    ligtyp[TriS[i].lig[ihacc1]]->link) {
			   TriS[i].active = 0;
			}
		     }
		     if (ihdon2 != -1 && ihacc2 != -1) {
			if (ligtyp[TriS[i].lig[ihdon2]]->link == 
			    ligtyp[TriS[i].lig[ihacc2]]->link) {
			   TriS[i].active = 0;
			}
		     }
		   }
	}
    }

    n = 0;
    for (i=0; i < ntriS; i++) {
	if (TriS[i].active) {
	   TriS[n] = TriS[i];
	   n++;
	}
    }
    ntriS = n;

    if (debugdck) fprintf(stderr,"Tris_NoLink: ntris reduced %d \n",ntriS);
}

void Select_Tris(ifrag)
int ifrag;
{
    int i,j,n,nacd,nacdl,ihacc,ihdon;

    n = 0;
    nacd = 0; nacdl = 0;

    for (i=0; i < ntriS; i++) {
	if (TriS[i].frag == ifrag) {
	   n++;
	   if ((TriS[i].grp[0] == H_ACC || TriS[i].grp[1] == H_ACC || 
		TriS[i].grp[2] == H_ACC) ||
		(TriS[i].grp[0] == H_DON || TriS[i].grp[1] == H_DON ||
		TriS[i].grp[2] == H_DON)) {
		   nacd++;
		   ihacc = -1; ihdon = -1;
		   for (j=0; j < 3; j++) {
			if (TriS[i].grp[j] == H_ACC) ihacc = j;
		   }
		   for (j=0; j < 3; j++) {
			if (TriS[i].grp[j] == H_DON) ihdon = j;
		   }
		   if (ihacc > -1 && ihdon > -1) {
			if (ligtyp[TriS[i].lig[ihdon]]->link != 
			    ligtyp[TriS[i].lig[ihacc]]->link)  nacdl++;
		   }
		}
 	}
    }

    fprintf(stderr,"Select_Tris: fragment %d ntris %d of which acc/don %d no linked %d\n",ifrag,n,nacd,nacdl);
}

void Sub_Selection_Tris()
{
    int i,j,n,ispair,oh0,oh1,oh2;
// The purpose of this function is to make a subselction of triplesin TriS[]
// that have at least one pair of acceptors or donors:
// acc-acc, acc-don or don-don
    n = 0;

    for (i=0; i < ntriS; i++) {
	ispair = 0;
	if ((TriS[i].grp[0] == H_ACC || TriS[i].grp[0] == H_DON)) ispair++;
	if ((TriS[i].grp[1] == H_ACC || TriS[i].grp[1] == H_DON)) ispair++;
	if ((TriS[i].grp[2] == H_ACC || TriS[i].grp[2] == H_DON)) ispair++;
	if (ispair < 2) {
	   TriS[i].active = 0;
	} else {
	   if (TriS[i].grp[0] == H_DON && TriS[i].grp[1] == H_DON) {
		if (ligtyp[TriS[i].lig[0]]->ohlig && 
		    ligtyp[TriS[i].lig[1]]->ohlig) {
		    oh0 = ABS(ligtyp[TriS[i].lig[0]]->ohsame);
		    oh1 = ABS(ligtyp[TriS[i].lig[1]]->ohsame);
		    if (oh0 == oh1) TriS[i].active = 0;
		}
	   } else if (TriS[i].grp[0] == H_DON && TriS[i].grp[2] == H_DON) {
		if (ligtyp[TriS[i].lig[0]]->ohlig && 
		    ligtyp[TriS[i].lig[2]]->ohlig) {
		    oh0 = ABS(ligtyp[TriS[i].lig[0]]->ohsame);
		    oh2 = ABS(ligtyp[TriS[i].lig[2]]->ohsame);
		    if (oh0 == oh2) TriS[i].active = 0;
		}
	   } else if (TriS[i].grp[1] == H_DON && TriS[i].grp[2] == H_DON) {
		if (ligtyp[TriS[i].lig[1]]->ohlig && 
		    ligtyp[TriS[i].lig[2]]->ohlig) {
		    oh1 = ABS(ligtyp[TriS[i].lig[1]]->ohsame);
		    oh2 = ABS(ligtyp[TriS[i].lig[2]]->ohsame);
		    if (oh1 == oh2) TriS[i].active = 0;
		}
	   } else {
		n++;
	   }
	}
    }

    n = 0;
    for (i=0; i < ntriS; i++) {
	if (TriS[i].active) {
	   TriS[n] = TriS[i];
	   n++;
	}
    }
    ntriS = n;

    fprintf(stderr,"Sub_Selection_Tris: ntris reduced %d \n",ntriS);
}

#define CHOSENCONF 8

int Monitor_AccDon(n1,n2,p1,p2,npair,npairl)
int n1;
int n2;
int *p1;
int *p2;
int *npair;
int *npairl;
{

   int i,j,l,Conf;
   double r,tt,toangs2,DCKCOFF2,R2MIN;

   toangs2 = TOANG*TOANG;
   DCKCOFF2 = dckcoff*dckcoff;

   R2MIN = BIGD;


// acc - don combination

   *npair = 0; *npairl = 0;

   for (i=0; i < n1; i++) {

     for (j=0; j < n2; j++) {

	if (ligtyp[p2[j]]->ohlig && ligtyp[p2[j]]->ohsame < 0) {

	   if (CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p2[j]]->ORI) &&
		ligtyp[p1[i]]->frag[0] == ligtyp[p2[j]]->frag[0]) {

	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p2[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 < R2MIN && r*toangs2 > DCKCMIN*DCKCMIN) {
 		R2MIN = r*toangs2;
		*npair = *npair + 1;
		if ((ligtyp[p1[i]]->link != ligtyp[p2[j]]->link) || 
		    !ligtyp[p1[i]]->ohlig || !ligtyp[p2[j]]->ohlig) 
			*npairl = *npairl + 1;
	      }

	   }
	}
     }
   }

// acc - acc combination

   for (i=0; i < n1; i++) {

     for (j=0; j < n1; j++) {

	if (i != j) {

	   if (CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p1[j]]->ORI) &&
		ligtyp[p1[i]]->frag[0] == ligtyp[p1[j]]->frag[0]) {

	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p1[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 < R2MIN && r*toangs2 > DCKCMIN*DCKCMIN) {
 		R2MIN = r*toangs2;
		*npair = *npair + 1;
		*npairl = *npairl + 1;
	      }

	   }
	}
     }
   }

// don - don combination

   for (i=0; i < n2; i++) {

     for (j=0; j < n2; j++) {

	if (i != j) {

	 if ((ligtyp[p2[i]]->ohlig && ligtyp[p2[i]]->ohsame < 0) &&
	     (ligtyp[p2[j]]->ohlig && ligtyp[p2[j]]->ohsame < 0)) {
	   if (CmpORI(ligtyp[p2[i]]->ORI,ligtyp[p2[j]]->ORI) &&
		ligtyp[p2[i]]->frag[0] == ligtyp[p2[j]]->frag[0]) {

	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p2[i]]->ORI[l] - ligtyp[p2[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 < R2MIN && r*toangs2 > DCKCMIN*DCKCMIN) {
 		R2MIN = r*toangs2;
		*npair = *npair + 1;
		*npairl = *npairl + 1;
	      }

	   }
	 }
	}
     }
   }

fprintf(stderr,"MONITOR_ACCDON: R2MIN %.3f DCKCOFF %.3f\n",R2MIN,DCKCOFF2);
   if (R2MIN != BIGD) {
	if (R2MIN > DCKCOFF2) {
	   dckcoff = 15.0;
fprintf(stderr,"NEW DCKCOFF %.3f\n",dckcoff);
// there is a distance bigger  than DCKCOFF in the same fragment. 
// Increase dckcoff
	   return(1);
	} else {
// there is a distance smaller than DCKCOFF in the same fragment
	   return(0);
	}
   } else {
// there is a NO AAC/DON pair in the same fragment. 
	return(1);
   }
}

void Reduce_Pairs(int FiltAD,int *npairl)
{
   int i,j,n,np;

   n = *npairl; np = 0;

   for (i=0; i < n; i++) {
	if (PAIRT[i] == FiltAD) {
	   
	   ADPAIR1[np] = ADPAIR1[i];
	   ADPAIR2[np] = ADPAIR2[i];
	   PAIRT[np] = PAIRT[i];
	   np++;
	}
   }
   *npairl = np;

if (debugdck) fprintf(stderr,"Reduce_Pairs: New np %d\n\n",np);
if (debugdck) fprintf(stderr,"Reduce_Pairs: ADPAIR1[0] %d ADPAIR2[0] %d\n\n",ADPAIR1[0],ADPAIR2[0]);

}

int Monitor_AccDon_Conformers(n1,n2,p1,p2,npair,npairl)
int n1;
int n2;
int *p1;
int *p2;
int *npair;
int *npairl;
{

   int i,j,l,Conf;
   double r,tt,toangs2,DCKCOFF2,*R2MINAD,*R2MINAA,*R2MINDD;
   double R2MINEST,R2MINADEST,R2MINAAEST,R2MINDDEST;

   R2MINAD = (double *) malloc(sizeof(double)*ntrif);
   R2MINAA = (double *) malloc(sizeof(double)*ntrif);
   R2MINDD = (double *) malloc(sizeof(double)*ntrif);

   toangs2 = TOANG*TOANG;
   DCKCOFF2 = dckcoff*dckcoff;

   for (i=0; i < ntrif; i++) {
	R2MINAD[i] = BIGD;
	R2MINAA[i] = BIGD;
	R2MINDD[i] = BIGD;
   }


// acc - don combination

   *npair = 0; *npairl = 0;

   for (i=0; i < n1; i++) {

     for (j=0; j < n2; j++) {

	if (ligtyp[p2[j]]->ohlig && ligtyp[p2[j]]->ohsame < 0) {

	   if (CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p2[j]]->ORI) &&
		ligtyp[p1[i]]->conf == ligtyp[p2[j]]->conf &&
		ligtyp[p1[i]]->link != ligtyp[p2[j]]->link) {

	      Conf = ligtyp[p1[i]]->conf;
	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p2[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 < R2MINAD[Conf] && r*toangs2 > DCKCMIN*DCKCMIN) {
 		R2MINAD[Conf] = r*toangs2;
		*npair = *npair + 1;
		if ((ligtyp[p1[i]]->link != ligtyp[p2[j]]->link) || 
		    !ligtyp[p1[i]]->ohlig || !ligtyp[p2[j]]->ohlig) 
			ADPAIR1[*npairl] =  ligtyp[p1[i]]->frag[0];
			ADPAIR2[*npairl] =  ligtyp[p2[j]]->frag[0];
			PAIRT[*npairl] =  1;
			*npairl = *npairl + 1;
	      }

	   }
	}
     }
   }

// acc - acc combination

   for (i=0; i < n1; i++) {

     for (j=0; j < n1; j++) {

	if (i != j) {

	   if (CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p1[j]]->ORI) &&
		ligtyp[p1[i]]->conf == ligtyp[p1[j]]->conf) {

	      Conf = ligtyp[p1[i]]->conf;

	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p1[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 < R2MINAA[Conf] && r*toangs2 > DCKCMIN*DCKCMIN) {
 		R2MINAA[Conf] = r*toangs2;
		*npair = *npair + 1;
		ADPAIR1[*npairl] =  ligtyp[p1[i]]->frag[0];
		ADPAIR2[*npairl] =  ligtyp[p1[j]]->frag[0];
		PAIRT[*npairl] =  2;
		*npairl = *npairl + 1;
	      }

	   }
	}
     }
   }

// don - don combination

   for (i=0; i < n2; i++) {

     for (j=0; j < n2; j++) {

	if (i != j) {

	 if ((ligtyp[p2[i]]->ohlig && ligtyp[p2[i]]->ohsame < 0) &&
	     (ligtyp[p2[j]]->ohlig && ligtyp[p2[j]]->ohsame < 0)) {
	   if (CmpORI(ligtyp[p2[i]]->ORI,ligtyp[p2[j]]->ORI) &&
		ligtyp[p2[i]]->conf == ligtyp[p2[j]]->conf) {

	      Conf = ligtyp[p2[i]]->conf;
	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p2[i]]->ORI[l] - ligtyp[p2[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 < R2MINDD[Conf] && r*toangs2 > DCKCMIN*DCKCMIN) {
 		R2MINDD[Conf] = r*toangs2;
		*npair = *npair + 1;
		ADPAIR1[*npairl] =  ligtyp[p2[i]]->frag[0];
		ADPAIR2[*npairl] =  ligtyp[p2[j]]->frag[0];
		PAIRT[*npairl] =  3;
		*npairl = *npairl + 1;
	      }

	   }
	 }
	}
     }
   }

   R2MINADEST = -BIGD;
   R2MINAAEST = -BIGD;
   R2MINDDEST = -BIGD;

   for (i=0; i < ntrif; i++) {
	if (R2MINAD[i] != BIGD) {
	   if (R2MINAD[i] > R2MINADEST) R2MINADEST = R2MINAD[i];
	}
	if (R2MINAA[i] != BIGD) {
	   if (R2MINAA[i] > R2MINAAEST) R2MINAAEST = R2MINAA[i];
	}
	if (R2MINDD[i] != BIGD) {
	   if (R2MINDD[i] > R2MINDDEST) R2MINDDEST = R2MINDD[i];
	}
   }

   R2MINEST = R2MINADEST;
   if (R2MINEST < R2MINAAEST) R2MINEST = R2MINAAEST;
   if (R2MINEST < R2MINDDEST) R2MINEST = R2MINDDEST;

   free(R2MINAD);
   free(R2MINAA);
   free(R2MINDD);

   if (R2MINEST != -BIGD) {
	if (R2MINEST > DCKCOFF2) {
	   dckcoff = 15.0;
	   FiltAD = 0;
	   if (R2MINEST == R2MINADEST) FiltAD = 1;
	   if (R2MINEST == R2MINAAEST) FiltAD = 2;
	   if (R2MINEST == R2MINDDEST) FiltAD = 3;
	   Reduce_Pairs(FiltAD,npairl);

	   if (debugdck) fprintf(stderr,"NEW DCKCOFF %.3f\n\n",dckcoff);
// there is a distance bigger  than DCKCOFF in the same fragment. 
// Increase dckcoff
	   return(1);
	} else {
// there is a distance smaller than DCKCOFF in the same fragment
	   return(0);
	}
   } else {
// there is a NO AAC/DON pair in the same fragment. 
	return(1);
   }
}

void Harvest_Triples(n1,n2,n3,p1,p2,p3)
int n1;
int n2;
int n3;
int *p1;
int *p2;
int *p3;
{
// Harvest Triples creates triples of interaction points by sampling
// three points from different or the same interaction arrays p1,p2,p3
// where each distance between the three interaction points
// must be smaller than DCKCOFF
//
// currently only triples belonging to ONE fragment are sampled !!!
//

   int i,j,k,l,p1isp2,p1isp3,p2isp3,SingleFrag,SameFrag,Conf;
   int OHSAME12,OHSAME13,OHSAME23;
   double r,p,q,dd,tt,toangs2,DCKCOFF2;
   float rr,pp,qq;

   toangs2 = TOANG*TOANG;
   DCKCOFF2 = dckcoff*dckcoff;

   p1isp2 = 0; p1isp3 = 0; p2isp3 = 0;

   if (p1 == p2) p1isp2 = 1;
   if (p1 == p3) p1isp3 = 1;
   if (p2 == p3) p2isp3 = 1;


   for (i=0; i < n1; i++) {

     for (j=0; j < n2; j++) {

	if (!p1isp2 || (p1isp2 && i != j)) {

	   OHSAME12 = 0;
	   if (ligtyp[p1[i]]->ohsame && ligtyp[p2[j]]->ohsame) {
		if (ABS(ligtyp[p1[i]]->ohsame) == ABS(ligtyp[p2[j]]->ohsame)) 
			OHSAME12 = 1;
	   }
	   if (CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p2[j]]->ORI) &&
		ligtyp[p1[i]]->conf == ligtyp[p2[j]]->conf && !OHSAME12) {

	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p2[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (r*toangs2 > DCKCOFF2) continue;

	      for (k=0; k < n3; k++) {

		Conf = -1;

		OHSAME13 = 0;
		if (ligtyp[p1[i]]->ohsame && ligtyp[p3[k]]->ohsame) {
		    if (ABS(ligtyp[p1[i]]->ohsame) == 
			ABS(ligtyp[p3[k]]->ohsame)) 
				OHSAME13 = 1;
		}

		OHSAME23 = 0;
		if (ligtyp[p2[j]]->ohsame && ligtyp[p3[k]]->ohsame) {
		    if (ABS(ligtyp[p2[j]]->ohsame) == 
			ABS(ligtyp[p3[k]]->ohsame)) 
				OHSAME23 = 1;
		}

		if ((!p1isp3 || (p1isp3 && i != k) &&
		     !p2isp3 || (p2isp3 && j != k) ) &&
		    CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p3[k]]->ORI) &&
		    CmpORI(ligtyp[p2[j]]->ORI,ligtyp[p3[k]]->ORI) &&
		    ligtyp[p2[j]]->conf == ligtyp[p3[k]]->conf &&
		    !OHSAME13 && !OHSAME23
		   ) {

		   if ( ligtyp[p1[i]]->conf != -1 ||
			ligtyp[p2[j]]->conf != -1 || 
			ligtyp[p3[k]]->conf != -1) {
			Conf = ligtyp[p1[i]]->conf;
		   }

		   SameFrag = 0;
		   if (ligtyp[p1[i]]->frag[0] == ligtyp[p2[j]]->frag[0] && 
			ligtyp[p1[i]]->frag[0] == ligtyp[p3[k]]->frag[0])
			SameFrag = 1;

		   SingleFrag = 0;
		   if (ligtyp[p1[i]]->nfrag == 1 && ligtyp[p2[j]]->nfrag == 1 &&
			ligtyp[p3[k]]->nfrag == 1) SingleFrag = 1;

		   if ((SameFrag && SingleFrag) || Conf != -1) {

			p = 0.0; q = 0.0;

			for (l=0; l < 3; l++) {
			   tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p3[k]]->ORI[l];
			   p = p + tt*tt;
			   tt = ligtyp[p2[j]]->ORI[l] - ligtyp[p3[k]]->ORI[l];
			   q = q + tt*tt;
			}

			if (p*toangs2 > DCKCOFF2) continue;
			if (q*toangs2 > DCKCOFF2) continue;

			TriS[ntriS].grp[0] = ligtyp[p1[i]]->type;
			TriS[ntriS].atindx[0] = ligtyp[p1[i]]->atom[0];
			TriS[ntriS].lig[0] = p1[i];
			TriS[ntriS].ohlig[0] = ligtyp[p1[i]]->ohlig;

			TriS[ntriS].grp[1] = ligtyp[p2[j]]->type;
			TriS[ntriS].atindx[1] = ligtyp[p2[j]]->atom[0];
			TriS[ntriS].lig[1] = p2[j];
			TriS[ntriS].ohlig[1] = ligtyp[p2[j]]->ohlig;

			TriS[ntriS].grp[2] = ligtyp[p3[k]]->type;
			TriS[ntriS].atindx[2] = ligtyp[p3[k]]->atom[0];
			TriS[ntriS].lig[2] = p3[k];
			TriS[ntriS].ohlig[2] = ligtyp[p3[k]]->ohlig;

			for (l=0; l < 3; l++) {
			   TriS[ntriS].p1[l] = (float) ligtyp[p1[i]]->ORI[l];
	      		   TriS[ntriS].p2[l] = (float) ligtyp[p2[j]]->ORI[l];
			   TriS[ntriS].p3[l] = (float) ligtyp[p3[k]]->ORI[l];
			}

			TriS[ntriS].frag = ligtyp[p2[j]]->frag[0];
			TriS[ntriS].conf = Conf;
			TriS[ntriS].nconf = 0;
			TriS[ntriS].active = 1;

			ntriS++;
			if (ntriS == MAXSTRI - 1) return;
		   }
	        }
	      }
	   }
	}
     }
   }
}

int DetAD(int i, int j)
{
   if (ligtyp[i]->type == H_DON && ligtyp[j]->type == H_ACC) return(1);
   if (ligtyp[i]->type == H_ACC && ligtyp[j]->type == H_DON) return(1);
   if (ligtyp[i]->type == H_ACC && ligtyp[j]->type == H_ACC) return(2);
   if (ligtyp[i]->type == H_DON && ligtyp[j]->type == H_DON) return(3);
   return(0);
}

void Harvest_Triples_NoFrag(n1,n2,n3,p1,p2,p3)
int n1;
int n2;
int n3;
int *p1;
int *p2;
int *p3;
{
// Harvest Triples creates triples of interaction points by sampling
// three points from different or the same interaction arrays p1,p2,p3
// where each distance between the three interaction points
// must be smaller than DCKCOFF
//
// currently only triples belonging to ONE fragment are sampled !!!
//

   int i,j,k,l,p1isp2,p1isp3,p2isp3,SingleFrag,SameFrag,Conf;
   int OHSAME12,OHSAME13,OHSAME23;
   double r,p,q,dd,tt,toangs2,DCKCOFF2;
   float rr,pp,qq;

   toangs2 = TOANG*TOANG;
   DCKCOFF2 = dckcoff*dckcoff;

   p1isp2 = 0; p1isp3 = 0; p2isp3 = 0;

   if (p1 == p2) p1isp2 = 1;
   if (p1 == p3) p1isp3 = 1;
   if (p2 == p3) p2isp3 = 1;


   for (i=0; i < n1; i++) {

     for (j=0; j < n2; j++) {

	if (!p1isp2 || (p1isp2 && i != j)) {

	   OHSAME12 = 0;
	   if (ligtyp[p1[i]]->ohsame && ligtyp[p2[j]]->ohsame) {
		if (ABS(ligtyp[p1[i]]->ohsame) == 
		    ABS(ligtyp[p2[j]]->ohsame))
			OHSAME12 = 1;
	   }

	   if (CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p2[j]]->ORI) &&
		ligtyp[p1[i]]->conf == ligtyp[p2[j]]->conf && !OHSAME12) {

	      r = 0.0;

	      for (l=0; l < 3; l++) {
	         tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p2[j]]->ORI[l];
	         r = r + tt*tt;
	      }

	      if (DetAD(p1[i],p2[j]) == FiltAD) {
		 if (r*toangs2 > DCKCOFF2) continue;
	      } else {
		 if (r*toangs2 > 100.0) continue;
	      }

	      for (k=0; k < n3; k++) {

		Conf = -1;

		OHSAME13 = 0;
		if (ligtyp[p1[i]]->ohsame && ligtyp[p3[k]]->ohsame) {
		   if (ABS(ligtyp[p1[i]]->ohsame) == 
		       ABS(ligtyp[p3[k]]->ohsame))
			OHSAME13 = 1;
		}

		OHSAME23 = 0;
		if (ligtyp[p2[j]]->ohsame && ligtyp[p3[k]]->ohsame) {
		    if (ABS(ligtyp[p2[j]]->ohsame) == 
			ABS(ligtyp[p3[k]]->ohsame)) 
				OHSAME23 = 1;
		}

		if ((!p1isp3 || (p1isp3 && i != k) &&
		     !p2isp3 || (p2isp3 && j != k) ) &&
		    CmpORI(ligtyp[p1[i]]->ORI,ligtyp[p3[k]]->ORI) &&
		    CmpORI(ligtyp[p2[j]]->ORI,ligtyp[p3[k]]->ORI) &&
		    ligtyp[p1[i]]->conf == ligtyp[p3[k]]->conf &&
		    ligtyp[p2[j]]->conf == ligtyp[p3[k]]->conf && 
		    !OHSAME13 && !OHSAME23
		   ) {

		   Conf = ligtyp[p1[i]]->conf;

		   if (Conf != -1) {

			p = 0.0; q = 0.0;

			for (l=0; l < 3; l++) {
			   tt = ligtyp[p1[i]]->ORI[l] - ligtyp[p3[k]]->ORI[l];
			   p = p + tt*tt;
			   tt = ligtyp[p2[j]]->ORI[l] - ligtyp[p3[k]]->ORI[l];
			   q = q + tt*tt;
			}

			if (DetAD(p1[i],p3[k]) == FiltAD) {
	 		   if (p*toangs2 > DCKCOFF2) continue;
			} else {
			   if (p*toangs2 > 100.0) continue;
			}

			if (DetAD(p2[j],p3[k]) == FiltAD) {
	 		   if (q*toangs2 > DCKCOFF2) continue;
			} else {
			   if (q*toangs2 > 100.0) continue;
			}

			TriS[ntriS].grp[0] = ligtyp[p1[i]]->type;
			TriS[ntriS].atindx[0] = ligtyp[p1[i]]->atom[0];
			TriS[ntriS].lig[0] = p1[i];
			TriS[ntriS].ohlig[0] = ligtyp[p1[i]]->ohlig;

			TriS[ntriS].grp[1] = ligtyp[p2[j]]->type;
			TriS[ntriS].atindx[1] = ligtyp[p2[j]]->atom[0];
			TriS[ntriS].lig[1] = p2[j];
			TriS[ntriS].ohlig[1] = ligtyp[p2[j]]->ohlig;

			TriS[ntriS].grp[2] = ligtyp[p3[k]]->type;
			TriS[ntriS].atindx[2] = ligtyp[p3[k]]->atom[0];
			TriS[ntriS].lig[2] = p3[k];
			TriS[ntriS].ohlig[2] = ligtyp[p3[k]]->ohlig;

			for (l=0; l < 3; l++) {
			   TriS[ntriS].p1[l] = (float) ligtyp[p1[i]]->ORI[l];
	      		   TriS[ntriS].p2[l] = (float) ligtyp[p2[j]]->ORI[l];
			   TriS[ntriS].p3[l] = (float) ligtyp[p3[k]]->ORI[l];
			}

			TriS[ntriS].conf = Conf;
//			TriS[ntriS].nconf = 0;
			TriS[ntriS].nconf = 1;

			if (TriS[ntriS].conf == -1) {
			   TriS[ntriS].frag = ligtyp[p2[j]]->frag[0];
			} else {
			   TriS[ntriS].frag = -1;
			   TriS[ntriS].frags[0] = ligtyp[p1[i]]->frag[0];
			   TriS[ntriS].frags[1] = ligtyp[p2[j]]->frag[0];
			   TriS[ntriS].frags[2] = ligtyp[p3[k]]->frag[0];
			}
			TriS[ntriS].active = 1;

			ntriS++;
			if (ntriS == MAXSTRI - 1) return;
		   }
	        }
	      }
	   }
	}
     }
   }
}

void Gen_triples()
{
   int i,j,l;

   for (i=0; i < ntriS; i++) {
     if (TriS[i].active) {
// these three lines may do nothing since TriS[i].d12 has not been set
	Tri1.d12 = TriS[i].d12;
	Tri1.d13 = TriS[i].d13;
	Tri1.d23 = TriS[i].d23;
	Tri1.grp[0] = TriS[i].grp[0];
	Tri1.grp[1] = TriS[i].grp[1];
	Tri1.grp[2] = TriS[i].grp[2];
	Tri1.lig[0] = TriS[i].lig[0];
	Tri1.lig[1] = TriS[i].lig[1];
	Tri1.lig[2] = TriS[i].lig[2];
	Tri1.ohlig[0] = TriS[i].ohlig[0];
	Tri1.ohlig[1] = TriS[i].ohlig[1];
	Tri1.ohlig[2] = TriS[i].ohlig[2];
	for (l=0; l < 3; l++) {
	   Tri1.p1[l] = TriS[i].p1[l];
	   Tri1.p2[l] = TriS[i].p2[l];
	   Tri1.p3[l] = TriS[i].p3[l];
	}
	Tri1.frag = TriS[i].frag;
	Tri1.conf = TriS[i].conf;
	Tri1.nconf = TriS[i].nconf;
	if (TriS[i].conf != -1) {
	   Tri1.frags[0] = TriS[i].frags[0];
	   Tri1.frags[1] = TriS[i].frags[1];
	   Tri1.frags[2] = TriS[i].frags[2];
	}
	Calc_Centroid(&Tri1);

	Find_Triangle_Match(Tri1,i);
	if (ntris == MAXTRI - 1) return;
     }
   }
}

void prtypes(ityp,n,iacc,nacc,idon,ndon,iphec,nphec,ipher,npher,iaro,naro)
INCRSTRU **ityp;
int n;
int *iacc;
int *nacc;
int *idon;
int *ndon;
int *iphec;
int *nphec;
int *ipher;
int *npher;
int *iaro;
int *naro;
{
   int i;

   *nacc = 0; *ndon = 0; *nphec = 0; *npher = 0; *naro = 0;

   if (n == 0) return;

   for (i=0; i < n; i++) {
	switch(ityp[i]->type) {
	case H_ACC:
	   fprintf(stderr,"%d H_ACC\n",i);
	   iacc[*nacc] = i;
	   (*nacc)++;
	   break;
	case H_DON:
	   fprintf(stderr,"%d H_DON\n",i);
	   idon[*ndon] = i;
	   (*ndon)++;
	   break;
	case PHENYL_CENTER:
	   fprintf(stderr,"%d PHENYL_CENTER\n",i);
	   iphec[*nphec] = i;
	   (*nphec)++;
	   break;
	case PHENYL_RING:
	   fprintf(stderr,"%d PHENYL_RING\n",i);
	   ipher[*npher] = i;
	   (*npher)++;
	   break;
	case CH:
	case CH2:
	case CH3:
	case SULFUR:
	case ARO:
	   fprintf(stderr,"%d ARO_GROUP\n",i);
	   iaro[*naro] = i;
	   (*naro)++;
	   break;
	default:
	   fprintf(stderr,"%d Other\n",i);
	}
   }

   fprintf(stderr,"\n");
}

void OrgLig()
{
     int i,j,k;
     int grpj,grpk;
     double t0[3],R1[4][4];
     float etot,OutO[3];

     for (i=0; i < 3; i++) t0[i] = 0.0;
     for (i=0; i < 4; i++) {
        for (j=0; j < 4; j++) {
	  if (i == j) {
	   R1[i][j] = 1.0;
	  } else {
	   R1[i][j] = 0.0;
	  }
        }
     }

     if (TriArr[0] == NULL) TriArr[0] = (TRISTRU *) malloc(sizeof(TRISTRU));

     allConf(&TriArr[0]->coo,ndocka);

     if (TriArr[0]->coo == NULL) return;

     for (i=0; i<ndocka; i++) {
	for (j=0; j<3; j++) {
	   TriArr[0]->coo[i*3+j] = DCKxyz.coo[i*3+j];
	}
     }

     prE = 1;
     etot = 0.0;
     for (j=0; j < lintp; j++) {
	grpj = Find_Group(ligtyp[j]->type);
	grpj = Find_Matching_Group(grpj);
	for (k=0; k < nintp; k++) {
	   grpk = Find_Group(inttyp[k]->type);
	   if (grpj == grpk) {
	      etot = etot + 
	      CalInt(k,j,ligtyp[j]->points,t0,R1,R1,OutO,OutO,1);
	   }
	}
     }
     TriArr[0]->e12 = etot;
     prE = 0;
     ntris++;
}

void RemCloseC()
{
   double dd[4],tt,CLOSED;
   int i,j,k,l,m,doit;

   CLOSED = CLOSEC/toangs;

   for (i = 0; i < ntris; i++ ) {
	if (TriArr[i] != NULL) {
	   for (j = 0; j < ndocka; j++ ) {
		for (k = 0; k < nintp; k++ ) {
		   doit = 0;
		   for (m = 0; m < inttyp[k]->area.n; m++ ) {
			dd[m] = 0.0; 
			for (l = 0; l < 3; l++ ) {
			   tt = TriArr[i]->coo[j*3+l] - inttyp[k]->c[m][l];
			   dd[m] = dd[m] + tt*tt;
			}
	 		dd[m] = sqrt(dd[m]);
			if (dd[m] < CLOSED) {
			   doit = 1;
			   break;
			}
		   }
		   if (doit) break;
		}
		if (doit) break;
	   }
	   if (doit) {
		if (TriArr[i]->coo != NULL) free(TriArr[i]->coo);
		free(TriArr[i]);
	        TriArr[i] = NULL;
	   }
	}
   }

   Compress_Tri_L();

}

void RemCloseC_One(int L,int all)
{
// Check triangle ligand coordinates TriArr[L]->coo for bunps against 
// all interaction points coordinates of the atoms that define the 
// interaction geometry.
// If the triangle bumps remove it.
//
// all = 0 check the whole of ligand
// all = 1 check only the the atoms belonging to the fragment the
//         ligand triangle belong to
//
// RemCloseC_One is called once after adding a new triangle in
// Find_Triangle_Match <== Gen_triple

   double dd[4],tt,CLOSED;
   int i,j,k,l,m,ido;

fprintf(stderr,"Entering RemCloseC_One: \n");
   CLOSED = CLOSEC/toangs;

   if (TriArr[L] != NULL) {
	for (k = 0; k < nintp; k++ ) {
	    for (j = 0; j < ndocka; j++ ) {
		ido = 0;
		if (!all) {
		   if (TriArr[L]->conf == -1) {
			if (singleb.ifrg[k] == TriArr[L]->frag) ido = 1;
		   } else {
			if (singleb.ifrg[k] == TriArr[L]->frags[0] ||
	    		    singleb.ifrg[k] == TriArr[L]->frags[1] ||
	    		    singleb.ifrg[k] == TriArr[L]->frags[2]) ido = 1;
		   }
		} else {
		   ido = 1;
		}
		if (ido) {
		   for (m = 0; m < inttyp[k]->area.n; m++ ) {
			dd[m] = 0.0; 
			for (l = 0; l < 3; l++ ) {
			   tt = TriArr[L]->coo[j*3+l] - inttyp[k]->c[m][l];
			   dd[m] = dd[m] + tt*tt;
			}
			dd[m] = sqrt(dd[m]);
			if (dd[m] < CLOSED) {
			   if (TriArr[L]->coo != NULL) free(TriArr[L]->coo);
			   free(TriArr[L]);
	        	   TriArr[L] = NULL;
			   ntris--;
			   return;
			}
		   }
		}
	    }
	}
   }

}

void RemCC_One(L)
int L;
{
// Check triangle ligand coordinates TriArr[L]->coo for bumps against 
// all atoms of the proein
// If the triangle bumps remove it.
//
// RemCC_One is called once after replacing the triangle with all
// conformers in Map_Conformers
//

    int i,j,k,l,ires;
    float tt,dd;
    double ddd,ttd,CLOSED;

    if (*ipdbon && calfptr->ncalf != 0) {
	for (ires = 1; ires < calfptr->ncalf+1; ires++ ) {

#if defined(VMS) || defined(UNDERSC)
	   getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
	   GETPDB(&ires,ipdb,ihpdb);
#else
   	   getpdb_(&ires,ipdb,ihpdb);
#endif
#endif
	   CLOSED = CLOSEC/toangs;

	   for (i=0; i<MXSYM; i++) {
		if (ipdb[i] > 0) {
		   if (TriArr[L] != NULL) {
			for (k = 0; k < ndocka; k++ ) {
			   ddd = 0.0;
			   for (l = 0; l < 3; l++ ) {
				ttd = xyzp->coo[(ipdb[i]-1)*3+l] - 
					TriArr[L]->coo[k*3+l];
				ddd = ddd + ttd*ttd;
			   }
			   if (sqrt(ddd) < CLOSED) {
				if (TriArr[L]->coo != NULL) 
				   free(TriArr[L]->coo);
				free(TriArr[L]);
				TriArr[L] = NULL;
				ntris--;
				break;
			   }
			}
		   }
		}
	   }

	   for (i=0; i<3*MXHSYM; i++) {
		if (ihpdb[i] > 0) {
		   if (TriArr[L] != NULL) {
			for (k = 0; k < ndocka; k++ ) {
			   ddd = 0.0;
			   for (l = 0; l < 3; l++ ) {
				ttd = xyzp->coo[(ihpdb[i]-1)*3+l] - 
					TriArr[L]->coo[k*3+l];
				ddd = ddd + ttd*ttd;
			   }
			   if (sqrt(ddd) < CLOSED) {
				if (TriArr[L]->coo != NULL) 
				   free(TriArr[L]->coo);
				free(TriArr[L]);
				TriArr[L] = NULL;
				ntris--;
				break;
			   }
			}
		   }
		}
	   }


	}
    }

}


int RemLoops(int j,int all,double CLOSED,int *ipdb,int *ihpdb)
{
   int i,k,l,ido;
   float tt,dd;
   double ddd,ttd;

   for (i=0; i<MXSYM; i++) {
	if (ipdb[i] > 0) {
	    for (k = 0; k < ndocka; k++ ) {

		ido = 0;
		if (!all) {
//		   if (TriArr[ntris]->conf == -1) {
		   if (TriArr[j]->conf == -1) {
			if (singleb.ifrg[k] == TriArr[j]->frag) ido = 1;
		   } else {
			if (singleb.ifrg[k] == TriArr[j]->frags[0] ||
	    		    singleb.ifrg[k] == TriArr[j]->frags[1] ||
	    		    singleb.ifrg[k] == TriArr[j]->frags[2]) ido = 1;
		   }
		} else {
			ido = 1;
		}

		if (ido) {
		      ddd = 0.0;
		      for (l = 0; l < 3; l++ ) {
			ttd = xyzp->coo[(ipdb[i]-1)*3+l] - 
				TriArr[j]->coo[k*3+l];
			ddd = ddd + ttd*ttd;
		      }
		      if (sqrt(ddd) < CLOSED) return(1);
		}

	    } // end for k ndocka
	} // ifend ipdb[i] > 0
   } // end for i MXSYM

   for (i=0; i<3*MXHSYM; i++) {
	if (ihpdb[i] > 0) {
	    for (k = 0; k < ndocka; k++ ) {
		ido = 0;
		if (!all) {
		   if (TriArr[j]->conf == -1) {
			if (singleb.ifrg[k] == TriArr[j]->frag) ido = 1;
		   } else {
			if (singleb.ifrg[k] == TriArr[j]->frags[0] ||
	    		    singleb.ifrg[k] == TriArr[j]->frags[1] ||
	    		    singleb.ifrg[k] == TriArr[j]->frags[2]) ido = 1;
		   }
		} else {
		   ido = 1;
		}

		if (ido) {

		      ddd = 0.0;
		      for (l = 0; l < 3; l++ ) {
			ttd = xyzp->coo[(ihpdb[i]-1)*3+l] - 
				TriArr[j]->coo[k*3+l];
			ddd = ddd + ttd*ttd;
		      }

		      if (sqrt(ddd) < CLOSED) return(1);
		}

	    } // end for k ndocka
	} // if end ihpdb[i] > 0
   } // end for i = MXHSYM

   return(0);
}

void RemCC_All(int all)
{
    int j,ires;
    double CLOSED;

    CLOSED = CLOSEC/toangs;

    if (*ipdbon && calfptr->ncalf != 0) {
	for (ires = 1; ires < calfptr->ncalf+1; ires++ ) {

#if defined(VMS) || defined(UNDERSC)
	   getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
	   GETPDB(&ires,ipdb,ihpdb);
#else
   	   getpdb_(&ires,ipdb,ihpdb);
#endif
#endif

	   for (j = 0; j < ntris; j++ ) {
		if (TriArr[j] != NULL) {

		   if (RemLoops(j,all,CLOSED,ipdb,ihpdb)) FreeTri(j);
		   
		} // if end TriArr[j] != NULL
	   } // end for j ntris


	}
    }

    Compress_Tri_L();

}

int ChkAro(ia1,ia2,xyz)
int ia1;
int ia2;
COOSTRU *xyz;
{
   int i,j,k,n1,n2,ian,ian1,ian2,ian3,ian12,ian13,ian23,itel;
   int ica1,ica2,icn[3];

   n1 = xyz->iconn[ia1*(MXCON+1)];
   n2 = xyz->iconn[ia2*(MXCON+1)];

   itel = 0;

   for (j=0; j < n1; j++) {
	k = xyz->iconn[ia1*(MXCON+1)+j+1];
	k = ABS(k) - 1;
	if (k != ia2 && itel < 3) {
	   icn[itel] = k;
	   itel++;
	}
   }

   ica1 = 0;

   if (itel == 2) {
	if (singleb.irsd[icn[0]] == 4) ica1++;
	if (singleb.irsd[icn[1]] == 4) ica1++;
	if (singleb.irsd[ia1] == 4) ica1++;
   }

   itel = 0;
   for (j=0; j < n2; j++) {
	k = xyz->iconn[ia2*(MXCON+1)+j+1];
	k = ABS(k) - 1;
	if (k != ia1 && itel < 3) {
	   icn[itel] = k;
	   itel++;
	}
   }

   ica2 = 0;

   if (itel == 2) {
	if (singleb.irsd[icn[0]] == 4) ica2++;
	if (singleb.irsd[icn[1]] == 4) ica2++;
	if (singleb.irsd[ia2] == 4) ica2++;
	if ( (ica1 == 3 && ica2 == 2) || (ica1 == 2 && ica2 == 3) ) return(0);
	if (ica1 == 3 && ica2 == 3) return(1);
   }

   return(0);
}

int IsPlanar(i1,i2,i3,i4,xyz)
int i1;
int i2;
int i3;
int i4;
COOSTRU *xyz;
{
   int j;
   float v1[3],v2[3],v3[3],v4[3],v5[3];
   double cosa;

   for (j=0; j<3; j++) {
	v1[j] = xyz->coo[i2*3+j] - xyz->coo[i1*3+j];
	v2[j] = xyz->coo[i3*3+j] - xyz->coo[i1*3+j];
	v3[j] = xyz->coo[i4*3+j] - xyz->coo[i1*3+j];
   }

   cross(v1,v2,v4);
   improd(v4,v3,&cosa);

   if (fabs(cosa) < 0.3) return(1);

   return(0);
}

int IsNPlanarH2(ia1,ia2,xyz)
int ia1;
int ia2;
COOSTRU *xyz;
{
   int j,k,n1,n2,ian1,ian2,itel;
   int ica1,ica2,icn[3],pl;

   n1 = xyz->iconn[ia1*(MXCON+1)];

   itel = 0;
   ian1 = 0;
   ian2 = 0;

   for (j=0; j < n1; j++) {
	k = xyz->iconn[ia1*(MXCON+1)+j+1];
	k = ABS(k) - 1;
	if (k != ia2 && itel < 3) {
	   icn[itel] = k;
	   itel++;
	}
   }

   pl = 0;

   if (itel == 2) {
	ian1 = xyz->ianz[icn[0]];
	ian2 = xyz->ianz[icn[1]];
	pl = IsPlanar(ia1,icn[0],icn[1],ia2,xyz);
	
   }
 
   if (pl == 1 && ian1+ian2 == 2) return(0);
   return(1);
}

int IsSymFrg(isng,xyz)
int isng;
COOSTRU *xyz;
{
   int i,j,k,n1,n2,ia1,ia2,ian,ian1,ian2,ian3,ian12,ian13,ian23,itel;
   int ica1,ica2,icn[3],pl1,pl2;

   ia1 = singleb.sng[isng][0];
   ia2 = singleb.sng[isng][1];

   n1 = xyz->iconn[ia1*(MXCON+1)];
   n2 = xyz->iconn[ia2*(MXCON+1)];

   itel = 0;

   for (j=0; j < n1; j++) {
	k = xyz->iconn[ia1*(MXCON+1)+j+1];
	k = ABS(k) - 1;
	if (k != ia2 && itel < 3) {
	   icn[itel] = k;
	   itel++;
	}
   }

   pl1 = 0;
   ica1 = 0;

   switch(itel) {
   case 3:
	ian1 = xyz->ianz[icn[0]];
	ian2 = xyz->ianz[icn[1]];
	ian3 = xyz->ianz[icn[2]];
	break;
   case 2:
	ian1 = xyz->ianz[icn[0]];
	ian2 = xyz->ianz[icn[1]];
	ian3 = 0;
	if (singleb.irsd[icn[0]] == 5) ica1++;
	if (singleb.irsd[icn[1]] == 5) ica1++;
	if (singleb.irsd[ia1] == 5) ica1++;
	pl1 = IsPlanar(ia1,icn[0],icn[1],ia2,xyz);
	break;
   case 1:
	ian1 = xyz->ianz[icn[0]];
	ian2 = 0;
	ian3 = 0;
	break;
   case 0:
	ian1 = 0;
	ian2 = 0;
	ian3 = 0;
	break;
   default:
	break;
   }

   ian12 = ian1 + ian2;
   ian13 = ian1 + ian3;
   ian23 = ian2 + ian3;


   if (itel == 3) {
	if (ian1 == ian2 && ian1 == ian3) return(1);
	if (ian12 == 2 || ian13 == 2 || ian23 == 2) return(2);
   }

   itel = 0;
   for (j=0; j < n2; j++) {
	k = xyz->iconn[ia2*(MXCON+1)+j+1];
	k = ABS(k) - 1;
	if (k != ia1 && itel < 3) {
	   icn[itel] = k;
	   itel++;
	}
   }

   pl2 = 0;
   ica2 = 0;

   switch(itel) {
   case 3:
	ian1 = xyz->ianz[icn[0]];
	ian2 = xyz->ianz[icn[1]];
	ian3 = xyz->ianz[icn[2]];
	break;
   case 2:
	ian1 = xyz->ianz[icn[0]];
	ian2 = xyz->ianz[icn[1]];
	ian3 = 0;
	if (singleb.irsd[icn[0]] == 5) ica2++;
	if (singleb.irsd[icn[1]] == 5) ica2++;
	if (singleb.irsd[ia2] == 5) ica2++;
	pl2 = IsPlanar(ia2,icn[0],icn[1],ia1,xyz);
	break;
   case 1:
	ian1 = xyz->ianz[icn[0]];
	ian2 = 0;
	ian3 = 0;
	break;
   case 0:
	ian1 = 0;
	ian2 = 0;
	ian3 = 0;
	break;
   default:
	break;
   }

   ian12 = ian1 + ian2;
   ian13 = ian1 + ian3;
   ian23 = ian2 + ian3;


   if (itel == 3) {
	if (ian1 == ian2 && ian1 == ian3) return(1);
	if (ian12 == 2 || ian13 == 2 || ian23) return(2);
   } else if (itel == 2) {
	if (ica1 == 3 && ica2 == 3) return(2);
	if (pl1 == 1 && pl2 == 1) return(2);
   }

   return(3);
}

void ExtraFrag(C)
COOSTRU *C;
{

   int i,in,j,k[3],kn,ktot,krng,ir1,ir2,iflg;

   for (i=0; i < ndocka; i++) {

	in = C->iconn[i*(MXCON+1)];
	ir1 = singleb.jrng[i];
	iflg = 0;
	krng = -1;
	
	if (in == 3 && ir1) {
	   ktot = 0;
	   for (j=0; j < 3; j++) {
		k[j] = C->iconn[i*(MXCON+1)+j+1]-1;
		if (singleb.jrng[k[j]] == ir1) {
		   ktot++;
		} else {
		   krng = k[j];
		}
	   }

	   if (ktot == 2) iflg = 1;
	}

	if (iflg && krng != -1 && krng > i) {

	   kn = C->iconn[krng*(MXCON+1)];
	   ir2 = singleb.jrng[krng];
	   iflg = 0;

	   if (kn == 3 && ir2) {

		ktot = 0;
		for (j=0; j < 3; j++) {
		   k[j] = C->iconn[krng*(MXCON+1)+j+1]-1;
		   if (singleb.jrng[k[j]] == ir2) ktot++;
	   	}

		if (ktot == 2) iflg = 1;
	   }

	   if (iflg) {
		singleb.sng[singleb.N][0] = i;
		singleb.sng[singleb.N][1] = krng;
		singleb.N++;
	   }

	}
	
   }

}

void Fragmentise(xyz)
COOSTRU *xyz;
{
   int i,j,k,l,n,m,itel,icn[4*MXCON],ICN[4*MXCON],N,iflg;

   singleb.NFRAG = 0;

   for (i=0; i < ndocka; i++) {
	singleb.ifrg[i] = -1;
   }

   singleb.ifrg[0] = 0;
   N = 1;
   ICN[0] = 0;
   xyzp->iatclr[0] = singleb.NFRAG;

   while (1) {

      n = 0;

      for (m=0; m < N; m++) {

	i = ICN[m];
	singleb.ifrg[i] = singleb.NFRAG;
	xyz->iatclr[i] = singleb.NFRAG;

	for (j=0; j < xyz->iconn[i*(MXCON+1)]; j++) {

	   k = xyz->iconn[i*(MXCON+1)+j+1];
	   k = ABS(k) - 1;

	   if (singleb.ifrg[k] == -1) {

		iflg = 0;

		for (l=0; l < singleb.N; l++) {
		   if (singleb.sng[l][0] == i && singleb.sng[l][1] == k) {
			iflg = 1;
		   }
		}

		if (!iflg)  {
		   singleb.ifrg[k] = singleb.NFRAG;
		   xyz->iatclr[k] = singleb.NFRAG;
		   icn[n] = k;
		   n++;
		}
	   }
	}
      }

      N = n;

      for (l=0; l < N; l++) {
	ICN[l] = icn[l];
      }

      if (!N) {

	iflg = 1;

        for (l=0; l < ndocka; l++) {
	   if (singleb.ifrg[l] == -1) {
		iflg = 0;
		ICN[0] = l;
		N = 1;
		singleb.NFRAG++;
		break;
	   }
	}
	if (iflg) break;
      }

   }

   singleb.NFRAG++;

   
   for (i=0; i < singleb.N; i++) {
	singleb.SngFrg[i][0] = singleb.ifrg[singleb.sng[i][0]];
	singleb.SngFrg[i][1] = singleb.ifrg[singleb.sng[i][1]];
	singleb.sngdone[i] = 0;
   }

   for (i=0; i < singleb.NFRAG; i++) {

	itel = 0;

	for (j=0; j < singleb.N; j++) {
	   if (i == singleb.ifrg[singleb.sng[j][0]] ||
	       i == singleb.ifrg[singleb.sng[j][1]]) {
		singleb.FrgSng[i][itel] = j;
		itel++;
	   }

	   singleb.FrgSngN[i] = itel;
	}
   }

}

// Map_Conformers uses existing array of TriArr
// to create new array elements with new conformers. However, these add
// the original conformer, so we need to remove the original.

void Map_Conformers()
{
   int i,j,k,l,ntrism1,beg[MAXTRI],end[MAXTRI],at1,at2,at3;
    
   for (i=0; i < ntriS; i++) {
	beg[i] = -1;
	end[i] = -1;
   }

   for (i=0; i < ntris; i++) {
	if (TriArr[i] != NULL) {
	  if (TriArr[i]->coo != NULL) {
	    if (TriArr[i]->triS < MAXTRI && TriArr[i]->triS >= 0) {
	    if (beg[TriArr[i]->triS] == -1) {
		beg[TriArr[i]->triS] = i;
	    }
	    end[TriArr[i]->triS] = i;
	    }
	  }
	}
   }


   for (i=0; i < ntriS; i++) {

	Tri1.grp[0] = TriS[i].grp[0];
	Tri1.grp[1] = TriS[i].grp[1];
	Tri1.grp[2] = TriS[i].grp[2];
	Tri1.frag   = TriS[i].frag;

	Tri2.grp[0] = TriS[i].grp[0];
	Tri2.grp[1] = TriS[i].grp[1];
	Tri2.grp[2] = TriS[i].grp[2];
	Tri2.lig[0] = TriS[i].lig[0];
	Tri2.lig[1] = TriS[i].lig[1];
	Tri2.lig[2] = TriS[i].lig[2];
	Tri2.frag   = TriS[i].frag;

	at1 = TriS[i].atindx[0];
	at2 = TriS[i].atindx[1];
	at3 = TriS[i].atindx[2];

	if (beg[i] != -1 && end[i] != -1) {

	   for (j=beg[i]; j < end[i]+1; j++) {

	    if (TriArr[j] != NULL) {
		for (l=0; l < 3; l++) {
		   Tri1.p1[l] = TriArr[j]->coo[at1*3+l];
		   Tri1.p2[l] = TriArr[j]->coo[at2*3+l];
		   Tri1.p3[l] = TriArr[j]->coo[at3*3+l];
	   	}

	   	Calc_Centroid(&Tri1);

	   	for (k=0; k < ntrif; k++) {

		   for (l=0; l < 3; l++) {
			Tri2.p1[l] = TriFin[k]->coo[at1*3+l];
			Tri2.p2[l] = TriFin[k]->coo[at2*3+l];
			Tri2.p3[l] = TriFin[k]->coo[at3*3+l];
		   }

// allocate new triarr structure, set TriA to TriArr original coo

		   ntris++;
		   if (ntris >= MAXTRI) {
			ntris = MAXTRI - 1;
			return;
		   }
		   ntrism1 = ntris-1;

		   TriArr[ntrism1] = (TRISTRU *) malloc(sizeof Tri1);

		   for (l=0; l < 3; l++) {
			TriArr[ntrism1]->p1[l]  = Tri2.p1[l];
			TriArr[ntrism1]->p2[l]  = Tri2.p2[l];
			TriArr[ntrism1]->p3[l]  = Tri2.p3[l];
			TriArr[ntrism1]->grp[l] = Tri2.grp[l];
			TriArr[ntrism1]->lig[l] = Tri2.lig[l];
		   }

		   Calc_Centroid(TriArr[ntrism1]);

		   Trans_Tri(&Tri1,TriArr[ntrism1]);
		   Trans_Coo(TriArr[ntrism1],TriFin[k]->coo);

		   TriArr[ntrism1]->frag = Tri2.frag;
		   TriArr[ntrism1]->eint = TriArr[j]->eint + TriFin[k]->eint;
		   TriArr[ntrism1]->e12  = TriArr[j]->e12;
		   for (l=0; l < 3; l++) {
			TriArr[ntrism1]->prot[l] = TriArr[j]->prot[l];
		   }

		}

		if (TriArr[j] != NULL) {
		   if (TriArr[j]->coo != NULL) {
			free(TriArr[j]->coo);
			TriArr[j]->coo = NULL;
		   }

		   free(TriArr[j]);
		   TriArr[j] = NULL;
		}
	    }

	   }
	}
   }

   Compress_Tri_L();

}

double OriDist(double *coo1, double *coo2)
{
   int i,j;
   double tt,total;

   tt = 0.0;
   total = 0.0;

   for (i=0; i < 3; i++) {
	tt = coo1[i]*toangs - coo2[i]*toangs;
	tt = tt*tt;
	total = total + tt;
   }

   total = sqrt(total);

   return(total);
}

void DispDist(int at1,int at2)
{
   double Ot1[3],Ot2[3];

   if (ntrif <= 1) return;

   Ot1[0] = TriFin[0]->coo[at1*3];
   Ot1[1] = TriFin[0]->coo[at1*3+1];
   Ot1[2] = TriFin[0]->coo[at1*3+2];

   Ot2[0] = TriFin[0]->coo[at2*3];
   Ot2[1] = TriFin[0]->coo[at2*3+1];
   Ot2[2] = TriFin[0]->coo[at2*3+2];

   fprintf(stderr,"Aft 0 Create_Conformers Dist: %.3f\n",OriDist(Ot1,Ot2));

   Ot1[0] = TriFin[1]->coo[at1*3];
   Ot1[1] = TriFin[1]->coo[at1*3+1];
   Ot1[2] = TriFin[1]->coo[at1*3+2];

   Ot2[0] = TriFin[1]->coo[at2*3];
   Ot2[1] = TriFin[1]->coo[at2*3+1];
   Ot2[2] = TriFin[1]->coo[at2*3+2];

   fprintf(stderr,"Aft 1 Create_Conformers Dist: %.3f\n",OriDist(Ot1,Ot2));
}

void Compress_Ligtyp_List()
{
   int i,j,k,lint;

fprintf(stderr,"Compress_Ligtyp_List: lintconf %d ntrif %d\n",lintconf,ntrif);
   for (i=0; i < lintconf; i++) {
	ligtyp[i]->nconf = 1;
	ligtyp[i]->ConfArr[0] = i;
	for (j=1; j < ntrif; j++) {
	   k = i+j*lintconf;
	   if ((ligtyp[i]->ORI[0] == ligtyp[k]->ORI[0]) &&
		(ligtyp[i]->ORI[1] == ligtyp[k]->ORI[1]) &&
		(ligtyp[i]->ORI[2] == ligtyp[k]->ORI[2]) ) {
fprintf(stderr,"Compress_Ligtyp_List: i %d k %d\n",i,k);

		ligtyp[i]->ConfArr[ligtyp[i]->nconf] = j;
		ligtyp[i]->nconf++;
		free(ligtyp[k]);
		ligtyp[k] = NULL;
	   }
	}
   }

   lint = 0;
   for (i=0; i < lintp; i++) {
	if (ligtyp[i] != NULL) {
	   if (i != 0) {
		ligtyp[lint] = ligtyp[i];
	   }
	   lint++;
	}
   }

   lintp = lint;
   fprintf(stderr,"Compress_ligtyp_list: lintp %d\n\n",lintp);
}

void AssLig(C,coo,iconf)
COOSTRU *C;
double *coo;
int iconf;
{
// AssLig creates interaction points from ligand OR
// ligand conformers, through coo's generated for conformers 

   int i,i1,in,iret,indx,indxm,it,j,k,kn,n,noh,nring,pl,kc1,kc2,jj;
   int jm1,jp1,io1,io2,io3;
   int aro,c2ar,n2ar,n2art,n2d,s2,ivalr,isetconf;
   int iring[6],oring[6],iele[4];

   ivalr = 0; 
   isetconf = 0;

   if (lintp == 0) isetconf = 1;

   for (i=0; i < ndocka; i++) {
	singleb.irng[i] = 0;
	singleb.jrng[i] = 0;
	C->lring[i] = 0;
	C->lwrit[i] = 0;
	C->iaton[i] = 2;
   }

   for (i=0; i < ndocka; i++) {
	i1 = i + 1;
	nring = 0;
#if defined(VMS) || defined(UNDERSC)
	ringd(&i1,iring,&nring,&ZERO,
#else
#ifdef CRAY
	RINGD(&i1,iring,&nring,&ZERO,
#else
	ringd_(&i1,iring,&nring,&ZERO,
#endif
#endif
	C->ianz,C->iaton,C->iconn,C->lwrit,C->lring, &iret);

	if (iret == 1) {
	   if (nring == 6 || nring == 5) singleb.irng[i] = 1;
	}
   }

   for (i=0; i < ndocka; i++) {
	C->lring[i] = 0;
	C->lwrit[i] = 0;
	C->iaton[i] = 2;
   }

   for (i=0; i < ndocka; i++) {

	i1 = i + 1;
	in = C->iconn[i*(MXCON+1)];
	
	for (j=0; j < in; j++) {
	   k = C->iconn[i*(MXCON+1)+j+1]-1;
	   kn = C->iconn[k*(MXCON+1)];
	   if (k >= 0) {
		if (k > i && (kn != 1 && in != 1)) {
		   if (singleb.irsd[i] == 3 || singleb.irsd[k] == 3) {
			pl = 1;
			if (C->ianz[i] == 8 || C->ianz[k] == 8) {
			   if (C->ianz[i] == 8 && C->ianz[k] == 1) pl = 0;
			   if (C->ianz[k] == 8 && kn == 2) {
				kc1 = C->iconn[k*(MXCON+1)+1]-1;
				kc2 = C->iconn[k*(MXCON+1)+2]-1;
				if (C->ianz[kc1] == 1 || C->ianz[kc2] == 1) 
					pl = 0;
			   }
			} if (C->ianz[i] == 7) {
			   pl = IsNPlanarH2(i,k,C);
			} else if (C->ianz[k] == 7) {
			   pl = IsNPlanarH2(k,i,C);
			}
			if (pl && ((!singleb.irng[i] || !singleb.irng[k]) ||
				(singleb.ityp[i]  == -50 || !singleb.irng[k]) )) {
			   singleb.sng[singleb.N][0] = i;
			   singleb.sng[singleb.N][1] = k;
			   singleb.N++;
			}
		   }

		   if ((singleb.ityp[i] == -2 && C->ianz[k] != 7) ||
			(singleb.ityp[k] == -2 && C->ianz[i] != 7)) {
			   singleb.sng[singleb.N][0] = i;
			   singleb.sng[singleb.N][1] = k;
			   singleb.N++;
		   }
		
		   if (singleb.irsd[i] == 4 && singleb.irsd[k] == 4) {
			if (ChkAro(i,k,C)) {
			   singleb.sng[singleb.N][0] = i;
			   singleb.sng[singleb.N][1] = k;
			   singleb.N++;
			}
		   }
		}
	   }
	}

	nring = 0;
	ivalr++;
#if defined(VMS) || defined(UNDERSC)
	ringd(&i1,iring,&nring,&ZERO,
#else
#ifdef CRAY
	RINGD(&i1,iring,&nring,&ZERO,
#else
	ringd_(&i1,iring,&nring,&ZERO,
#endif
#endif
	C->ianz,C->iaton,C->iconn,C->lwrit,C->lring, &iret);

	if (iret == 1) {
	   if (nring == 6 || nring == 5) {
	        singleb.irng[i] = 1;
		RNGmin1(iring,nring);
		ReORNG(C,iring,nring);
		RNGput(iring,nring,ivalr);
                isC3RNG(C,iring,oring,nring);
		n2ar = 0;
		n2art = -1;
		c2ar = 0;
		aro = 0;
		n2d = 0;
		s2  = 0;
		for (j=0; j < nring; j++) {
		   if (C->ityp[iring[j]] == 23) s2++;
		   if (isANY(C->ityp[iring[j]],C2ar,2)) c2ar++;
		   if (isANY(C->ityp[iring[j]],Aany,6)) aro++;
		   if (isANY(C->ityp[iring[j]],N2ar,2)) {
			if (n2art == -1) {
			   n2art = j;
			} else {
			   n2d = j - n2art;
			}
			n2ar++;
		   }
		}
/* address: ARO = C@AR + N2AR + S.2 */

		if (c2ar == 6 || (c2ar == 5 && n2ar == 1) || 
		   (n2ar == 2 && c2ar == 4) || (n2ar == 3 && c2ar == 3)) {
/* phenyl_center */

		   AllInt(C,&lintp,iring[0],iring[3],iring[1],0,
			3,PHENYL_CENTER,PHC1,coo,iconf,0);
		   AllInt(C,&lintp,iring[0],iring[3],iring[1],0,
			3,PHENYL_CENTER,PHC2,coo,iconf,0);
		   for (j=0; j < nring; j++) {
			if (oring[j] == 1) {
			   jm1 = j-1; if (jm1 < 0) jm1 = nring-1;
			   jp1 = j+1; if (jp1 > nring-1) jp1 = 0;
			   AllInt(C,&lintp,iring[j],iring[jm1],iring[jp1],
				0,3,PHENYL_RING,PHR,coo,iconf,0);
			}
			C->lwrit[iring[j]] = 1;
		   }
		}

		if ((n2ar == 1 && c2ar == 4) || (n2ar == 2 && c2ar == 3) ||
		    (c2ar == 4 && s2 == 1) ) {
/* phenyl_center */
		   AllInt(C,&lintp,iring[0],iring[3],iring[1],0,
			3,PHENYL_CENTER,PHC1,coo,iconf,0);
		   AllInt(C,&lintp,iring[0],iring[3],iring[1],0,
			3,PHENYL_CENTER,PHC2,coo,iconf,0);
		   for (j=0; j < nring; j++) {
			if (oring[j] == 1) {
			   jm1 = j-1; if (jm1 < 0) jm1 = nring-1;
			   jp1 = j+1; if (jp1 > nring-1) jp1 = 0;
			   AllInt(C,&lintp,iring[j],iring[jm1],iring[jp1],
				0,3,PHENYL_RING,PHR,coo,iconf,0);
			}
			C->lwrit[iring[j]] = 1;
		   }
		}

		if (nring == 6) {
		   if (c2ar == 1 && aro == 5) {
		   fprintf(stderr,"adding phenyl ring\n");
/* aro_ring6_H */
		   }
		}
	   }
	}

	if (isANY(C->ityp[i],Nany,7) && Has_Con(C,i,1,iele) && 
		C->qat[i] >= 0.3) {

	   AllInt(C,&lintp,iele[0],i,0,0,2,H_DON,ONH,coo,iconf,0);

	} else if (isDON(C->ityp[i]) && Has_Con(C,i,1,iele)) {

	   if (isCOH(i,&io1,&io2,&it)) {
	      double *GenOH = NULL;

	      if (it == 5) {
		noh = 3;
	        OHGenRot(coo,&GenOH,io1,i,io2,noh,120);
	      } else {
		noh = 2;
		OHGenRot(coo,&GenOH,io1,i,io2,noh,180);
	      }
	      for (jj=0; jj < noh; jj++) {
		if (jj == 0) {
		   OHAllInt(C,&lintp,io2,i,io1,coo,&GenOH[0],iconf,i,-i1,jj);
		} else {
		   OHAllInt(C,&lintp,io2,i,io1,coo,&GenOH[0],iconf,i,i1,jj);
		}
	      }
	   } else {
	      AllInt(C,&lintp,iele[0],i,0,0,2,H_DON,NHP,coo,iconf,0);
	   }
	   if (iele[1] != -1) {
		AllInt(C,&lintp,iele[1],i,0,0,2,H_DON,NHP,coo,iconf,0);
	   }

	} else {
/* todo: donors_cooh */
	}

	if (issCOO(i,&io1,&io2)) {

	   AllInt(C,&lintp,io1,i,io2,0,3,H_ACC,COOmin,coo,iconf,0);

	   ligtyp[lintp-1]->q0 = -0.5; 
	   ligtyp[lintp-1]->q1 =  0.0; 
	   ligtyp[lintp-1]->q2 = -0.5; 

	   AllInt(C,&lintp,io2,i,io1,0,3,H_ACC,COOmin,coo,iconf,0);
	} else if (isCO(i,&io1)) {
	   AllInt(C,&lintp,io1,i,0,0,2,H_ACC,CO,coo,iconf,0);
	} else if (isCOmin(i,&io1)) {
	   AllInt(C,&lintp,io1,i,0,0,2,H_ACC,CO,coo,iconf,0);
	}
	if (isSO(i,&io1,&io2)) {
	   if (io1 != -1) AllInt(C,&lintp,io1,i,0,0,2,H_ACC,CO,coo,iconf,0);
	   if (io2 != -1) AllInt(C,&lintp,io2,i,0,0,2,H_ACC,CO,coo,iconf,0);
	}
	if (isNO2(i,&io1,&io2)) {
	   AllInt(C,&lintp,io1,i,io2,0,3,H_ACC,COOmin,coo,iconf,0);
	   AllInt(C,&lintp,io2,i,io1,0,3,H_ACC,COOmin,coo,iconf,0);

	} else if (isNO(i,&io1)) {
	   AllInt(C,&lintp,io1,i,0,0,2,H_ACC,CO,coo,iconf,0);
	}
	if (isPO(i,&io1,&io2,&io3)) {
	   if (io1 != -1) AllInt(C,&lintp,io1,i,0,0,2,H_ACC,CO,coo,iconf,0);
	   if (io2 != -1) AllInt(C,&lintp,io2,i,0,0,2,H_ACC,CO,coo,iconf,0);
	   if (io3 != -1) AllInt(C,&lintp,io3,i,0,0,2,H_ACC,CO,coo,iconf,0);
	}
	if (isC3OH(i,&io1,&io2)) {
	   AllInt(C,&lintp,i,io1,io2,0,3,H_ACC,OSP3,coo,iconf,i);
	}
	if (isC2OH(i,&io1,&io2)) {
	   AllInt(C,&lintp,i,io1,io2,0,3,H_ACC,OSP2,coo,iconf,i);
	}
	if (isCOC(i,&io1,&io2)) {
	   AllInt(C,&lintp,i,io1,io2,0,3,H_ACC,COC,coo,iconf,0);
	}
	if (isRF(i,&io1)) {
	   AllInt(C,&lintp,i,io1,0,0,2,H_ACC,CO,coo,iconf,0);
	}
	if (!isAZIDE(i)) {
	   if (isNaryl(i,&io1,&io2)) {
		AllInt(C,&lintp,i,io1,io2,0,3,H_ACC,NARYL,coo,iconf,0);
	   }
	}
	if (isAMID(i,&io1,&io2)) {
	   AllInt(C,&lintp,i,io2,io1,0,3,H_ACC,AMID1,coo,iconf,0);
	   AllInt(C,&lintp,i,io2,io1,0,3,H_ACC,AMID2,coo,iconf,0);
	}
	if (isNamino(i,&io1,&io2,&io3)) {
	   AllInt(C,&lintp,i,io1,io2,io3,4,H_ACC,NAMINO,coo,iconf,0);
	}
	if (isNT(i,&io1)) AllInt(C,&lintp,i,io1,0,0,2,H_ACC,CO,coo,iconf,0);

	n = isCH3R(i);
	if (n == 1) {
	   AllInt(C,&lintp,i,0,0,0,1,CH3,SPH1,coo,iconf,0);
	   indxm = lintp;
	   AllInt(C,&lintp,i,0,0,0,1,PHE_CH3,CH3_PHE,coo,iconf,0);
	   ligtyp[indxm]->area.radius = 4.0;
	} else if (n == 2) {
	   AllInt(C,&lintp,i,0,0,0,1,CH2,SPH1,coo,iconf,0);
	} else if (n == 3) {
	   AllInt(C,&lintp,i,0,0,0,1,CH,SPH1,coo,iconf,0);
	}
	n = isCarR(i);
	if (n == 1 || n == 2) {
	   AllInt(C,&lintp,i,0,0,0,1,ARO,SPH1,coo,iconf,0);
	}
	if (isS3(i)) AllInt(C,&lintp,i,0,0,0,1,SULFUR,SPH2,coo,iconf,0);
	if (isSNH(i,&io1,&io2)) {
	   AllInt(C,&lintp,i,io1,io2,0,3,H_ACC,COC,coo,iconf,0);
	}
   }

   if (isetconf) lintconf = lintp;
}

#define MXINP 100

#define CONFWIN 2.0

void SortConf()
{
      int nt,i;
      float Emin;

      qsort((TRISTRU *) TriFin, ntrif, sizeof(TRISTRU *), cmpeint);

      Emin = TriFin[0]->eint + CONFWIN;

      nt = -1;

      for (i=0; i < ntrif; i++) {
	if (TriFin[i] != NULL && nt == -1) {
	   if (TriFin[i]->eint > Emin) nt = i;
	}
      }

      if (nt != -1) {
	for (i=nt; i < ntrif; i++) {
	   if (TriFin[i]->coo != NULL) free(TriFin[i]->coo);
	   if (TriFin[i] != NULL) free(TriFin[i]);
	}
        ntrif = nt;
      }

if (debugdck) {
      fprintf(stderr,"After sort conformations:\n\n");
      for (i=0; i < ntrif; i++) {
	   if (TriFin[i] != NULL) {
		fprintf(stderr,"i %d eint %.3f\n",i,TriFin[i]->eint);
	   }
      }

      Write_Results("confchk.mol2",TriFin,ntrif,xyzp,1,0);
}

}

void FindSameTriS(int ind)
{
   int i,lig[3],act;
   float d12,d13,d23;

   for (i=0; i < 3; i++) {
      lig[i] = TriS[ind].lig[i];
   }

   d12 = TriS[ind].d12;
   d13 = TriS[ind].d13;
   d23 = TriS[ind].d23;

   TriS[ind].nconf = 1;
   TriS[ind].ConfArr[0] = TriS[ind].conf;

   for (i=0; i < ntriS; i++) {
	if (TriS[i].active && i != ind) {
	   if (TriS[i].lig[0] == lig[0] && TriS[i].lig[1] == lig[1] &&
		TriS[i].lig[2] == lig[2] ) {
	        if (TriS[i].d12 == d12 && TriS[i].d13 == d13 &&
		    TriS[i].d23 == d23 ) {
		   TriS[ind].ConfArr[TriS[ind].nconf] = TriS[i].conf;
		   TriS[ind].nconf++;
		   TriS[i].active = 0;
		}
	   }
	}
   }
}

int Find_Lig_Conf(int k,int itri)
{
     int i,iset1,iset2;

     iset1 = 0;

     for (i=0; i < ligtyp[TriArr[itri]->lig[1]]->nconf; i++) {
	if (k == ligtyp[TriArr[itri]->lig[1]]->ConfArr[i]) {
	   iset1 = 1;
	}
     }

     iset2 = 0;

     for (i=0; i < ligtyp[TriArr[itri]->lig[2]]->nconf; i++) {
	if (k == ligtyp[TriArr[itri]->lig[2]]->ConfArr[i]) {
	   iset2 = 1;
	}
     }

     if (iset1 && iset2) return(1);
     return(0);
}

void TrimTriS(int np)
{
   int i,j,n,act,ntriso;

   for (i=0; i < ntriS; i++) {
	for (j=0; j < np; j++) {
	   if (!(ADPAIR1[j] == TriS[i].frags[0] || 
		 ADPAIR2[j] == TriS[i].frags[0]))
			TriS[i].active = 0;
	   if (!(ADPAIR1[j] == TriS[i].frags[1] || 
		 ADPAIR2[j] == TriS[i].frags[1]))
			TriS[i].active = 0;
	   if (!(ADPAIR1[j] == TriS[i].frags[2] || 
		 ADPAIR2[j] == TriS[i].frags[2]))
			TriS[i].active = 0;
	}
   }

   for (i=0; i < ntriS; i++) {
	act = TriS[i].active;
	if (act) FindSameTriS(i);
   }

   
   n = 0;
   for (i=0; i < ntriS; i++) {
	if (TriS[i].active) {
	   TriS[n] = TriS[i];
	   n++;
	}
   }
   ntriS = n;
}


void ProcLig(imode)
int imode;
{
   int i,i1,in,j,k,kn,l,m,indx,nring,iret,aro,c2ar,n2ar,n2art,n2d,iattmp,ipdbtmp;
   int jm1,jp1,io1,io2,io3,ierr,n,ninp[4],itel,maxsol,ic,pl,Ifrag,NoFrag;
   int *inpp[4],Score_Org_Ligand,indxm,irng,irs,iflg,iatomsd,mxnatd,ihaszmd;
   int nacc,ndon,nphec,npher,naro;
   int ncacc,ncdon,ncphec,ncpher,ncaro;
   int iacc[MAXLIGSTRU],idon[MAXLIGSTRU],iphec[MAXLIGSTRU],ipher[MAXLIGSTRU];
   int iaro[MAXLIGSTRU];
   int cacc[MAXLIGSTRU],cdon[MAXLIGSTRU],cphec[MAXLIGSTRU],cpher[MAXLIGSTRU];
   int caro[MAXLIGSTRU];
   int iring[6],oring[6],iele[4],ngrp,npair,npair_nolink;
   int *ianztmp,nt,tl0,tl1,tl2,l0,l1,l2;
   short int *ityptmp;
   time_t curtime;
   COOSTRU *pp;

   DCKLIGPROC = 1;
   Ifrag = -1;
   indx = 0;
   NoFrag = 0;
   MapConformers = 1;

   pp = xyzp;

   if (imode == 1) {
      iatomsd = *(xyzp->iatoms);
      mxnatd  = *(xyzp->mxnat);
      ihaszmd = *(zmptrp->ihaszm);
      xyzp = &DCKxyz;
      setiat(ndocka);
   } else {
      ndocka = *xyzp->iatoms;
   }

   for (i=0; i < ndocka; i++) {
	xyzp->lring[i] = 0;
	xyzp->lwrit[i] = 0;
	xyzp->iaton[i] = 2;
   }

   for (i=0; i < ndocka; i++) {

	i1 = i + 1;
	
	xyzp->iaton[i] = 2;
#if defined(VMS) || defined(UNDERSC)
	ispnd(&irs,&i1,&irng,&ONE,&ZERO,
#else
#ifdef CRAY
	ISPND(&irs,&i1,&irng,&ONE,&ZERO,
#else
	ispnd_(&irs,&i1,&irng,&ONE,&ZERO,
#endif
#endif
	   xyzp->qat,xyzp->ianz,xyzp->iaton,xyzp->iconn,xyzp->lwrit,xyzp->lring);
	singleb.irsd[i] = IHBT[irs-1];

   }

   singleb.N = 0;

   lintp = 0;

   AssLig(xyzp,xyzp->coo,-1);
   ExtraFrag(xyzp);

   Fragmentise(xyzp);

   for (j=0; j < lintp; j++) FrgInt(j);

   if (imode == 1) {
      xyzp = pp;
      setiat(iatomsd);
      *(xyzp->mxnat)  = mxnatd;
      *(zmptrp->ihaszm) = ihaszmd;
   }

   prtypes(ligtyp,lintp,iacc,&nacc,idon,&ndon,iphec,&nphec,ipher,&npher,iaro,&naro);

   if (imode == 0) {
      ndocka = *xyzp->iatoms;
      Create_Conformers(0,xyzp);
      if (ntrif == -1) CopyLig(xyzp);
if (debugdck) Write_Results("conformers.mol2",TriFin,ntrif,xyzp,1,0);
      Loop_Opt_Dih(0,xyzp,1);
      return;
   }

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   ninp[0] = nacc; ninp[1] = ndon; ninp[2] = nphec; ninp[3] = npher; 
   inpp[0] = iacc; inpp[1] = idon; inpp[2] = iphec; inpp[3] = ipher;

if (debugdck) fprintf(stderr,"ndon %d nphec %d npher %d nacc %d\n",ndon,nphec,npher,nacc);
   ntriS = 0;

   ngrp = 2;

   if (Monitor_AccDon(nacc,ndon,iacc,idon,&npair,&npair_nolink)) {
	ngrp = 3;
if (debugdck) fprintf(stderr,"After Monitor_AccDon: ngrp %d\n",ngrp);
   } else {
	npher = 0;
	ninp[3] = 0;
   }

if (debugdck) fprintf(stderr,"npair %d npairl %d\n",npair,npair_nolink);


   for (i=0; i < MAXTRI; i++) {
	TriArr[i] = NULL;
	TriArrCopy[i] = NULL;
   }

   if (npair_nolink == 0) {
	Ifrag = 0;
	MapConformers = 0;
   } else {

	fprintf(stderr,"Start Setup_Distance_Tables\n");
 
if (debugdck) {
  time(&curtime);
  fprintf(stderr,"Begin Time: %s\n",ctime(&curtime));
}
	Setup_Distance_Tables();

if (debugdck) {
  time(&curtime);
  fprintf(stderr,"End Time: %s\n",ctime(&curtime));
}

	for (i=0; i < ngrp; i++) {
	   for (j=0; j < ngrp; j++) {
		for (k=0; k < ngrp; k++) {
		   Harvest_Triples(ninp[i],ninp[j],ninp[k],
			inpp[i],inpp[j],inpp[k]);
		}
	   }
	}

	Tris_NoLink();
	if (npair && ntriS > 150) Sub_Selection_Tris();

if (debugdck) fprintf(stderr,"Harvest_Triples: ntriS %d\n\n",ntriS);

	Gen_triples();

if (debugdck) {
fprintf(stderr,"aft gen_triples:\n");
for (i=0; i < ntris; i++) {
   if (TriArr[i] != NULL) PrtTrp(i);
}
}
	fprintf(stderr,"Gen_Triples: matched protein triples ntris %d\n\n",ntris);

	Ifrag = CalcSchInt();
   }


   if (imode == 1) {
      iatomsd = *(xyzp->iatoms);
      mxnatd  = *(xyzp->mxnat);
      ihaszmd = *(zmptrp->ihaszm);
      xyzp = &DCKxyz;
      setiat(ndocka);

      Create_Conformers(Ifrag,xyzp);
      if (ntrif == -1) CopyLig(xyzp);

if (debugdck) Write_Results("conformers.mol2",TriFin,ntrif,xyzp,1,0);

      if (!MapConformers) SortConf();

   }

   if (ntriS == 0 || npair_nolink == 0) {

	ReleaseLig();
	lintp = 0;

// These two lines are here to test ONE conformer, that has smallest RMSD
// with the crystal conformer


	for (i=0; i < ntrif; i++) {
	   AssLig(&DCKxyz,TriFin[i]->coo,i);
	}

	for (j=0; j < lintp; j++) FrgInt(j);

	Compress_Ligtyp_List();

	prtypes(ligtyp,lintp,iacc,&nacc,idon,&ndon,iphec,&nphec,
		ipher,&npher,iaro,&naro);

// we need a routine that takes an array such as iacc and a conformer number
// and create a specific subselection array

	ninp[0] = nacc; ninp[1] = ndon; ninp[2] = nphec; ninp[3] = npher;
	inpp[0] = iacc; inpp[1] = idon; inpp[2] = iphec; inpp[3] = ipher;

	ntriS = 0;

// This call is put in here to increase DCKCOFF to 15.0 if no ACC/DON pair
// is found with DCKCOFF 10.0
// as a side effect it also sets npair and npair_nolink

//	if (Monitor_AccDon_Conformers(ncacc,ncdon,cacc,cdon,&npair,
//		&npair_nolink)) {
	if (Monitor_AccDon_Conformers(nacc,ndon,iacc,idon,&npair,
		&npair_nolink)) {
	   ngrp = 3;
	   ngrp = 2;
if (debugdck) fprintf(stderr,"After Monitor_AccDon_Conformers: ngrp %d\n",ngrp);
	} else {
	   npher = 0;
	   ninp[3] = 0;
	}

	fprintf(stderr,"2nd: Start Setup_Distance_Tables\n");

if (debugdck) {
   time(&curtime);
   fprintf(stderr,"Begin Time: %s nintp %d\n",ctime(&curtime),nintp);
}

	Setup_Distance_Tables();

if (debugdck) {
   time(&curtime);
   fprintf(stderr,"End Time: %s npairl %d\n",ctime(&curtime),npair_nolink);
}

	if (npair_nolink == 0) {

	   Harvest_Triples_NoFrag(ndon,nphec,naro,idon,iphec,iaro);
	   Harvest_Triples_NoFrag(ndon,npher,naro,idon,ipher,iaro);
	   Harvest_Triples_NoFrag(nacc,nphec,naro,iacc,iphec,iaro);
	   Harvest_Triples_NoFrag(nacc,npher,naro,iacc,ipher,iaro);

	} else {

	   Harvest_Triples_NoFrag(ndon,ndon,nphec,idon,idon,iphec);
	   Harvest_Triples_NoFrag(ndon,ndon,npher,idon,idon,ipher);
	   Harvest_Triples_NoFrag(ndon,nacc,nphec,idon,iacc,iphec);
	   Harvest_Triples_NoFrag(ndon,nacc,npher,idon,iacc,ipher);
	   Harvest_Triples_NoFrag(nacc,nacc,nphec,iacc,iacc,iphec);
	   Harvest_Triples_NoFrag(nacc,nacc,npher,iacc,iacc,ipher);

fprintf(stderr,"Aft Harvest_Triples_NoFrag: ntriS %d\n",ntriS);
//	   TrimTriS(npair_nolink);
	   Tris_NoLink();
	}

	fprintf(stderr,"Harvest_Triples: ntriS %d\n",ntriS);

	Gen_triples();

	if (imode == 1) {
	   xyzp = pp;
	   setiat(iatomsd);
	   *(xyzp->mxnat)  = mxnatd;
	   *(zmptrp->ihaszm) = ihaszmd;
	}
	fprintf(stderr,"Gen_Triples: matched protein triples ntris %d\n",ntris);

	CalcSchInt();

   }

   if (imode == 1) {
      xyzp = pp;
      setiat(iatomsd);
      *(xyzp->mxnat)  = mxnatd;
      *(zmptrp->ihaszm) = ihaszmd;
   }


if (debugdck) fprintf(stderr,"bef CalcAllInt: ntris %d\n",ntris);

   CalcAllInt(0,0);

if (debugdck) fprintf(stderr,"aft CalcAllInt: ntris %d\n",ntris);

if (debugdck) {
   fprintf(stderr,"bef Write_Results befrem.mol2 ntris %d\n",ntris);
//   Write_Results("befrem.mol2",TriArr,ntris,&DCKxyz,0,0);
}

   RemCC_All(0);

if (debugdck) {

   fprintf(stderr,"Bef aftrem.mol2 ntris %d\n",ntris);

   Write_Results("aftrem.mol2",TriArr,ntris,&DCKxyz,0,1);

   fprintf(stderr,"after RemCC_All:  ntris %d\n",ntris);
}

   Compress_Tri_L();

if (debugdck) fprintf(stderr,"Bef Linkage_List ntris %d\n",ntris);

// If we leave this in we dont get the any solutions with negative energy
// passing this point. So the good ones are taken out !!!!!
// Perhaps we should consider doing the linkage with e12 !!!
   if (ntris > 10 && ntris < 1000) Linkage_List();

   Compress_Tri_L();

if (debugdck) fprintf(stderr,"after Compress_Tri_L:  ntris %d\n",ntris);


   Compress_Tri_List_e12();

if (debugdck) Write_Results("dockbef.mol2",TriArr,ntris,&DCKxyz,0,1);

   OptTris();

   if (MapConformers) Map_Conformers();

if (debugdck) fprintf(stderr,"after #MapConformers %d ntris %d\n",MapConformers,ntris);

   if (ntris > 0) {
	if (MapConformers) {
	   qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmptriF);
	} else {
	   qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmpeint);
	}
   }

if (debugdck) {
   if (MapConformers) {
	if (1) Write_Results("mconformers.mol2",TriArr,ntris,&DCKxyz,1,1);

        fprintf(stderr,"after Map_Conformers:  ntris %d\n",ntris);
   }
}

   Loop_Opt_Dih(Ifrag,&DCKxyz,0);

if (debugdck) {

   fprintf(stderr,"bef dockdih write:\n");

   for (i=0; i < ntris; i++) {
	if (TriArr[i] != NULL) PrtTrp(i);
   }

   Write_Results("dockdih.mol2",TriArr,ntris,&DCKxyz,1,1);
}

// CalcAllInt calculates e12 = interaction energy between protein and
// ligand. perhaps at this point it should be calculating Etot:
// Etot: Etot = e12 + eint
// after this do an other sort this time on Etot

   CalcAllInt(debugdck,1);

   if (ntris > 0) {
	qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmpeint);
   }

   Score_Org_Ligand = 0;
   if (Score_Org_Ligand) OrgLig();

//   wrt_TriArr();

   RemCC_All(1);
   Linkage_List();
   Compress_Tri_L();

   Conformers_Energies(&DCKxyz);

   if (ntris > 0) {
	if (MapConformers) {
	   qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmptriF);
	} else {
	   qsort((TRISTRU *) TriArr, ntris, sizeof(TRISTRU *), cmpeint);
	}
   }

if (debugdck) fprintf(stderr,"ntris %d dckout %s\n",ntris,dckout);

   Write_Results(dckout,TriArr,ntris,&DCKxyz,1,1);

#if defined(VMS) || defined(UNDERSC)
   curs(&ZERO);
#else
#ifdef CRAY
   CURS(&ZERO);
#else
   curs_(&ZERO);
#endif
#endif

}


int WrtSDFs(char *sdfnam, FILEOP *fileop)
{
   int i,ii,j,k,i1,iasel,it,idum,n,icel,istat,ierr;
   int iatomsd,mxnatd,ihaszmd,size,fftmp,ipdbd;
   double rdum;
   char *ss,*strtmp;
   double *ppcoo,qtmp[MXLIGA];
   int *ppanz,*ppatclr;
   COOSTRU *pp,*ppp;
   double *pppcoo,*pppqat;
   int *pppianz, *pppiatclr,*pppires,*pppiconn;
   short int *pppityp,*pppipdbt;

   iasel = 0;
   icel = 0;
   size = MXLIGA;

   if (MOLxyz.coo == NULL) alldck(&MOLxyz,&size);

   iatomsd = *(xyzp->iatoms);
   mxnatd = *(xyzp->mxnat);
   ihaszmd = *(zmptrp->ihaszm);
   ipdbd = *ipdbon;
   *ipdbon = 0;

/* get ambfor xyz file (gaff atom types */

   fftmp = *fftyp;

   pppcoo = xyzp->coo;
   pppianz = xyzp->ianz;
   pppiatclr = xyzp->iatclr;
   pppqat = xyzp->qat;
   pppires = xyzp->iresid;
   pppiconn = xyzp->iconn;
   pppityp = xyzp->ityp;
   pppipdbt = xyzp->ipdbt;
   ppp = xyzp;

   xyzp->coo = MOLxyz.coo;
   xyzp->ianz = MOLxyz.ianz;
   xyzp->iatclr = MOLxyz.iatclr;
   xyzp->qat = MOLxyz.qat;
   xyzp->iresid = MOLxyz.iresid;
   xyzp->ityp = MOLxyz.ityp;
   xyzp->ipdbt = MOLxyz.ipdbt;
   *xyzp->mxnat = mxliga;

   cpstr(sdfnam,tmpfil,SUBLEN1);
   ierr = 0;

#if defined(VMS) || defined(UNDERSC)
   filop(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
#ifdef CRAY
   FILOP(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
   filop_(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#endif
#endif

   if (ierr) {
      fprintf(stderr,"WARNING: was not able to write mol from ligand");
   }

   for (ii=0; ii < fileop->nfiles; ii++) {

	mfdata->imol = ii + 1;
	fileop->currl = GetLineIndx(ii,fileop);

#if defined(VMS) || defined(UNDERSC)
	rdmod(&ZERO,&ZERO,&ZERO,&istat,
#else
#ifdef CRAY
	RDMOD(&ZERO,&ZERO,&ZERO,&istat,
#else
	rdmod_(&ZERO,&ZERO,&ZERO,&istat,
#endif
#endif
	   MOLxyz.coo,MOLxyz.qat,MOLxyz.ianz,MOLxyz.iatclr,MOLxyz.iresid,
	   MOLxyz.iconn,MOLxyz.ityp,MOLxyz.ipdbt,
	   calfptr->icalf,&calfptr->ncalf,&calfptr->ianf,&calfptr->islu,
   	   &calfptr->nchain,&calfptr->iamino,&calfptr->reson,
	   &calfptr->isal,&calfptr->ishoh,&calfptr->ihashb,
	   &cell->natc,&cell->norg,&cell->icent,&cell->ncon,&cell->nspg,
	   &cell->kz,&cell->ichx,&cell->nopr,cell->ir,cell->it,
	   &cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2],
	   &cell->xyzc[3],&cell->xyzc[4],&cell->xyzc[5],
	   &cell->cellc[0],&cell->cellc[1],&cell->cellc[2],
	   &cell->cellc[3],&cell->cellc[4],&cell->cellc[5]);

	if (istat <= 0) {
	   sprintf(cmdstr,"File %s is NOT mol2 format\n",sdfnam);
	   if (DoCan(event.xbutton.x_root, event.xbutton.y_root,cmdstr,0)) {}
	   return(0);
	}


/* restore original fftyp, iatoms pointers */

	*fftyp = fftmp;
	MOLxyz.iatoms = &nmolat;
	*MOLxyz.iatoms = *(xyzp->iatoms);

/* retype to sybyl atom types */

	pp = xyzp;
	xyzp = &MOLxyz;

/* now MOLxyz.ityp is sybyl atom types */

	iasel = MOLxyz.iresid[0];

#if defined(VMS) || defined(UNDERSC)
	outmod(&SEVENTYSEVEN,
#else
#ifdef CRAY
	OUTMOD(&SEVENTYSEVEN,
#else
	outmod_(&SEVENTYSEVEN,
#endif
#endif
	MOLxyz.coo,MOLxyz.ianz,MOLxyz.iconn);

#if defined(VMS) || defined(UNDERSC)
	sdfsep(&SEVENTYSEVEN);
#else
#ifdef CRAY
	SDFSEP(&SEVENTYSEVEN);
#else
	sdfsep_(&SEVENTYSEVEN);
#endif
#endif
   }
	
   xyzp = ppp;
   xyzp->coo = pppcoo;
   xyzp->ianz = pppianz;
   xyzp->iatclr = pppiatclr;
   xyzp->qat = pppqat;
   xyzp->iresid = pppires;
   xyzp->iconn = pppiconn;
   xyzp->ityp = pppityp;
   xyzp->ipdbt = pppipdbt;

   *(xyzp->iatoms) = iatomsd;
   *(xyzp->mxnat)  = mxnatd;
   *(zmptrp->ihaszm) = ihaszmd;
   *ipdbon = ipdbd;
   *fftyp = fftmp;

   mfdata->imol = 1;
   fileop->currl = 0;

#if defined(VMS) || defined(UNDERSC)
   filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
   FILCLO(&SEVENTYSEVEN);
#else
   filclo_(&SEVENTYSEVEN);
#endif
#endif

   return(1);
}

int nline(char *str)
{
   int i,i1,i2,n;

   if (COO[istruct]->memfil.str != NULL) {

	i1 = COO[istruct]->memfil.line_index[COO[istruct]->memfil.currl];
	COO[istruct]->memfil.currl++;

	if (COO[istruct]->memfil.currl < COO[istruct]->memfil.nlines) {
	   i2 = COO[istruct]->memfil.line_index[COO[istruct]->memfil.currl];
	   n = i2 - i1 - 1;
	} else {
	   if (COO[istruct]->memfil.currl == COO[istruct]->memfil.nlines) {
		n = COO[istruct]->memfil.size - i1 - 1;
	   } else {
	   }
	}

	if (n > MXSTRFOR) n = MXSTRFOR;
	if (n < 0) n = 0;

	strncpy(str,&COO[istruct]->memfil.str[i1],(size_t) n);
	str[n] = '\n';
	for (i=n; i<137; i++) str[i] = ' ';
   }
}

int ChkAddHs(FILEOP *fileop)
{
  int in,n,endmol,nh;
  char linstr[MAXFILELEN];
  char str[MAXFILELEN];
  FILE *f;

  if (getob()) {

	nh = 0;
	mfdata->imol = 1;
	fileop->currl = GetLineIndx(0,fileop);

	endmol = GetLineIndx(1,fileop);
	if (endmol == -1) endmol = fileop->nlines + 1;

	n = endmol - fileop->currl;

	for (in=0; in < n; in++) {
		nline(linstr);
		if (strstr(linstr," H ") != NULL) {
		   nh++;
		   break;
		}
		
	}

	if (nh > 0) return(1);
  }

  return(0);
}

int CheckTimed()
{
  int fd,size,itel,itelm;
  struct stat buf;
  FILE *f;

  itel = 0; itelm = 0;

  while (1) {

	f = fopen("/tmp/yo","r");

	itelm++;

	if (f != NULL) {
	   fd = fileno(f);
	   fstat(fd, &buf);
	   size = buf.st_size;
	   fclose(f);
	   if (size > 0) {
	   	unlink("/tmp/yo");
		return(1);
	   }
	}

	if (itelm > 100) {
	   sleep(1); itel++;

	   if (itel > 10) return(0);
	}
  }

}

int AddHs(FILEOP *fileop,int isdfopt)
{
  int i,ii,in,n,fd,istat,endmol,size,pid,status;
  struct stat buf;
  char linstr[MAXFILELEN];
  char str[MAXFILELEN];
  char strh[MAXFILELEN];
  char *string;
  FILE *f,*ff,*fdest;
  size_t nl;

  if (getob()) {


   switch (isdfopt) {
   case 0:
   case 1:
	if (ChkAddHs(&COO[istruct]->memfil)) {
	   strcpy(cmdstr, "No need to add hydrogens");
	   if (DoCan(event.xbutton.x_root,event.xbutton.y_root,cmdstr, 0)) {}
	   return(0);
	}
	break;
   case 2:
	break;
   case 3:
	break;
   default:
	break;
   }

#if defined(VMS) || defined(UNDERSC)
   curs(&ONE);
#else
#ifdef CRAY
   CURS(&ONE);
#else
   curs_(&ONE);
#endif
#endif

   getstemp(stemp);

   switch (isdfopt) {
   case 0:
	strcat(stemp,"+polH.sdf");
	break;
   case 1:
	strcat(stemp,"+H.sdf");
	break;
   case 2:
	strcat(stemp,"+conv.sdf");
	break;
   case 3:
	strcat(stemp,"+3D.sdf");
	break;
   default:
	break;
   }

   fdest = fopen(stemp,"w");
   fclose(fdest);

   for (ii=0; ii < fileop->nfiles; ii++) {

	mfdata->imol = ii + 1;
	fileop->currl = GetLineIndx(ii,fileop);

	endmol = GetLineIndx(ii+1,fileop);
	if (endmol == -1) endmol = fileop->nlines + 1;

	n = endmol - fileop->currl;

	sprintf(str,"/tmp/%07d.mol",ii);
	sprintf(strh,"/tmp/%07d+h.mol",ii);

	f = fopen(str,"w");

	if (f != NULL) {
	   for (in=0; in < n; in++) {
		nline(linstr);
		fputs(linstr,f);
		fputs("\n",f);
	   }

	   fclose(f);
	}

	if (access("/tmp/yo",F_OK) == 0) unlink("/tmp/yo");

	switch (OBloc) {
	case 1:
	   sprintf(cmdstr,
		"%sobabel %s -i mol %s -O %s > /dev/null 2> /tmp/yo &", 
		exepath[0],sdfcopt[isdfopt],str,strh);
	   break;

	case 2:
	   sprintf(cmdstr,
		"/usr/bin/obabel %s -i mol %s -O %s > /dev/null 2> /tmp/yo &",
		sdfcopt[isdfopt],str,strh);
	   break;
	case 0:
	   sprintf(cmdstr,
	   "/usr/local/bin/obabel %s -i mol %s -O %s > /dev/null 2> /tmp/yo &",
		sdfcopt[isdfopt],str,strh);
	   break;
	default:
	   break;
	}

	excmd(cmdstr,&pid);

	if (CheckTimed()) {

		if (access(str,F_OK) == 0) unlink(str);
		ff = fopen(strh,"r");

		if (ff != NULL) {
		   fd = fileno(f);
		   fstat(fd, &buf);
		   size = buf.st_size;
		   string = malloc(sizeof(char)*size+1);
		   nl = fread(string, sizeof(char), size, ff);
		   string[nl] = '\0';
		   fclose(ff);
		   if (access(strh,F_OK) == 0) unlink(strh);

		   if (nl != 0) {
			fdest = fopen(stemp,"a");

			fputs(string,fdest);
			fputs("$$$$\n",fdest);
			fflush(fdest);
			free(string);
			fclose(fdest);
		   } else {
			free(string);
		   }

		} else {
		   fprintf(stderr,"error opening file %s\n",strh);
		   killob();
		}

	} else {
		killob();
		if (access(str,F_OK) == 0) unlink(str);
		if (access(strh,F_OK) == 0) unlink(strh);
		fprintf(stderr,"Error adding hydrogens: %s\n",strh);
	}



   }

#if defined(VMS) || defined(UNDERSC)
   curs(&ZERO);
#else
#ifdef CRAY
   CURS(&ZERO);
#else
   curs_(&ZERO);
#endif
#endif

   sprintf(molwstr, "Wrote file %s",stemp);
   StatusStr(0,1);

  }

  return(1);
}

int WrtMol2s(char *mol2nam, FILEOP *fileop)
{
   int i,ii,j,k,i1,iasel,it,idum,igtmo,iadd,irng,irs,n,icel,istat,ierr;
   int iatomsd,mxnatd,ihaszmd,size,fftmp,ipdbd;
   double rdum;
   char *ss,*strtmp;
   double *ppcoo,qtmp[MXLIGA];
   int *ppanz,*ppatclr;
   COOSTRU *pp,*ppp;
   double *pppcoo;
   int *pppianz, *pppiatclr;

   iadd = 0;
   iasel = 0;
   icel = 0;
   size = MXLIGA;

   if (MOLxyz.coo == NULL) alldck(&MOLxyz,&size);

   iatomsd = *(xyzp->iatoms);
   mxnatd = *(xyzp->mxnat);
   ihaszmd = *(zmptrp->ihaszm);
   ipdbd = *ipdbon;
   *ipdbon = 0;

/* get ambfor xyz file (gaff atom types */

   fftmp = *fftyp;

   pppcoo = xyzp->coo;
   pppianz = xyzp->ianz;
   pppiatclr = xyzp->iatclr;
   ppp = xyzp;

   xyzp->coo = MOLxyz.coo;
   xyzp->ianz = MOLxyz.ianz;
   xyzp->iatclr = MOLxyz.iatclr;
   *xyzp->mxnat = mxliga;

   cpstr(mol2nam,tmpfil,SUBLEN1);
   ierr = 0;

#if defined(VMS) || defined(UNDERSC)
   filop(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
#ifdef CRAY
   FILOP(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#else
   filop_(&SEVENTYSEVEN,&ONE,&ZERO,&ZERO,&ierr);
#endif
#endif

   if (ierr) {
      fprintf(stderr,"WARNING: was not able to write mol from ligand");
   }

   for (ii=0; ii < fileop->nfiles; ii++) {

	mfdata->imol = ii + 1;
	fileop->currl = GetLineIndx(ii,fileop);
#if defined(VMS) || defined(UNDERSC)
	getmod(&igtmo,&ZERO,
#else
#ifdef CRAY
	GETMOD(&igtmo,&ZERO,
#else
	getmod_(&igtmo,&ZERO,
#endif
#endif
	   MOLxyz.coo,MOLxyz.qat,MOLxyz.ianz,MOLxyz.iaton,MOLxyz.iconn,
	   MOLxyz.iresid);

	if (!igtmo) {
	   sprintf(cmdstr,"File %s is NOT mol format\n",mol2nam);
	   if (DoCan(event.xbutton.x_root, event.xbutton.y_root,cmdstr,0)) {}
	   return(0);
	}


/* restore original fftyp, iatoms pointers */

	*fftyp = fftmp;
	MOLxyz.iatoms = &nmolat;
	*MOLxyz.iatoms = *(xyzp->iatoms);

/* retype to sybyl atom types */

	pp = xyzp;
	xyzp = &MOLxyz;

	for (i=0; i < nmolat; i++) {

	   i1 = i + 1;
	   MOLxyz.iaton[i] = 2;
#if defined(VMS) || defined(UNDERSC)
	   ispnd(&irs,&i1,&irng,&ONE,&ONE,
#else
#ifdef CRAY
	   ISPND(&irs,&i1,&irng,&ONE,&ONE,
#else
	   ispnd_(&irs,&i1,&irng,&ONE,&ONE,
#endif
#endif
	   MOLxyz.qat,MOLxyz.ianz,MOLxyz.iaton,MOLxyz.iconn,MOLxyz.lwrit,MOLxyz.lring);

	   strcpy(strname,elemts[MOLxyz.ianz[i]-1]);
	   strcat(strname,ATYPE[irs-1]);

	   ss = strname; 
	   if (strname[0] == ' ') ss++;

	   for (j=0; j < MXMOL2; j++) {
		if (strncmp(ss,mol2[j],5) == 0) MOLxyz.ityp[i] = j+1;
	   }
	}

/* now MOLxyz.ityp is sybyl atom types */

	iasel = MOLxyz.iresid[0];

#if defined(VMS) || defined(UNDERSC)
	calgad(&iasel,&ZERO,&istat,
#else
#ifdef CRAY
	CALGAD(&iasel,&ZERO,&istat,
#else
	calgad_(&iasel,&ZERO,&istat,
#endif
#endif
	MOLxyz.qat,MOLxyz.ianz,MOLxyz.iconn,MOLxyz.iresid,MOLxyz.ityp);


#if defined(VMS) || defined(UNDERSC)
	wrmod(&SEVENTYSEVEN,
#else
#ifdef CRAY
	WRMOD(&SEVENTYSEVEN,
#else
	wrmod_(&SEVENTYSEVEN,
#endif
#endif
	MOLxyz.coo,MOLxyz.qat,MOLxyz.ianz,MOLxyz.iaton,MOLxyz.iatclr,
	MOLxyz.iconn,
	MOLxyz.iresid,MOLxyz.lring,MOLxyz.inat,MOLxyz.ityp,MOLxyz.ipdbt,
	&idum,&ZERO,&idum,&idum,
	&idum,&idum,&idum, &rdum,&rdum,&rdum, &rdum,&rdum,&rdum);

   }
	
   xyzp = ppp;
   xyzp->coo = pppcoo;
   xyzp->ianz = pppianz;
   xyzp->iatclr = pppiatclr;

   *(xyzp->iatoms) = iatomsd;
   *(xyzp->mxnat)  = mxnatd;
   *(zmptrp->ihaszm) = ihaszmd;
   *ipdbon = ipdbd;
   *fftyp = fftmp;

   mfdata->imol = 1;
   fileop->currl = 0;

#if defined(VMS) || defined(UNDERSC)
   filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
   FILCLO(&SEVENTYSEVEN);
#else
   filclo_(&SEVENTYSEVEN);
#endif
#endif

   return(1);
}

static char molstruc[MAXPATHLEN] = "dock.xyz";
static float mol_q[MXLIGA],mol_vdwr[MXLIGA],mol_vdwe[MXLIGA];

void calc_grid_points(int mode, int npts[3], float step[3], 
	float origin[3], float *field)
{


   int i,j,k,ii,jj,index,idiel,node[3],shft[3],tel,smooth;
   float energy,r12,tt,eps,rv2,rv,rs2,rs3,rsum,epsm,p6,p12;
   float point[3],econv;

   idiel = 1;
   smooth = 0;

// or smooth = -1

   if (idiel) {
	eps = 1.0;
   } else {
	eps = 80.0;
   }

   econv = 332.05382;

   for (node[2] = 0; node[2] < npts[2]; (node[2])++) {
      for (node[1] = 0; node[1] < npts[1]; (node[1])++) {
         for (node[0] = 0; node[0] < npts[0]; (node[0])++) {

	  energy = 0.0;
	  tel = 0;

          for (j = smooth; j <= 0; ++j) {
            for (shft[2] = j; shft[2] <= 1; shft[2] += 2) {
              for (shft[1] = j; shft[1] <= 1; shft[1] += 2) {
                for (shft[0] = j; shft[0] <= 1; shft[0] += 2) {

		  for (i = 0; i < 3; i++) {
			point[i] = (node[i] + (float) shft[i] / 3.0)*step[i] 
			+ origin[i];
		  }

	 	  for (ii = 0; ii < nmolat; ii++) {
		     rv2 = 0.0;
		     for (jj = 0; jj < 3; jj++) {
/*
			tt = (((float) MOLxyz.coo[ii*3+jj]) - point[jj]);
			tt = tt*toangs;
*/
			tt = (((float) MOLxyz.coo[ii*3+jj])*toangs - point[jj]);
			rv2 += tt*tt;
		     }
		     rv  = sqrtf(rv2);

		     if (mode == 0) {
			rsum = mol_vdwr[ii] + 1.9080;
			epsm = sqrtf(mol_vdwe[ii]*0.1094);
			rs2 = rsum*rsum;
			rs3 = rs2*rsum;
			p6   = (rs3*rs3) / (rv2*rv2*rv2);
			p12  = p6 * p6;
			energy += epsm * (p12 - 2.0*p6);
		     } else {
			energy += (econv * mol_q[ii]) / (eps * rv);
		     }

	 	  }

		  tel++;
		}
	      }
	    }
	  }

	  energy /= (float) tel;
          index = node[2]*npts[0]*npts[1] + node[1]*npts[0] + node[0];
	  field[index] = energy;
         }
      }
   }

}

void AssVDWL_mol(float *vdwr, float *vdwe,float *q,short int *ityp, double *qat)
{
   int i,it,il;

   for (i=0; i < nmolat; i++) {
	it = (int) ityp[i];
	if (it < 0) {
	   il = ABS(it) - 1;
	   vdwr[i] = (float) chgvdwptr->gfvdw[il][0];
	   vdwe[i] = (float) chgvdwptr->gfvdw[il][1];
	   q[i] = (float) qat[i];

	} else {
	   vdwr[i] = 0.0;
	   vdwe[i] = 0.0;
	   q[i] = 0.0;
	}
   }
}

int GetStruct(char *fil2op)
{
	int i,j,k,i1,iasel,it,idum,igtmo,iadd,irng,irs,n,icel,istat;
	int iatomsd,mxnatd,ihaszmd,size,fftmp,ipdbd;
	FILEOP tmpfil;
	FILEOP nfil = {NULL, NULL, 0, 0, 0, 0};
	double rdum;
	char *ss;
	double *ppcoo,qtmp[MXLIGA];
	int *ppanz,*ppatclr;
	COOSTRU *pp;

	iadd = 0;
	iasel = 0;
	icel = 0;
	size = MXLIGA;

	if (MOLxyz.coo == NULL) alldck(&MOLxyz,&size);

	tmpfil = COO[istruct]->memfil;
	fileop = nfil;

	nomemf = 0;
	filmem(0,0,fil2op,&fileop);

	iatomsd = *(xyzp->iatoms);
	mxnatd = *(xyzp->mxnat);
	ihaszmd = *(zmptrp->ihaszm);
	ipdbd = *ipdbon;
	*ipdbon = 0;

/* get ambfor xyz file (gaff atom types */

	fftmp = *fftyp;

	ppcoo = xyzp->coo;
	ppanz = xyzp->ianz;
	ppatclr = xyzp->iatclr;

	xyzp->coo = MOLxyz.coo;
	xyzp->ianz = MOLxyz.ianz;
	xyzp->iatclr = MOLxyz.iatclr;
	*xyzp->mxnat = mxliga;

/* get mol file */

#if defined(VMS) || defined(UNDERSC)
	getmod(&igtmo,&iadd,
#else
#ifdef CRAY
	GETMOD(&igtmo,&iadd,
#else
	getmod_(&igtmo,&iadd,
#endif
#endif
	   MOLxyz.coo,MOLxyz.qat,MOLxyz.ianz,MOLxyz.iaton,MOLxyz.iconn,
	   MOLxyz.iresid);

	if (!igtmo) {
	   sprintf(cmdstr,"File %s is NOT mol format\n",fil2op);
	   if (DoCan(event.xbutton.x_root, event.xbutton.y_root,cmdstr,0)) {}
	   return(0);
	}

/* restore original coo, ianz and iatclr pointers */

	xyzp->coo = ppcoo;
	xyzp->ianz = ppanz;
	xyzp->iatclr = ppatclr;

/* restore original fftyp, iatoms pointers */

	*fftyp = fftmp;
	MOLxyz.iatoms = &nmolat;
	*MOLxyz.iatoms = *(xyzp->iatoms);


/* convert to au */

/* retype to sybyl atom types */

	pp = xyzp;
	xyzp = &MOLxyz;

	for (i=0; i < nmolat; i++) {

	   i1 = i + 1;
	   MOLxyz.iaton[i] = 2;
#if defined(VMS) || defined(UNDERSC)
	   ispnd(&irs,&i1,&irng,&ONE,&ONE,
#else
#ifdef CRAY
	   ISPND(&irs,&i1,&irng,&ONE,&ONE,
#else
	   ispnd_(&irs,&i1,&irng,&ONE,&ONE,
#endif
#endif
	   MOLxyz.qat,MOLxyz.ianz,MOLxyz.iaton,MOLxyz.iconn,MOLxyz.lwrit,MOLxyz.lring);

	   strcpy(strname,elemts[MOLxyz.ianz[i]-1]);
	   strcat(strname,ATYPE[irs-1]);

	   ss = strname; 
	   if (strname[0] == ' ') ss++;

	   for (j=0; j < MXMOL2; j++) {
		if (strncmp(ss,mol2[j],5) == 0) MOLxyz.ityp[i] = j+1;
	   }
	}

//	Write_Mol("tmpje.mol2",nmolat,MOLxyz,1);
/* now MOLxyz.ityp is sybyl atom types */

	iasel = MOLxyz.iresid[0];

#if defined(VMS) || defined(UNDERSC)
	calgad(&iasel,&ZERO,&istat,
#else
#ifdef CRAY
	CALGAD(&iasel,&ZERO,&istat,
#else
	calgad_(&iasel,&ZERO,&istat,
#endif
#endif
	MOLxyz.qat,MOLxyz.ianz,MOLxyz.iconn,MOLxyz.iresid,MOLxyz.ityp);

/* now MOLxyz.ityp convert to GAFF atom types */

	*fftyp = 7;

#if defined(VMS) || defined(UNDERSC)
	dotyd(&icel,
#else
#ifdef CRAY
	DOTYD(&icel,
#else
	dotyd_(&icel,
#endif
#endif
	MOLxyz.ianz,MOLxyz.iaton,MOLxyz.iatclr,MOLxyz.iconn,MOLxyz.iresid,
	MOLxyz.lwrit,MOLxyz.lring,MOLxyz.ityp,MOLxyz.coo,qtmp,
	MOLxyz.icont,
	&idum,&ZERO,&idum,&idum,
	&idum,idum,&idum,&idum,
	&rdum,&rdum,&rdum,&rdum,&rdum,&rdum);

	AssVDWL_mol(mol_vdwr, mol_vdwe, mol_q, MOLxyz.ityp, MOLxyz.qat);

	fileop = tmpfil;
	COO[istruct]->memfil = fileop;
	
	xyzp = pp;

	*(xyzp->iatoms) = iatomsd;
	*(xyzp->mxnat)  = mxnatd;
	*(zmptrp->ihaszm) = ihaszmd;
	*ipdbon = ipdbd;
	*fftyp = fftmp;

	return(1);
}

int GetLig()
{
	int i,j,k,i1,it,idum,igttnk,idebug,iffset,ipdbon,iheat,irng,irs,n;
	int iatomsd,mxnatd,ihaszmd,size,fftmp;
	double rdum,heat;
	FILEOP tmpfil;
	FILEOP nfil = {NULL, NULL, 0, 0, 0, 0};
	char *ss;
	double *ppcoo;
	int *ppanz,*ppatclr;
	COOSTRU *pp;

	size = MXLIGA;

	alldck(&DCKxyz,&size);


	tmpfil = COO[istruct]->memfil;
	fileop = nfil;

	nomemf = 0;
	filmem(0,0,dcklig,&fileop);

	iffset = 0;

	iatomsd = *(xyzp->iatoms);
	mxnatd = *(xyzp->mxnat);
	ihaszmd = *(zmptrp->ihaszm);

/* get ambfor xyz file (gaff atom types */

	fftmp = *fftyp;

	ppcoo = xyzp->coo;
	ppanz = xyzp->ianz;
	ppatclr = xyzp->iatclr;

	xyzp->coo = DCKxyz.coo;
	xyzp->ianz = DCKxyz.ianz;
	xyzp->iatclr = DCKxyz.iatclr;

	gettnd_(&igttnk,&idebug,&ipdbon,&iffset,&iheat,&heat,
	DCKxyz.ianz,DCKxyz.iconn,DCKxyz.iatclr,DCKxyz.ityp,DCKxyz.coo,
	DCKxyz.qat,DCKxyz.isurf,
	&idum,&idum,&idum,&idum,&idum,&idum,&idum,&idum,
	&rdum,&rdum,&rdum,&rdum,&rdum,&rdum,
	&rdum,&rdum,&rdum,&rdum,&rdum,&rdum);

	xyzp->coo = ppcoo;
	xyzp->ianz = ppanz;
	xyzp->iatclr = ppatclr;

	if (!igttnk) {
	   sprintf(cmdstr,"File %s is NOT [AMBFOR] format\n",dcklig);
	   if (DoCan(event.xbutton.x_root, event.xbutton.y_root,cmdstr,0)) {}
	   return(0);
	}

	*fftyp = fftmp;
	DCKxyz.iatoms = &ndocka;
	*DCKxyz.iatoms = *(xyzp->iatoms);

/* convert to au */

	for (i=0; i < ndocka; i++) {
	   singleb.ityp[i] = DCKxyz.ityp[i];
	}

/* retype to sybyl atom types */

	pp = xyzp;
	xyzp = &DCKxyz;

	for (i=0; i < ndocka; i++) {

	   i1 = i + 1;
	   DCKxyz.iaton[i] = 2;
#if defined(VMS) || defined(UNDERSC)
	   ispnd(&irs,&i1,&irng,&ONE,&ZERO,
#else
#ifdef CRAY
	   ISPND(&irs,&i1,&irng,&ONE,&ZERO,
#else
	   ispnd_(&irs,&i1,&irng,&ONE,&ONE,
#endif
#endif
	   DCKxyz.qat,DCKxyz.ianz,DCKxyz.iaton,DCKxyz.iconn,DCKxyz.lwrit,DCKxyz.lring);

	   strcpy(strname,elemts[DCKxyz.ianz[i]-1]);
	   strcat(strname,ATYPE[irs-1]);
	   singleb.irsd[i] = IHBT[irs-1];

	   ss = strname; 
	   if (strname[0] == ' ') ss++;

	   for (j=0; j < MXMOL2; j++) {
		if (strncmp(ss,mol2[j],5) == 0) DCKxyz.ityp[i] = j+1;
	   }
	}

	fileop = tmpfil;
	COO[istruct]->memfil = fileop;
	
	xyzp = pp;

	*(xyzp->iatoms) = iatomsd;
	*(xyzp->mxnat)  = mxnatd;
	*(zmptrp->ihaszm) = ihaszmd;

	return(1);
}

void ogDockSphere()
{
    int i,j,k,l,ires;

#ifdef DOGL
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
    ogsphere(1,CNTDCK,DCKRadius,1);
    glDisable(GL_BLEND);              
#endif

}

void ProcProt()
{
    int i,j,k,l,ic,ires,indx,clss,doit;
    float tmp1[3],tmp3[3],C1[3],C2[3],C3[3],tt,dd;
    double colv[3];
    INCRSTRU tmptyp;
    double roddef;

fprintf(stderr,"ProcProt: DCKRadius %.3f CNTDCK %.3f %.3f %.3f\n",
DCKRadius,CNTDCK[0],CNTDCK[1],CNTDCK[2]);
    if (DCKRadius*toangs > 8.0) DCKRadius = 8.0/toangs;

    if (*ipdbon && calfptr->ncalf != 0) {
	indx = 0;
	for (ires = 1; ires < calfptr->ncalf+1; ires++ ) {

	   doit = 0;

#if defined(VMS) || defined(UNDERSC)
	   getpdb(&ires,ipdb,ihpdb);
#else
#ifdef CRAY
	   GETPDB(&ires,ipdb,ihpdb);
#else
   	   getpdb_(&ires,ipdb,ihpdb);
#endif
#endif
	   for (i=0; i<MXSYM; i++) {
		dd = 0.0;
		if (ipdb[i] > 0) {
	   	   for (j=0; j<3; j++) {
			tt = ((float) xyzp->coo[(ipdb[i]-1)*3+j] - CNTDCK[j]);
			dd = dd + tt*tt;
		   }
		   if (sqrt(dd) < DCKRadius) doit = 1;
		}
	   }

	   for (i=0; i<3*MXHSYM; i++) {
		dd = 0.0;
		if (ihpdb[i] > 0) {
	   	   for (j=0; j<3; j++) {
			tt = ((float) xyzp->coo[(ihpdb[i]-1)*3+j] - CNTDCK[j]);
			dd = dd + tt*tt;
		   }
		   if (sqrt(dd) < DCKRadius) doit = 1;
		}
	   }

	if (doit) {
	   if (calfptr->icalf[ires][1] != 0) {

	   /* amide */

	   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

	   for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[2]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = 
			xyzp->coo[(calfptr->icalf[ires][1]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[3]-1)*3+j]; 
	   }
	   inttyp[indx]->type = AMIDE;
	   inttyp[indx]->area = AMID1;
	   inttyp[indx]->res  = calfptr->irsnr[ires-1];

	   cal_area(inttyp[indx]);
	   indx++;

	   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

	   for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[2]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(calfptr->icalf[ires][1]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[3]-1)*3+j]; 
	   }
	   inttyp[indx]->type = AMIDE;
	   inttyp[indx]->area = AMID2;
	   inttyp[indx]->res  = calfptr->irsnr[ires-1];

	   cal_area(inttyp[indx]);
	   indx++;
	   }

	   /* backbone C=O */

	   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

	   for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[3]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[2]-1)*3+j]; 
	   }
	   inttyp[indx]->type = H_ACC;
	   inttyp[indx]->area = CO;
	   inttyp[indx]->res  = calfptr->irsnr[ires-1];

	   cal_area(inttyp[indx]);

	   indx++;

	   /* backbone NH */

	   if ((ipdb[0] != 0 && ihpdb[0] != 0) && 
		calfptr->iamino[ires-1] != 15 ) {

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[0]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[0]-1)*3+j]; 
		}
		inttyp[indx]->atom[0] = ihpdb[0]-1; 
		inttyp[indx]->atom[1] = ipdb[0]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;
	   }

	   switch (calfptr->iamino[ires-1]) {
	   case 3:
	   case 4:
	   case 5:
	   /* serine, threonine */
	   /* serine, threonine OH */

	        if (calfptr->iamino[ires-1] != 4) {

		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		   for (j=0; j<3; j++) {
	              if (calfptr->iamino[ires-1] == 3) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[9]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[30]-1)*3+j]; 
		      } else if (calfptr->iamino[ires-1] == 5) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[12]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[31]-1)*3+j]; 
		      }
		   }
	           if (calfptr->iamino[ires-1] == 3) {
			inttyp[indx]->atom[0] = ihpdb[9]-1; 
			inttyp[indx]->atom[1] = ipdb[30]-1; 
		   } else if (calfptr->iamino[ires-1] == 5) {
			inttyp[indx]->atom[0] = ihpdb[12]-1; 
			inttyp[indx]->atom[1] = ipdb[31]-1; 
		   }
		   inttyp[indx]->type = H_DON;
		   inttyp[indx]->area = ONH;
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
	   	   indx++;

		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		   for (j=0; j<3; j++) {
	              if (calfptr->iamino[ires-1] == 3) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[30]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
			inttyp[indx]->c[2][j] = xyzp->coo[(ihpdb[9]-1)*3+j]; 
		      } else {
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[31]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
			inttyp[indx]->c[2][j] = xyzp->coo[(ihpdb[12]-1)*3+j]; 
		      }
		   }
		   inttyp[indx]->type = H_ACC;
		   inttyp[indx]->area = OSP3;
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
	   	   indx++;

		} else {

		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		   for (j=0; j<3; j++) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[36]-1)*3+j]; 
		   }
		   inttyp[indx]->type = SULFUR;
		   inttyp[indx]->area = SPH2;
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
	   	   indx++;

		}

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
	        if (calfptr->iamino[ires-1] != 5) {
		   inttyp[indx]->type = CH2;
		} else {
		   inttyp[indx]->type = CH;
		}
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	        if (calfptr->iamino[ires-1] == 5) {

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[7]-1)*3+j]; 
		}
		inttyp[indx]->type = CH3;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[7]-1)*3+j]; 
		}
		inttyp[indx]->type = PHE_CH3;
		inttyp[indx]->area = CH3_PHE;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		}

		break;
	   case 1:
	   case 2:
	   case 6:
	   case 7:
	   case 11:
	   /* glycine, alanine, isoleucine, leucine */

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
	        if (calfptr->iamino[ires-1] != 1) {
		   inttyp[indx]->type = CH;
		} else {
		   inttyp[indx]->type = CH2;
		}
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	        if (calfptr->iamino[ires-1] >= 2) {
	   /* Cbeta */
		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		   for (j=0; j<3; j++) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		   }
	           if (calfptr->iamino[ires-1] == 9 || 
			calfptr->iamino[ires-1] == 11) {
			inttyp[indx]->type = CH2;
	           } else if (calfptr->iamino[ires-1] > 2) {
			inttyp[indx]->type = CH;
		   } else {
			inttyp[indx]->type = CH3;
		   }
		   inttyp[indx]->area = SPH1;
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
	   	   indx++;

	           if (calfptr->iamino[ires-1] == 2) {
			inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

			for (j=0; j<3; j++) {
			   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
			}
			inttyp[indx]->type = PHE_CH3;
			inttyp[indx]->area = CH3_PHE;
	        	inttyp[indx]->res  = calfptr->irsnr[ires-1];

			cal_area(inttyp[indx]);
	   		indx++;
		   }
		}

	        if (calfptr->iamino[ires-1] >= 6) {
	   /* Cgamma */

		   if (calfptr->iamino[ires-1] != 7 && ipdb[6] != 0) {
			inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

			for (j=0; j<3; j++) {
			   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[6]-1)*3+j]; 
			}
	        	if (calfptr->iamino[ires-1] > 6) {
			   inttyp[indx]->type = CH;
			} else {
			   inttyp[indx]->type = CH2;
			}
			inttyp[indx]->area = SPH1;
	        	inttyp[indx]->res  = calfptr->irsnr[ires-1];

			cal_area(inttyp[indx]);
	   		indx++;
		   }

	           if (calfptr->iamino[ires-1] == 6 || 
			calfptr->iamino[ires-1] == 7 ||
			calfptr->iamino[ires-1] == 11) {
			/* isoleucine cg2,cd1 and leucine cd1,cd2 */
			/* valine cg1,cg2 */

			inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

			for (j=0; j<3; j++) {
			   if (calfptr->iamino[ires-1] == 6) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[7]-1)*3+j]; 
			   } else if (calfptr->iamino[ires-1] == 11) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
			   } else {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[6]-1)*3+j]; 
			   }
			}
			inttyp[indx]->type = PHE_CH3;
			inttyp[indx]->area = CH3_PHE;
	        	inttyp[indx]->res  = calfptr->irsnr[ires-1];

			cal_area(inttyp[indx]);
	   		indx++;

			inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

			for (j=0; j<3; j++) {
			   if (calfptr->iamino[ires-1] == 6) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[7]-1)*3+j]; 
			   } else if (calfptr->iamino[ires-1] == 11) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
			   } else {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[6]-1)*3+j]; 
			   }
			}
			inttyp[indx]->type = CH3;
			inttyp[indx]->area = SPH1;
	        	inttyp[indx]->res  = calfptr->irsnr[ires-1];

			cal_area(inttyp[indx]);
	   		indx++;

			inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

			for (j=0; j<3; j++) {
			   if (calfptr->iamino[ires-1] == 6) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
			   } else if (calfptr->iamino[ires-1] == 11) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
			   } else {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[7]-1)*3+j]; 
			   }
			}
			inttyp[indx]->type = PHE_CH3;
			inttyp[indx]->area = CH3_PHE;
	        	inttyp[indx]->res  = calfptr->irsnr[ires-1];

			cal_area(inttyp[indx]);
	   		indx++;

			inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

			for (j=0; j<3; j++) {
			   if (calfptr->iamino[ires-1] == 6) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
			   } else if (calfptr->iamino[ires-1] == 11) {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
			   } else {
			      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[7]-1)*3+j]; 
			   }
			}
			inttyp[indx]->type = CH3;
			inttyp[indx]->area = SPH1;
	        	inttyp[indx]->res  = calfptr->irsnr[ires-1];

			cal_area(inttyp[indx]);
	   		indx++;
		   }
		}

		break;
	   case 8:
	   /* methionine */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		    inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[35]-1)*3+j]; 
		}
		inttyp[indx]->type = SULFUR;
		inttyp[indx]->area = SPH2;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[11]-1)*3+j]; 
		}
		inttyp[indx]->type = PHE_CH3;
		inttyp[indx]->area = CH3_PHE;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		      inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[11]-1)*3+j]; 
		}
		inttyp[indx]->type = CH3;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 9:
	   /* asparate */
	   /* OD1, CG, OD2 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[28]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[29]-1)*3+j]; 
		}
		inttyp[indx]->q0 = -0.5; 
		inttyp[indx]->q1 =  0.0; 
		inttyp[indx]->q2 = -0.5; 
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = COOmin;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);

	   	indx++;

	   /* OD2, CG, OD1 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[29]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[28]-1)*3+j]; 
		}
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = COOmin;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);

	   	indx++;

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 10:
	   /* asparagine */
	   /* ND2 HD21/HD22 */


		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[21]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[20]-1)*3+j]; 
		}
		inttyp[indx]->atom[0] = ihpdb[21]-1; 
		inttyp[indx]->atom[1] = ipdb[20]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[24]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[20]-1)*3+j]; 
		}
		inttyp[indx]->atom[0] = ihpdb[24]-1; 
		inttyp[indx]->atom[1] = ipdb[20]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[28]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = CO;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 12:
	   /* Lysine */

		if (ihpdb[41] == 0) {
		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[26]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[11]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ihpdb[39]-1)*3+j]; 
		   inttyp[indx]->c[3][j] = xyzp->coo[(ihpdb[40]-1)*3+j]; 
		}
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = NAMINO;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;
		}

		/* hz_1 nz */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[39]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[26]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 1.0; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = NHP;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

		/* hz_2 nz */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[40]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[26]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 1.0; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = NHP;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

		/* hz_3 nz */

		if (ihpdb[41] != 0) {
		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[41]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[26]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 1.0; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = NHP;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;
		}

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cdelta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[8]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cepsilon */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[11]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 13:
	   /* glutamate */
	   /* OE1, CD, OE2 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[33]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[8]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[34]-1)*3+j]; 
		}
		inttyp[indx]->q0 = -0.5; 
		inttyp[indx]->q1 =  0.0; 
		inttyp[indx]->q2 = -0.5; 
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = COOmin;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
if (calfptr->irsnr[ires-1] == 353) MTXCOO1 = indx;
	   	indx++;

	   /* OE2, CD, OE1 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[34]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[8]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[33]-1)*3+j]; 
		}
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = COOmin;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
if (calfptr->irsnr[ires-1] == 353) MTXCOO2 = indx;
	   	indx++;

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 14:
	   /* glutamine */
	   /* NE2 HE21/HE22 */


		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[33]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[23]-1)*3+j]; 
		}
		inttyp[indx]->atom[0] = ihpdb[33]-1; 
		inttyp[indx]->atom[1] = ipdb[23]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[34]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[23]-1)*3+j]; 
		}
		inttyp[indx]->atom[0] = ihpdb[34]-1; 
		inttyp[indx]->atom[1] = ipdb[23]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[33]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[8]-1)*3+j]; 
		}
		inttyp[indx]->type = H_ACC;
		inttyp[indx]->area = CO;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
		indx++;

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 15:
	   /* Proline */
	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cdelta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[8]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 16:
	   /* Arginine */
	   /* ne-he */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[27]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[21]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 0.333; 
		inttyp[indx]->atom[0] = ihpdb[27]-1; 
		inttyp[indx]->atom[1] = ipdb[21]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* nh1-hh11 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[54]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[24]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 0.333; 
		inttyp[indx]->atom[0] = ihpdb[54]-1; 
		inttyp[indx]->atom[1] = ipdb[24]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* nh1-hh12 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[55]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[24]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 0.333; 
		inttyp[indx]->atom[0] = ihpdb[55]-1; 
		inttyp[indx]->atom[1] = ipdb[24]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* nh2-hh21 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[57]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[25]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 0.333; 
		inttyp[indx]->atom[0] = ihpdb[57]-1; 
		inttyp[indx]->atom[1] = ipdb[25]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* nh2-hh22 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[58]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[25]-1)*3+j]; 
		}
		inttyp[indx]->q0 = 0.0; 
		inttyp[indx]->q1 = 0.333; 
		inttyp[indx]->atom[0] = ihpdb[58]-1; 
		inttyp[indx]->atom[1] = ipdb[25]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 17:
	   /* Histidine */

		if ((ihpdb[21] != 0 && ihpdb[33] != 0) ||
			(ihpdb[21] != 0 && ihpdb[33] == 0)) {

		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));


		   for (j=0; j<3; j++) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[21]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[19]-1)*3+j]; 
		   }
		   if (ihpdb[21] != 0 && ihpdb[33] != 0) {
			inttyp[indx]->type = H_DON;
			inttyp[indx]->area = NHP;
		   } else {
			inttyp[indx]->atom[0] = ihpdb[21]-1; 
			inttyp[indx]->atom[1] = ipdb[19]-1; 
			inttyp[indx]->type = H_DON;
			inttyp[indx]->area = ONH;
		   }
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
		   indx++;

		}

		if ((ihpdb[21] != 0 && ihpdb[33] != 0) ||
			(ihpdb[33] != 0 && ihpdb[21] == 0)) {

		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		   for (j=0; j<3; j++) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[33]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[23]-1)*3+j]; 
		   }
		   if (ihpdb[21] != 0 && ihpdb[33] != 0) {
			inttyp[indx]->type = H_DON;
			inttyp[indx]->area = NHP;
		   } else {
			inttyp[indx]->atom[0] = ihpdb[33]-1; 
			inttyp[indx]->atom[1] = ipdb[33]-1; 
			inttyp[indx]->type = H_DON;
			inttyp[indx]->area = ONH;
		   }
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
		   indx++;
		}

		if (ihpdb[21] == 0 || ihpdb[33] == 0) {


		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));
		   for (j=0; j<3; j++) {
		     if (ihpdb[21] == 0) {
			/* HIE */
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[19]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
			inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		     } else {
			/* HID */
			inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[23]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
			inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		     }
		   }

		   inttyp[indx]->type = H_ACC;
		   inttyp[indx]->area = NARYL;
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
if (calfptr->irsnr[ires-1] == 524)  MTXCO1 = indx;

		   indx++;
		}

	   /* Calpha */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cbeta */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* Cgamma */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* CE1 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

	   /* CD2 */

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 18:
	   case 19:
	   /* phenylalanine, tyrosine */

	        if (calfptr->iamino[ires-1] == 19) {

		   /* OH */

		   inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		   for (j=0; j<3; j++) {
			inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[51]-1)*3+j]; 
			inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[32]-1)*3+j]; 
		   }
		   inttyp[indx]->atom[0] = ihpdb[51]-1; 
		   inttyp[indx]->atom[1] = ipdb[32]-1; 
		   inttyp[indx]->type = H_DON;
		   inttyp[indx]->area = ONH;
	           inttyp[indx]->res  = calfptr->irsnr[ires-1];

		   cal_area(inttyp[indx]);
	   	   indx++;

		}

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[16]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_CENTER;
		inttyp[indx]->area = PHC1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[16]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_CENTER;
		inttyp[indx]->area = PHC2;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
if (calfptr->irsnr[ires-1] == 404)  {
 MTXCO2 = indx;
}
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[16]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
if (calfptr->irsnr[ires-1] == 404)  {
 MTXCO3 = indx;
}
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[13]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[13]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[16]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[16]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[13]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[12]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[13]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[16]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   case 20:
	   /* tryptofan */


		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   if (ihpdb[29] > 0) {
		      inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[29]-1)*3+j]; 
		   } else if (ihpdb[31] > 0) {
		      inttyp[indx]->c[0][j] = xyzp->coo[(ihpdb[31]-1)*3+j]; 
		   }
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[22]-1)*3+j]; 
		}
		if (ihpdb[29] > 0) {
		   inttyp[indx]->atom[0] = ihpdb[29]-1; 
		} else if (ihpdb[31] > 0) {
		   inttyp[indx]->atom[0] = ihpdb[31]-1; 
		}
		inttyp[indx]->atom[1] = ipdb[22]-1; 
		inttyp[indx]->type = H_DON;
		inttyp[indx]->area = ONH;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;


		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[14]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[17]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_CENTER;
		inttyp[indx]->area = PHC1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[14]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[18]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_CENTER;
		inttyp[indx]->area = PHC2;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[18]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[14]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[15]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[15]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[18]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[17]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[17]-1)*3+j]; 
		   inttyp[indx]->c[1][j] = xyzp->coo[(ipdb[15]-1)*3+j]; 
		   inttyp[indx]->c[2][j] = xyzp->coo[(ipdb[13]-1)*3+j]; 
		}
		inttyp[indx]->type = PHENYL_RING;
		inttyp[indx]->area = PHR;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[1]-1)*3+j]; 
		}
		inttyp[indx]->type = CH;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[4]-1)*3+j]; 
		}
		inttyp[indx]->type = CH2;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[5]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[9]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[10]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[13]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[14]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[17]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[18]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		inttyp[indx] =  (INCRSTRU *) malloc((sizeof tmptyp));

		for (j=0; j<3; j++) {
		   inttyp[indx]->c[0][j] = xyzp->coo[(ipdb[15]-1)*3+j]; 
		}
		inttyp[indx]->type = ARO;
		inttyp[indx]->area = SPH1;
	        inttyp[indx]->res  = calfptr->irsnr[ires-1];

		cal_area(inttyp[indx]);
	   	indx++;

		break;
	   }
	  }
	}
    }

    nintp = indx;
    DCKPROTPROC = 1;
}

void TrnsTria(Tri,Cen,O,t,R1,R2)
TRISTRU *Tri;
float Cen[3];
float O[3];
double t[3];
double R1[4][4];
double R2[4][4];
{
    int i,l;
    float O1[3],O2[3],O3[3],C[3],Out[3];
    double ctmp[3],v1[3],v2[3];
    double colv[3];
    float tmp1[3],tmp3[3];
   
#ifdef DOGL
    for (l=0; l < 3; l++) {

	O1[l] = Tri->p1c[l];
	O2[l] = Tri->p2c[l];
	O3[l] = Tri->p3c[l];

	C[l]  = ((float) t[l]) + Cen[l];
	Out[l]= O[l];
    }


    for (l=0; l < 3; l++) {
	Out[l]= C[l] + Tri->OutO[l];
    }
    glLineWidth(20.0);

    colv[0] = ((GLdouble) colorr[10]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[10]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[10]) / 65535.0 ; 

    for (l=0; l<3; l++) {
	tmp1[l] = O1[l];
    }

    glBegin(GL_LINES);
    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = O2[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);

    colv[0] = ((GLdouble) colorr[11]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[11]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[11]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = O3[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);

    for (l=0; l<3; l++) {
	tmp1[l] = O2[l];
    }

    colv[0] = ((GLdouble) colorr[12]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[12]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[12]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = O3[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);
 
    for (l=0; l<3; l++) {
	tmp1[l] = C[l];
    }

    colv[0] = ((GLdouble) colorr[15]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[15]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[15]) / 65535.0 ; 

    glColor4f(colv[0],colv[1],colv[2],tr_val);

    glVertex3d(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = Out[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);
    glEnd();
#endif

}

void plcoo(Tri)
TRISTRU *Tri;
{
    int i,l,k,j,ia,ja,ic,m,ido;
    double colv[3];
    float tmp1[3],tmp2[3],tmp3[3];

    if (Tri->coo == NULL) return;

#ifdef DOGL
    for (i=0; i<ndocka; i++) {

        ia = DCKxyz.ianz[i];
        ic = DCKxyz.iatclr[i]-1;
	ic = 1;

        for (l=0; l<3; l++) 
               tmp1[l] = (float) Tri->coo[i*3+l];

        for (k=0; k<DCKxyz.iconn[i*(MXCON+1)]; k++) {

	    
            m = DCKxyz.iconn[i*(MXCON+1)+k+1];
            j = ABS(m) - 1;
            ja = DCKxyz.ianz[j];

            for (l=0; l<3; l++) 
	       tmp2[l] = (float) Tri->coo[j*3+l];

            ido = 1;

            if (ja == ia) {

               if (j > i) {
                  for (l=0; l<3; l++) tmp3[l] = tmp2[l];
               } else {
                  ido = 0;
               }

            } else {

               for (l=0; l<3; l++) 
                  tmp3[l] = (tmp2[l] - tmp1[l])/2.0 + tmp1[l];
            }
 
            if (ido) {

	       colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	       colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	       colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

	       glColor4d(colv[0],colv[1],colv[2],tr_val);
	       glVertex3f(tmp1[0],tmp1[1],tmp1[2]);
	       glVertex3f(tmp3[0],tmp3[1],tmp3[2]);

	    }


	}
    }
#endif

}

void pltris(Tri)
TRISTRU *Tri;
{
    float tmp1[3],tmp3[3],C0[3],C1[3],C2[3],C3[3];
    double colv[3];
    int i,l;

#ifdef DOGL
    glLineWidth(2.0);

    colv[0] = ((GLdouble) colorr[2]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[2]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[2]) / 65535.0 ; 

    for (l=0; l<3; l++) {
	tmp1[l] = Tri->P1[l];
    }

    glBegin(GL_LINES);
    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = Tri->P3[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);

/* end vertex0 p1-p3 */

    colv[0] = ((GLdouble) colorr[3]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[3]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[3]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = Tri->P2[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);

/* end vertex1 p1-p2 */

    for (l=0; l<3; l++) {
	tmp1[l] = Tri->P3[l];
    }

    colv[0] = ((GLdouble) colorr[4]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[4]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[4]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = Tri->P2[l];
    }

    glVertex3d(tmp3[0],tmp3[1],tmp3[2]);

/* end vertex1 p3-p2 */

    for (l=0; l<3; l++) {
	tmp1[l] = Tri->CenO[l];
    }

    colv[0] = ((GLdouble) colorr[0]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[0]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[0]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    glVertex3f(tmp1[0],tmp1[1],tmp1[2]);

    for (l=0; l<3; l++) {
	tmp3[l] = Tri->CenO[l] + Tri->OutOrg[l];
    }

    glVertex3f(tmp3[0],tmp3[1],tmp3[2]);

    if (Tri->coo != NULL) plcoo(Tri);

    glEnd();

    TrnsTria(Tri,Tri->Cen,Tri->Out,Tri->t,Tri->R1,Tri->R2);

#endif
}

void ogTris()
{
    int j,k,l,ic;
    float C0[3],C1[3],C2[3],C3[3];
    double colv[3];
    double roddef;

#ifdef DOGL
    glBegin(GL_LINES);

    for (k=0; k < ntris; k++) {
	if (TriArr[k] != NULL) {
	   pltris(TriArr[k]);
	}
    }

    glEnd();

    for (j=0; j<3; j++) {
	   C1[j] = ORI[j] + B1[j];
	   C2[j] = ORI[j] + B2[j];
	   C3[j] = ORI[j] + B3[j];
    }

    ic = -1;

    roddef = (0.13/0.52917706);
    ogsphere(1,ORI,0.5*roddef,0);

    ic = 2;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
    glColor4d(colv[0],colv[1],colv[2],tr_val);

    ogarrow(1,ORI,C1,roddef);

    ic = 3;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    ogarrow(2,ORI,C2,roddef);

    ic = 5;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);
    ogarrow(3,ORI,C3,roddef);
#endif

}

void ogORI(int k,int opt)
{
    int i,ic;
    double roddef;
    float ori[3];

#ifdef DOGL
    ic = -1;

    roddef = (0.13/0.52917706);
    
    for (i=0; i<3; i++) {
	if (opt) {
	   ori[i] = (float) ligtyp[k]->ORI[i];
	} else {
	   ori[i] = (float) inttyp[k]->ORI[i];
	}
    }
    ogsphere(1,ori,0.5*roddef,0);
#endif
}

void ogIntSurf()
{
    int i,j,k,l,ic,clss;
    float tmp1[3],tmp3[3],C1[3],C2[3],C3[3];
    double colv[3];
    double roddef;

    if (!DCKPROTPROC) ProcProt();

#ifdef DOGL

    if (DCKINVOKE) {
	if (!GetLig()) {
	   IntSurfDone = 1;
	   return;
	}
    }

    if (theIntSurf[istruct] > 0) glDeleteLists(theIntSurf[istruct],1);
    theIntSurf[istruct] = -1;
    theIntSurf[istruct] = glGenLists(1);

    glNewList(theIntSurf[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glLineWidth(2.0);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_COLOR_MATERIAL);
    glBegin(GL_LINES);

    for (k=0; k<nintp; k++) {

	ic = 1;
	clss = 0;

	switch (inttyp[k]->type) {
	case H_ACC: 
		ic = 0;
		clss = 1;
		break;
	case H_DON: 
		ic = 12;
		clss = -1;
		break;
	case CH:
	case CH2:
	case CH3:
	case PHE_CH3:
	case ARO:
	case AMIDE:
	case SULFUR:
	case PHENYL_RING:
		ic = 2;
		clss = -2;
		break;
	case PHENYL_CENTER:
		ic = 3;
		clss = 2;
		break;
	case METAL:
		ic = 4;
		clss = 3;
		break;
	case METAL_ACC:
		ic = 5;
		clss = -3;
		break;
	}

if (k == ATMselp) {
//fprintf(stderr,"inttyp[%d]->res %d\n",k,inttyp[k]->res);
	for (i=0; i<inttyp[k]->npts; i++) {

	    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
	    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
	    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

            for (l=0; l<3; l++) {
               tmp1[l] = (float) inttyp[k]->points[i*3+l];
	    }

            glBegin(GL_LINES);
	    glColor4d(colv[0],colv[1],colv[2],tr_val);
	    for (j=0; j<6; j++) {
		glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
           	for (l=0; l<3; l++) {
		   tmp3[l] = (float)(tmp1[l] + CV[j][l]);
		}
		glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	    }
            glEnd();

	}
}
    }

    glEnd();

    for (k=0; k<nintp; k++) {
	if (k == ATMselp) {
	   ogORI(k,0);
	}
    }


    ogTris();

    glEnable(GL_LIGHTING);
    glDisable(GL_COLOR_MATERIAL);
    glEndList();
#endif

    if (!DCKBYPASS) ogLigSurf();

    IntSurfDone = 1;

}

void plpnts(int ic,int k)
{
    float tmp1[3],tmp3[3];
    double colv[3];
    int i,j,l;

#ifdef DOGL
    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    for (i=0; i<ligtyp[k]->npts; i++) {
	for (l=0; l<3; l++) {
		tmp1[l] = (float) ligtyp[k]->points[i*3+l];
	}
	glBegin(GL_LINES);
	glColor4d(colv[0],colv[1],colv[2],tr_val);
	for (j=0; j<6; j++) {
	   glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
      	   for (l=0; l<3; l++) {
		tmp3[l] = (float)(tmp1[l] + CV[j][l]);
	   }
	   glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	}
	glEnd();
    }
#endif
}

void plpropnts(int ic,int k)
{
    float tmp1[3],tmp3[3];
    double colv[3];
    int i,j,l;

#ifdef DOGL
    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    if (inttyp[k] == NULL) return;

    for (i=0; i<inttyp[k]->npts; i++) {
	for (l=0; l<3; l++) {
		tmp1[l] = (float) inttyp[k]->points[i*3+l];
	}
	glBegin(GL_LINES);
	glColor4d(colv[0],colv[1],colv[2],tr_val);
	for (j=0; j<6; j++) {
	   glVertex3d(tmp1[0],tmp1[1],tmp1[2]);
      	   for (l=0; l<3; l++) {
		tmp3[l] = (float)(tmp1[l] + CV[j][l]);
	   }
	   glVertex3d(tmp3[0],tmp3[1],tmp3[2]);
	}
	glEnd();
    }
#endif
}

void ogLigSurf()
{
    int i,j,k,l,ic,clss;
    float tmp1[3],tmp3[3],C0[3],C1[3],C2[3],C3[3];
    double colv[3];
    double roddef;

    if (!DCKLIGPROC) {

	if (!(*ipdbon)) {
	   for (i=0; i < *xyzp->iatoms; i++) {
		singleb.ityp[i] = xyzp->ityp[i];
	   }
	}

	if (*fftyp != 5) typit(5,1);
	if (!(*ipdbon)) ProcLig(0);
    }

#ifdef DOGL

    if (theLigSurf[istruct] > 0) glDeleteLists(theLigSurf[istruct],1);
    theLigSurf[istruct] = -1;
    theLigSurf[istruct] = glGenLists(1);

    glNewList(theLigSurf[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glLineWidth(2.0);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_COLOR_MATERIAL);
    glBegin(GL_LINES);

    for (k=0; k<lintp; k++) {

	ic = 1;
	clss = 0;

	switch (ligtyp[k]->type) {
	case H_ACC: 
		ic = 0;
		clss = 1;
		break;
	case H_DON: 
		ic = 12;
		clss = -1;
		break;
	case CH:
	case CH2:
	case CH3:
	case PHE_CH3:
	case ARO:
	case AMIDE:
	case SULFUR:
	case PHENYL_RING:
		ic = 2;
		clss = -2;
		break;
	case PHENYL_CENTER:
		ic = 3;
		clss = 2;
		break;
	case METAL:
		ic = 4;
		clss = 3;
		break;
	case METAL_ACC:
		ic = 5;
		clss = -3;
		break;
	}

//	if (clss == 1 || clss == -1) {
//	if (k == 8 || k == 22 || k == 12 || k == ATMsel) {
	if (k == ATMselp) {
	   plpnts(ic,k);
	}

    }

//    plpropnts(0,227);

    for (k=0; k<lintp; k++) {
	if (k == ATMselp) {
	   ogORI(k,1);
	}
    }

    ogTris();


    glEnable(GL_LIGHTING);
    glDisable(GL_COLOR_MATERIAL);
    glEndList();
#endif

    IntSurfDone = 1;


}

void ogAxs()
{
    int i,j,k,l,ic,doit;
    float tmp1[3],tmp3[3],C0[3],C1[3],C2[3],C3[3];
    double colv[3];
    double roddef;

#ifdef DOGL
    if (theIntSurf[istruct] > 0) glDeleteLists(theIntSurf[istruct],1);
    theIntSurf[istruct] = -1;
    theIntSurf[istruct] = glGenLists(1);

    glNewList(theIntSurf[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glLineWidth(2.0);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_COLOR_MATERIAL);

    for (j=0; j<3; j++) {
	   C1[j] = ORI[j] + B1[j];
	   C2[j] = ORI[j] + B2[j];
	   C3[j] = ORI[j] + B3[j];
    }

    ic = -1;

    roddef = (0.13/0.52917706);
    ogsphere(1,ORI,0.5*roddef,0);

    ic = 2;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
    glColor4d(colv[0],colv[1],colv[2],tr_val);

    ogarrow(1,ORI,C1,roddef);

/* orange */

    ic = 1;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    ogarrow(2,ORI,C2,roddef);

    ic = 5;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);
    ogarrow(3,ORI,C3,roddef);

    glEnable(GL_LIGHTING);
    glDisable(GL_COLOR_MATERIAL);
    glEndList();
#endif
    IntSurfDone = 1;

}

void ogAxs2()
{
    int i,j,k,l,ic,doit;
    float tmp1[3],tmp3[3],C0[3],C1[3],C2[3],C3[3];
    double colv[3];
    double roddef;

#ifdef DOGL
    if (theIntSurf2[istruct] > 0) glDeleteLists(theIntSurf2[istruct],1);
    theIntSurf2[istruct] = -1;
    theIntSurf2[istruct] = glGenLists(1);

    glNewList(theIntSurf2[istruct], GL_COMPILE);
    glDisable(GL_LIGHTING);
    glLineWidth(2.0);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_COLOR_MATERIAL);

    for (j=0; j<3; j++) {
	   C1[j] = ORI2[j] + Bt1[j];
	   C2[j] = ORI2[j] + Bt2[j];
	   C3[j] = ORI2[j] + Bt3[j];
    }

    ic = -1;

    roddef = (0.13/0.52917706);
    ogsphere(1,ORI2,0.5*roddef,0);

    ic = 6;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 
    glColor4d(colv[0],colv[1],colv[2],tr_val);

    ogarrow(1,ORI2,C1,roddef);

/* grey */

    ic = 7;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);

    ogarrow(2,ORI2,C2,roddef);

/* purple */

    ic = 8;

    colv[0] = ((GLdouble) colorr[ic+1]) / 65535.0 ; 
    colv[1] = ((GLdouble) colorg[ic+1]) / 65535.0 ; 
    colv[2] = ((GLdouble) colorb[ic+1]) / 65535.0 ; 

    glColor4d(colv[0],colv[1],colv[2],tr_val);
    ogarrow(3,ORI2,C3,roddef);

    glEnable(GL_LIGHTING);
    glDisable(GL_COLOR_MATERIAL);
    glEndList();
#endif
    IntSurfDone = 1;

}

#include<sys/wait.h>
#if !defined(DARWIN) && !defined(FREEBSD)
#include<sys/prctl.h>
#endif
#include<setjmp.h>

#define STR_MAX 256
#define READ  0
#define WRITE 1
#define LARGE_BUF_LEN      8192
#define BUF_LEN        1024
#define TITLE_LEN      60

static double ONER = 1.0;

static char dname[STR_MAX];

typedef struct XData XData;

struct XData {
  int active_x_vars;
  int zero_x_values;
  double min_x_value;
  double max_x_value;
  double min_cutoff;
  double max_cutoff;
  double sdcut_x_var;
  double x_weight_coefficient;
  double temp_x_weight_coefficient;
};

static pid_t pid = 0;

typedef struct {
        float origin[3];
        float coord[3];
        float step[3];
        int npts[3];
        int x_vars; } BOXSTRU;

static BOXSTRU BOXX = {{0.0,0.0,0.0},{0.0,0.0,0.0},{0.0,0.0,0.0},0,0,0,0};

typedef struct {
        int ID;
        char name[STR_MAX]; } MOLLIST;

static MOLLIST *mol_list = NULL;
static int num_struct = 0;

static jmp_buf env_alarm;

static void sig_alarm(int signo)
{
    longjmp(env_alarm, 1);
}

void wrtcmd(char *msg, int inp, int outp, FILE *fout)
{
  char buf[PIPE_BUF];
  int n;

  sigprocmask(SIG_BLOCK,&base_mask,NULL);
  write(outp, msg, strlen(msg));
  sigprocmask(SIG_UNBLOCK,&base_mask,NULL);

  alarm(1);
  while (1) {
    n = read(inp, buf, PIPE_BUF);
    buf[n] = '\0';
    fprintf(fout,"%s",buf);
    if (strstr(buf,"END COMMAND")) break;
    if (strstr(buf,"unknown command")) {
	char error[MXCMD]; char *ptr;
	strcpy(error,msg);
	ptr = strstr(error,"\n");
	if (ptr != NULL) ptr[0] = ' ';
	strcat(error,": unknown command");
	DoCan(event.xbutton.x_root, event.xbutton.y_root,error,0);
	break;
    }
  }
  alarm(0);

}

void remalp(char *str)
{
   int len,i,j,k;

   len = strlen(str);

   for (j=0; j<len;j++) {
	 while ( (str[j] >= 'a' && str[j] <= 'z') ||
	         (str[j] >= 'A' && str[j] <= 'Z') ||
		 (str[j] == ',') || (str[j] == ':') ) {
		for (k=j; k<len;k++) {
		   str[k] = str[k+1];
		}
	 	len--;
	 }
   }
}

int get_err(FILE *fout)
{
   char str[STR_MAX];

   rewind(fout);

   while(1) {
	if (fgets(str,STR_MAX,fout) != NULL) {
	   if (strstr(str,"set the O3_BABEL_PATH") != NULL) {
		return(1);
	   }
	} else {
	   break;
	}
   }

   return(0);
}

void get_box(FILE *fout)
{
   char str[STR_MAX];

   rewind(fout);

   while(1) {
	if (fgets(str,STR_MAX,fout) != NULL) {
	   if (strstr(str,"X start")) {
		remalp(str);
		sscanf(str,"%f %f",&BOXX.origin[0],&BOXX.coord[0]);
	   }
	   if (strstr(str,"Y start")) {
		remalp(str);
		sscanf(str,"%f %f",&BOXX.origin[1],&BOXX.coord[1]);
	   }
	   if (strstr(str,"Z start")) {
		remalp(str);
		sscanf(str,"%f %f",&BOXX.origin[2],&BOXX.coord[2]);
	   }
	   if (strstr(str,"X nodes")) {
		remalp(str);
		sscanf(str,"%d",&BOXX.npts[0]);
	   }
	   if (strstr(str,"Y nodes")) {
		remalp(str);
		sscanf(str,"%d",&BOXX.npts[1]);
	   }
	   if (strstr(str,"Z nodes")) {
		remalp(str);
		sscanf(str,"%d",&BOXX.npts[2]);
	   }
	   if (strstr(str,"X step")) {
		remalp(str);
		sscanf(str,"%f",&BOXX.step[0]);
	   }
	   if (strstr(str,"Y step")) {
		remalp(str);
		sscanf(str,"%f",&BOXX.step[1]);
	   }
	   if (strstr(str,"Z step")) {
		remalp(str);
		sscanf(str,"%f",&BOXX.step[2]);
	   }
	   if (strstr(str,"Grid points:")) {
		remalp(str);
		sscanf(str,"%d",&BOXX.x_vars);
	   }
	} else {
	   break;
	}
   }

/*
printf("origin[] %f %f %f\n",BOXX.origin[0],BOXX.origin[1],BOXX.origin[2]);
printf("coord[] %f %f %f\n",BOXX.coord[0],BOXX.coord[1],BOXX.coord[2]);
printf("npts[] %d %d %d\n",BOXX.npts[0],BOXX.npts[1],BOXX.npts[2]);
printf("step[] %f %f %f\n",BOXX.step[0],BOXX.step[1],BOXX.step[2]);
printf("x_var %d\n",BOXX.x_vars);
*/
}

void get_list(FILE *fout,char *sub)
{
   char str[STR_MAX];
   int doit = 0,idum,tel;

   rewind(fout);

   tel = 0;

   while(1) {
	if (fgets(str,STR_MAX,fout) != NULL) {
	   if (strstr(str,"BGN COMMAND")) {
		if (strstr(str,sub))  doit = 1;
	   }
	   if (doit == 1) {
		if (strstr(str,"Number of objects:")) {
		   remalp(str);
		   sscanf(str,"%d",&num_struct);
		   if (mol_list != NULL) free(mol_list);

		   mol_list = (MOLLIST *) malloc(sizeof(MOLLIST)*num_struct);
		   doit = 2;
		}
	   }
	   if (doit == 2) {
		if (strstr(str,"TRAINING SET")) {
		   sscanf(str,"%d %d %d %s",
			&idum,&mol_list[tel].ID,&idum,mol_list[tel].name);
		   tel++;
		}
		if (strstr(str,"END COMMAND")) return;
	   }
	}
   }
}

void print_list()
{
   int i;

   printf("Number of objects: %d\n",num_struct);

   for (i=0; i<num_struct;i++) {
	printf("%d ID %d name %s\n",i,mol_list[i].ID,mol_list[i].name);
   }
}

#include <ftw.h>
time_t Mtime = 0;

int checkifnewer(const char *path, const struct stat *sb, int typeflag)
{
    if (strstr(path,"O3Q.") && strstr(path,".mol_dir") ) {
	if (typeflag == FTW_D && sb->st_mtime > Mtime) {
           Mtime = sb->st_mtime;
           strncpy(dname, path, STR_MAX);
	}
    }
    return 0;
}

void get_dir(char *dname)
{
   DIR *dir;
   int ftype;
   struct stat st;
   struct dirent *dp;
   char tmpfname[STR_MAX];
   char temp_dir_name[STR_MAX];

#ifdef DO_PIPE
   sprintf(temp_dir_name,"/tmp/O3Q.%d.mol_dir",(int) pid);
   strcat(dname,"");

   dir = opendir("/tmp");
   if (dir) {
     while ( (dp = readdir(dir)) != NULL) {
	sprintf(tmpfname,"/tmp/%s",dp->d_name);
	st.st_mode = 0;
	stat(tmpfname, &st);
	ftype = st.st_mode & S_IFMT;
	if (ftype == S_IFDIR) {
	   if (strstr(tmpfname,temp_dir_name)) {
		strcpy(dname,tmpfname);
		return;
	   }
	}
     }
   } else {
     printf("could not open tmp direcory /tmp\n");
   }
#else
   ftw("/tmp/O3Q",checkifnewer,1);
#endif
}



void initialise_xdata(XData *x_data, int x_vars)
{
    x_data->active_x_vars = x_vars;
    x_data->zero_x_values = 0;
    x_data->min_x_value = 0.0;
    x_data->max_x_value = 0.0;
    x_data->min_cutoff = 0.0;
    x_data->max_cutoff  = 0.0;
    x_data->sdcut_x_var = 0.0;
    x_data->x_weight_coefficient = 1.0;
    x_data->temp_x_weight_coefficient = 0.0;
}

int save_dat(char *dat)
{
  char buffer[LARGE_BUF_LEN];
  char print_buf[BUF_LEN];
  char header[TITLE_LEN + 1];
  int alen;
  int mol_len;
  int fnum,struc;
  int i,j,k;
  uint64_t valid;
  float *field;
  FILE *mol_fd;
  FILE *dat_out;
  char name[BUF_LEN];
  XData x_data[2];
  
  memset(&mol_fd, 0, sizeof(mol_fd));

  dat_out = fopen(dat,"w+");

  fwrite(&ONE, sizeof(int), 1, dat_out);

  memset(buffer, 0, LARGE_BUF_LEN);
  memset(header, ' ', TITLE_LEN);
  header[TITLE_LEN] = '\0';
  sprintf(header,"Open3DQSAR v 2.3 written by Molden");

  for (i = 0; i < TITLE_LEN; ++i) {
    if (!header[i]) {
      header[i] = ' ';
      break;
    }
  }

  fwrite(header, 1, TITLE_LEN, dat_out);

  fwrite(&TWO, sizeof(int), 1, dat_out);

  fwrite(&num_struct, sizeof(int), 1, dat_out);

  field = (float *) malloc(sizeof(float)*BOXX.x_vars);

  fwrite(&(BOXX.x_vars), sizeof(int), 1, dat_out);

/* y_vars */

  fwrite(&ZERO, sizeof(int), 1, dat_out);

  for (i = 0; i < 3; ++i) {
    fwrite(&(BOXX.origin[i]), sizeof(float), 1, dat_out);
  }

  for (i = 0; i < 3; ++i) {
    fwrite(&(BOXX.coord[i]), sizeof(float), 1, dat_out);
  }
  
  for (i = 0; i < 3; ++i) {
    fwrite(&(BOXX.npts[i]), sizeof(float), 1, dat_out);
  }

  for (i = 0; i < 3; ++i) {
    fwrite(&(BOXX.step[i]), sizeof(float), 1, dat_out);
  }
  
  valid = 16384;
  fwrite(&valid, sizeof(uint64_t), 1, dat_out);
  
  initialise_xdata(&x_data[0],BOXX.x_vars);
  initialise_xdata(&x_data[1],BOXX.x_vars);

  fwrite(&x_data[0], sizeof(XData), 2, dat_out);

  fnum = 0;

  for (i = 0; i < 2; i++) {

    struc = 0;

    for (j = 0; j < num_struct; j++) {

      memset(print_buf, ' ', 64);
      snprintf(print_buf, 64, "%-32s%-32s", "HEADER", mol_list[j].name);
      fwrite(print_buf, 1, 64, dat_out);

      fwrite(&fnum, sizeof(int), 1, dat_out);
      fwrite(&struc, sizeof(int), 1, dat_out);

      fwrite(&(mol_list[j].ID), sizeof(int), 1, dat_out);

      mol_len = 0;

      sprintf(name, "%s/%04d.mol", dname, mol_list[j].ID);

      if (!fnum) {

        mol_fd = fopen(name, "rb");

        if (mol_fd) {
          alen = LARGE_BUF_LEN;

          while (alen == LARGE_BUF_LEN) {
            alen = fread(buffer, 1, LARGE_BUF_LEN, mol_fd);
            mol_len += alen;
          }

          rewind(mol_fd);
        }
      }

      fwrite(&mol_len, sizeof(int), 1, dat_out);

      if (!fnum) {

        if (mol_fd) {
          alen = LARGE_BUF_LEN;
          while (alen == LARGE_BUF_LEN) {
            mol_len = fread(buffer, 1, LARGE_BUF_LEN, mol_fd);
            if (mol_len > 0) {
              alen = fwrite(buffer, 1, mol_len, dat_out);
            } else {
              break;
            }
          }
          fclose(mol_fd);
          mol_fd = NULL;
        }
      }

      GetStruct(name);

      calc_grid_points(i,BOXX.npts,BOXX.step,BOXX.origin,field);
      fwrite(field,sizeof(float), BOXX.x_vars, dat_out);

      ++struc;
    }
    ++fnum;
  }

  for (i = 0; i < 2; ++i) {
      fwrite(&THREE, sizeof(uint16_t), 1, dat_out);
  }

  for (i = 0; i < num_struct; ++i) {
      fwrite(&ONE, sizeof(uint16_t), 1, dat_out);
  }

  for (i = 0; i < num_struct; ++i) {
      fwrite(&ONER, sizeof(double), 1, dat_out);
  }

  for (i = 0; i < 2; ++i) {
    for (j = 0; j < BOXX.x_vars; ++j) {
      fwrite(&ONE, sizeof(uint16_t), 1, dat_out);
    }
  }

  fclose(dat_out);

  return 0;
}

/*
cutoff field_list=1 type=max level=50.0
cutoff field_list=1 type=min level=-50.0
exclude field_list=2 ref_field=1 type=match
cutoff type=max level=30.0
cutoff type=min level=-30.0
zero type=all level=0.05
sdcut level=0.1
*/

int GetAtomNumber(char *str)
{
   int j;

   for (j=0; j<100; j++) {
	if (strcasecmp(str,elements[j]) == 0) {
	    return(j);
	}
   }

   return(-1);
}

int read_sdf()
{
  char buffer[LARGE_BUF_LEN];
  char name[BUF_LEN];
  char element[3];
  int itel,itelm;
  int i,j,k,m;
  int nmolat,nbnds,ntotal,str1,str2;
  double coord[3];
  int bnd[2];
  FILE *mol_fd;
  
  memset(&mol_fd, 0, sizeof(mol_fd));

  ntotal = 0;

  for (k = 0; k < num_struct; k++) {

      sprintf(name, "%s/%04d.mol", dname, mol_list[k].ID);

      mol_fd = fopen(name, "r");

      if (mol_fd) {

        nmolat = 0;

	while (fgets(buffer, BUF_LEN, mol_fd)) {

	  if (strlen(buffer) > 34) {
	     if (strncasecmp(&buffer[34], "V2000", 5) == 0) {
		sscanf(buffer, "%d", &nmolat);
		ntotal += nmolat;
		break;
	     }
	  }
	}

        fclose(mol_fd);
        mol_fd = NULL;
      }
  }

  New_Entry(&str1,str2,ntotal,1);

  *xyzp->iatoms = ntotal;

  itel = 0;

  for (k = 0; k < num_struct; k++) {

      itelm = itel;

      sprintf(name, "%s/%04d.mol", dname, mol_list[k].ID);

      mol_fd = fopen(name, "r");

      if (mol_fd) {

        nmolat = 0;

	while (fgets(buffer, BUF_LEN, mol_fd)) {

	  if (strlen(buffer) > 34) {
	     if (!strncasecmp(&buffer[34], "V2000", 5)) {
		sscanf(buffer, "%d %d", &nmolat,&nbnds);
		break;
	     }
	  }
	}

	for (i = 0; i < nmolat; i++) {
	    xyzp->iconn[(itelm+i)*(MXCON+1)] = 0;
	}

	for (i = 0; i < nmolat; i++) {
	    if (fgets(buffer, BUF_LEN, mol_fd)) {
		for (j = 0; j < 3; j++) {
		   sscanf(&buffer[10 * j], "%lf", &coord[j]);
		   coord[j] /= toangs;
		   xyzp->coo[(itel)*3+j] = coord[j];
		}
		sscanf(&buffer[31], "%s", element);
		xyzp->ianz[itel] = GetAtomNumber(element);
		xyzp->iaton[itel] = 1;
		xyzp->iresid[itel] = -3;
		itel++;
	    } else {
		break;
	    }
	}

	for (i = 0; i < nbnds; i++) {
	    if (fgets(buffer, BUF_LEN, mol_fd)) {
		sscanf(&buffer[0], "%d %d", &bnd[0],&bnd[1]);

		(xyzp->iconn[(itelm+bnd[0]-1)*(MXCON+1)])++;
		m = xyzp->iconn[(itelm+bnd[0]-1)*(MXCON+1)];
		xyzp->iconn[(itelm+bnd[0]-1)*(MXCON+1)+m] = bnd[1] + itelm;

		(xyzp->iconn[(itelm+bnd[1]-1)*(MXCON+1)])++;
		m = xyzp->iconn[(itelm+bnd[1]-1)*(MXCON+1)];
		xyzp->iconn[(itelm+bnd[1]-1)*(MXCON+1)+m] = bnd[0] + itelm;
	    } else {
		break;
	    }
	}

        fclose(mol_fd);
        mol_fd = NULL;
      }


  }

#if defined(VMS) || defined(UNDERSC)
  docent();doscal();
#else
#ifdef CRAY
  DOCENT();DOSCAL();
#else
  docent_();doscal_();
#endif
#endif

  return 0;
}

void Add_Command(char *msg, SHFILSTRU *sh, int fill)
{
  int l;
  char *ptr;

  if (!fill) return;

  l = strlen(msg);
  ptr = (char *) malloc(sizeof(char)*(MAXNAM+1));
  strcpy(ptr,msg);
  sh->Open3Dcomms[sh->nOpen3Dcomm] = ptr;
  sh->nOpen3Dcomm++;

}

int Gen_Commands(int fill, SHFILSTRU *sh)
{
  int i,n;
  char msg[PIPE_BUF];

  n = 0;

  if (!fill) {
	if (sh->Open3Dcomms != NULL && shfiles[0].nOpen3Dcomm) {
	   for (i = 0; i < shfiles[0].nOpen3Dcomm; i++) {
		if (shfiles[0].Open3Dcomms[i] != NULL) 
			free(shfiles[0].Open3Dcomms[i]);
	   }
	   free(shfiles[0].Open3Dcomms);
	   shfiles[0].nOpen3Dcomm = 0;
	}
  }

  sprintf(msg,"import type=sdf file=%s",QSAR.sdf);
  Add_Command(msg,sh,fill);
  n++;

  sprintf(msg,"box step=2.0");
  Add_Command(msg,sh,fill);
  n++;

  if (QSAR.fldopt) {
	sprintf(msg,"calc_field type=vdw");
	Add_Command(msg,sh,fill);
	n++;
	sprintf(msg,"calc_field type=mm_ele");
	Add_Command(msg,sh,fill);
	n++;
  } else {
	sprintf(msg,"load file=%s",QSAR.dat);
	Add_Command(msg,sh,fill);
	n++;
  }


  if (QSAR.cut) {
	sprintf(msg,"cutoff type=max level=%f",QSAR.cutmax);
	Add_Command(msg,sh,fill);
	n++;

	sprintf(msg,"cutoff type=min level=%f",QSAR.cutmin);
	Add_Command(msg,sh,fill);
	n++;
  }

  sprintf(msg,"import type=dependent file=%s",QSAR.act);
  Add_Command(msg,sh,fill);
  n++;

  sprintf(msg,"pls pc=%d",QSAR.pc);
  Add_Command(msg,sh,fill);
  n++;

  if (QSAR.cv) {
	sprintf(msg,"cv pc=%d",QSAR.pc);
	Add_Command(msg,sh,fill);
	n++;
  }

  sprintf(msg,"export type=coefficients pc=%d file=%s format=maestro interpolate=3",QSAR.pc,QSAR.plt);
  Add_Command(msg,sh,fill);
  n++;

  if (!fill) {
	sh->Open3Dcomms = (char **) malloc(sizeof(char *)*MXCMD);
	return(n);
  } else return(-1);
}

int SubQSAR()
{
    char cmdfil[MAXCMD];
    char cmdfil2[MAXCMD];
    char resolved[MAXCMD];

    if (getob()) {
	strcpy(cmdfil,"/usr/local/bin/open3dqsar");
	strcpy(cmdfil2,"/usr/bin/open3dqsar");

	if ((access(cmdfil,F_OK) == 0 && !isdir(cmdfil)) ) {

	   setenv("O3_BABEL_PATH","/usr/local/bin",1);
	   sprintf(cmdfil,"%s/open3dqsar","/usr/local/bin");
#ifdef DO_PIPE
	   execlp(cmdfil, "open3dqsar",(char*) NULL);
	   return(0);
#else
	   sprintf(cmdfil,"%s/open3dqsar -i qsar.inp -o qsar.log",
		"/usr/local/bin");
	   system(cmdfil);
	   return(0);
#endif

	} else if ((access(cmdfil2,F_OK) == 0 && !isdir(cmdfil2)) ) {

	   setenv("O3_BABEL_PATH","/usr/bin",1);
#ifdef DO_PIPE
	   sprintf(cmdfil,"%s/open3dqsar","/usr/bin");
	   execlp(cmdfil, "open3dqsar",(char*) NULL);
	   return(0);
#else
	   sprintf(cmdfil,"%s/open3dqsar -i qsar.inp -o qsar.log","/usr/bin");
	   system(cmdfil);
	   return(0);
#endif

	} else {

	     if (getenv("OPEN3DQSAR_PATH") == NULL) {
		realpath(exepath[0],resolved);
		setenv("O3_BABEL_PATH",resolved,1);
#ifdef DO_PIPE
		sprintf(cmdfil,"%s/open3dqsar",exepath[0]);
		execlp(cmdfil, "open3dqsar",(char*) NULL);
		return(0);
#else
		sprintf(cmdfil, "%s/open3dqsar.sh",exepath[0]);
		if (access(cmdfil,F_OK) == 0) {
		   sprintf(cmdfil, "%s/open3dqsar.sh -i qsar.inp -o qsar.log",
		   exepath[0]);
		   system(cmdfil);
		   return(0);
		} else {
		   sprintf(cmdfil, "%s/open3dqsar",exepath[0]);
		   if (access(cmdfil,F_OK) == 0) {
			sprintf(cmdfil, "%s/open3dqsar -i qsar.inp -o qsar.log",
				exepath[0]);
			system(cmdfil);
		   	return(0);
		   } else {
			return(-1);
		   }
		}
#endif
	     } else {
#ifdef DO_PIPE
		sprintf(cmdfil,"%s/open3dqsar",getenv("OPEN3DQSAR_PATH"));
		execlp(cmdfil, "open3dqsar",(char*) NULL);
#else
		sprintf(cmdfil, "%s/open3dqsar.sh",getenv("OPEN3DQSAR_PATH"));
		if (access(cmdfil,F_OK) == 0) {
		   sprintf(cmdfil, "%s/open3dqsar.sh -i qsar.inp -o qsar.log",
		   getenv("OPEN3DQSAR_PATH"));
		   system(cmdfil);
		   return(0);
		} else {
		   sprintf(cmdfil, "%s/open3dqsar",
		   getenv("OPEN3DQSAR_PATH"));
		   if (access(cmdfil,F_OK) == 0) {
		   	sprintf(cmdfil, "%s/open3dqsar -i qsar.inp -o qsar.log",
		   	getenv("OPEN3DQSAR_PATH"));
			system(cmdfil);
		   	return(0);
		   } else {
			return(-1);
		   }
		}
#endif
	     }
	}
    } else {
        fprintf(stderr,"Openbabel executables are needed for \nthe proper operation for open3dqsar\n");
    }
    return(-1);
}

void rdqsarc_pipe()
{
  int i,n;
  int inp[2];
  int outp[2];
  char buf[PIPE_BUF];
  char msg[PIPE_BUF];
  int status,ierr,ijag,istat;
  FILE *fout;
  char fname[MAXSTRLEN];
  char bind_comp[MAXSTRLEN];
  char cmd[MAXSTRLEN];
  char cmdfil[MAXCMD];
  char cmdfil2[MAXCMD];

#if defined(VMS) || defined(UNDERSC)
  curs(&ONE);
#else
#ifdef CRAY
  CURS(&ONE);
#else
  curs_(&ONE);
#endif
#endif

  pipe(inp);
  pipe(outp);
  pid = fork();

  if (pid == 0) {

    close(outp[WRITE]);
    dup2(outp[READ], READ);
    close(inp[READ]);
    dup2(inp[WRITE], WRITE);

#if !defined(DARWIN) && !defined(FREEBSD)
    prctl(PR_SET_PDEATHSIG, SIGTERM);
#endif

    SubQSAR();

    exit(1);

  } else {

    close(outp[READ]);
    close(inp[WRITE]);
  }


  fout = fopen("qsar.log","w+");

  while(1) {
    n = read(inp[0], buf, PIPE_BUF);
    buf[n] = '\0';
    fprintf(fout,"%s", buf);
    if (strstr(buf,"Open3DQSAR>")) break;
  }

  if (signal(SIGALRM, SIG_IGN) == SIG_ERR) exit(0);

  if (setjmp(env_alarm) != 0) {
     printf("setjmp: Timeout Or Error\n");
     exit(0);
  }

  for (i = 0; i < shfiles[0].nOpen3Dcomm; i++) {
	char *ptr;
	strcpy(msg,shfiles[0].Open3Dcomms[i]);
	strcat(msg,"\n");
	ptr = strstr(msg,"load file=");
	if (strstr(msg,"calc_field type=vdw") || ptr) {
	   if (ptr) {
		ptr = ptr + 10;
		strcpy(QSAR.dat,ptr);
		ptr = strstr(QSAR.dat,"\n");
		if (ptr != NULL) ptr[0] = '\0';
		save_dat(QSAR.dat);
	   }
	   read_sdf();
	}
	wrtcmd(msg,inp[0],outp[1],fout);
	if (strstr(msg,"import type")) {
	   get_list(fout,"IMPORT SDF tool");
	   get_dir(dname);
	} else if (strstr(msg,"remove_object")) {
	   get_list(fout,"REMOVE_OBJECT tool");
	} else if (strstr(msg,"box step=")) {
	   get_box(fout);
	} else if (strstr(msg,"unknown command")) {
	   fprintf(fout,"%s\n",msg);
	   break;
	}
	fflush(fout);
  }

  kill(pid, SIGKILL); 
  waitpid(pid, &status, 0);
  signal(SIGALRM,SIG_IGN);

  sprintf(fname,"%s_fld-01_y-01.plt",QSAR.plt);

  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (ierr) {
     fprintf(stderr,"Could open File: %s\n",fname);
  }

  ijag = 5;

#if defined(VMS) || defined(UNDERSC)
  cubtst(&SEVENTYSEVEN,&ijag);
#else
#ifdef CRAY
  CUBTST(&SEVENTYSEVEN,&ijag);
#else
  cubtst_(&SEVENTYSEVEN,&ijag);
#endif
#endif

  if (ijag != -1) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  sprintf(fname,"%s_fld-02_y-01.plt",QSAR.plt);
  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (!ierr) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn2,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  } else {
	fprintf(stderr,"Could open File: %s\n",fname);
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  *scle = -1.0;

  QSAR.vdwsrf = NSurf[istruct];

  UpdateContours();

  fflush(fout);
  fclose(fout);

  if (shfiles[0].FILEup == 1) {
	if (shfiles[0].fileop.lines != NULL) {
		for (i = 0; i < shfiles[0].fileop.nlines; i++) {
		   free(shfiles[0].fileop.lines[i]);
		}
		free(shfiles[0].fileop.lines);
		shfiles[0].fileop.lines = NULL;
		filmem(0,1,"qsar.log",&shfiles[0].fileop);
		free(shfiles[0].fileop.str);
		shfiles[0].FILElist.list.list = shfiles[0].fileop.lines;
		shfiles[0].FILElist.list.nents = &shfiles[0].fileop.nlines;
		GetCommandPositions(&shfiles[0]);
		*(shfiles[0].FILElist.scrbar.wpos) = 
			shfiles[0].commds[shfiles[0].icomm];
		RedrawLBox(&shfiles[0].FILElist); 
		RedrawScroll(&shfiles[0].FILElist.scrbar);
	}
  }

#if defined(VMS) || defined(UNDERSC)
  curs(&ZERO);
#else
#ifdef CRAY
  CURS(&ZERO);
#else
  curs_(&ZERO);
#endif
#endif

}

void rdqsarc()
{
  int i;
  char buf[PIPE_BUF];
  char msg[PIPE_BUF];
  int status,ierr,ijag,istat;
  FILE *fout,*fin;
  char fname[MAXSTRLEN];
  char bind_comp[MAXSTRLEN];
  char cmd[MAXSTRLEN];

#if defined(VMS) || defined(UNDERSC)
  curs(&ONE);
#else
#ifdef CRAY
  CURS(&ONE);
#else
  curs_(&ONE);
#endif
#endif

  fin = fopen("qsar.inp","w");

  mkdir("/tmp/O3Q",0777);

  sprintf(msg,"env temp_dir=/tmp/O3Q\n");
  fputs(msg,fin);

  sprintf(msg,"import type=sdf file=%s\n",QSAR.sdf);
  fputs(msg,fin);

  sprintf(msg,"box step=2.0\n");
  fputs(msg,fin);

  fclose(fin);

  if (SubQSAR() == -1) {
	fprintf(stderr,"Could not open File: %s\n",fname);
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }

  fout = fopen("qsar.log","r");

  if (get_err(fout)) {
	if (!DoCan(event.xbutton.x_root,
	event.xbutton.y_root,"Could not locate openbabel executables (obenergy)\nor BABEL_LIBDIR and BABELDATADIR were not set correctly\n",1)) {
	}
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }

  get_list(fout,"IMPORT SDF tool");
  get_dir(dname);
  get_box(fout);
 
/* if changed, get name of load file */

  for (i = 0; i < shfiles[0].nOpen3Dcomm; i++) {
	char *ptr;
	strcpy(msg,shfiles[0].Open3Dcomms[i]);
	strcat(msg,"\n");
	ptr = strstr(msg,"load file=");
	if (ptr) {
	   ptr = ptr + 10;
	   strcpy(QSAR.dat,ptr);
	   ptr = strstr(QSAR.dat,"\n");
	   if (ptr != NULL) ptr[0] = '\0';
	}
  }

  if (QSAR.fldopt) {
	read_sdf();
  } else {
	save_dat(QSAR.dat);
	read_sdf();
  }

  fclose(fout);

  fin = fopen("qsar.inp","w");

  for (i = 0; i < shfiles[0].nOpen3Dcomm; i++) {
	char *ptr;
	strcpy(msg,shfiles[0].Open3Dcomms[i]);
	strcat(msg,"\n");
	fputs(msg,fin);
  }

  fclose(fin);

  SubQSAR();

  sprintf(fname,"%s_fld-01_y-01.plt",QSAR.plt);

  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (ierr) {
	fprintf(stderr,"Could not open File: %s\n",fname);
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }

  ijag = 5;

#if defined(VMS) || defined(UNDERSC)
  cubtst(&SEVENTYSEVEN,&ijag);
#else
#ifdef CRAY
  CUBTST(&SEVENTYSEVEN,&ijag);
#else
  cubtst_(&SEVENTYSEVEN,&ijag);
#endif
#endif

  if (ijag != -1) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  sprintf(fname,"%s_fld-02_y-01.plt",QSAR.plt);
  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (!ierr) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn2,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  } else {
	fprintf(stderr,"Could not open File: %s\n",fname);
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  *scle = -1.0;

  QSAR.vdwsrf = NSurf[istruct];

  UpdateContours();

  if (shfiles[0].FILEup == 1) {
	if (shfiles[0].fileop.lines != NULL) {
		for (i = 0; i < shfiles[0].fileop.nlines; i++) {
		   free(shfiles[0].fileop.lines[i]);
		}
		free(shfiles[0].fileop.lines);
		shfiles[0].fileop.lines = NULL;
		filmem(0,1,"qsar.log",&shfiles[0].fileop);
		free(shfiles[0].fileop.str);
		shfiles[0].FILElist.list.list = shfiles[0].fileop.lines;
		shfiles[0].FILElist.list.nents = &shfiles[0].fileop.nlines;
		GetCommandPositions(&shfiles[0]);
		*(shfiles[0].FILElist.scrbar.wpos) = 
			shfiles[0].commds[shfiles[0].icomm];
		RedrawLBox(&shfiles[0].FILElist); 
		RedrawScroll(&shfiles[0].FILElist.scrbar);
	}
  }

  if (shfiles[0].FILEup != 1) {
	filmem(0,1,"qsar.log",&shfiles[0].fileop);
	free(shfiles[0].fileop.str);
  }

  for (i=0; i< shfiles[0].fileop.nlines ; i++) {
	if (strstr(shfiles[0].fileop.lines[i],"unknown command")) {
	   char error[MXCMD];
	   strcpy(error,shfiles[0].fileop.lines[i]);
	   DoCan(event.xbutton.x_root, event.xbutton.y_root,error,0);
	}
  }

#if defined(VMS) || defined(UNDERSC)
  curs(&ZERO);
#else
#ifdef CRAY
  CURS(&ZERO);
#else
  curs_(&ZERO);
#endif
#endif

  remove_temp_files(dname);
}

void rdqsar()
{
  int i;
  char buf[PIPE_BUF];
  char msg[PIPE_BUF];
  int status,ierr,ijag,istat;
  FILE *fout, *fin;
  char fname[MAXSTRLEN];
  char bind_comp[MAXSTRLEN];
  char cmd[MAXSTRLEN];

#if defined(VMS) || defined(UNDERSC)
  curs(&ONE);
#else
#ifdef CRAY
  CURS(&ONE);
#else
  curs_(&ONE);
#endif
#endif

  fin = fopen("qsar.inp","w");

  mkdir("/tmp/O3Q",0777);

  sprintf(msg,"env temp_dir=/tmp/O3Q\n");
  fputs(msg,fin);

  sprintf(msg,"import type=sdf file=%s\n",QSAR.sdf);
  fputs(msg,fin);

  sprintf(msg,"box step=2.0\n");
  fputs(msg,fin);

  fclose(fin);

  if (SubQSAR() == -1) {
	fprintf(stderr,"Could not find open3dqsar executable\nConsider setting environment variable OPEN3DQSAR_PATH\n to point to the directory where molden can find it\n");
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }


  fout = fopen("qsar.log","r");
  if (get_err(fout)) {
	if (!DoCan(event.xbutton.x_root, event.xbutton.y_root,
"Could not locate openbabel executables (obenergy)\nor BABEL_LIBDIR and BABEL_DATADIR were not set correctly\n",0)) {
	}
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }

  get_list(fout,"IMPORT SDF tool");
  get_dir(dname);
  get_box(fout);

  if (QSAR.fldopt) {
	read_sdf();
  } else {
	save_dat(QSAR.dat);
	read_sdf();
  }

  fclose(fout);

  fin = fopen("qsar.inp","w");

  sprintf(msg,"import type=sdf file=%s\n",QSAR.sdf);
  fputs(msg,fin);

  sprintf(msg,"box step=2.0\n");
  fputs(msg,fin);

  if (QSAR.fldopt) {
	sprintf(msg,"calc_field type=vdw\n");
	fputs(msg,fin);
	sprintf(msg,"calc_field type=mm_ele\n");
	fputs(msg,fin);
  } else {
	sprintf(msg,"load file=%s\n",QSAR.dat);
	fputs(msg,fin);
  }

  if (QSAR.cut) {
	sprintf(msg,"cutoff type=max level=%f\n",QSAR.cutmax);
	fputs(msg,fin);

	sprintf(msg,"cutoff type=min level=%f\n",QSAR.cutmin);
	fputs(msg,fin);
  }

  sprintf(msg,"import type=dependent file=%s\n",QSAR.act);
  fputs(msg,fin);

  sprintf(msg,"pls pc=%d\n",QSAR.pc);
  fputs(msg,fin);

  if (QSAR.cv) {
	sprintf(msg,"cv pc=%d\n",QSAR.pc);
	fputs(msg,fin);
  }

  sprintf(msg,"export type=coefficients pc=%d file=%s format=maestro interpolate=3\n",QSAR.pc,QSAR.plt);
  fputs(msg,fin);

  fclose(fin);

  SubQSAR();

  sprintf(fname,"%s_fld-01_y-01.plt",QSAR.plt);

  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (ierr) {
     fprintf(stderr,"Could not open File: %s\n",fname);
#if defined(VMS) || defined(UNDERSC)
     curs(&ZERO);
#else
#ifdef CRAY
     CURS(&ZERO);
#else
     curs_(&ZERO);
#endif
#endif
     return;
  }

  ijag = 5;

#if defined(VMS) || defined(UNDERSC)
  cubtst(&SEVENTYSEVEN,&ijag);
#else
#ifdef CRAY
  CUBTST(&SEVENTYSEVEN,&ijag);
#else
  cubtst_(&SEVENTYSEVEN,&ijag);
#endif
#endif

  if (ijag != -1) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  sprintf(fname,"%s_fld-02_y-01.plt",QSAR.plt);
  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (!ierr) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn2,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  } else {
	fprintf(stderr,"Could not open File: %s\n",fname);
#if defined(VMS) || defined(UNDERSC)
	curs(&ZERO);
#else
#ifdef CRAY
	CURS(&ZERO);
#else
	curs_(&ZERO);
#endif
#endif
     return;
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  *scle = -1.0;

  QSAR.vdwsrf = NSurf[istruct];

  UpdateContours();

  if (shfiles[0].FILEup == 1) {
	if (shfiles[0].fileop.lines != NULL) {
		for (i = 0; i < shfiles[0].fileop.nlines; i++) {
		   free(shfiles[0].fileop.lines[i]);
		}
		free(shfiles[0].fileop.lines);
		shfiles[0].fileop.lines = NULL;
		filmem(0,1,"qsar.log",&shfiles[0].fileop);
		free(shfiles[0].fileop.str);
		shfiles[0].FILElist.list.list = shfiles[0].fileop.lines;
		shfiles[0].FILElist.list.nents = &shfiles[0].fileop.nlines;
		GetCommandPositions(&shfiles[0]);
		*(shfiles[0].FILElist.scrbar.wpos) = 
			shfiles[0].commds[shfiles[0].icomm];
		RedrawLBox(&shfiles[0].FILElist); 
		RedrawScroll(&shfiles[0].FILElist.scrbar);
	}
  }

#if defined(VMS) || defined(UNDERSC)
  curs(&ZERO);
#else
#ifdef CRAY
  CURS(&ZERO);
#else
  curs_(&ZERO);
#endif
#endif

  remove_temp_files(dname);
}

#include <limits.h>

void rdqsar_pipe()
{
  int i;
  int inp[2];
  int outp[2];
  char buf[PIPE_BUF];
  char msg[PIPE_BUF];
  int status,ierr,ijag,istat;
  FILE *fout;
  char fname[MAXSTRLEN];
  char bind_comp[MAXSTRLEN];
  char cmd[MAXSTRLEN];

#if defined(VMS) || defined(UNDERSC)
  curs(&ONE);
#else
#ifdef CRAY
  CURS(&ONE);
#else
  curs_(&ONE);
#endif
#endif

  pipe(inp);
  pipe(outp);
  pid = fork();

  if (pid == 0) {

    close(outp[WRITE]);
    dup2(outp[READ], READ);
    close(inp[READ]);
    dup2(inp[WRITE], WRITE);

#if !defined(DARWIN) && !defined(FREEBSD)
    prctl(PR_SET_PDEATHSIG, SIGTERM);
#endif

    SubQSAR();

    exit(1);

  } else {

    close(outp[READ]);
    close(inp[WRITE]);
  }


  fout = fopen("qsar.log","w+");

  while(1) {
    read(inp[0], buf, PIPE_BUF);
    fprintf(fout,"%s", buf);
    if (strstr(buf,"Open3DQSAR>")) break;
  }

  if (signal(SIGALRM, sig_alarm) == SIG_ERR) exit(0);

  if (setjmp(env_alarm) != 0) {
     printf("Timeout Or Error\n");
     exit(0);
  }

  sprintf(msg,"import type=sdf file=%s\n",QSAR.sdf);
  wrtcmd(msg,inp[0],outp[1],fout);

  get_list(fout,"IMPORT SDF tool");
  get_dir(dname);

  sprintf(msg,"box step=2.0\n");
  wrtcmd(msg,inp[0],outp[1],fout);

  get_box(fout);

  if (QSAR.fldopt) {
	read_sdf();
	sprintf(msg,"calc_field type=vdw\n");
	wrtcmd(msg,inp[0],outp[1],fout);
	sprintf(msg,"calc_field type=mm_ele\n");
	wrtcmd(msg,inp[0],outp[1],fout);
  } else {
	save_dat(QSAR.dat);
	read_sdf();

	sprintf(msg,"load file=%s\n",QSAR.dat);
	wrtcmd(msg,inp[0],outp[1],fout);
  }


  if (QSAR.cut) {
	sprintf(msg,"cutoff type=max level=%f\n",QSAR.cutmax);
	wrtcmd(msg,inp[0],outp[1],fout);

	sprintf(msg,"cutoff type=min level=%f\n",QSAR.cutmin);
	wrtcmd(msg,inp[0],outp[1],fout);
  }

  sprintf(msg,"import type=dependent file=%s\n",QSAR.act);
  wrtcmd(msg,inp[0],outp[1],fout);

  sprintf(msg,"pls pc=%d\n",QSAR.pc);
  wrtcmd(msg,inp[0],outp[1],fout);

  if (QSAR.cv) {
	sprintf(msg,"cv pc=%d\n",QSAR.pc);
	wrtcmd(msg,inp[0],outp[1],fout);
  }

  sprintf(msg,"export type=coefficients pc=%d file=%s format=maestro interpolate=3\n",QSAR.pc,QSAR.plt);
  wrtcmd(msg,inp[0],outp[1],fout);

  kill(pid, SIGKILL); 
  waitpid(pid, &status, 0);
  signal(SIGALRM,SIG_IGN);

  sprintf(fname,"%s_fld-01_y-01.plt",QSAR.plt);

  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (ierr) {
     fprintf(stderr,"Could open File: %s\n",fname);
  }

  ijag = 5;

#if defined(VMS) || defined(UNDERSC)
  cubtst(&SEVENTYSEVEN,&ijag);
#else
#ifdef CRAY
  CUBTST(&SEVENTYSEVEN,&ijag);
#else
  cubtst_(&SEVENTYSEVEN,&ijag);
#endif
#endif

  if (ijag != -1) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  sprintf(fname,"%s_fld-02_y-01.plt",QSAR.plt);
  cpstr(fname,tmpfil,SUBLEN1);
  ierr = 0;

#if defined(VMS) || defined(UNDERSC)
  cpkeyw();
  filop(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
#ifdef CRAY
  CPKEYW();
  FILOP(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#else
  cpkeyw_();
  filop_(&SEVENTYSEVEN,&ONE,&ONE,&ZERO,&ierr);
#endif
#endif

  if (!ierr) {
#if defined(VMS) || defined(UNDERSC)
	rdpld(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
#ifdef CRAY
	RDPLD(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#else
	rdpld_(&hlpsrf->nps1,&hlpsrf->nps2,&hlpsrf->nps3,&SEVENTYSEVEN,&istat,
#endif
#endif
	sgrd.denn2,sgrd.dens,sgrd.pmnn,&cell->ichx,
	&cell->xyzc[0],&cell->xyzc[1],&cell->xyzc[2]);
  } else {
	fprintf(stderr,"Could open File: %s\n",fname);
  }

#if defined(VMS) || defined(UNDERSC)
  filclo(&SEVENTYSEVEN);
#else
#ifdef CRAY
  FILCLO(&SEVENTYSEVEN);
#else
  filclo_(&SEVENTYSEVEN);
#endif
#endif

  *scle = -1.0;

  QSAR.vdwsrf = NSurf[istruct];

  UpdateContours();

  fflush(fout);
  fclose(fout);

  if (shfiles[0].FILEup == 1) {
	if (shfiles[0].fileop.lines != NULL) {
		for (i = 0; i < shfiles[0].fileop.nlines; i++) {
		   free(shfiles[0].fileop.lines[i]);
		}
		free(shfiles[0].fileop.lines);
		shfiles[0].fileop.lines = NULL;
		filmem(0,1,"qsar.log",&shfiles[0].fileop);
		free(shfiles[0].fileop.str);
		shfiles[0].FILElist.list.list = shfiles[0].fileop.lines;
		shfiles[0].FILElist.list.nents = &shfiles[0].fileop.nlines;
		GetCommandPositions(&shfiles[0]);
		*(shfiles[0].FILElist.scrbar.wpos) = 
			shfiles[0].commds[shfiles[0].icomm];
		RedrawLBox(&shfiles[0].FILElist); 
		RedrawScroll(&shfiles[0].FILElist.scrbar);
	}
  }

#if defined(VMS) || defined(UNDERSC)
  curs(&ZERO);
#else
#ifdef CRAY
  CURS(&ZERO);
#else
  curs_(&ZERO);
#endif
#endif

}

void remove_temp_files(dirname)
char* dirname;
{
  DIR           *dir;
  int            ftype;
  struct stat    st;
  struct dirent *dp;
  char tmpfname[MAXFILELEN];

  if (dirname[strlen(dirname)-1] != '/') strcat(dirname,"/");

  dir = opendir(dirname);

  while ( (dp = readdir(dir)) != NULL) {

	strcpy(tmpfname,dirname);
	strcat(tmpfname,dp->d_name);
        st.st_mode = 0;
        stat(tmpfname, &st);
	ftype = st.st_mode & S_IFMT;  
        if (ftype == S_IFREG) unlink(tmpfname);

  }

  closedir(dir);
  rmdir(dirname);
}

